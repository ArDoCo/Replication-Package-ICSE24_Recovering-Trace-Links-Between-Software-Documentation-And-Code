commit_id,summary,diff,files,commit_time
bbb-libreoffice/uninstall-remote.sh,"#!/bin/bash
set -e

if [ ""$EUID"" -ne 0 ]; then
	echo ""Please run this script as root ( or with sudo )"" ;
	exit 1;
fi;


FOLDER_CHECK=`[ -d /usr/share/bbb-libreoffice-conversion/ ] && echo 1 || echo 0`
if [ ""$FOLDER_CHECK"" = ""1"" ]; then
	echo ""Removing install folder""
	rm -rf /usr/share/bbb-libreoffice-conversion/
fi;"
bbb-libreoffice/uninstall-local.sh,"#!/bin/bash
set -e

if [ ""$EUID"" -ne 0 ]; then
	echo ""Please run this script as root ( or with sudo )"" ;
	exit 1;
fi;


IMAGE_CHECK=`docker image inspect bbb-soffice 2>&1 > /dev/null && echo 1 || echo 0`
if [ ""$IMAGE_CHECK""  = ""1"" ]; then
	echo ""Removing image""
	docker image rm bbb-soffice
fi

FOLDER_CHECK=`[ -d /usr/share/bbb-libreoffice-conversion/ ] && echo 1 || echo 0`
if [ ""$FOLDER_CHECK"" = ""1"" ]; then
	echo ""Removing install folder""
	rm -rf /usr/share/bbb-libreoffice-conversion/
fi;

FILE_SUDOERS_CHECK=`[ -f /etc/sudoers.d/zzz-bbb-docker-libreoffice ] && echo 1 || echo 0`
if [ ""$FILE_SUDOERS_CHECK"" = ""1"" ]; then
	echo ""Removing Sudoers file""
	rm /etc/sudoers.d/zzz-bbb-docker-libreoffice
fi;"
bbb-libreoffice/install-remote.sh,"#!/bin/bash
if [ ""$EUID"" -ne 0 ]; then
	echo ""Please run this script as root ( or with sudo )"" ;
	exit 1;
fi;

cd ""$(dirname ""$0"")""

FOLDER_CHECK=`[ -d /usr/share/bbb-libreoffice-conversion/ ] && echo 1 || echo 0`
if [ ""$FOLDER_CHECK"" = ""0"" ]; then
	echo ""Install folder doesn't exists, installing""
	mkdir -m 755 /usr/share/bbb-libreoffice-conversion/
	cp assets/convert-remote.sh /usr/share/bbb-libreoffice-conversion/convert.sh
	chmod 755 /usr/share/bbb-libreoffice-conversion/convert.sh
	cp assets/etherpad-export.sh /usr/share/bbb-libreoffice-conversion/etherpad-export.sh
	chmod 755 /usr/share/bbb-libreoffice-conversion/etherpad-export.sh
	chown -R root /usr/share/bbb-libreoffice-conversion/
else
	echo ""Install folder already exists""
fi;
"
bbb-libreoffice/assets/convert-remote.sh,"#!/bin/bash
set -e
set -u
PATH=""/bin/:/usr/bin/""

# This is a sample script - adjust it per your need
# 1 - setup a server with JOD-CONVERTER-REST ( docker run --memory 512m --rm -p 8080:8080 eugenmayer/jodconverter:rest )
# 2 - replace the HOST information in below command with your server host

# This script receives three params
# Param 1: Input office file path (e.g. ""/tmp/test.odt"")
# Param 2: Output pdf file path (e.g. ""/tmp/test.pdf"")
# Param 3: Destination Format (pdf default)

if (( $# == 0 )); then
	echo ""Missing parameter 1 (Input office file path)"";
	exit 1
elif (( $# == 1 )); then
	echo ""Missing parameter 2 (Output pdf file path)"";
	exit 1
fi;


source=""$1""
dest=""$2""

#If output format is missing, define PDF
convertTo=""${3:-pdf}""

curl -X POST ""http://127.0.0.1:8080/lool/convert-to/$convertTo"" -H ""accept: application/octet-stream"" -H ""Content-Type: multipart/form-data"" -F ""data=@${source}"" > ""${dest}""

exit 0"
bbb-libreoffice/assets/convert-local.sh,"#!/bin/bash
set -e
set -u
PATH=""/bin/:/usr/bin/""

# Conversion of office files to Pdf using local docker bbb-soffice

# This script receives three params
# Param 1: Input office file path (e.g. ""/tmp/test.odt"")
# Param 2: Output pdf file path (e.g. ""/tmp/test.pdf"")
# Param 3: Output format (pdf default)
# Param 4: Timeout (secs) (optional)

if (( $# == 0 )); then
	echo ""Missing parameter 1 (Input office file path)"";
	exit 1
elif (( $# == 1 )); then
	echo ""Missing parameter 2 (Output pdf file path)"";
	exit 1
fi;


#Create tmp dir for conversion
mkdir -p ""/tmp/bbb-soffice-$(whoami)/""
tempDir=""$(mktemp -d -p /tmp/bbb-soffice-$(whoami)/)""
trap 'rm -fr ""$tempDir""' EXIT

source=""$1""
dest=""$2""

#If output format is missing, define PDF
convertTo=""${3:-pdf}""
convertToParam=""--convert-to $convertTo""

#If timeout is missing, define 60
timeoutSecs=""${4:-60}""
#Truncate timeout to max 3 digits (as expected by sudoers)
timeoutSecs=""${timeoutSecs:0:3}""

#If output is html, include param --writer to avoid blank page
if [ ${1: -5} == "".html"" ]
then
	convertToParam=""$convertToParam --writer""
fi

cp ""${source}"" ""$tempDir/file""
sudo /usr/bin/docker run --rm --memory=1g --memory-swap=1g --network none --env=""HOME=/tmp/"" -w /tmp/ --user=$(printf %05d `id -u`) -v ""$tempDir/"":/data/ -v /usr/share/fonts/:/usr/share/fonts/:ro --rm bbb-soffice sh -c ""timeout $(printf %03d $timeoutSecs)s /usr/bin/soffice -env:UserInstallation=file:///tmp/ $convertToParam --outdir /data /data/file""
cp ""$tempDir/file.$convertTo"" ""${dest}"""
bbb-libreoffice/assets/etherpad-export.sh,"#!/bin/bash

#This script is used to enable Etherpad to export to PDF/ODT
# 1- Edit /usr/share/etherpad-lite/settings.json
# 2- Set ""soffice"" config to this script path (default ""/usr/share/bbb-libreoffice-conversion/etherpad-export.sh"")

/usr/share/bbb-libreoffice-conversion/convert.sh ""$8"" ""$(echo $8 | sed -E -e 's/html|odt/'$7'/')"" $7

exit 0"
bbb-libreoffice/install-local.sh,"#!/bin/bash
if [ ""$EUID"" -ne 0 ]; then
	echo ""Please run this script as root ( or with sudo )"" ;
	exit 1;
fi;

cd ""$(dirname ""$0"")""

DOCKER_CHECK=`docker --version &> /dev/null && echo 1 || echo 0`

if [ ""$DOCKER_CHECK""  = ""0"" ]; then
	echo ""Docker not found"";
	apt update;
	apt install apt-transport-https ca-certificates curl software-properties-common
	curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
	add-apt-repository ""deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable""
	apt update
	apt install docker-ce -y
	systemctl enable docker
	systemctl start docker
	systemctl status docker
else
	echo ""Docker already installed"";
fi

IMAGE_CHECK=`docker image inspect bbb-soffice &> /dev/null && echo 1 || echo 0`
if [ ""$IMAGE_CHECK""  = ""0"" ]; then
	echo ""Docker image doesn't exists, building""
	docker build -t bbb-soffice docker/
else
	echo ""Docker image already exists"";
fi

FOLDER_CHECK=`[ -d /usr/share/bbb-libreoffice-conversion/ ] && echo 1 || echo 0`
if [ ""$FOLDER_CHECK"" = ""0"" ]; then
	echo ""Install folder doesn't exists, installing""
	mkdir -m 755 /usr/share/bbb-libreoffice-conversion/
	cp assets/convert-local.sh /usr/share/bbb-libreoffice-conversion/convert.sh
	chmod 755 /usr/share/bbb-libreoffice-conversion/convert.sh
	cp assets/etherpad-export.sh /usr/share/bbb-libreoffice-conversion/etherpad-export.sh
	chmod 755 /usr/share/bbb-libreoffice-conversion/etherpad-export.sh
	chown -R root /usr/share/bbb-libreoffice-conversion/
else
	echo ""Install folder already exists""
fi;

FILE_SUDOERS_CHECK=`[ -f /etc/sudoers.d/zzz-bbb-docker-libreoffice ] && echo 1 || echo 0`
if [ ""$FILE_SUDOERS_CHECK"" = ""0"" ]; then
	echo ""Sudoers file doesn't exists, installing""
	cp assets/zzz-bbb-docker-libreoffice /etc/sudoers.d/zzz-bbb-docker-libreoffice
	chmod 0440 /etc/sudoers.d/zzz-bbb-docker-libreoffice
	chown root:root /etc/sudoers.d/zzz-bbb-docker-libreoffice
else
	echo ""Sudoers file already exists""
fi;

aptInstalledList=$(apt list --installed 2>&1)
fontInstalled=0

for font in fonts-arkpandora fonts-crosextra-carlito fonts-crosextra-caladea fonts-noto fonts-noto-cjk fonts-liberation fonts-arkpandora
do
	if [[ $(echo $aptInstalledList | grep $font | wc -l) = ""0"" ]]; then
		echo ""Font $font doesn't exists, installing""
		apt-get install -y --no-install-recommends $font
		fontInstalled=1
	else
		echo ""Font $font already installed""
	fi
done

if [ $fontInstalled = ""1"" ]; then
	dpkg-reconfigure fontconfig && fc-cache -f -s -v
fi"
bbb-graphql-server/build_hasura.sh,"#!/bin/bash

# Atualizar o sistema e instalar dependências básicas
sudo apt update && sudo apt install -y curl git

# Instalar GHC e Cabal
sudo apt-get install -y software-properties-common
sudo add-apt-repository -y ppa:hvr/ghc
sudo apt-get update
sudo apt-get install -y ghc-9.0.1 cabal-install-3.2

# Atualizar as variáveis de ambiente
echo 'export PATH=$PATH:/opt/ghc/bin:/opt/cabal/bin' >> ~/.bashrc
source ~/.bashrc

# Instalar dependências de desenvolvimento do PostgreSQL
sudo apt-get install -y libpq-dev

# Clonar o repositório do Hasura e entrar na pasta
#git clone https://github.com/hasura/graphql-engine.git
wget https://github.com/hasura/graphql-engine/archive/refs/tags/v2.22.0.zip
unzip v2.22.0.zip
mv graphql-engine-2.22.0 graphql-engine
cd graphql-engine

# Construir o projeto com o Cabal
cabal update
cabal build --only-dependencies
cabal build

echo ""Hasura compilado com sucesso. Para executar, siga as instruções fornecidas anteriormente.""
"
bbb-graphql-server/install-hasura.sh,"#!/bin/bash
if [ ""$EUID"" -ne 0 ]; then
	echo ""Please run this script as root ( or with sudo )"" ;
	exit 1;
fi;

cd ""$(dirname ""$0"")""


# Install Postgresql
apt update
apt install postgresql postgresql-contrib -y
sudo -u postgres psql -c ""alter user postgres password 'bbb_graphql'""
sudo -u postgres psql -c ""drop database if exists bbb_graphql""
sudo -u postgres psql -c ""create database bbb_graphql""
sudo -u postgres psql -U postgres -d bbb_graphql -a -f bbb_schema.sql --set ON_ERROR_STOP=on
sudo -u postgres psql -c ""drop database if exists hasura_app""
sudo -u postgres psql -c ""create database hasura_app""

echo ""Postgresql installed!""


#Build Hasura
# https://github.com/hasura/graphql-engine/blob/master/server/CONTRIBUTING.md
# sudo apt install haskell-platform -y
# sudo apt-get install cabal-install -y
#wget https://golang.org/dl/go1.16.3.linux-amd64.tar.gz
#sudo sh -c ""rm -rf /usr/local/go && tar -C /usr/local -xzf go1.16.3.linux-amd64.tar.gz""
#export PATH=$PATH:/usr/local/go/bin
#go version

# Configs nginx
cp ./graphql.nginx /usr/share/bigbluebutton/nginx
systemctl restart nginx

# Install Hasura graphql as service
#wget https://graphql-engine-cdn.hasura.io/server/latest/linux-amd64 -O /usr/local/bin/hasura-graphql-engine
#chmod +x /usr/local/bin/hasura-graphql-engine

git clone --branch v2.23.0 https://github.com/iMDT/hasura-graphql-engine.git
cat hasura-graphql-engine/hasura-graphql.part-a* > hasura-graphql
rm -rf hasura-graphql-engine/
chmod +x hasura-graphql
mv hasura-graphql /usr/local/bin/hasura-graphql-engine

apt-get install -y gnupg2 curl apt-transport-https ca-certificates libkrb5-3 libpq5 libnuma1 unixodbc-dev libmariadb-dev-compat mariadb-client-10.3
cp ./hasura-config.env /etc/default/bbb-graphql-server
#Enable Console --Desenv only!!
sudo sed -i 's/HASURA_GRAPHQL_ENABLE_CONSOLE=false/HASURA_GRAPHQL_ENABLE_CONSOLE=true/' /etc/default/bbb-graphql-server

cp ./bbb-graphql-server.service /lib/systemd/system/bbb-graphql-server.service
systemctl enable bbb-graphql-server
systemctl start bbb-graphql-server

# Install Hasura CLI
curl -L https://github.com/hasura/graphql-engine/raw/stable/cli/get.sh | bash

# Apply BBB metadata in Hasura
/usr/local/bin/hasura metadata apply

echo """"
echo """"
echo ""Bbb-graphql-server Installed!""
echo ""http://$(hostname -f):8080/console"""
bigbluebutton-html5/deploy_to_usr_share.sh,"#!/bin/sh -ex
cd ""$(dirname ""$0"")""

# Please check bigbluebutton/bigbluebutton-html5/dev_local_deployment/README.md

UPPER_DESTINATION_DIR=/usr/share/meteor
DESTINATION_DIR=$UPPER_DESTINATION_DIR/bundle

SERVICE_FILES_DIR=/usr/lib/systemd/system
LOCAL_PACKAGING_DIR=""$(pwd)/../build/packages-template/bbb-html5""

if [ ! -d ""$LOCAL_PACKAGING_DIR"" ]; then
  echo ""Did not find LOCAL_PACKAGING_DIR=$LOCAL_PACKAGING_DIR""
  exit
fi

sudo rm -rf ""$UPPER_DESTINATION_DIR""
sudo mkdir -p ""$UPPER_DESTINATION_DIR""
sudo chown -R meteor:meteor ""$UPPER_DESTINATION_DIR""

# the next 5 lines may be temporarily commented out if you are sure you are not tweaking the required node_modules after first use of the script. This will save a minute or two during the run of the script
if [ -d ""node_modules"" ]; then
   rm -r node_modules/
fi
meteor reset
meteor npm ci --production

sudo chmod 777 /usr/share/meteor
METEOR_DISABLE_OPTIMISTIC_CACHING=1 meteor build $UPPER_DESTINATION_DIR --architecture os.linux.x86_64 --allow-superuser --directory

sudo chown -R meteor:meteor ""$UPPER_DESTINATION_DIR""/
echo 'stage3'


cd ""$DESTINATION_DIR""/programs/server/ || exit
sudo chmod -R 777 .
meteor npm i

echo ""deployed to $DESTINATION_DIR/programs/server\n\n\n""

echo ""writing $DESTINATION_DIR/mongod_start_pre.sh""
sudo cp $LOCAL_PACKAGING_DIR/mongod_start_pre.sh ""$DESTINATION_DIR""/mongod_start_pre.sh

echo ""writing $DESTINATION_DIR/mongo-ramdisk.conf""
sudo cp $LOCAL_PACKAGING_DIR/mongo-ramdisk.conf ""$DESTINATION_DIR""/mongo-ramdisk.conf

echo ""writing $DESTINATION_DIR/bbb-html5-with-roles.conf""
sudo tee ""$DESTINATION_DIR/bbb-html5-with-roles.conf"" >/dev/null <<HERE
# Default = 2; Min = 1; Max = 4
# On powerful systems with high number of meetings you can set values up to 4 to accelerate handling of events
NUMBER_OF_BACKEND_NODEJS_PROCESSES=2
# Default = 2; Min = 0; Max = 8
# If 0 is set, bbb-html5 will handle both backend and frontend roles in one process (default until Feb 2021)
# Set a number between 1 and 4 times the value of NUMBER_OF_BACKEND_NODEJS_PROCESSES where higher number helps with meetings
# stretching the recommended number of users in BigBlueButton
NUMBER_OF_FRONTEND_NODEJS_PROCESSES=2

HERE

echo ""writing $DESTINATION_DIR/systemd_start.sh""
sudo cp $LOCAL_PACKAGING_DIR/systemd_start.sh ""$DESTINATION_DIR""/systemd_start.sh

echo ""writing $DESTINATION_DIR/systemd_start_frontend.sh""
sudo cp $LOCAL_PACKAGING_DIR/systemd_start_frontend.sh ""$DESTINATION_DIR""/systemd_start_frontend.sh

sudo chown -R meteor:meteor ""$UPPER_DESTINATION_DIR""/
sudo chmod +x ""$DESTINATION_DIR""/mongod_start_pre.sh
sudo chmod +x ""$DESTINATION_DIR""/systemd_start.sh
sudo chmod +x ""$DESTINATION_DIR""/systemd_start_frontend.sh

sudo cp $LOCAL_PACKAGING_DIR/workers-start.sh ""$DESTINATION_DIR""/workers-start.sh
sudo chmod +x ""$DESTINATION_DIR""/workers-start.sh



echo ""writing $SERVICE_FILES_DIR/bbb-html5-frontend@.service""
sudo cp $LOCAL_PACKAGING_DIR/bbb-html5-frontend@.service ""$SERVICE_FILES_DIR""/bbb-html5-frontend@.service

echo ""writing $SERVICE_FILES_DIR/bbb-html5-backend@.service""
sudo cp $LOCAL_PACKAGING_DIR/bbb-html5-backend@.service ""$SERVICE_FILES_DIR""/bbb-html5-backend@.service

sudo systemctl daemon-reload

echo 'before stopping bbb-html5:'
ps -ef | grep node-
sudo ss -netlp | grep -i node
echo 'before stopping bbb-html5:'
echo '_____________'

sudo systemctl stop bbb-html5

sleep 5s
echo 'after stopping bbb-html5:'
ps -ef | grep node-
sudo ss -netlp | grep -i node
echo 'after stopping bbb-html5:'
echo '_____________'

echo 'starting bbb-html5'
sudo systemctl start bbb-html5
sleep 10s
echo 'after:...'
ps -ef | grep node-
sudo ss -netlp | grep -i node
echo 'after:'
echo '_____________'"
bigbluebutton-html5/run-dev.sh,"#!/usr/bin/env bash

sudo systemctl stop bbb-html5 mongod

cd ""$(dirname ""$0"")""

for var in ""$@""
do
    if [[ $var == --reset ]] ; then
    	echo ""Performing Meteor reset...""
        rm -rf node_modules
		meteor reset
    fi
done

if [ ! -d ./node_modules ] ; then
	meteor npm i
fi

npm start"
bigbluebutton-html5/transifex.sh,"#!/bin/bash

#colors
RED='\033[0;31m'
GREEN='\033[1;32m'
NC='\033[0m'
SOURCE_LANGUAGE=""en""
LOCALES_DIRECTORY=""./public/locales""
PULL_SOURCE=false

if [[ ! -e $LOCALES_DIRECTORY ]]; then
    echo -e ""Directory ${RED}$LOCALES_DIRECTORY${NC} does not exist, creating""
    mkdir $LOCALES_DIRECTORY
    PULL_SOURCE=true
fi

if [ ""$#"" = 0 ]
then
  echo -e ""${RED}ERR${NC}: Usage = ${GREEN}./transifex.sh pt_BR de  ${NC}or  ${GREEN}./transifex all${NC}""
else
  read -p ""Enter Transifex Username: "" USER
  read -p ""password: "" -s PW
  echo -e ""\n----------------------------------\nchecking project info\n----------------------------------""
  PROJECT_INFO=$( curl -L --user ""$USER"":""$PW"" -X GET https://www.transifex.com/api/2/project/bigbluebutton-v26-html5-client/languages/ )

  if [ ""$PROJECT_INFO"" == ""Authorization Required"" ]
  then
    echo -e ""${RED}Err${NC} : $PROJECT_INFO""
  else
    echo -e ""Project Information Found :${GREEN} ✓${NC}""
    if [ ""$PROJECT_INFO"" == ""Forbidden"" ]
    then
      echo -e ""${RED}Err${NC}: Invalid User Permissions""
    else
      for ARG in ""$@""
      do
        if [ ""$ARG"" == ""all""  ]
        then
          AVAILABLE_TRANSLATIONS=$( echo ""$PROJECT_INFO"" | grep 'language_code' | cut -d':' -f2 | tr -d '["",]' )

          echo ""$AVAILABLE_TRANSLATIONS"" | while read l
            do
              LOCALE=$( echo ""$l"" | tr -d '[:space:]' )
              if [ ""$LOCALE"" == ""$SOURCE_LANGUAGE"" ] && [ ""$PULL_SOURCE"" == false ]; then
                continue # only pull source file if locales folder did not exist
              fi
              TRANSLATION=$(curl -L --user ""$USER"":""$PW"" -X GET ""https://www.transifex.com/api/2/project/bigbluebutton-v26-html5-client/resource/enjson/translation/$LOCALE/?mode=onlytranslated&file"")
              NO_EMPTY_STRINGS=$(echo ""$TRANSLATION"" | sed '/: *\""\""/D' | sed '/}$/D')
              if [ $(echo ""$NO_EMPTY_STRINGS"" | wc -l) -lt 100 ]
              then
                echo -e ""${RED}WARN:${NC} translation file $LOCALE.json contains less than 100 lines\n${RED}WARN:${NC} $LOCALE.json not created""
                continue
              else
                NO_TRAILING_COMMA=$(echo ""$NO_EMPTY_STRINGS"" | sed  '$ s/,$//')
                echo ""$NO_TRAILING_COMMA"" > ""$LOCALES_DIRECTORY/$LOCALE"".json
                echo -e ""\n}\n"" >> ""$LOCALES_DIRECTORY/$LOCALE"".json
                echo -e ""Added translation file $LOCALE.json : ${GREEN}✓${NC}""
              fi
            done
        else
          TRANSLATION=$(curl -L --user ""$USER"":""$PW"" -X GET ""https://www.transifex.com/api/2/project/bigbluebutton-v26-html5-client/resource/enjson/translation/$ARG/?mode=onlytranslated&file"")
          if [ ""$TRANSLATION"" == ""Not Found"" ]
          then
            echo -e ""${RED}Err${NC}: Translations not found for locale ->${RED}$ARG${NC}<-""
          else
            NO_EMPTY_STRINGS=$(echo ""$TRANSLATION"" | sed '/: *\""\""/D' | sed '/}$/D')
            if [ $(echo ""$NO_EMPTY_STRINGS"" | wc -l) -lt 100 ]
            then
              echo -e ""${RED}WARN:${NC} translation file $ARG.json contains less than 100 lines\n${RED}WARN:${NC} $ARG.json not created""
            else
              NO_TRAILING_COMMA=$(echo ""$NO_EMPTY_STRINGS"" | sed  '$ s/,//')
              echo ""$NO_TRAILING_COMMA"" > ""$LOCALES_DIRECTORY/$ARG"".json
              echo -e ""\n}\n"" >> ""$LOCALES_DIRECTORY/$ARG"".json
              echo -e ""Added translation file $ARG.json :${GREEN} ✓${NC}""
            fi
          fi
        fi
      done
    fi
  fi
fi"
bigbluebutton-html5/test-html5.sh,"export BBB_SERVER_URL=""http://localhost/bigbluebutton/api""

# Change to HTML5 directory
cd $(dirname $0)
echo ""Working directory: $PWD""

# Build and run Docker image
docker build -t b2 .
docker=$(docker run -d -p 80:80/tcp -p 443:443/tcp -p 1935:1935 -p 5066:5066 -p 3478:3478 -p 3478:3478/udp b2 -h localhost)
echo $docker

# Check if HTML5 client is ready 
cd tests/puppeteer
node html5-check.js
status=$?
echo $status

conf=$(docker exec $(docker ps -q) bbb-conf --secret | grep ""Secret:"")
secret=$(echo $conf | cut -d' ' -f2)
export BBB_SHARED_SECRET=$secret
echo $BBB_SHARED_SECRET

# Run tests
if [ $status -eq 0 ]; then
  # runInBand will force jest to run in a single thread
  # https://jestjs.io/docs/en/troubleshooting#tests-are-extremely-slow-on-docker-and-or-continuous-integration-ci-server
  npm test -- --runInBand
fi

# Stop Docker container
docker stop $docker
docker rm $docker"
bbb-learning-dashboard/deploy.sh,"#!/usr/bin/env bash
cd ""$(dirname ""$0"")""

for var in ""$@""
do
    if [[ $var == --reset ]] ; then
    	echo ""Performing a full reset...""
      rm -rf node_modules
    fi
done

if [ ! -d ./node_modules ] ; then
	npm install
fi

npm run build
cp -r build/* /var/bigbluebutton/learning-dashboard
sudo systemctl restart nginx
echo ''
echo ''
echo '----------------'
echo 'bbb-learning-dashboard updated'"
bbb-learning-dashboard/run-dev.sh,"#!/usr/bin/env bash
cd ""$(dirname ""$0"")""

for var in ""$@""
do
    if [[ $var == --reset ]] ; then
    	echo ""Performing a full reset...""
      rm -rf node_modules
    fi
done

if [ ! -d ./node_modules ] ; then
	npm install
fi

mkdir -p public/test/test

if [ -e public/test/test/learning_dashboard_data.json ]; then
	echo ""Json found in public/test/test/learning_dashboard_data.json""
	echo """"
	tput setaf 2;
	echo ""To test the Dashboard access:""
	echo ""http://localhost:3000/learning-analytics-dashboard?meeting=test&report=test""
	echo """"
	tput sgr0
else
	echo ""ERROR: Before running, copy a Dashboard data .json from a meeting and save in $(pwd)/public/test/test/learning_dashboard_data.json""
	echo ""This file can be found in /var/bigbluebutton/learning-dashboard/\$meetingId/""
  exit 1
fi

npm start | cat"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/commands/GetUsersCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.commands;

public class GetUsersCommand extends ConferenceCommand {

	public GetUsersCommand(String room, Integer requesterId) {
		super(room, requesterId);
	}

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/commands/MuteUserCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.commands;

public class MuteUserCommand extends ConferenceCommand {

	private final Integer participantId;
	private final boolean mute;
	
	public MuteUserCommand(String room, Integer requesterId, Integer participantId, boolean mute) {
		super(room, requesterId);
		this.participantId = participantId;
		this.mute = mute;
	}

	public Integer getParticipantId() {
		return participantId;
	}

	public boolean isMute() {
		return mute;
	}

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/commands/EjectUserCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.commands;

public class EjectUserCommand extends ConferenceCommand {

	private final Integer participantId;
	
	public EjectUserCommand(String room, Integer requesterId, Integer participantId) {
		super(room, requesterId);
		this.participantId = participantId;
	}

	public Integer getParticipantId() {
		return participantId;
	}

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/commands/RecordCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.commands;

public class RecordCommand extends ConferenceCommand {

	public RecordCommand(String room, Integer requesterId) {
		super(room, requesterId);
	}

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/commands/ConferenceCommandResult.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.commands;

public class ConferenceCommandResult {

	private final String room;
	private final Integer requesterId;
	private boolean success = false;
	private String message = """";
	
	public ConferenceCommandResult(String room, Integer requesterId) {
		this.room = room;
		this.requesterId = requesterId;
	}

	public boolean isSuccess() {
		return success;
	}

	public void setSuccess(boolean success) {
		this.success = success;
	}

	public String getRoom() {
		return room;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

	public Integer getRequesterId() {
		return requesterId;
	}
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/commands/ConferenceCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.commands;

public abstract class ConferenceCommand {

	private final String room;
	private final Integer requesterId;
	
	public ConferenceCommand(String room, Integer requesterId) {
		this.room = room;
		this.requesterId = requesterId;
	}

	public String getRoom() {
		return room;
	}

	public Integer getRequesterId() {
		return requesterId;
	}
	
	
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/ConferenceServerListener.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice;

public interface ConferenceServerListener {
	public void joined(String room, Integer participant, String name, Boolean muted, Boolean talking);
	public void left(String room, Integer participant);
	public void muted(String room, Integer participant, Boolean muted);
	public void talking(String room, Integer participant, Boolean talking);	
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/VoiceUserJoinedEvent.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.events;

public class VoiceUserJoinedEvent extends VoiceConferenceEvent {

	private final String voiceUserId;
	private final String callerIdNum;
	private final String callerIdName;
	private final Boolean muted;
	private final Boolean speaking;
	private final Boolean locked = false;
	private final String userId;
	private final String callingWith;
	
	public VoiceUserJoinedEvent(String userId, String voiceUserId, String room, 
								String callerIdNum, String callerIdName,
								Boolean muted, Boolean speaking, String callingWith) {
		super(room);
		this.userId = userId;
		this.voiceUserId = voiceUserId;
		this.callerIdName = callerIdName;
		this.callerIdNum = callerIdNum;
		this.muted = muted;
		this.speaking = speaking;
		this.callingWith = callingWith;
	}

	public String getUserId() {
		return userId;
	}
	
	public String getVoiceUserId() {
		return voiceUserId;
	}
	
	public String getCallerIdNum() {
		return callerIdNum;
	}

	public String getCallerIdName() {
		return callerIdName;
	}

	public Boolean getMuted() {
		return muted;
	}

	public Boolean getSpeaking() {
		return speaking;
	}
	
	public Boolean isLocked() {
		return locked;
	}

	public String getCallingWith() {
		return callingWith;
	}
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/ConfMember.java,"package org.bigbluebutton.freeswitch.voice.events;

public class ConfMember {
    public final String voiceUserId;
    public final String callerIdNum;
    public final String callerIdName;
    public final Boolean muted;
    public final Boolean speaking;
    public final Boolean locked = false;
    public final String userId;
    public final String callingWith;

    public ConfMember(String userId,
                      String voiceUserId,
                      String callerIdNum,
                      String callerIdName,
                      Boolean muted,
                      Boolean speaking,
                      String callingWith) {
        this.userId = userId;
        this.voiceUserId = voiceUserId;
        this.callerIdName = callerIdName;
        this.callerIdNum = callerIdNum;
        this.muted = muted;
        this.speaking = speaking;
        this.callingWith = callingWith;
    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/ConfRecording.java,"package org.bigbluebutton.freeswitch.voice.events;

public class ConfRecording {
    public final String recordingPath;
    public final Long recordingStartTime;

    public ConfRecording(String recordingPath, Long recordingStartTime) {
        this.recordingPath = recordingPath;
        this.recordingStartTime = recordingStartTime;
    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/FreeswitchStatusReplyEvent.java,"package org.bigbluebutton.freeswitch.voice.events;

import java.util.List;

public class FreeswitchStatusReplyEvent extends VoiceConferenceEvent {

    public final List<String> status;
    public Long sendCommandTimestamp;
    public Long receivedResponseTimestamp;

    public FreeswitchStatusReplyEvent(Long sendCommandTimestamp,
                                      List<String> status,
                                      Long receivedResponseTimestamp) {
        super(""unused"");
        this.status = status;
        this.sendCommandTimestamp = sendCommandTimestamp;
        this.receivedResponseTimestamp = receivedResponseTimestamp;
    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/VoiceConfRunningEvent.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */
package org.bigbluebutton.freeswitch.voice.events;

public class VoiceConfRunningEvent extends VoiceConferenceEvent {

  private boolean running;

  public VoiceConfRunningEvent(String room, boolean running) {
    super(room);
    this.running = running;
  }

  public boolean isRunning() {
    return running;
  }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/FreeswitchHeartbeatEvent.java,"package org.bigbluebutton.freeswitch.voice.events;

import java.util.Map;

public class FreeswitchHeartbeatEvent extends VoiceConferenceEvent {

    public final Map<String, String> heartbeat;

    public FreeswitchHeartbeatEvent(Map<String, String> heartbeat) {
        super(""unused"");
        this.heartbeat = heartbeat;
    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/VoiceUserMutedEvent.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.events;

public class VoiceUserMutedEvent extends VoiceConferenceEvent {

	private final boolean muted;
	private final String userId;
	
	public VoiceUserMutedEvent(String userId, String room, boolean muted) {
		super(room);
		this.muted = muted;
		this.userId = userId;
	}

	public String getUserId() {
		return userId;
	}
	
	public boolean isMuted() {
		return muted;
	}

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/VoiceConfRunningAndRecordingEvent.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */
package org.bigbluebutton.freeswitch.voice.events;

import java.util.List;

public class VoiceConfRunningAndRecordingEvent extends VoiceConferenceEvent {

  public final boolean running;
  public final boolean recording;
  public final List<ConfRecording> confRecordings;

  public VoiceConfRunningAndRecordingEvent(String room,
                                           boolean running,
                                           boolean recording,
                                           List<ConfRecording> confRecordings) {
    super(room);
    this.running = running;
    this.recording = recording;
    this.confRecordings = confRecordings;
  }

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/VoiceUsersStatusEvent.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.events;

import java.util.List;

public class VoiceUsersStatusEvent extends VoiceConferenceEvent {

    public final List<ConfMember> confMembers;
    public final List<ConfRecording> confRecordings;

	public VoiceUsersStatusEvent(String room, List<ConfMember> confMembers,
                                 List<ConfRecording> confRecordings) {
	    super(room);
        this.confMembers = confMembers;
        this.confRecordings = confRecordings;
	}

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/UnknownConferenceEvent.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.events;

public class UnknownConferenceEvent extends VoiceConferenceEvent {

	public UnknownConferenceEvent(String participantId, String room) {
		super(room);
	}

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/VoiceUserLeftEvent.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.events;

public class VoiceUserLeftEvent extends VoiceConferenceEvent {

	private final String userId;
	
	public VoiceUserLeftEvent(String userId, String room) {
		super(room);
		this.userId = userId;
	}
	
	public String getUserId() {
		return userId;
	}
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/VoiceStartRecordingEvent.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.events;

public class VoiceStartRecordingEvent extends VoiceConferenceEvent {

	private String timestamp;
	private String filename;
	private boolean record;
	
	public VoiceStartRecordingEvent(String room, boolean record) {
		super(room);
		this.record =  record;
	}
	
	public void setTimestamp(String timestamp) {
		this.timestamp = timestamp;
	}

	public void setRecordingFilename(String filename) {
		this.filename = filename;
	}
	
	public String getTimestamp() {
		return timestamp;
	}
	
	public String getRecordingFilename() {
		return filename;
	}
	
	public boolean startRecord() {
		return record;
	}
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/VoiceCallStateEvent.java,"package org.bigbluebutton.freeswitch.voice.events;

public class VoiceCallStateEvent extends VoiceConferenceEvent {
    public final String callSession;
    public final String clientSession;
    public final String userId;
    public final String callerName;
    public final String callState;
    public final String origCallerIdName;
    public final String origCalledDest;

    public VoiceCallStateEvent(
            String conf,
            String callSession,
            String clientSession,
            String userId,
            String callerName,
            String callState,
            String origCallerIdName,
            String origCalledDest) {
        super(conf);
        this.callSession = callSession;
        this.clientSession = clientSession;
        this.userId = userId;
        this.callerName = callerName;
        this.callState = callState;
        this.origCallerIdName = origCallerIdName;
        this.origCalledDest = origCalledDest;
    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/AudioFloorChangedEvent.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2018 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
*
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.events;

public class AudioFloorChangedEvent extends VoiceConferenceEvent {

	private final String voiceUserId;
	private final String oldVoiceUserId;
	private final String floorTimestamp;

	public AudioFloorChangedEvent(
			String room,
			String voiceUserId,
			String oldVoiceUserId,
			String floorTimestamp
		) {
		super(room);
		this.voiceUserId = voiceUserId;
		this.oldVoiceUserId = oldVoiceUserId;
		this.floorTimestamp = floorTimestamp;
	}

	public String getVoiceUserId() {
		return voiceUserId;
	}

	public String getOldVoiceUserId() {
		return oldVoiceUserId;
	}

	public String getFloorTimestamp() {
		return floorTimestamp;
	}
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/ConferenceEventListener.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.events;


public interface ConferenceEventListener {
	public void handleConferenceEvent(VoiceConferenceEvent event);
	
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/VoiceConferenceEvent.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.events;

public abstract class VoiceConferenceEvent {
	private final String room;
	
	public VoiceConferenceEvent(String room) {
		this.room = room;
	}

	public String getRoom() {
		return room;
	}
	
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/VoiceUserLockedEvent.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.events;

public class VoiceUserLockedEvent extends VoiceConferenceEvent {

	private final boolean locked;
	private final String userId;
	
	public VoiceUserLockedEvent(String userId, String room, boolean locked) {
		super(room);
		this.locked = locked;
		this.userId = userId;
	}

	public String getUserId() {
		return userId;
	}
	
	public boolean isLocked() {
		return locked;
	}

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/events/VoiceUserTalkingEvent.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.events;

public class VoiceUserTalkingEvent extends VoiceConferenceEvent {

	private final boolean talking;
	private final String userId;
	
	public VoiceUserTalkingEvent(String userId, String room, boolean talking) {
		super(room);
		this.talking = talking;
		this.userId = userId;
	}

	public String getUserId() {
		return userId;
	}
	
	public boolean isTalking() {
		return talking;
	}

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/IVoiceConferenceService.java,"package org.bigbluebutton.freeswitch.voice;

import org.bigbluebutton.freeswitch.voice.events.ConfMember;
import org.bigbluebutton.freeswitch.voice.events.ConfRecording;

import java.util.List;
import java.util.Map;

public interface IVoiceConferenceService {
  void voiceConfRecordingStarted(String voiceConfId,
                                 String recordStream,
                                 Boolean recording,
                                 String timestamp);

  void voiceConfRunning(String voiceConfId,
                        Boolean running);

  void userJoinedVoiceConf(String voiceConfId,
                           String voiceUserId,
                           String userId,
                           String callerIdName,
                           String callerIdNum,
                           Boolean muted,
                           Boolean speaking,
                           String avatarURL);

  void voiceUsersStatus(String voiceConfId,
                        java.util.List<ConfMember> confMembers,
                        java.util.List<ConfRecording> confRecordings);

  void userLeftVoiceConf(String voiceConfId,
                         String voiceUserId);

  void userLockedInVoiceConf(String voiceConfId,
                             String voiceUserId,
                             Boolean locked);

  void userMutedInVoiceConf(String voiceConfId,
                            String voiceUserId,
                            Boolean muted);

  void userTalkingInVoiceConf(String voiceConfId,
                              String voiceUserId,
                              Boolean talking);

  void audioFloorChanged(String room,
                         String voiceUserId,
                         String oldVoiceUserId,
                         String floorTimestamp);

  void voiceConfRunningAndRecording(String room,
                                    Boolean isRunning,
                                    Boolean isRecording,
                                    java.util.List<ConfRecording> confRecording);

  void voiceCallStateEvent(String conf,
                           String callSession,
                           String clientSession,
                           String userId,
                           String callerName,
                           String callState,
                           String origCallerIdName,
                           String origCalledDest);

  void freeswitchStatusReplyEvent(Long sendCommandTimestamp,
                                  List<String> status,
                                  Long receivedResponseTimestamp);

  void freeswitchHeartbeatEvent(Map<String, String> heartbeat);
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/FreeswitchConferenceEventListener.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */
package org.bigbluebutton.freeswitch.voice;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import org.bigbluebutton.freeswitch.voice.events.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class FreeswitchConferenceEventListener implements ConferenceEventListener {
  private static Logger log = LoggerFactory.getLogger(FreeswitchConferenceEventListener.class);

  private static final int SENDERTHREADS = 1;
  private static final Executor msgSenderExec = Executors.newFixedThreadPool(SENDERTHREADS);
  private static final Executor runExec = Executors.newFixedThreadPool(SENDERTHREADS);
  private BlockingQueue<VoiceConferenceEvent> messages = new LinkedBlockingQueue<VoiceConferenceEvent>();

  private volatile boolean sendMessages = false;
  private final IVoiceConferenceService vcs;

  public FreeswitchConferenceEventListener(IVoiceConferenceService vcs) {
    this.vcs = vcs;
  }

  private void queueMessage(VoiceConferenceEvent event) {
    try {
      messages.offer(event, 5, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
      // TODO Auto-generated catch block
      log.error(""Exception queueing message: "", e);
    }
  }

  private void sendMessageToBigBlueButton(final VoiceConferenceEvent event) {
    Runnable task = new Runnable() {
      public void run() {
        if (event instanceof VoiceUserJoinedEvent) {
          VoiceUserJoinedEvent evt = (VoiceUserJoinedEvent) event;
          vcs.userJoinedVoiceConf(evt.getRoom(), evt.getVoiceUserId(), evt.getUserId(), evt.getCallerIdName(),
            evt.getCallerIdNum(), evt.getMuted(), evt.getSpeaking(), evt.getCallingWith());
        } else if (event instanceof VoiceConfRunningEvent) {
          VoiceConfRunningEvent evt = (VoiceConfRunningEvent) event;
          vcs.voiceConfRunning(evt.getRoom(), evt.isRunning());
        } else if (event instanceof VoiceUserLeftEvent) {
          VoiceUserLeftEvent evt = (VoiceUserLeftEvent) event;
          vcs.userLeftVoiceConf(evt.getRoom(), evt.getUserId());
        } else if (event instanceof VoiceUserMutedEvent) {
          VoiceUserMutedEvent evt = (VoiceUserMutedEvent) event;
          vcs.userMutedInVoiceConf(evt.getRoom(), evt.getUserId(), evt.isMuted());
        } else if (event instanceof VoiceUserTalkingEvent) {
          VoiceUserTalkingEvent evt = (VoiceUserTalkingEvent) event;
          vcs.userTalkingInVoiceConf(evt.getRoom(), evt.getUserId(), evt.isTalking());
        } else if (event instanceof VoiceStartRecordingEvent) {
          VoiceStartRecordingEvent evt = (VoiceStartRecordingEvent) event;
          vcs.voiceConfRecordingStarted(evt.getRoom(), evt.getRecordingFilename(), evt.startRecord(), evt.getTimestamp());
        } else if (event instanceof AudioFloorChangedEvent) {
          AudioFloorChangedEvent evt = (AudioFloorChangedEvent) event;
          vcs.audioFloorChanged(
            evt.getRoom(),
            evt.getVoiceUserId(),
            evt.getOldVoiceUserId(),
            evt.getFloorTimestamp()
          );
        } else if (event instanceof VoiceConfRunningAndRecordingEvent) {
          VoiceConfRunningAndRecordingEvent evt = (VoiceConfRunningAndRecordingEvent) event;
          if (evt.running && ! evt.recording) {
            log.warn(""Voice conf running but not recording. conf="" + evt.getRoom()
                    + "",running="" + evt.running
                    + "",rec="" + evt.recording);
          }

          vcs.voiceConfRunningAndRecording(evt.getRoom(), evt.running, evt.recording, evt.confRecordings);
        } else if (event instanceof VoiceUsersStatusEvent) {
          VoiceUsersStatusEvent evt = (VoiceUsersStatusEvent) event;
          vcs.voiceUsersStatus(evt.getRoom(), evt.confMembers, evt.confRecordings);
        } else if (event instanceof VoiceCallStateEvent) {
          VoiceCallStateEvent evt = (VoiceCallStateEvent) event;
          vcs.voiceCallStateEvent(evt.getRoom(),
                  evt.callSession,
                  evt.clientSession,
                  evt.userId,
                  evt.callerName,
                  evt.callState,
                  evt.origCallerIdName,
                  evt.origCalledDest);
        } else if (event instanceof FreeswitchStatusReplyEvent) {
          FreeswitchStatusReplyEvent evt = (FreeswitchStatusReplyEvent) event;
          vcs.freeswitchStatusReplyEvent(evt.sendCommandTimestamp,
                  evt.status,
                  evt.receivedResponseTimestamp);
        } else if (event instanceof FreeswitchHeartbeatEvent) {
          FreeswitchHeartbeatEvent hbearEvt = (FreeswitchHeartbeatEvent) event;
          vcs.freeswitchHeartbeatEvent(hbearEvt.heartbeat);
        }

      }
    };

    runExec.execute(task);
  }

  public void start() {
    sendMessages = true;
    Runnable sender = new Runnable() {
      public void run() {
        while (sendMessages) {
          VoiceConferenceEvent message;
          try {
            message = messages.take();
            sendMessageToBigBlueButton(message);
          } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            log.error(""Exception taking message form queue: "", e);
          }
        }
      }
    };
    msgSenderExec.execute(sender);
  }

  public void stop() {
    sendMessages = false;
  }

  public void handleConferenceEvent(VoiceConferenceEvent event) {
    queueMessage(event);
  }

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/EjectAllUsersCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

public class EjectAllUsersCommand extends FreeswitchCommand {
    
    public EjectAllUsersCommand(String room, String requesterId) {
            super(room, requesterId);
    }

    @Override
    public String getCommandArgs() {
        return room + "" kick all"";
    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/TransferUserToMeetingCommand.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * 
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

public class TransferUserToMeetingCommand extends FreeswitchCommand {

    private final String targetRoom;
    private final String participant;
    private final String audioProfile;

    public TransferUserToMeetingCommand(String room, String targetRoom,
            String participant, String profile, String requesterId) {
        super(room, requesterId);
        this.targetRoom = targetRoom;
        this.participant = participant;
        this.audioProfile = profile;
    }

    @Override
    public String getCommandArgs() {
        return room + SPACE + ""transfer"" + SPACE + targetRoom + ""@""
                + this.audioProfile + SPACE + participant;
    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/GetUsersStatusCommand.java,"package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

import org.apache.commons.lang3.StringUtils;
import org.bigbluebutton.freeswitch.voice.events.*;
import org.bigbluebutton.freeswitch.voice.freeswitch.response.ConferenceMember;
import org.bigbluebutton.freeswitch.voice.freeswitch.response.XMLResponseConferenceListParser;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GetUsersStatusCommand extends FreeswitchCommand {
  private static Logger log = LoggerFactory.getLogger(GetUsersStatusCommand.class);
  private static final Pattern CALLERNAME_PATTERN = Pattern.compile(""(.*)-bbbID-(.*)$"");
  private static final Pattern CALLERNAME_WITH_SESS_INFO_PATTERN = Pattern.compile(""^(.*)_(\\d+)-bbbID-(.*)$"");
  private static final Pattern GLOBAL_AUDION_PATTERN = Pattern.compile(""(GLOBAL_AUDIO)_(.*)$"");

  public GetUsersStatusCommand(String room, String requesterId) {
    super(room, requesterId);
  }

  @Override
  public String getCommandArgs() {
    return getRoom() + SPACE + ""xml_list"";
  }

  public void handleResponse(EslMessage response, ConferenceEventListener eventListener) {

    String firstLine = response.getBodyLines().get(0);
    //log.info(""GetUsersStatusCommand: Check conference first line response: "" + firstLine);

    if(!firstLine.startsWith(""<?xml"")) {
      log.info(""Conference is not running {}."", room);
      return;
    }

    XMLResponseConferenceListParser confXML = new XMLResponseConferenceListParser();
    //get a factory
    SAXParserFactory spf = SAXParserFactory.newInstance();
    try {

      //get a new instance of parser
      SAXParser sp = spf.newSAXParser();

      //Hack turning body lines back into string then to ByteStream.... BLAH!
      String responseBody = StringUtils.join(response.getBodyLines(), ""\n"");
      //http://mark.koli.ch/2009/02/resolving-orgxmlsaxsaxparseexception-content-is-not-allowed-in-prolog.html
      //This Sux!
      responseBody = responseBody.trim().replaceFirst(""^([\\W]+)<"",""<"");

      ByteArrayInputStream bs = new ByteArrayInputStream(responseBody.getBytes());
      sp.parse(bs, confXML);

      Integer numUsers =  confXML.getConferenceList().size();
      if (numUsers > 0) {
        //log.info(""Check user status response: "" + responseBody);

        List<ConfMember> confMembers = new ArrayList<ConfMember>();
        List<ConfRecording> confRecordings = new ArrayList<ConfRecording>();

        for (ConferenceMember member : confXML.getConferenceList()) {
          if (""caller"".equals(member.getMemberType())) {
            String callerId = member.getCallerId();
            String callerIdName = member.getCallerIdName();
            String voiceUserId = callerIdName;
            String uuid = member.getUUID();
            String clientSession = ""0"";

            Matcher gapMatcher = GLOBAL_AUDION_PATTERN.matcher(callerIdName);
            // Ignore GLOBAL_AUDIO user.
            if (!gapMatcher.matches()) {
              Matcher matcher = CALLERNAME_PATTERN.matcher(callerIdName);
              Matcher callWithSess = CALLERNAME_WITH_SESS_INFO_PATTERN.matcher(callerIdName);
              if (callWithSess.matches()) {
                voiceUserId = callWithSess.group(1).trim();
                clientSession = callWithSess.group(2).trim();
                callerIdName = callWithSess.group(3).trim();
              } else if (matcher.matches()) {
                voiceUserId = matcher.group(1).trim();
                callerIdName = matcher.group(2).trim();
              } else {
                // This is a caller using dial in or out
                voiceUserId = ""v_"" + member.getId().toString();
              }

              log.info(""Conf user. uuid="" + uuid
                      + "",caller="" + callerIdName
                      + "",clientSession="" + clientSession
                      + "",callerId="" + callerId
                      + "",conf="" + room
                      + "",muted="" + member.getMuted()
                      + "",talking="" + member.getSpeaking());

              ConfMember confMember = new ConfMember(voiceUserId,
                      member.getId().toString(),
                      callerId, callerIdName,
                      member.getMuted(),
                      member.getSpeaking(),
                      ""none"");
              confMembers.add(confMember);
            }
          } else if (""recording_node"".equals(member.getMemberType())) {
            ConfRecording confRecording = new ConfRecording(member.getRecordPath(), member.getRecordStartTime());
            confRecordings.add(confRecording);
          }
        }

        VoiceUsersStatusEvent voiceUsersStatusEvent =
                new VoiceUsersStatusEvent(getRoom(), confMembers, confRecordings);
        eventListener.handleConferenceEvent(voiceUsersStatusEvent);
      }
    }catch(SAXException se) {
      log.error(""Cannot parse response. "", se);
    }catch(ParserConfigurationException pce) {
      log.error(""ParserConfigurationException. "", pce);
    }catch (IOException ie) {
      log.error(""Cannot parse response. IO Exception. "", ie);
    }
  }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/RecordConferenceCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

import org.bigbluebutton.freeswitch.voice.events.ConferenceEventListener;
import org.freeswitch.esl.client.transport.message.EslMessage;

public class RecordConferenceCommand extends FreeswitchCommand {

	private boolean record;
	private String recordPath;
	
	public RecordConferenceCommand(String room, String requesterId, boolean record, String recordPath){
		super(room, requesterId);
		this.record = record;
		this.recordPath = recordPath;
	}
	

	@Override
	public String getCommandArgs() {
		String action = ""norecord"";
		if (record)
			action = ""record"";
		
		return SPACE + getRoom() + SPACE + action + SPACE + recordPath;
	}

	public void handleResponse(EslMessage response, ConferenceEventListener eventListener) {

        //Test for Known Conference

    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/GetAllUsersCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

import org.freeswitch.esl.client.transport.message.EslMessage;
import org.apache.commons.lang3.StringUtils;
import org.bigbluebutton.freeswitch.voice.events.ConferenceEventListener;
import org.bigbluebutton.freeswitch.voice.events.VoiceUserJoinedEvent;
import org.bigbluebutton.freeswitch.voice.freeswitch.response.ConferenceMember;
import org.bigbluebutton.freeswitch.voice.freeswitch.response.XMLResponseConferenceListParser;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.xml.sax.SAXException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class GetAllUsersCommand extends FreeswitchCommand {
    private static Logger log = LoggerFactory.getLogger(GetAllUsersCommand.class);
    public GetAllUsersCommand(String room, String requesterId) {
            super(room, requesterId);
    }
    
    @Override
    public String getCommandArgs() {
        return getRoom() + SPACE + ""xml_list"";
    }

    private static final Pattern CALLERNAME_PATTERN = Pattern.compile(""(.*)-bbbID-(.*)$"");
    
    public void handleResponse(EslMessage response, ConferenceEventListener eventListener) {

        //Test for Known Conference

        String firstLine = response.getBodyLines().get(0);

        //E.g. Conference 85115 not found
        
        if(!firstLine.startsWith(""<?xml"")) {
//            System.out.println(""Not XML: [{}]"", firstLine);
            return;
        }


        XMLResponseConferenceListParser confXML = new XMLResponseConferenceListParser();

        //get a factory
        SAXParserFactory spf = SAXParserFactory.newInstance();
        try {

            //get a new instance of parser
            SAXParser sp = spf.newSAXParser();

            //Hack turning body lines back into string then to ByteStream.... BLAH!
            
            String responseBody = StringUtils.join(response.getBodyLines(), ""\n"");

            //http://mark.koli.ch/2009/02/resolving-orgxmlsaxsaxparseexception-content-is-not-allowed-in-prolog.html
            //This Sux!
            responseBody = responseBody.trim().replaceFirst(""^([\\W]+)<"",""<"");

            ByteArrayInputStream bs = new ByteArrayInputStream(responseBody.getBytes());
            sp.parse(bs, confXML);

            Integer numUsers =  confXML.getConferenceList().size();
            log.info(""Num users in conf when starting. conf={},numUsers={}."", room, numUsers);

            if (numUsers > 0) {
                log.info(""Check conference response: "" + responseBody);

                for(ConferenceMember member : confXML.getConferenceList()) {
                    if (""caller"".equals(member.getMemberType())) {
                        //Foreach found member in conference create a JoinedEvent
                        String callerId = member.getCallerId();
                        String callerIdName = member.getCallerIdName();
                        String voiceUserId = callerIdName;
                        String uuid = member.getUUID();
                        log.info(""Conf user. uuid="" + uuid
                                + "",caller="" + callerIdName + "",callerId="" + callerId + "",conf="" + room);
                        Matcher matcher = CALLERNAME_PATTERN.matcher(callerIdName);
                        if (matcher.matches()) {
                            voiceUserId = matcher.group(1).trim();
                            callerIdName = matcher.group(2).trim();
                        }

                        VoiceUserJoinedEvent pj = new VoiceUserJoinedEvent(voiceUserId, member.getId().toString(), confXML.getConferenceRoom(),
                                callerId, callerIdName, member.getMuted(), member.getSpeaking(), ""none"");
                        eventListener.handleConferenceEvent(pj);
                    } else if (""recording_node"".equals(member.getMemberType())) {

                    }


                }
            } else {
                log.info(""INFO! Successfully ejected all users from conference {}."", room);
            }

        }catch(SAXException se) {
//            System.out.println(""Cannot parse repsonce. "", se);
        }catch(ParserConfigurationException pce) {
//            System.out.println(""ParserConfigurationException. "", pce);
        }catch (IOException ie) {
//        	System.out.println(""Cannot parse repsonce. IO Exception. "", ie);
        }
    }

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/FreeswitchCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

public abstract class FreeswitchCommand {
    public static final String SPACE = "" "";

    protected final String room;
    protected final String requesterId;

    public FreeswitchCommand(String room, String requesterId) {
            this.room = room;
            this.requesterId = requesterId;
    }

    public String getCommand() {
        return ""conference""; //conference is default, override if needed.
    }

    public abstract String getCommandArgs();

    public String getRoom() {
            return room;
    }

    public String getRequesterId() {
            return requesterId;
    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/BroadcastConferenceCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

import org.bigbluebutton.freeswitch.voice.events.ConferenceEventListener;
import org.freeswitch.esl.client.transport.message.EslMessage;

public class BroadcastConferenceCommand extends FreeswitchCommand {
	private boolean record;
	private String icecastPath;
	
	public BroadcastConferenceCommand(String room, String requesterId, boolean record, String icecastPath){
		super(room, requesterId);
		this.record = record;
		this.icecastPath = icecastPath;
	}
	

	@Override
	public String getCommandArgs() {
		String action = ""norecord"";
		if (record)
			action = ""record"";
		
		return SPACE + getRoom() + SPACE + action + SPACE + icecastPath;
	}

	public void handleResponse(EslMessage response, ConferenceEventListener eventListener) {

        //Test for Known Conference


    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/PlaySoundCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2022 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
*
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

public class PlaySoundCommand extends FreeswitchCommand {

    private final String participant;
    private final String soundPath;

    public PlaySoundCommand(String room, String participant, String soundPath, String requesterId) {
            super(room, requesterId);
            this.participant = participant;
            this.soundPath = soundPath;
    }

    @Override
    public String getCommandArgs() {
            String action = ""play"";

            return room + SPACE + action + SPACE
                + this.soundPath + SPACE + participant;
    }

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/MuteUserCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

public class MuteUserCommand extends FreeswitchCommand {
	
    private final String participant;
    private final Boolean mute;

    public MuteUserCommand(String room, String participant, Boolean mute, String requesterId) {
            super(room, requesterId);
            this.participant = participant;
            this.mute = mute;
    }

    @Override
    public String getCommandArgs() {
            String action = ""unmute"";
            if (mute) action = ""mute"";

            return room + SPACE + action + SPACE + participant;
    }

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/EjectUserCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

public class EjectUserCommand extends FreeswitchCommand {
    
    private final String participant;

    public EjectUserCommand(String room, String participant, String requesterId) {
            super(room, requesterId);
            this.participant = participant;
    }

    @Override
    public String getCommandArgs() {
        return room + "" kick "" + participant;
    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/ConferenceCheckRecordCommand.java,"package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

import org.apache.commons.lang3.StringUtils;
import org.bigbluebutton.freeswitch.voice.events.ConfRecording;
import org.bigbluebutton.freeswitch.voice.events.ConferenceEventListener;
import org.bigbluebutton.freeswitch.voice.events.VoiceConfRunningAndRecordingEvent;
import org.bigbluebutton.freeswitch.voice.freeswitch.response.ConferenceMember;
import org.bigbluebutton.freeswitch.voice.freeswitch.response.XMLResponseConferenceListParser;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ConferenceCheckRecordCommand extends FreeswitchCommand {
  private static Logger log = LoggerFactory.getLogger(ConferenceCheckRecordCommand.class);

  public ConferenceCheckRecordCommand(String room, String requesterId) {
    super(room, requesterId);
  }

  @Override
  public String getCommandArgs() {
    //return room + "" chkrecord"";
    return getRoom() + SPACE + ""xml_list"";
  }

  public void handleResponse(EslMessage response, ConferenceEventListener eventListener) {
    List<ConfRecording> confRecordings = new ArrayList<ConfRecording>();

    String firstLine = response.getBodyLines().get(0);
    //log.info(""Check conference first line response: "" + firstLine);

    if(!firstLine.startsWith(""<?xml"")) {
      //log.info(""Conference is not running and recording {}."", room);
      VoiceConfRunningAndRecordingEvent voiceConfRunningAndRecordingEvent =
              new VoiceConfRunningAndRecordingEvent(getRoom(), false, false, confRecordings);
      eventListener.handleConferenceEvent(voiceConfRunningAndRecordingEvent);
      return;
    }

    XMLResponseConferenceListParser confXML = new XMLResponseConferenceListParser();
    //get a factory
    SAXParserFactory spf = SAXParserFactory.newInstance();
    try {

      boolean running = false;
      boolean recording = false;

      //get a new instance of parser
      SAXParser sp = spf.newSAXParser();

      //Hack turning body lines back into string then to ByteStream.... BLAH!
      String responseBody = StringUtils.join(response.getBodyLines(), ""\n"");
      //http://mark.koli.ch/2009/02/resolving-orgxmlsaxsaxparseexception-content-is-not-allowed-in-prolog.html
      //This Sux!
      responseBody = responseBody.trim().replaceFirst(""^([\\W]+)<"",""<"");

      ByteArrayInputStream bs = new ByteArrayInputStream(responseBody.getBytes());
      sp.parse(bs, confXML);


      Integer numUsers =  confXML.getConferenceList().size();
      if (numUsers > 0) {
        //log.info(""Check conference response: "" + responseBody);
        running = true;

        for (ConferenceMember member : confXML.getConferenceList()) {
          if (""caller"".equals(member.getMemberType())) {
            // We don't need this. If there is at least one user in the conference,
            // then it is running. (ralam Oct 16, 2019)

          } else if (""recording_node"".equals(member.getMemberType())) {
            recording = true;
            ConfRecording confRecording = new ConfRecording(member.getRecordPath(), member.getRecordStartTime());
            confRecordings.add(confRecording);
          }
        }
      }

      VoiceConfRunningAndRecordingEvent voiceConfRunningAndRecordingEvent =
              new VoiceConfRunningAndRecordingEvent(getRoom(), running, recording, confRecordings);
      eventListener.handleConferenceEvent(voiceConfRunningAndRecordingEvent);

    }catch(SAXException se) {
      log.error(""Cannot parse response. "", se);
    }catch(ParserConfigurationException pce) {
      log.error(""ParserConfigurationException. "", pce);
    }catch (IOException ie) {
      log.error(""Cannot parse response. IO Exception. "", ie);
    }
  }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/ForceEjectUserCommand.java,"package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

import com.google.gson.Gson;
import org.bigbluebutton.freeswitch.voice.events.ConferenceEventListener;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ForceEjectUserCommand extends FreeswitchCommand {
    private static Logger log = LoggerFactory.getLogger(ForceEjectUserCommand.class);

    private final String voiceConf;
    private final String userId;
    private final String uuid;

    public ForceEjectUserCommand(String voiceConf, String userId, String uuid) {
        super(voiceConf, userId);
        this.voiceConf = voiceConf;
        this.userId = userId;
        this.uuid = uuid;
    }
    @Override
    public String getCommand() {
        return ""uuid_kill "" + uuid;
    }

    @Override
    public String getCommandArgs() {
        log.debug(""Force eject user "" + userId + "" from conf "" + voiceConf + "" by uuid_kill "" + uuid);
        return """";
    }

    public void handleResponse(EslMessage response, ConferenceEventListener eventListener) {
        Gson gson = new Gson();
        log.info(gson.toJson(response.getBodyLines()));

    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/CheckIfConfIsRunningCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

import org.apache.commons.lang3.StringUtils;
import org.bigbluebutton.freeswitch.voice.events.ConferenceEventListener;
import org.bigbluebutton.freeswitch.voice.freeswitch.DelayedCommandSenderService;
import org.bigbluebutton.freeswitch.voice.freeswitch.response.ConferenceMember;
import org.bigbluebutton.freeswitch.voice.freeswitch.response.XMLResponseConferenceListParser;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.regex.Matcher;

public class CheckIfConfIsRunningCommand extends FreeswitchCommand {
    private static Logger log = LoggerFactory.getLogger(CheckIfConfIsRunningCommand.class);
    private DelayedCommandSenderService delayedCommandSenderService;
    private Integer forceEjectCount = 0;

    public CheckIfConfIsRunningCommand(String room, String requesterId,
                                       DelayedCommandSenderService delayedCommandSenderService,
                                       Integer forceEjectCount) {
            super(room, requesterId);
            this.delayedCommandSenderService = delayedCommandSenderService;
            this.forceEjectCount = forceEjectCount + 1;
    }
    
    @Override
    public String getCommandArgs() {
        log.debug(""Check if ejecting users was a success for {}."", room);
        return getRoom() + SPACE + ""xml_list"";
    }
    
    public void handleResponse(EslMessage response, ConferenceEventListener eventListener) {

        //Test for Known Conference

        String firstLine = response.getBodyLines().get(0);

        //log.info(""Check conference first line response: "" + firstLine);
        //E.g. Conference 85115 not found
        
        if(!firstLine.startsWith(""<?xml"")) {
            log.info(""INFO! Successfully ejected all users from conference {}."", room);
            return;
        }


        XMLResponseConferenceListParser confXML = new XMLResponseConferenceListParser();

        //get a factory
        SAXParserFactory spf = SAXParserFactory.newInstance();
        try {

            //get a new instance of parser
            SAXParser sp = spf.newSAXParser();

            //Hack turning body lines back into string then to ByteStream.... BLAH!
            String responseBody = StringUtils.join(response.getBodyLines(), ""\n"");
            //http://mark.koli.ch/2009/02/resolving-orgxmlsaxsaxparseexception-content-is-not-allowed-in-prolog.html
            //This Sux!
            responseBody = responseBody.trim().replaceFirst(""^([\\W]+)<"",""<"");

            ByteArrayInputStream bs = new ByteArrayInputStream(responseBody.getBytes());
            sp.parse(bs, confXML);

            Integer numUsers =  confXML.getConferenceList().size();
            if (numUsers > 0) {
                log.info(""Check conference response: "" + responseBody);
                log.warn(""WARNING! Failed to eject all users from conf={},numUsers={},attempts={}."",
                        room, numUsers, forceEjectCount);
                if (forceEjectCount <= 5) {
                    for (ConferenceMember member : confXML.getConferenceList()) {
                        if (""caller"".equals(member.getMemberType())) {
                            //Foreach found member in conference create a JoinedEvent
                            String callerId = member.getCallerId();
                            String callerIdName = member.getCallerIdName();
                            String voiceUserId = callerIdName;
                            String uuid = member.getUUID();
                            log.info(""WARNING! User possibly stuck in conference. uuid="" + uuid
                                    + "",caller="" + callerIdName + "",callerId="" + callerId + "",conf="" + room);

                            // We have stubborn users that cannot be ejected from the voice conference.
                            // This results in the voice conference hanging around for potentially a long time.
                            // Force ejection by killing their uuid. (ralam Oct 1, 2019)
                            ForceEjectUserCommand forceEjectUserCommand = new ForceEjectUserCommand(getRoom(),
                                    member.getId().toString(),
                                    member.getUUID());
                            delayedCommandSenderService.handleMessage(forceEjectUserCommand, 5000L);

                        } else if (""recording_node"".equals(member.getMemberType())) {

                        }
                    }
                    // Check again if the conference is still running after ejecting the users. (ralam Oct. 1, 2019)
                    CheckIfConfIsRunningCommand command = new CheckIfConfIsRunningCommand(getRoom(),
                            getRequesterId(),
                            delayedCommandSenderService,
                            forceEjectCount + 1);
                    delayedCommandSenderService.handleMessage(command, 10000);
                } else {
                    log.warn(""Failed to eject users for voice conf "" + getRoom() + "" after "" + forceEjectCount + "" tries."");
                }
            } else {
                log.info(""INFO! Successfully ejected all users from conference {}."", room);
            }


        }catch(SAXException se) {
//            System.out.println(""Cannot parse repsonce. "", se);
        }catch(ParserConfigurationException pce) {
//            System.out.println(""ParserConfigurationException. "", pce);
        }catch (IOException ie) {
//        	System.out.println(""Cannot parse repsonce. IO Exception. "", ie);
        }
    }

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/StopSoundCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2022 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
*
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

public class StopSoundCommand extends FreeswitchCommand {

    private final String participant;

    public StopSoundCommand(String room, String participant, String requesterId) {
            super(room, requesterId);
            this.participant = participant;
    }

    @Override
    public String getCommandArgs() {
            String action = ""stop all"";

            return room + SPACE + action + SPACE + participant;
    }

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/DeafUserCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2022 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
*
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

public class DeafUserCommand extends FreeswitchCommand {

    private final String participant;
    private final Boolean deaf;

    public DeafUserCommand(String room, String participant, Boolean deaf, String requesterId) {
            super(room, requesterId);
            this.participant = participant;
            this.deaf = deaf;
    }

    @Override
    public String getCommandArgs() {
            String action = ""undeaf"";
            if (deaf) action = ""deaf"";

            return room + SPACE + action + SPACE + participant;
    }

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/HoldUserCommand.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2022 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
*
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

public class HoldUserCommand extends FreeswitchCommand {

    private final String participant;
    private final Boolean hold;

    public HoldUserCommand(String room, String participant, Boolean hold, String requesterId) {
            super(room, requesterId);
            this.participant = participant;
            this.hold = hold;
    }

    @Override
    public String getCommandArgs() {
            String action = ""unhold"";
            if (hold) action = ""hold"";

            return room + SPACE + action + SPACE + participant;
    }

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/DelayedCommand.java,"package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

import java.util.concurrent.Delayed;
import java.util.concurrent.TimeUnit;

public class DelayedCommand implements Delayed {
  public final FreeswitchCommand conferenceCommand;
  public final long callTime;


  public DelayedCommand(FreeswitchCommand conferenceCommand, long delayInMillis) {
    this.conferenceCommand = conferenceCommand;
    this.callTime = System.currentTimeMillis() + delayInMillis;
  }

  @Override
  public long getDelay(TimeUnit unit) {
    long diff = callTime - System.currentTimeMillis();
    return unit.convert(diff, TimeUnit.MILLISECONDS);
  }

  @Override
  public int compareTo(Delayed o) {
    return new Long(this.callTime - ((DelayedCommand) o).callTime).intValue();
  }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/actions/CheckFreeswitchStatusCommand.java,"package org.bigbluebutton.freeswitch.voice.freeswitch.actions;

import com.google.gson.Gson;
import org.apache.commons.lang3.StringUtils;
import org.bigbluebutton.freeswitch.voice.events.ConferenceEventListener;
import org.bigbluebutton.freeswitch.voice.events.FreeswitchStatusReplyEvent;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CheckFreeswitchStatusCommand extends FreeswitchCommand {
    private static Logger log = LoggerFactory.getLogger(CheckFreeswitchStatusCommand.class);

    private long sendCommandTimestamp = 0L;

    public CheckFreeswitchStatusCommand(String room, String requesterId) {
        super(room, requesterId);
    }

    @Override
    public String getCommand() {
        sendCommandTimestamp = System.currentTimeMillis();
        return ""status"";
    }

    @Override
    public String getCommandArgs() {
        log.debug(""Check FreeSWITCH Status."");
        return """";
    }

    public void handleResponse(EslMessage response, ConferenceEventListener eventListener) {
        Gson gson = new Gson();
        log.info(gson.toJson(response.getBodyLines()));
        FreeswitchStatusReplyEvent statusEvent = new FreeswitchStatusReplyEvent(
                sendCommandTimestamp,
                response.getBodyLines(),
                System.currentTimeMillis());
        eventListener.handleConferenceEvent(statusEvent);
    }

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/ESLEventListener.java,"package org.bigbluebutton.freeswitch.voice.freeswitch;


import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.google.gson.Gson;
import org.bigbluebutton.freeswitch.voice.events.*;
import org.freeswitch.esl.client.IEslEventListener;
import org.freeswitch.esl.client.transport.event.EslEvent;
import org.jboss.netty.channel.ExceptionEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ESLEventListener implements IEslEventListener {
    private static Logger log = LoggerFactory.getLogger(ESLEventListener.class);

    private static final String START_TALKING_EVENT = ""start-talking"";
    private static final String STOP_TALKING_EVENT = ""stop-talking"";
    private static final String START_RECORDING_EVENT = ""start-recording"";
    private static final String STOP_RECORDING_EVENT = ""stop-recording"";
    private static final String CONFERENCE_CREATED_EVENT = ""conference-create"";
    private static final String CONFERENCE_DESTROYED_EVENT = ""conference-destroy"";
    private static final String FLOOR_CHANGE_EVENT = ""video-floor-change"";

    private final ConferenceEventListener conferenceEventListener;
    
    public ESLEventListener(ConferenceEventListener conferenceEventListener) {
        this.conferenceEventListener = conferenceEventListener;
    }
    
    @Override
    public void conferenceEventPlayFile(String uniqueId, String confName, int confSize, EslEvent event) {
        //Ignored, Noop
    }

    @Override
    public void backgroundJobResultReceived(EslEvent event) {
        //System.out.println( ""Background job result received ["" + event + ""]"");
    }

    @Override
    public void exceptionCaught(ExceptionEvent e) {
        log.warn(""Exception caught: "", e);
//        setChanged();
//        notifyObservers(e);
    }

    private static final Pattern GLOBAL_AUDION_PATTERN = Pattern.compile(""(GLOBAL_AUDIO)_(.*)$"");
    private static final Pattern CALLERNAME_PATTERN = Pattern.compile(""(.*)-bbbID-(.*)$"");
    private static final Pattern CALLERNAME_WITH_SESS_INFO_PATTERN = Pattern.compile(""^(.*)_(\\d+)-bbbID-(.*)$"");
    private static final Pattern CALLERNAME_LISTENONLY_PATTERN = Pattern.compile(""^(.*)_(\\d+)-bbbID-LISTENONLY-(.*)$"");
    private static final Pattern ECHO_TEST_DEST_PATTERN = Pattern.compile(""^echo(\\d+)$"");
    
    @Override
    public void conferenceEventJoin(String uniqueId, String confName, int confSize, EslEvent event) {

        Integer memberId = this.getMemberIdFromEvent(event);
        Map<String, String> headers = event.getEventHeaders();
        String callerId = this.getCallerIdFromEvent(event);
        String callerIdName = this.getCallerIdNameFromEvent(event);
        boolean muted = headers.get(""Speak"").equals(""true"") ? false : true; //Was inverted which was causing a State issue
        boolean speaking = headers.get(""Talking"").equals(""true"") ? true : false;

        String voiceUserId = callerIdName;

        Matcher gapMatcher = GLOBAL_AUDION_PATTERN.matcher(callerIdName);
        if (gapMatcher.matches()) {
            //System.out.println(""Ignoring GLOBAL AUDIO USER ["" + callerIdName + ""]"");
            return;
        }

        String coreuuid = headers.get(""Core-UUID"");
        String callState = ""IN_CONFERENCE"";
        String origCallerIdName = headers.get(""Caller-Caller-ID-Name"");
        String origCallerDestNumber = headers.get(""Caller-Destination-Number"");
        String clientSession = ""0"";

        Matcher matcher = CALLERNAME_PATTERN.matcher(callerIdName);
        Matcher callWithSess = CALLERNAME_WITH_SESS_INFO_PATTERN.matcher(callerIdName);
        if (callWithSess.matches()) {
            voiceUserId = callWithSess.group(1).trim();
            clientSession = callWithSess.group(2).trim();
            callerIdName = callWithSess.group(3).trim();
        } else if (matcher.matches()) {
            voiceUserId = matcher.group(1).trim();
            callerIdName = matcher.group(2).trim();
        } else {
            // This is a caller using phone. Let's create a userId that will allow
            // us to identify the user as such in other parts of the system.
            // (ralam - sept 1, 2017)
            voiceUserId = ""v_"" + memberId.toString();
        }

        VoiceCallStateEvent csEvent = new VoiceCallStateEvent(
                confName,
                coreuuid,
                clientSession,
                voiceUserId,
                callerIdName,
                callState,
                origCallerIdName,
                origCallerDestNumber);
        conferenceEventListener.handleConferenceEvent(csEvent);

        String callerUUID = this.getMemberUUIDFromEvent(event);
        log.info(""Caller joined: conf="" + confName +
                "",uuid="" + callerUUID +
                "",memberId="" + memberId +
                "",callerId="" + callerId +
                "",callerIdName="" + callerIdName +
                "",muted="" + muted +
                "",talking="" + speaking);

        VoiceUserJoinedEvent pj = new VoiceUserJoinedEvent(
                voiceUserId,
                memberId.toString(),
                confName,
                callerId,
                callerIdName,
                muted,
                speaking,
                ""none"");
        conferenceEventListener.handleConferenceEvent(pj);
    }

    @Override
    public void conferenceEventLeave(String uniqueId, String confName, int confSize, EslEvent event) {      
        Integer memberId = this.getMemberIdFromEvent(event);
        String callerId = this.getCallerIdFromEvent(event);
        String callerIdName = this.getCallerIdNameFromEvent(event);

        String callerUUID = this.getMemberUUIDFromEvent(event);
        log.info(""Caller left: conf="" + confName +
                "",uuid="" + callerUUID +
                "",memberId="" + memberId +
                "",callerId="" + callerId +
                "",callerIdName="" + callerIdName);
        VoiceUserLeftEvent pl = new VoiceUserLeftEvent(memberId.toString(), confName);
        conferenceEventListener.handleConferenceEvent(pl);
    }

    @Override
    public void conferenceEventMute(String uniqueId, String confName, int confSize, EslEvent event) {
        Integer memberId = this.getMemberIdFromEvent(event);
        VoiceUserMutedEvent pm = new VoiceUserMutedEvent(memberId.toString(), confName, true);
        conferenceEventListener.handleConferenceEvent(pm);
    }

    @Override
    public void conferenceEventUnMute(String uniqueId, String confName, int confSize, EslEvent event) {
        Integer memberId = this.getMemberIdFromEvent(event);
        VoiceUserMutedEvent pm = new VoiceUserMutedEvent(memberId.toString(), confName, false);
        conferenceEventListener.handleConferenceEvent(pm);
    }

    @Override
    public void conferenceEventAction(String uniqueId, String confName, int confSize, String action, EslEvent event) {
        if (action == null) {
            return;
        }

        if (action.equals(START_TALKING_EVENT)) {
            Integer memberId = this.getMemberIdFromEvent(event);
            VoiceUserTalkingEvent pt = new VoiceUserTalkingEvent(memberId.toString(), confName, true);
            conferenceEventListener.handleConferenceEvent(pt);          
        } else if (action.equals(STOP_TALKING_EVENT)) {
            Integer memberId = this.getMemberIdFromEvent(event);
            VoiceUserTalkingEvent pt = new VoiceUserTalkingEvent(memberId.toString(), confName, false);
            conferenceEventListener.handleConferenceEvent(pt);          
        } else if (action.equals(CONFERENCE_CREATED_EVENT)) {
            VoiceConfRunningEvent pt = new VoiceConfRunningEvent(confName, true);
            conferenceEventListener.handleConferenceEvent(pt);
        } else if (action.equals(CONFERENCE_DESTROYED_EVENT)) {
            VoiceConfRunningEvent pt = new VoiceConfRunningEvent(confName, false);
            conferenceEventListener.handleConferenceEvent(pt);
        } else if (action.equals(FLOOR_CHANGE_EVENT)) {
            String holderMemberId = this.getNewFloorHolderMemberIdFromEvent(event);
            String oldHolderMemberId = this.getOldFloorHolderMemberIdFromEvent(event);
            String floorTimestamp = event.getEventHeaders().get(""Event-Date-Timestamp"");
            AudioFloorChangedEvent vFloor= new AudioFloorChangedEvent(confName, holderMemberId, oldHolderMemberId, floorTimestamp);
            conferenceEventListener.handleConferenceEvent(vFloor);
        } else {
            log.warn(""Unknown conference Action ["" + action + ""]"");
        }
    }

    @Override
    public void conferenceEventTransfer(String uniqueId, String confName, int confSize, EslEvent event) {
        //Ignored, Noop
    }

    @Override
    public void conferenceEventThreadRun(String uniqueId, String confName, int confSize, EslEvent event) {
        
    }
    
    //@Override
    public void conferenceEventRecord(String uniqueId, String confName, int confSize, EslEvent event) {
        String action = event.getEventHeaders().get(""Action"");

        if(action == null) {
            return;
        }

        if (action.equals(START_RECORDING_EVENT)) {
            VoiceStartRecordingEvent sre = new VoiceStartRecordingEvent(confName, true);
            sre.setRecordingFilename(getRecordFilenameFromEvent(event));
            sre.setTimestamp(genTimestamp().toString());

            conferenceEventListener.handleConferenceEvent(sre);
        } else if (action.equals(STOP_RECORDING_EVENT)) {
            VoiceStartRecordingEvent sre = new VoiceStartRecordingEvent(confName, false);
            sre.setRecordingFilename(getRecordFilenameFromEvent(event));
            sre.setTimestamp(genTimestamp().toString());
            conferenceEventListener.handleConferenceEvent(sre);
        } 

        else {
            log.warn(""Processing UNKNOWN conference Action "" + action + ""]"");
        }
    }

    private Long genTimestamp() {
        return TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
    }
    
    @Override
    public void eventReceived(EslEvent event) {
//        System.out.println(""*********** ESL Event Listener received event=["" + event.getEventName() + ""]"" +
//                event.getEventHeaders().toString());

        /**
        Map<String, String> eventHeaders1 = event.getEventHeaders();
         StringBuilder sb = new StringBuilder("""");
         sb.append(""\n"");
         for (Iterator it = eventHeaders1.entrySet().iterator(); it.hasNext(); ) {
         Map.Entry entry = (Map.Entry)it.next();
         sb.append(entry.getKey());
         sb.append("" => '"");
         sb.append(entry.getValue());
         sb.append(""'\n"");
         }

         System.out.println(""##### ===>>> "" + sb.toString());
         System.out.println(""<<<=== #####"");
        **/

        if (event.getEventName().equals(""HEARTBEAT"")) {
            Gson gson = new Gson();
            String json = gson.toJson(event.getEventHeaders());
            //log.info(json);

            log.info(""Received Heartbeat from Freeswitch."");
            Map<String, String> headers = event.getEventHeaders();

            Map<String, String> hb = new HashMap<String, String>();
            hb.put(""timestamp"", headers.get(""Event-Date-Timestamp""));
            hb.put(""version"", headers.get(""FreeSWITCH-Version""));
            hb.put(""uptime"", headers.get(""Up-Time""));

            FreeswitchHeartbeatEvent hbeatEvent = new FreeswitchHeartbeatEvent(hb);
            conferenceEventListener.handleConferenceEvent(hbeatEvent);

        } else if (event.getEventName().equals( ""CHANNEL_EXECUTE"" )) {
            Map<String, String> eventHeaders = event.getEventHeaders();

            String application = (eventHeaders.get(""Application"") == null) ? """" : eventHeaders.get(""Application"");
            String channelCallState = (eventHeaders.get(""Channel-Call-State"") == null) ? """" : eventHeaders.get(""Channel-Call-State"");
            String varvBridge = (eventHeaders.get(""variable_vbridge"") == null) ? """" : eventHeaders.get(""variable_vbridge"");

            if (""echo"".equalsIgnoreCase(application) && !varvBridge.isEmpty()) {
                String origCallerIdName = eventHeaders.get(""Caller-Caller-ID-Name"");
                String origCallerDestNumber = eventHeaders.get(""Caller-Destination-Number"");
                String coreuuid = eventHeaders.get(""Core-UUID"");

                //System.out.println(""******** uuid="" + coreuuid + "" "" + origCallerIdName + "" is in echo test "" + origCallerDestNumber + "" vbridge="" + varvBridge);

                String voiceUserId = """";
                String callerName = origCallerIdName;
                String clientSession = ""0"";
                String callState = ""IN_ECHO_TEST"";

                Matcher callerListenOnly = CALLERNAME_LISTENONLY_PATTERN.matcher(origCallerIdName);
                Matcher callWithSess = CALLERNAME_WITH_SESS_INFO_PATTERN.matcher(origCallerIdName);
                if (callWithSess.matches()) {
                    voiceUserId = callWithSess.group(1).trim();
                    clientSession = callWithSess.group(2).trim();
                    callerName = callWithSess.group(3).trim();
                } else if (callerListenOnly.matches()) {
                    voiceUserId = callerListenOnly.group(1).trim();
                    clientSession = callWithSess.group(2).trim();
                    callerName = callerListenOnly.group(3).trim();
                }

                String conf = origCallerDestNumber;
                Matcher callerDestNumberMatcher = ECHO_TEST_DEST_PATTERN.matcher(origCallerDestNumber);
                if (callerDestNumberMatcher.matches()) {
                    conf = callerDestNumberMatcher.group(1).trim();
                }

                VoiceCallStateEvent csEvent = new VoiceCallStateEvent(conf,
                        coreuuid,
                        clientSession,
                        voiceUserId,
                        callerName,
                        callState,
                        origCallerIdName,
                        origCallerDestNumber);
                conferenceEventListener.handleConferenceEvent(csEvent);

            } else if (""RINGING"".equalsIgnoreCase(channelCallState) && !varvBridge.isEmpty()) {
                String origCallerIdName = eventHeaders.get(""Caller-Caller-ID-Name"");
                String origCallerDestNumber = eventHeaders.get(""Caller-Destination-Number"");
                String coreuuid = eventHeaders.get(""Core-UUID"");
                //System.out.println(""******** uuid="" + coreuuid + "" "" + origCallerIdName + "" is in ringing "" + origCallerDestNumber + "" vbridge="" + varvBridge);

                String voiceUserId = """";
                String callerName = origCallerIdName;
                String clientSession = ""0"";
                String callState = ""CALL_STARTED"";

                Matcher callerListenOnly = CALLERNAME_LISTENONLY_PATTERN.matcher(origCallerIdName);
                Matcher callWithSess = CALLERNAME_WITH_SESS_INFO_PATTERN.matcher(origCallerIdName);
                if (callWithSess.matches()) {
                    voiceUserId = callWithSess.group(1).trim();
                    clientSession = callWithSess.group(2).trim();
                    callerName = callWithSess.group(3).trim();
                } else if (callerListenOnly.matches()) {
                    voiceUserId = callerListenOnly.group(1).trim();
                    clientSession = callWithSess.group(2).trim();
                    callerName = callerListenOnly.group(3).trim();
                }

                String conf = origCallerDestNumber;
                Matcher callerDestNumberMatcher = ECHO_TEST_DEST_PATTERN.matcher(origCallerDestNumber);
                if (callerDestNumberMatcher.matches()) {
                    conf = callerDestNumberMatcher.group(1).trim();
                }

                VoiceCallStateEvent csEvent = new VoiceCallStateEvent(conf,
                        coreuuid,
                        clientSession,
                        voiceUserId,
                        callerName,
                        callState,
                        origCallerIdName,
                        origCallerDestNumber);
                conferenceEventListener.handleConferenceEvent(csEvent);
            }
        } else if (event.getEventName().equalsIgnoreCase(""CHANNEL_STATE"")) {
            Map<String, String> eventHeaders = event.getEventHeaders();
            String channelCallState = (eventHeaders.get(""Channel-Call-State"") == null) ? """" : eventHeaders.get(""Channel-Call-State"");
            String channelState = (eventHeaders.get(""Channel-State"") == null) ? """" : eventHeaders.get(""Channel-State"");

            if (""HANGUP"".equalsIgnoreCase(channelCallState) && ""CS_DESTROY"".equalsIgnoreCase(channelState)) {
                String origCallerIdName = eventHeaders.get(""Caller-Caller-ID-Name"");
                String origCallerDestNumber = eventHeaders.get(""Caller-Destination-Number"");
                String coreuuid = eventHeaders.get(""Core-UUID"");
                //System.out.println(""******** uuid="" + coreuuid + "" "" + origCallerIdName + "" is hanging up "" + origCallerDestNumber);

                String voiceUserId = """";
                String callerName = origCallerIdName;
                String clientSession = ""0"";
                String callState = ""CALL_ENDED"";

                Matcher callerListenOnly = CALLERNAME_LISTENONLY_PATTERN.matcher(origCallerIdName);
                Matcher callWithSess = CALLERNAME_WITH_SESS_INFO_PATTERN.matcher(origCallerIdName);
                if (callWithSess.matches()) {
                    voiceUserId = callWithSess.group(1).trim();
                    clientSession = callWithSess.group(2).trim();
                    callerName = callWithSess.group(3).trim();
                } else if (callerListenOnly.matches()) {
                    voiceUserId = callerListenOnly.group(1).trim();
                    clientSession = callWithSess.group(2).trim();
                    callerName = callerListenOnly.group(3).trim();
                }

                String conf = origCallerDestNumber;
                Matcher callerDestNumberMatcher = ECHO_TEST_DEST_PATTERN.matcher(origCallerDestNumber);
                if (callerDestNumberMatcher.matches()) {
                    conf = callerDestNumberMatcher.group(1).trim();
                }

                VoiceCallStateEvent csEvent = new VoiceCallStateEvent(conf,
                        coreuuid,
                        clientSession,
                        voiceUserId,
                        callerName,
                        callState,
                        origCallerIdName,
                        origCallerDestNumber
                        );
                conferenceEventListener.handleConferenceEvent(csEvent);

            } else if (""RINGING"".equalsIgnoreCase(channelCallState) && ""CS_EXECUTE"".equalsIgnoreCase(channelState)) {
                String origCallerIdName = eventHeaders.get(""Caller-Caller-ID-Name"");
                String origCallerDestNumber = eventHeaders.get(""Caller-Destination-Number"");
                String coreuuid = eventHeaders.get(""Core-UUID"");
                //System.out.println(""******** uuid="" + coreuuid + "" "" + origCallerIdName + "" is ringing "" + origCallerDestNumber);

                String voiceUserId = """";
                String callerName = origCallerIdName;
                String clientSession = ""0"";
                String callState = ""CALL_STARTED"";

                Matcher callerListenOnly = CALLERNAME_LISTENONLY_PATTERN.matcher(origCallerIdName);
                Matcher callWithSess = CALLERNAME_WITH_SESS_INFO_PATTERN.matcher(origCallerIdName);
                if (callWithSess.matches()) {
                    voiceUserId = callWithSess.group(1).trim();
                    clientSession = callWithSess.group(2).trim();
                    callerName = callWithSess.group(3).trim();
                } else if (callerListenOnly.matches()) {
                    voiceUserId = callerListenOnly.group(1).trim();
                    clientSession = callWithSess.group(2).trim();
                    callerName = callerListenOnly.group(3).trim();
                }

                String conf = origCallerDestNumber;
                Matcher callerDestNumberMatcher = ECHO_TEST_DEST_PATTERN.matcher(origCallerDestNumber);
                if (callerDestNumberMatcher.matches()) {
                    conf = callerDestNumberMatcher.group(1).trim();
                }

                VoiceCallStateEvent csEvent = new VoiceCallStateEvent(conf,
                        coreuuid,
                        clientSession,
                        voiceUserId,
                        callerName,
                        callState,
                        origCallerIdName,
                        origCallerDestNumber
                        );
                conferenceEventListener.handleConferenceEvent(csEvent);
            }

        }
    }

    private Integer getMemberIdFromEvent(EslEvent e) {
        return new Integer(e.getEventHeaders().get(""Member-ID""));
    }

    private String getCallerIdFromEvent(EslEvent e) {
        return e.getEventHeaders().get(""Caller-Caller-ID-Number"");
    }

    private String getMemberUUIDFromEvent(EslEvent e) {
        return e.getEventHeaders().get(""Caller-Unique-ID"");
    }

    private String getCallerChannelCreateTimeFromEvent(EslEvent e) {
        return e.getEventHeaders().get(""Caller-Channel-Created-Time"");
    }

    private String getCallerChannelHangupTimeFromEvent(EslEvent e) {
        return e.getEventHeaders().get(""Caller-Channel-Hangup-Time"");
    }


    private String getCallerIdNameFromEvent(EslEvent e) {
        return e.getEventHeaders().get(""Caller-Caller-ID-Name"");
    }

    private String getRecordFilenameFromEvent(EslEvent e) {
        return e.getEventHeaders().get(""Path"");
    }

    private String getOldFloorHolderMemberIdFromEvent(EslEvent e) {
        String oldFloorHolder = e.getEventHeaders().get(""Old-ID"");
        if(oldFloorHolder == null || oldFloorHolder.equalsIgnoreCase(""none"")) {
            oldFloorHolder= """";
        }
        return oldFloorHolder;
    }

    private String getNewFloorHolderMemberIdFromEvent(EslEvent e) {
        String newHolder = e.getEventHeaders().get(""New-ID"");
        if(newHolder == null || newHolder.equalsIgnoreCase(""none"")) {
            newHolder = """";
        }
        return newHolder;
    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/response/XMLResponseConferenceListParser.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.freeswitch.voice.freeswitch.response;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 *
 * @author leif
 */
public class XMLResponseConferenceListParser extends DefaultHandler {
    private List<ConferenceMember> myConfrenceMembers;
    private String tempVal;
    private ConferenceMember tempMember;
    private ConferenceMemberFlags tempFlags;
    private String room;
    private boolean inFlags = false;
    
    public XMLResponseConferenceListParser() {
        myConfrenceMembers = new ArrayList<ConferenceMember>();
    }

    public String getConferenceRoom() {
        return room;
    }

    public void printConferneceMemebers() {
        Iterator<ConferenceMember> it = myConfrenceMembers.iterator();
        while(it.hasNext()) {
            
        }
    }

    public List<ConferenceMember> getConferenceList() {
        return myConfrenceMembers;
    }

            /*
<?xml version=""1.0""?>
<conferences>
  <conference name=""3001-192.168.1.10"" member-count=""1"" rate=""8000"" running=""true"" answered=""true"" enforce_min=""true"" dynamic=""true"">
    <members>
      <member>
        <id>6</id>
        <flags>
          <can_hear>true</can_hear>
          <can_speak>true</can_speak>
          <talking>false</talking>
          <has_video>false</has_video>
          <has_floor>true</has_floor>
          <is_moderator>false</is_moderator>
          <end_conference>false</end_conference>
        </flags>
        <uuid>3a16f061-0df6-45d5-b401-d8e977e08a5c</uuid>
        <caller_id_name>1001</caller_id_name>
        <caller_id_number>1001</caller_id_number>
        <join_time>65</join_time>
        <last_talking>4</last_talking>
      </member>
    </members>
  </conference>
</conferences>

             */


    //SAX Event Handlers
    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
        //reset
        // Do not reset to false as the flags won't be processed. (ralam OCt 21, 2019)
        //inFlags = false;
        tempVal = """";

        if(qName.equalsIgnoreCase(""member"")) {
            String memberType = attributes.getValue(""type"");
            //create a new instance of ConferenceMember
            tempMember = new ConferenceMember();
            tempMember.setMemberType(memberType);
        }

        if(qName.equalsIgnoreCase(""flags"")) {
            //create a new instance of ConferenceMember
            tempFlags = new ConferenceMemberFlags();
            inFlags = true;
        }

        if(qName.equalsIgnoreCase(""conference"")) {
            room = attributes.getValue(""name"");
        }
    }


    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {
        tempVal = new String(ch,start,length);
    }

    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException {

        if(qName.equalsIgnoreCase(""member"")) {
            //add it to the list
            myConfrenceMembers.add(tempMember);
        }else if(qName.equalsIgnoreCase(""flags"")) {
            tempMember.setFlags(tempFlags);
            inFlags = false;
        }else if(inFlags) {
            if (qName.equalsIgnoreCase(""can_speak"")) {
                tempFlags.setCanSpeak(tempVal);
            }else if (qName.equalsIgnoreCase(""talking"")) {
                tempFlags.setTalking(tempVal);
            }
        }else if (qName.equalsIgnoreCase(""id"")) {
            try {
                tempMember.setId(Integer.parseInt(tempVal));
            } catch(NumberFormatException nfe) {
                
            }
        }else if (qName.equalsIgnoreCase(""uuid"")) {
            tempMember.setUUID(tempVal);
        }else if (qName.equalsIgnoreCase(""caller_id_name"")) {
            tempMember.setCallerIdName(tempVal);
        }else if (qName.equalsIgnoreCase(""caller_id_number"")) {
            tempMember.setCallerId(tempVal);
        }else if (qName.equalsIgnoreCase(""join_time"")) {
            if (tempMember.getMemberType().equalsIgnoreCase(""caller"")) {
                try {
                    tempMember.setJoinTime(Integer.parseInt(tempVal));
                } catch(NumberFormatException nfe) {

                }
            } else if (tempMember.getMemberType().equalsIgnoreCase(""recording_node"")) {
                try {
                    tempMember.setRecordStartTime(Long.parseLong(tempVal));
                } catch(NumberFormatException nfe) {

                }
            }

        }else if (qName.equalsIgnoreCase(""last_talking"")) {
            try {
                tempMember.setLastTalking(Integer.parseInt(tempVal));
            } catch(NumberFormatException nfe) {
                
            }
        } else if (qName.equalsIgnoreCase(""record_path"")) {
            tempMember.setRecordPath(tempVal);
        }
    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/response/ConferenceMemberFlags.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.freeswitch.voice.freeswitch.response;

/**
 *
 * @author leif
 */
public class ConferenceMemberFlags {
    //private boolean canHear = false;
    private boolean canSpeak = false;
    private boolean talking = false;
    //private boolean hasVideo = false;
    //private boolean hasFloor = false;
    //private boolean isModerator = false;
    //private boolean endConference = false;

    boolean getIsSpeaking() {
        return talking;
    }

    boolean getIsMuted() {
        if(canSpeak == true) {
            return false;
        }
        return true;
    }

    void setCanSpeak(String tempVal) {
        canSpeak = tempVal.equals(""true"") ? true : false;
    }

    void setTalking(String tempVal) {
        talking = tempVal.equals(""true"") ? true : false;
    }

}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/response/ConferenceMember.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.freeswitch.voice.freeswitch.response;

/**
 *
 * @author leif
 */
public class ConferenceMember {

    protected Integer memberId;
    protected ConferenceMemberFlags flags;
    protected String uuid;
    protected String callerIdName;
    protected String callerId;
    protected Integer joinTime;
    protected Integer lastTalking;
    protected String memberType;

    // For recording
    protected String recordPath;
    protected Long recordStartTime;

    public Integer getId() {
        return memberId;
    }

    public ConferenceMemberFlags getFlags() {
        return flags;
    }

    public String getCallerId() {
        return callerId;
    }

    public String getCallerIdName() {
        return callerIdName;
    }

    public boolean getMuted() {
        return flags.getIsMuted();
    }

    public boolean getSpeaking() {
        return flags.getIsSpeaking();
    }

    public void setFlags(ConferenceMemberFlags flags) {
        this.flags = flags;
    }

    public void setId(int parseInt) {
        memberId = parseInt;
    }

    public void setUUID(String tempVal) {
        this.uuid = tempVal;
    }

    public String getUUID() {
        return uuid;
    }

    public void setCallerIdName(String tempVal) {
        this.callerIdName = tempVal;
    }

    public void setCallerId(String tempVal) {
        this.callerId = tempVal;
    }

    public void setJoinTime(int parseInt) {
        this.joinTime = parseInt;
    }

    void setLastTalking(int parseInt) {
        this.lastTalking = parseInt;
    }

    public void setMemberType(String memberType) {
        this.memberType = memberType;
    }

    public String getMemberType() {
        return memberType;
    }

    public void setRecordPath(String path) {
        this.recordPath = path;
    }

    public String getRecordPath() {
        return recordPath;
    }

    public void setRecordStartTime(Long recordStartTime) {
        this.recordStartTime = recordStartTime;
    }

    public Long getRecordStartTime() {
        return recordStartTime;
    }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/DelayedCommandSenderService.java,"package org.bigbluebutton.freeswitch.voice.freeswitch;

import org.bigbluebutton.freeswitch.voice.freeswitch.actions.DelayedCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.FreeswitchCommand;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class DelayedCommandSenderService {
  private static Logger log = LoggerFactory.getLogger(DelayedCommandSenderService.class);

  private BlockingQueue<DelayedCommand> receivedMessages = new DelayQueue<DelayedCommand>();

  private volatile boolean processMessage = false;

  private final Executor msgProcessorExec = Executors.newSingleThreadExecutor();

  private IDelayedCommandListener listener;

  public void setDelayedCommandListener(IDelayedCommandListener listener) {
    this.listener = listener;
  }

  public void stop() {
    log.info(""Stopping DelayedCommandSenderService."");
    processMessage = false;
  }

  public void start() {
    log.info(""Starting DelayedCommandSenderService."");
    try {
      processMessage = true;

      Runnable messageProcessor = new Runnable() {
        public void run() {
          while (processMessage) {
            try {
              DelayedCommand msg = receivedMessages.take();
              log.info(""Scheduling DelayedCommand."");
              if (listener != null) {
                listener.runDelayedCommand(msg.conferenceCommand);
              }
            } catch (InterruptedException e) {
              log.error(""Error while taking received message from queue."");
            }
          }
        }
      };
      msgProcessorExec.execute(messageProcessor);
    } catch (Exception e) {
      log.error(""Error subscribing to channels: "" + e);
    }
  }

  public void handleMessage(FreeswitchCommand command, long delayInMillis) {
    log.info(""Queueing DelayedCommand."");
    DelayedCommand dc = new DelayedCommand(command, delayInMillis);
    receivedMessages.add(dc);
  }
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/ConnectionManager.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * 
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */
package org.bigbluebutton.freeswitch.voice.freeswitch;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import org.bigbluebutton.freeswitch.voice.events.ConferenceEventListener;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.BroadcastConferenceCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.EjectAllUsersCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.EjectUserCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.GetAllUsersCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.MuteUserCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.RecordConferenceCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.TransferUserToMeetingCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.*;
import org.freeswitch.esl.client.inbound.Client;
import org.freeswitch.esl.client.inbound.InboundConnectionFailure;
import org.freeswitch.esl.client.manager.ManagerConnection;
import org.freeswitch.esl.client.transport.CommandResponse;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ConnectionManager {
	private static Logger log = LoggerFactory.getLogger(ConnectionManager.class);

	private static final String EVENT_NAME = ""Event-Name"";

	private static final ScheduledExecutorService connExec = Executors
			.newSingleThreadScheduledExecutor();

	private final ManagerConnection manager;
	private ScheduledFuture<ConnectThread> connectTask;

	private volatile boolean subscribed = false;

	private final ConferenceEventListener conferenceEventListener;
	private final ESLEventListener eslEventListener;

	private long lastStatusCheck = 0L;

	public ConnectionManager(ManagerConnection connManager,
			ESLEventListener eventListener, ConferenceEventListener confListener) {
		this.manager = connManager;
		this.eslEventListener = eventListener;
		this.conferenceEventListener = confListener;
		// Set up listener here. Before it was inside connect()
		// but on auto-reconnect, another listener is added
		// increasing the number of listeners causing duplicate
		// messages to akka-apps (ralam Oct 10, 2019)
		Client c = manager.getESLClient();
		c.addEventListener(eslEventListener);
	}

	private void connect() {
		//log.info(""Connecting to FS ESL"");
		try {
			Client c = manager.getESLClient();
			if (!c.canSend()) {
				log.info(""Attempting to connect to FreeSWITCH ESL"");
				subscribed = false;
				manager.connect();
			} else {
				if (!subscribed) {
					log.info(""Subscribing for ESL events."");
					c.cancelEventSubscriptions();
					CommandResponse response = c.setEventSubscriptions(""plain"", ""all"");
					if (response.isOk()) {
						log.info(""Subscribed to ESL events."" +
								"" Command: ["" + response.getCommand() + ""] "" +
								"" Response: ["" + response.getReplyText() + ""]"");
					}

					c.addEventFilter(EVENT_NAME, ""HEARTBEAT"");
					//c.addEventFilter(EVENT_NAME, ""custom"");
					//c.addEventFilter(EVENT_NAME, ""background_job"");
					c.addEventFilter(EVENT_NAME, ""CHANNEL_EXECUTE"");
					c.addEventFilter(EVENT_NAME, ""CHANNEL_STATE"");
					subscribed = true;
				} else {
					// Let's check for status every minute.
					Long now = System.currentTimeMillis();
					if ((now - lastStatusCheck) > 60000) {
						lastStatusCheck = now;
						CheckFreeswitchStatusCommand fsStatusCmd = new CheckFreeswitchStatusCommand(""foo"", ""bar"");
						checkFreeswitchStatus(fsStatusCmd);
					}
				}
			}
		} catch (InboundConnectionFailure e) {
			log.error(""Failed to connect to ESL"");
		} catch(Exception e) {
			log.error(e.getMessage());
		}
	}

	public void start() {
		log.info(""Starting FreeSWITCH ESL connection manager."");
		ConnectThread connector = new ConnectThread();
		connectTask = (ScheduledFuture<ConnectThread>) connExec
				.scheduleAtFixedRate(connector, 5, 5, TimeUnit.SECONDS);
	}

	public void stop() {
		log.info(""Stopping FreeSWITCH ESL connection manager."");
		if (connectTask != null) {
			log.info(""Cancelling connect task."");
			connectTask.cancel(true);
		}
	}

	private class ConnectThread implements Runnable {
		public void run() {
			connect();
		}
	}

	public void broadcast(BroadcastConferenceCommand rcc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			EslMessage response = c.sendSyncApiCommand(rcc.getCommand(),
					rcc.getCommandArgs());
			rcc.handleResponse(response, conferenceEventListener);
		}
	}

	public void getUsersStatus(GetUsersStatusCommand prc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			EslMessage response = c.sendSyncApiCommand(prc.getCommand(),
					prc.getCommandArgs());
			prc.handleResponse(response, conferenceEventListener);
		}
	}

	public void getUsers(GetAllUsersCommand prc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			EslMessage response = c.sendSyncApiCommand(prc.getCommand(),
					prc.getCommandArgs());
			prc.handleResponse(response, conferenceEventListener);
		}
	}

	public void checkIfConfIsRunningCommand(CheckIfConfIsRunningCommand command) {
		log.info(""Sending CheckIfConfIsRunningCommand to FreeSWITCH"");
    Client c = manager.getESLClient();
    if (c.canSend()) {
      EslMessage response = c.sendSyncApiCommand(command.getCommand(),
        command.getCommandArgs());
      command.handleResponse(response, conferenceEventListener);
    }
  }

	public void checkFreeswitchStatus(CheckFreeswitchStatusCommand ccrc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			EslMessage response = c.sendSyncApiCommand(ccrc.getCommand(),
					ccrc.getCommandArgs());
			ccrc.handleResponse(response, conferenceEventListener);
		}
	}

	public void forceEjectUser(ForceEjectUserCommand ccrc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			EslMessage response = c.sendSyncApiCommand(ccrc.getCommand(),
					ccrc.getCommandArgs());
			ccrc.handleResponse(response, conferenceEventListener);
		}
	}

	public void checkIfConferenceIsRecording(ConferenceCheckRecordCommand ccrc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			EslMessage response = c.sendSyncApiCommand(ccrc.getCommand(),
				ccrc.getCommandArgs());
			ccrc.handleResponse(response, conferenceEventListener);
		}
	}

	public void mute(MuteUserCommand mpc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			c.sendAsyncApiCommand(mpc.getCommand(), mpc.getCommandArgs());
		}
	}

	public void deaf(DeafUserCommand duc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			c.sendAsyncApiCommand(duc.getCommand(), duc.getCommandArgs());
		}
	}

	public void hold(HoldUserCommand huc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			c.sendAsyncApiCommand(huc.getCommand(), huc.getCommandArgs());
		}
	}

	public void playSound(PlaySoundCommand psc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			c.sendAsyncApiCommand(psc.getCommand(), psc.getCommandArgs());
		}
	}

	public void stopSound(StopSoundCommand ssc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			c.sendAsyncApiCommand(ssc.getCommand(), ssc.getCommandArgs());
		}
	}

	public void tranfer(TransferUserToMeetingCommand tutmc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			c.sendAsyncApiCommand(tutmc.getCommand(), tutmc.getCommandArgs());
		}
	}

	public void eject(EjectUserCommand mpc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			c.sendAsyncApiCommand(mpc.getCommand(), mpc.getCommandArgs());
		}
	}

	public void ejectAll(EjectAllUsersCommand mpc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			c.sendAsyncApiCommand(mpc.getCommand(), mpc.getCommandArgs());
		}
	}

	public void record(RecordConferenceCommand rcc) {
		Client c = manager.getESLClient();
		if (c.canSend()) {
			EslMessage response = c.sendSyncApiCommand(rcc.getCommand(),
					rcc.getCommandArgs());
			rcc.handleResponse(response, conferenceEventListener);
		}
	}
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/IDelayedCommandListener.java,"package org.bigbluebutton.freeswitch.voice.freeswitch;

import org.bigbluebutton.freeswitch.voice.freeswitch.actions.FreeswitchCommand;

public interface IDelayedCommandListener {
  public void runDelayedCommand(FreeswitchCommand command);
}"
akka-bbb-fsesl/src/main/java/org/bigbluebutton/freeswitch/voice/freeswitch/FreeswitchApplication.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2015 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */
package org.bigbluebutton.freeswitch.voice.freeswitch;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.BroadcastConferenceCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.EjectAllUsersCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.EjectUserCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.FreeswitchCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.GetAllUsersCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.MuteUserCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.DeafUserCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.HoldUserCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.PlaySoundCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.StopSoundCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.RecordConferenceCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.TransferUserToMeetingCommand;
import org.bigbluebutton.freeswitch.voice.freeswitch.actions.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class FreeswitchApplication implements  IDelayedCommandListener{
  private static Logger log = LoggerFactory.getLogger(FreeswitchApplication.class);

  private static final int SENDERTHREADS = 1;
  private static final Executor msgSenderExec = Executors.newFixedThreadPool(SENDERTHREADS);
  private static final Executor runExec = Executors.newFixedThreadPool(SENDERTHREADS);
  private BlockingQueue<FreeswitchCommand> messages = new LinkedBlockingQueue<FreeswitchCommand>();

  private final ConnectionManager manager;
  private DelayedCommandSenderService delayedCommandSenderService;

  private final String USER = ""0""; /* not used for now */

  private volatile boolean sendMessages = false;

  private final String audioProfile;

  public FreeswitchApplication(ConnectionManager manager, String profile) {
    this.manager = manager;
    this.audioProfile = profile;
    delayedCommandSenderService = new DelayedCommandSenderService();
    delayedCommandSenderService.setDelayedCommandListener(this);
  }

  public void runDelayedCommand(FreeswitchCommand command) {
    log.info(""Run DelayedCommand."");
    queueMessage(command);
  }

  private void queueMessage(FreeswitchCommand command) {
    try {
      log.info(""Queue message: "" + command.getCommand() + "" "" + command.getCommandArgs());
      messages.offer(command, 5, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
      // TODO Auto-generated catch block
      log.error(""Exception queueing message: "", e);
    }
  }

  public void transferUserToMeeting(String voiceConfId,
                                    String targetVoiceConfId, String voiceUserId) {
    TransferUserToMeetingCommand tutmc = new TransferUserToMeetingCommand(
      voiceConfId, targetVoiceConfId, voiceUserId, this.audioProfile,
      USER);
    queueMessage(tutmc);
  }

  public void start() {
    delayedCommandSenderService.start();

    sendMessages = true;
    Runnable sender = new Runnable() {
      public void run() {
        while (sendMessages) {
          FreeswitchCommand message;
          try {
            message = messages.take();
            sendMessageToFreeswitch(message);
          } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            log.error(""Exception taking message from queue: "", e);
          }
        }
      }
    };
    msgSenderExec.execute(sender);
  }

  public void getUsersStatus(String voiceConfId, String meetingId) {
    GetUsersStatusCommand ccrc = new GetUsersStatusCommand(voiceConfId, meetingId);
    queueMessage(ccrc);
  }

  public void checkRunningAndRecording(String voiceConfId, String meetingId) {
    ConferenceCheckRecordCommand ccrc = new ConferenceCheckRecordCommand(voiceConfId, meetingId);
    queueMessage(ccrc);
  }

  public void getAllUsers(String voiceConfId) {
    GetAllUsersCommand prc = new GetAllUsersCommand(voiceConfId, USER);
    queueMessage(prc);
  }

  public void muteUser(String voiceConfId, String voiceUserId, Boolean mute) {
    MuteUserCommand mpc = new MuteUserCommand(voiceConfId, voiceUserId, mute, USER);
    queueMessage(mpc);
  }

  public void deafUser(String voiceConfId, String voiceUserId, Boolean deaf) {
    DeafUserCommand duc = new DeafUserCommand(voiceConfId, voiceUserId, deaf, USER);
    queueMessage(duc);
  }

  public void holdUser(String voiceConfId, String voiceUserId, Boolean hold) {
    HoldUserCommand huc = new HoldUserCommand(voiceConfId, voiceUserId, hold, USER);
    queueMessage(huc);
  }

  public void playSound(String voiceConfId, String voiceUserId, String soundPath) {
    PlaySoundCommand psc = new PlaySoundCommand(voiceConfId, voiceUserId, soundPath, USER);
    queueMessage(psc);
  }

  public void stopSound(String voiceConfId, String voiceUserId) {
    StopSoundCommand ssc = new StopSoundCommand(voiceConfId, voiceUserId, USER);
    queueMessage(ssc);
  }

  public void eject(String voiceConfId, String voiceUserId) {
    EjectUserCommand mpc = new EjectUserCommand(voiceConfId, voiceUserId, USER);
    queueMessage(mpc);
  }

  public void ejectAll(String voiceConfId) {
    EjectAllUsersCommand mpc = new EjectAllUsersCommand(voiceConfId, USER);
    queueMessage(mpc);
  }

  private Long genTimestamp() {
    return TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
  }

  public void startRecording(String voiceConfId, String meetingid, String voicePath) {
    RecordConferenceCommand rcc = new RecordConferenceCommand(voiceConfId, USER, true, voicePath);
    queueMessage(rcc);
  }

  public void stopRecording(String voiceConfId, String meetingid, String voicePath) {
    RecordConferenceCommand rcc = new RecordConferenceCommand(voiceConfId, USER, false, voicePath);
    queueMessage(rcc);
  }

  private void sendMessageToFreeswitch(final FreeswitchCommand command) {
    Runnable task = new Runnable() {
      public void run() {
        log.info(""Sending message: "" + command.getCommand() + "" "" + command.getCommandArgs());
        try {
          if (command instanceof GetAllUsersCommand) {
            GetAllUsersCommand cmd = (GetAllUsersCommand) command;
            manager.getUsers(cmd);
          } else if (command instanceof MuteUserCommand) {
            MuteUserCommand cmd = (MuteUserCommand) command;
            manager.mute(cmd);
          } else if (command instanceof DeafUserCommand) {
            DeafUserCommand cmd = (DeafUserCommand) command;
            manager.deaf(cmd);
          } else if (command instanceof HoldUserCommand) {
            HoldUserCommand cmd = (HoldUserCommand) command;
            manager.hold(cmd);
          } else if (command instanceof PlaySoundCommand) {
            PlaySoundCommand cmd = (PlaySoundCommand) command;
            manager.playSound(cmd);
          } else if (command instanceof StopSoundCommand) {
            StopSoundCommand cmd = (StopSoundCommand) command;
            manager.stopSound(cmd);
          } else if (command instanceof EjectUserCommand) {
            EjectUserCommand cmd = (EjectUserCommand) command;
            manager.eject(cmd);
          } else if (command instanceof EjectAllUsersCommand) {
            EjectAllUsersCommand cmd = (EjectAllUsersCommand) command;
            manager.ejectAll(cmd);

            CheckIfConfIsRunningCommand command = new CheckIfConfIsRunningCommand(cmd.getRoom(),
                    cmd.getRequesterId(),
                    delayedCommandSenderService, 0);
            delayedCommandSenderService.handleMessage(command, 5000);
          } else if (command instanceof TransferUserToMeetingCommand) {
            TransferUserToMeetingCommand cmd = (TransferUserToMeetingCommand) command;
            manager.tranfer(cmd);
          } else if (command instanceof RecordConferenceCommand) {
            manager.record((RecordConferenceCommand) command);
          } else if (command instanceof BroadcastConferenceCommand) {
            manager.broadcast((BroadcastConferenceCommand) command);
          } else if (command instanceof ConferenceCheckRecordCommand) {
            manager.checkIfConferenceIsRecording((ConferenceCheckRecordCommand) command);
          } else if (command instanceof CheckIfConfIsRunningCommand) {
            manager.checkIfConfIsRunningCommand((CheckIfConfIsRunningCommand) command);
          } else if (command instanceof ForceEjectUserCommand) {
            manager.forceEjectUser((ForceEjectUserCommand) command);
          } else if (command instanceof GetUsersStatusCommand) {
            manager.getUsersStatus((GetUsersStatusCommand) command);
          }
        } catch (RuntimeException e) {
          log.warn(e.getMessage());
        }
      }
    };

    runExec.execute(task);
  }

  public void stop() {
    delayedCommandSenderService.stop();

    sendMessages = false;
  }

}"
akka-bbb-fsesl/run-dev.sh,"#!/usr/bin/env bash

rm -rf src/main/resources
cp -R src/universal/conf src/main/resources
exec sbt run"
akka-bbb-fsesl/wait-for-it.sh,"#!/usr/bin/env bash
#   Use this script to test if a given TCP host/port are available

cmdname=$(basename $0)

echoerr() { if [[ $QUIET -ne 1 ]]; then echo ""$@"" 1>&2; fi }

usage()
{
    cat << USAGE >&2
Usage:
    $cmdname host:port [-s] [-t timeout] [-- command args]
    -h HOST | --host=HOST       Host or IP under test
    -p PORT | --port=PORT       TCP port under test
                                Alternatively, you specify the host and port as host:port
    -s | --strict               Only execute subcommand if the test succeeds
    -q | --quiet                Don't output any status messages
    -t TIMEOUT | --timeout=TIMEOUT
                                Timeout in seconds, zero for no timeout
    -- COMMAND ARGS             Execute command with args after the test finishes
USAGE
    exit 1
}

wait_for()
{
    if [[ $TIMEOUT -gt 0 ]]; then
        echoerr ""$cmdname: waiting $TIMEOUT seconds for $HOST:$PORT""
    else
        echoerr ""$cmdname: waiting for $HOST:$PORT without a timeout""
    fi
    start_ts=$(date +%s)
    while :
    do
        if [[ $ISBUSY -eq 1 ]]; then
            nc -z $HOST $PORT
            result=$?
        else
            (echo > /dev/tcp/$HOST/$PORT) >/dev/null 2>&1
            result=$?
        fi
        if [[ $result -eq 0 ]]; then
            end_ts=$(date +%s)
            echoerr ""$cmdname: $HOST:$PORT is available after $((end_ts - start_ts)) seconds""
            break
        fi
        sleep 1
    done
    return $result
}

wait_for_wrapper()
{
    # In order to support SIGINT during timeout: http://unix.stackexchange.com/a/57692
    if [[ $QUIET -eq 1 ]]; then
        timeout $BUSYTIMEFLAG $TIMEOUT $0 --quiet --child --host=$HOST --port=$PORT --timeout=$TIMEOUT &
    else
        timeout $BUSYTIMEFLAG $TIMEOUT $0 --child --host=$HOST --port=$PORT --timeout=$TIMEOUT &
    fi
    PID=$!
    trap ""kill -INT -$PID"" INT
    wait $PID
    RESULT=$?
    if [[ $RESULT -ne 0 ]]; then
        echoerr ""$cmdname: timeout occurred after waiting $TIMEOUT seconds for $HOST:$PORT""
    fi
    return $RESULT
}

# process arguments
while [[ $# -gt 0 ]]
do
    case ""$1"" in
        *:* )
        hostport=(${1//:/ })
        HOST=${hostport[0]}
        PORT=${hostport[1]}
        shift 1
        ;;
        --child)
        CHILD=1
        shift 1
        ;;
        -q | --quiet)
        QUIET=1
        shift 1
        ;;
        -s | --strict)
        STRICT=1
        shift 1
        ;;
        -h)
        HOST=""$2""
        if [[ $HOST == """" ]]; then break; fi
        shift 2
        ;;
        --host=*)
        HOST=""${1#*=}""
        shift 1
        ;;
        -p)
        PORT=""$2""
        if [[ $PORT == """" ]]; then break; fi
        shift 2
        ;;
        --port=*)
        PORT=""${1#*=}""
        shift 1
        ;;
        -t)
        TIMEOUT=""$2""
        if [[ $TIMEOUT == """" ]]; then break; fi
        shift 2
        ;;
        --timeout=*)
        TIMEOUT=""${1#*=}""
        shift 1
        ;;
        --)
        shift
        CLI=(""$@"")
        break
        ;;
        --help)
        usage
        ;;
        *)
        echoerr ""Unknown argument: $1""
        usage
        ;;
    esac
done

if [[ ""$HOST"" == """" || ""$PORT"" == """" ]]; then
    echoerr ""Error: you need to provide a host and port to test.""
    usage
fi

TIMEOUT=${TIMEOUT:-15}
STRICT=${STRICT:-0}
CHILD=${CHILD:-0}
QUIET=${QUIET:-0}

# check to see if timeout is from busybox?
# check to see if timeout is from busybox?
TIMEOUT_PATH=$(realpath $(which timeout))
if [[ $TIMEOUT_PATH =~ ""busybox"" ]]; then
        ISBUSY=1
        BUSYTIMEFLAG=""-t""
else
        ISBUSY=0
        BUSYTIMEFLAG=""""
fi

if [[ $CHILD -gt 0 ]]; then
    wait_for
    RESULT=$?
    exit $RESULT
else
    if [[ $TIMEOUT -gt 0 ]]; then
        wait_for_wrapper
        RESULT=$?
    else
        wait_for
        RESULT=$?
    fi
fi

if [[ $CLI != """" ]]; then
    if [[ $RESULT -ne 0 && $STRICT -eq 1 ]]; then
        echoerr ""$cmdname: strict mode, refusing to execute subprocess""
        exit $RESULT
    fi
    exec ""${CLI[@]}""
else
    exit $RESULT
fi"
akka-bbb-fsesl/run.sh,"#!/usr/bin/env bash

sbt clean stage
sudo service bbb-fsesl-akka stop
cd target/universal/stage
exec ./bin/bbb-fsesl-akka"
bbb-webrtc-sfu.placeholder.sh,"git clone --branch v2.10.0-alpha.2 --depth 1 https://github.com/bigbluebutton/bbb-webrtc-sfu bbb-webrtc-sfu"
bbb-webrtc-recorder.placeholder.sh,"git clone --branch v0.2.0 --depth 1 https://github.com/bigbluebutton/bbb-webrtc-recorder bbb-webrtc-recorder"
bbb-lti.placeholder.sh,"git clone --branch main --depth 1 https://github.com/bigbluebutton/bbb-lti bbb-lti"
bbb-fsesl-client/src/test/java/org/freeswitch/esl/client/transport/message/EslFrameDecoderTest.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.transport.message;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.buffer.ChannelBuffers;
import org.jboss.netty.handler.codec.embedder.DecoderEmbedder;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class EslFrameDecoderTest
{
    private final Logger log = LoggerFactory.getLogger( this.getClass() );
    
    private DecoderEmbedder<EslMessage> embedder;

    @Before
    public void setupTest()
    {
        embedder = new DecoderEmbedder<EslMessage>( new EslFrameDecoder( 64 ) );    
    }
    
    @Test
    public void simpleMessage() throws Exception
    {
        List<String> inputLines = new ArrayList<String>();
        inputLines.add( ""Content-Type: command/reply"" );
        inputLines.add( ""Reply-Text: +OK event listener enabled plain"" );
        inputLines.add( """" );
        
        embedder.offer( createInputBuffer( inputLines, true ) );
        embedder.finish();
        
        EslMessage result = embedder.poll();
        
        assertNotNull( result );
        assertEquals( 2, result.getHeaders().size() );
        assertFalse( result.hasContentLength() );
    }
    
    @Test
    public void simpleMessageWithContent() throws Exception
    {
        List<String> inputLines = new ArrayList<String>();
        inputLines.add( ""Content-Type: api/response"" );
        inputLines.add( ""Content-Length: 694"" );
        inputLines.add( """" );
        inputLines.add( ""================================================================================================="" );
        inputLines.add( ""                     Name     Type                               Data  State"" );
        inputLines.add( ""                 internal  profile   sip:mod_sofia@192.168.1.1:5060        RUNNING (0)"" );
        inputLines.add( ""                 external  profile   sip:mod_sofia@yyy.yyy.yyy.yyy:5080    RUNNING (0)"" );
        inputLines.add( ""                    iinet  gateway   sip:02xxxxxxxx@sip.nsw.iinet.net.au   REGED"" );
        inputLines.add( ""                   clinic  profile   sip:mod_sofia@yyy.yyy.yyy.yyy:5070    RUNNING (0)"" );
        inputLines.add( ""              192.168.1.1  alias                             internal  ALIASED"" );
        inputLines.add( ""================================================================================================="" );
        
        embedder.offer( createInputBuffer( inputLines, true ) );
        
        EslMessage result = embedder.poll();
        embedder.finish();
        
        assertNotNull( result );
        assertEquals( 2, result.getHeaders().size() );
        assertTrue( result.hasContentLength() );
        assertEquals( 8, result.getBodyLines().size() );
    }
    
    @Test
    public void eventWithSecondContentLength()
    {
        List<String> inputLines = new ArrayList<String>();
        inputLines.add( ""Content-Length: 582"" );
        inputLines.add( ""Content-Type: text/event-plain"" );
        inputLines.add( """" );
        inputLines.add( ""Job-UUID: 7f4db78a-17d7-11dd-b7a0-db4edd065621"" );
        inputLines.add( ""Job-Command: originate"" );
        inputLines.add( ""Job-Command-Arg: sofia/default/1005%20'%26park'"" );
        inputLines.add( ""Event-Name: BACKGROUND_JOB"" );
        inputLines.add( ""Core-UUID: 42bdf272-16e6-11dd-b7a0-db4edd065621"" );
        inputLines.add( ""FreeSWITCH-Hostname: ser"" );
        inputLines.add( ""FreeSWITCH-IPv4: 192.168.1.104"" );
        inputLines.add( ""FreeSWITCH-IPv6: 127.0.0.1"" );
        inputLines.add( ""Event-Date-Local: 2008-05-02%2007%3A37%3A03"" );
        inputLines.add( ""Event-Date-GMT: Thu,%2001%20May%202008%2023%3A37%3A03%20GMT"" );
        inputLines.add( ""Event-Date-timestamp: 1209685023894968"" );
        inputLines.add( ""Event-Calling-File: mod_event_socket.c"" );
        inputLines.add( ""Event-Calling-Function: api_exec"" );
        inputLines.add( ""Event-Calling-Line-Number: 609"" );
        inputLines.add( ""Content-Length: 41"" );
        inputLines.add( """" );
        inputLines.add( ""+OK 7f4de4bc-17d7-11dd-b7a0-db4edd065621"" );
        
        embedder.offer( createInputBuffer( inputLines, false ) );

        /*
         *  NB .. there is no trailing '\n' in this event  
         */
        
        EslMessage result = embedder.poll();
        embedder.finish();
        
        assertNotNull( result );
        assertEquals( 2, result.getHeaders().size() );
        assertTrue( result.hasContentLength() );
        assertEquals( 17, result.getBodyLines().size() );
    }

    
    private ChannelBuffer createInputBuffer( List<String> inputLines, boolean terminateLastLine )
    {
        ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
        
        Iterator<String> it = inputLines.iterator();
        while ( it.hasNext() )
        {
            buffer.writeBytes( it.next().getBytes() );
            // only terminate last line if asked
            if ( it.hasNext() || terminateLastLine )
            {
                buffer.writeByte( '\n' );
            }
        }
        
        log.debug( ""Created buffer with [{}] bytes"", buffer.writerIndex() );
        
        return buffer;
    }
}"
bbb-fsesl-client/src/test/java/org/freeswitch/esl/client/inbound/ClientTest.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.inbound;

import java.util.Map.Entry;

import org.freeswitch.esl.client.example.EslEventListener;
import org.freeswitch.esl.client.transport.event.EslEvent;
import org.freeswitch.esl.client.transport.message.EslHeaders.Name;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.jboss.netty.channel.ExceptionEvent;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ClientTest
{
    private final Logger log = LoggerFactory.getLogger( this.getClass() );

    private String host = ""freeswitch-test"";
    private int port = 8021;
    private String password = ""ClueCon""; 
        
    @Test
    public void do_connect() throws InterruptedException
    {
        Client client = new Client();
     
        client.addEventListener( new EslEventListener()
        {
            public void eventReceived( EslEvent event )
            {
                log.info( ""Event received [{}]"", event );
            }
            public void backgroundJobResultReceived( EslEvent event )
            {
                log.info( ""Background job result received [{}]"", event );
            }

            public void conferenceEventJoin(String uniqueId, String confName, int confSize, EslEvent event) {
                log.info( ""Event received [{}]"", event );
            }

            public void conferenceEventLeave(String uniqueId, String confName, int confSize, EslEvent event) {
                log.info( ""Event received [{}]"", event );
            }

            public void conferenceEventMute(String uniqueId, String confName, int confSize, EslEvent event) {
                log.info( ""Event received [{}]"", event );
            }

            public void conferenceEventUnMute(String uniqueId, String confName, int confSize, EslEvent event) {
                log.info( ""Event received [{}]"", event );
            }

            public void conferenceEventAction(String uniqueId, String confName, int confSize, String action, EslEvent event) {
                log.info( ""Event received [{}]"", event );
            }

            public void conferenceEventTransfer(String uniqueId, String confName, int confSize, EslEvent event) {
                log.info( ""Event received [{}]"", event );
            }

            public void conferenceEventThreadRun(String uniqueId, String confName, int confSize, EslEvent event) {
                log.info( ""Event received [{}]"", event );
            }

            public void conferenceEventPlayFile(String uniqueId, String confName, int confSize, EslEvent event) {
                log.info( ""Event received [{}]"", event );
            }
            
            public void exceptionCaught(ExceptionEvent e) {
                log.info( ""exception received [{}]"", e );
            }

            
        } );
        
        log.info( ""Client connecting .."" );
        try
        {
            client.connect( host, port, password, 2 );
        }
        catch ( InboundConnectionFailure e )
        {
            log.error( ""Connect failed"", e );
            return;
        }
        log.info( ""Client connected .."" );
        
//      client.setEventSubscriptions( ""plain"", ""heartbeat CHANNEL_CREATE CHANNEL_DESTROY BACKGROUND_JOB"" );
        client.setEventSubscriptions( ""plain"", ""all"" );
        client.addEventFilter( ""Event-Name"", ""heartbeat"" );
        client.cancelEventSubscriptions();
        client.setEventSubscriptions( ""plain"", ""all"" );
        client.addEventFilter( ""Event-Name"", ""heartbeat"" );
        client.addEventFilter( ""Event-Name"", ""channel_create"" );
        client.addEventFilter( ""Event-Name"", ""background_job"" );
        client.sendSyncApiCommand( ""echo"", ""Foo foo bar"" );

//        client.sendSyncCommand( ""originate"", ""sofia/internal/101@192.168.100.201! sofia/internal/102@192.168.100.201!"" );
        
//        client.sendSyncApiCommand( ""sofia status"", """" );
        String jobId = client.sendAsyncApiCommand( ""status"", """" );
        log.info( ""Job id [{}] for [status]"", jobId );
        client.sendSyncApiCommand( ""version"", """" );
//        client.sendAsyncApiCommand( ""status"", """" );
//        client.sendSyncApiCommand( ""sofia status"", """" );
//        client.sendAsyncApiCommand( ""status"", """" );
        EslMessage response = client.sendSyncApiCommand( ""sofia status"", """" );
        log.info( ""sofia status = [{}]"", response.getBodyLines().get( 3 ) );
        
        // wait to see the heartbeat events arrive
        Thread.sleep( 25000 );
        client.close();
    }

    @Test
    public void do_multi_connects() throws InterruptedException
    {
        Client client = new Client();
        
        log.info( ""Client connecting .."" );
        try
        {
            client.connect( host, port, password, 2 );
        }
        catch ( InboundConnectionFailure e )
        {
            log.error( ""Connect failed"", e );
            return;
        }
        log.info( ""Client connected .."" );
        
        log.info( ""Client connecting .."" );
        try
        {
            client.connect( host, port, password, 2 );
        }
        catch ( InboundConnectionFailure e )
        {
            log.error( ""Connect failed"", e );
            return;
        }
        log.info( ""Client connected .."" );
        
        client.close();
    }
    
    @Test
    public void sofia_contact()
    {
        Client client = new Client();
        try
        {
            client.connect( host, port, password, 2 );
        }
        catch ( InboundConnectionFailure e )
        {
            log.error( ""Connect failed"", e );
            return;
        }
        
        EslMessage response = client.sendSyncApiCommand( ""sofia_contact"", ""internal/102@192.168.100.201"" );

        log.info( ""Response to 'sofia_contact': [{}]"", response );
        for ( Entry<Name, String> header : response.getHeaders().entrySet() )
        {
            log.info( "" * header [{}]"", header );
        }
        for ( String bodyLine : response.getBodyLines() )
        {
            log.info( "" * body [{}]"", bodyLine );
        }
        client.close();
    }
}"
bbb-fsesl-client/src/test/java/org/freeswitch/esl/client/outbound/SocketClientTest.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.outbound;

import org.freeswitch.esl.client.outbound.example.SimpleHangupPipelineFactory;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This 'test' is not really a unit test, more an integration test. In order to see
 * any result, configure a FreeSWITCH installation with an extension something like
 * the following:
 * <pre>
    &lt;extension&gt;
      &lt;condition field=""destination_number"" expresssion=""444""&gt;  
        &lt;action application=""socket"" data=""192.168.100.88:8084 async full""/&gt;
      &lt;/condition&gt;
    &lt;/extension&gt;
 * <pre>
 * Replace the ip address with the host that FreeSWITCH sees that you are running the test on, perhaps
 * localhost.
 * <p/>
 * Run the test, you have 45 seconds to make a call to extension 444 and observe the logs.
 *  
 * @author  david varnes
 */
public class SocketClientTest
{
    private final Logger log = LoggerFactory.getLogger( this.getClass() );

    /*
     *  Example usage of an 'outbound' socket client.  Of course an application developer would need to
     *  create their own implementation of a handler and pipeline factory, and invoke the SocketClient.
     *  
     */
    @Test
    public void run_client() throws InterruptedException
    {
        log.info( ""Test starting ..."" );

        SocketClient client = new SocketClient( 8084, new SimpleHangupPipelineFactory() );
        
        client.start();
        
        Thread.sleep( 45000 );

        client.stop();
        
        log.info( ""Test ended"" );
    }
    
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/transport/message/EslFrameDecoder.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.transport.message;

import org.freeswitch.esl.client.internal.HeaderParser;
import org.freeswitch.esl.client.transport.message.EslHeaders.Name;
import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.handler.codec.frame.TooLongFrameException;
import org.jboss.netty.handler.codec.replay.ReplayingDecoder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Decoder used by the IO processing pipeline. Client consumers should never need to use
 * this class.
 * <p>
 * Follows the following decode algorithm (from FreeSWITCH wiki)
 * <pre>
 *    Look for \n\n in your receive buffer
 *
 *    Examine data for existence of Content-Length
 * 
 *    If NOT present, process event and remove from receive buffer
 *  
 *    IF present, Shift buffer to remove 'header'
 *    Evaluate content-length value
 *    
 *    Loop until receive buffer size is >= Content-length
 *    Extract content-length bytes from buffer and process
 * </pre>
 * 
 * @author  david varnes
 */
public class EslFrameDecoder extends ReplayingDecoder<EslFrameDecoder.State>
{
    /**
     * Line feed character
     */
    static final byte LF = 10;

    protected static enum State
    {
        READ_HEADER,
        READ_BODY,
    }
    
    private final Logger log = LoggerFactory.getLogger( this.getClass() );
    private final int maxHeaderSize;
    private EslMessage currentMessage;
    private boolean treatUnknownHeadersAsBody = false;
    
    public EslFrameDecoder( int maxHeaderSize )
    {
        super( State.READ_HEADER );
        if (maxHeaderSize <= 0) 
        {
            throw new IllegalArgumentException(
                    ""maxHeaderSize must be a positive integer: "" +
                    maxHeaderSize);
        }
        this.maxHeaderSize = maxHeaderSize;
    }
    
    public EslFrameDecoder( int maxHeaderSize, boolean treatUnknownHeadersAsBody )
    {
        this( maxHeaderSize );
        this.treatUnknownHeadersAsBody = treatUnknownHeadersAsBody;
    }
    
    @Override
    protected Object decode( ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer,
            State state ) throws Exception
    {
        log.trace( ""decode() : state [{}]"", state );
        switch ( state )
        {
        case READ_HEADER:
            if ( currentMessage == null )
            {
                currentMessage = new EslMessage();
            }
            /*
             *  read '\n' terminated lines until reach a single '\n'
             */
            boolean reachedDoubleLF = false;
            while ( ! reachedDoubleLF )
            {
                // this will read or fail
                String headerLine = readToLineFeedOrFail( buffer, maxHeaderSize );
                log.debug( ""read header line [{}]"", headerLine );
                if ( ! headerLine.isEmpty() )
                {
                    // split the header line
                    String[] headerParts = HeaderParser.splitHeader( headerLine );
                    Name headerName = Name.fromLiteral( headerParts[0] );
                    if ( headerName == null )
                    {
                        if ( treatUnknownHeadersAsBody )
                        {
                            // cache this 'header' as a body line <-- useful for Outbound client mode
                            currentMessage.addBodyLine( headerLine );
                        }
                        else
                        {
                            throw new IllegalStateException( ""Unhandled ESL header ["" + headerParts[0] + ']' );
                        }
                    }
                    currentMessage.addHeader( headerName, headerParts[1] );
                }
                else
                {
                    reachedDoubleLF = true;
                }
                // do not read in this line again
                checkpoint();
            } 
            // have read all headers - check for content-length
            if ( currentMessage.hasContentLength() )
            {
                checkpoint( State.READ_BODY );
                log.debug( ""have content-length, decoding body .."" );
                //  force the next section

                return null;
            }
            else
            {
                // end of message
                checkpoint( State.READ_HEADER );
                // send message upstream
                EslMessage decodedMessage = currentMessage;
                currentMessage = null;
                
                return decodedMessage;
            }

        case READ_BODY:
            /*
             *   read the content-length specified
             */
            int contentLength = currentMessage.getContentLength();
            ChannelBuffer bodyBytes = buffer.readBytes( contentLength );
            log.debug( ""read [{}] body bytes"", bodyBytes.writerIndex() );
            // most bodies are line based, so split on LF
            while( bodyBytes.readable() )
            {
                String bodyLine = readLine( bodyBytes, contentLength );
                log.debug( ""read body line [{}]"", bodyLine );
                currentMessage.addBodyLine( bodyLine );
            }
            
            // end of message
            checkpoint( State.READ_HEADER );
            // send message upstream
            EslMessage decodedMessage = currentMessage;
            currentMessage = null;
            
            return decodedMessage;
            
        default:
            throw new Error( ""Illegal state: ["" + state  + ']' );
        }
    }

    private String readToLineFeedOrFail( ChannelBuffer buffer, int maxLineLegth ) throws TooLongFrameException
    {
        StringBuilder sb = new StringBuilder(64);
        while ( true ) 
        {
            // this read might fail
            byte nextByte = buffer.readByte();
            if ( nextByte == LF ) 
            {
                return sb.toString();
            }
            else
            {
                // Abort decoding if the decoded line is too large.
                if ( sb.length() >=  maxLineLegth ) 
                {
                    throw new TooLongFrameException(
                            ""ESL header line is longer than "" + maxLineLegth + "" bytes."");
                }
                sb.append( (char) nextByte );
            }
        }
    }
   
    private String readLine( ChannelBuffer buffer, int maxLineLength ) throws TooLongFrameException 
    {
        StringBuilder sb = new StringBuilder(64);
        while ( buffer.readable() ) 
        {
            // this read should always succeed
            byte nextByte = buffer.readByte();
            if (nextByte == LF) 
            {
                return sb.toString();
            }
            else 
            {
                // Abort decoding if the decoded line is too large.
                if ( sb.length() >= maxLineLength ) 
                {
                    throw new TooLongFrameException(
                            ""ESL message line is longer than "" + maxLineLength + "" bytes."");
                }
                sb.append( (char) nextByte );
            }
        }
        
        return sb.toString();
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/transport/message/EslMessage.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.transport.message;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.freeswitch.esl.client.transport.message.EslHeaders.Name;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Basic FreeSWITCH Event Socket messages from the server are decoded into this data object.
 * <p>
 * An ESL message is modelled as text lines.  A message always has one or more header lines, and 
 * optionally may have some body lines.
 * <p>
 * Header lines are parsed and cached in a map keyed by the {@link EslHeaders.Name} enum.  A message
 * is always expected to have a ""Content-Type"" header
 * <p>
 * Any Body lines are cached in a list.
 * 
 * @author  david varnes
 * @see EslHeaders.Name
 */
public class EslMessage
{
    private final Logger log = LoggerFactory.getLogger( this.getClass() );
    
    private final Map<Name,String> headers = new HashMap<Name,String>();
    private final List<String> body = new ArrayList<String>();
    
    private Integer contentLength = null;

    /**
     * All the received message headers in a map keyed by {@link EslHeaders.Name}. The string mapped value 
     * is the parsed content of the header line (ie, it does not include the header name).
     *  
     * @return map of header values
     */
    public Map<Name,String> getHeaders()
    {
        return headers;
    }

    /**
     * Convenience method
     * 
     * @param headerName as a {@link EslHeaders.Name}
     * @return true if an only if there is a header entry with the supplied header name 
     */
    public boolean hasHeader( Name headerName )
    {
        return headers.containsKey( headerName );
    }

    /**
     * Convenience method
     * 
     * @param headerName as a {@link EslHeaders.Name}
     * @return same as getHeaders().get( headerName )
     */
    public String getHeaderValue( Name headerName )
    {
        return headers.get( headerName );
    }
    
    /**
     * Convenience method
     * 
     * @return true if and only if a header exists with name ""Content-Length"" 
     */
    public boolean hasContentLength()
    {
        return headers.containsKey( Name.CONTENT_LENGTH );
    }
    
    /**
     * Convenience method
     * 
     * @return integer value of header with name ""Content-Length""
     */
    public Integer getContentLength()
    {
        if ( contentLength != null )
        {
            return contentLength;
        }
        if ( hasContentLength() )
        {
            contentLength = Integer.valueOf( headers.get( Name.CONTENT_LENGTH) );
        }
        return contentLength;
    }
    
    /**
     * Convenience method
     * 
     * @return header value of header with name ""Content-Type""
     */
    public String getContentType()
    {
        return headers.get( Name.CONTENT_TYPE );
    }

    /**
     * Any received message body lines
     * 
     * @return list with a string for each line received, may be an empty list
     */
    public List<String> getBodyLines()
    {
        return body;
    }
    
    /**
     * Used by the {@link EslMessageDecoder}.
     * 
     * @param name
     * @param value
     */
    void addHeader( Name name, String value )
    {
        log.debug( ""adding header [{}] [{}]"", name, value );
        headers.put( name, value );
    }
    
    /**
     * Used by the {@link EslMessageDecoder}
     * 
     * @param line
     */
    void addBodyLine( String line )
    {
        if ( line == null )
        {
            return;
        }
        body.add( line );
    }

    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder( ""EslMessage: contentType=["" );
        sb.append( getContentType() );
        sb.append( ""] headers="" );
        sb.append( headers.size() );
        sb.append( "", body="" );
        sb.append( body.size() );
        sb.append( "" lines."" );
        
        return sb.toString();
    }
    
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/transport/message/EslHeaders.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.transport.message;

/**
 * Container class for enumeration of ESL message header names, and some commonly used 
 * header string values.
 * 
 * @author  david varnes
 */
public class EslHeaders
{
    /**
     * Standard ESL header names.
     * <p>
     * Note this enum will need to be kept in synch with any new headers introduced on the server side.
     * 
     * @author david varnes 
     */
    public enum Name
    {
        /*
         *  Minor optimization - put most often used headers at the top for fastest resolution
         *  in static fromLiteral().  
         */
        
        /**
         * {@code ""Content-Type""}
         */
        CONTENT_TYPE( ""Content-Type"" ),
        /**
         * {@code ""Content-Length""}
         */
        CONTENT_LENGTH( ""Content-Length"" ),
        /**
         * {@code ""Reply-Text""}
         */
        REPLY_TEXT( ""Reply-Text"" ),
        /**
         * {@code ""Job-UUID""}
         */
        JOB_UUID( ""Job-UUID"" ),
        /**
         * {@code ""Socket-Mode""}
         */
        SOCKET_MODE( ""Socket-Mode"" ),
        /**
         * {@code ""Control""}
         */
        Control( ""Control"" ),
        ;
        
        private final String literal;
        
        private Name( String literal )
        {
            this.literal = literal;
        }
        
        public String literal()
        {
            return literal;
        }
        
        public static Name fromLiteral( String literal )
        {
            for ( Name name : values() )
            {
                if ( name.literal.equalsIgnoreCase( literal ) )
                {
                    return name;
                }
            }
            
            return null;
        }
    }
    
    /**
     * Some common ESL header values. These are provided as a convenience for commonly used values.
     * <p>
     * This values are not coded as an enum to allow for the very large range of possible values,
     * since they are just Strings.
     *
     * @author david varnes
     */
    public static final class Value 
    {
        /**
         * {@code ""+OK""}
         */
        public static final String OK = ""+OK"";
        /**
         * {@code ""auth/request""}
         */
        public static final String AUTH_REQUEST = ""auth/request"";
        /**
         * {@code ""api/response""}
         */
        public static final String API_RESPONSE = ""api/response"";
        /**
         * {@code ""command/reply""}
         */
        public static final String COMMAND_REPLY = ""command/reply"";
        /**
         * {@code ""text/event-plain""}
         */
        public static final String TEXT_EVENT_PLAIN = ""text/event-plain"";
        /**
         * {@code ""text/event-xml""}
         */
        public static final String TEXT_EVENT_XML = ""text/event-xml"";
        /**
         * {@code ""text/disconnect-notice""}
         */
        public static final String TEXT_DISCONNECT_NOTICE = ""text/disconnect-notice"";
        /**
         * {@code ""-ERR invalid""}
         */
        public static final String ERR_INVALID = ""-ERR invalid"";
    }
    
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/transport/SendMsg.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.transport;

import java.util.ArrayList;
import java.util.List;

/**
 * 
 * @author  david varnes
 */
public class SendMsg
{
    private final List<String> msgLines = new ArrayList<String>();
    private final boolean hasUuid;
    
    /**
     * Constructor for use with outbound socket client only.  This client mode does not need a call
     * UUID for context.
     */
    public SendMsg()
    {
        msgLines.add( ""sendmsg"" );
        hasUuid = false;
    }
    
    /**
     * Constructor for use with the inbound client. 
     * 
     * @param uuid of the call to send message to (it should be in 'park' to be operated on).
     */
    public SendMsg( String uuid )
    {
        msgLines.add( ""sendmsg "" + uuid );
        hasUuid = true;
    }
    
    /**
     * Adds the following line to the message:
     * <pre>
     *   call-command: command
     * </pre>
     * @param command the string command [ execute | hangup ] 
     */
    public void addCallCommand( String command )
    {
        msgLines.add( ""call-command: "" + command );
    }
    
    /**
     * Adds the following line to the message:
     * <pre>
     *   execute-app-name: appName
     * </pre>
     * @param appName the string app name to execute 
     */
    public void addExecuteAppName( String appName )
    {
        msgLines.add( ""execute-app-name: "" + appName );
    }
    
    /**
     * Adds the following line to the message:
     * <pre>
     *   execute-app-arg: arg
     * </pre>
     * @param arg the string arg
     */
    public void addExecuteAppArg( String arg )
    {
        msgLines.add( ""execute-app-arg: "" + arg );
    }

    /**
     * Adds the following line to the message:
     * <pre>
     *   loops: count
     * </pre>
     * @param count the int number of times to loop
     */
    public void addLoops( int count )
    {
        msgLines.add( ""loops: "" + count );
    }

    /**
     * Adds the following line to the message:
     * <pre>
     *   hangup-cause: cause
     * </pre>
     * @param cause the string cause
     */
    public void addHangupCause( String cause )
    {
        msgLines.add( ""hangup-cause: "" + cause );
    }

    /**
     * Adds the following line to the message:
     * <pre>
     *   nomedia-uid: value
     * </pre>
     * @param value the string value part of the line
     */
    public void addNomediaUuid( String value )
    {
        msgLines.add( ""nomedia-uuid: "" + value );
    }
    
    /**
     *  Adds the following line to the message:
     *  <pre>
     *    event-lock: true
     *  </pre> 
     */
    public void addEventLock()
    {
        msgLines.add( ""event-lock: true"" );
    }
    
    /**
     * A generic method to add a message line. The constructed line in the sent message will be in the
     * form:
     * <pre>
     *   name: value
     * </pre>
     * 
     * @param name part of line 
     * @param value part of line
     */
    public void addGenericLine( String name, String value )
    {
        msgLines.add( name + "": "" + value );
    }
    
    /**
     * The list of strings that make up the message to send to FreeSWITCH.
     * 
     * @return list of strings, as they were added to this message.
     */
    public List<String> getMsgLines()
    {
        return msgLines;
    }

    /**
     * Indicate if message was constructed with a UUID.
     * 
     * @return true if constructed with a UUID.
     */
    public boolean hasUuid()
    {
        return hasUuid;
    }
    
    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder( ""SendMsg: "" );
        if ( msgLines.size() > 1 )
        {
            sb.append( msgLines.get( 1 ) );
        } 
        else if ( msgLines.size() > 0 )
        {
            sb.append( 0 );
        }
        
        return sb.toString();
    }
    
    
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/transport/event/EslEvent.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.transport.event;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.freeswitch.esl.client.internal.HeaderParser;
import org.freeswitch.esl.client.transport.message.EslHeaders;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.freeswitch.esl.client.transport.message.EslHeaders.Name;
import org.freeswitch.esl.client.transport.message.EslHeaders.Value;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * FreeSWITCH Event Socket <strong>events</strong> are decoded into this data object.
 * <p>
 * An ESL event is modelled as a collection of text lines. An event always has several eventHeader
 * lines, and optionally may have some eventBody lines.  In addition the messageHeaders of the 
 * original containing {@link EslMessage} which carried the event are also available. 
 * <p>
 * The eventHeader lines are parsed and cached in a map keyed by the eventHeader name string. An event
 * is always expected to have an ""Event-Name"" eventHeader. Commonly used eventHeader names are coded
 * in {@link EslEventHeaderNames}
 * <p>
 * Any eventBody lines are cached in a list.
 * <p>
 * The messageHeader lines from the original message are cached in a map keyed by {@link EslHeaders.Name}.
 * 
 * @author  david varnes
 * @see EslEventHeaderNames
 */
public class EslEvent 
{
    private final Logger log = LoggerFactory.getLogger( this.getClass() );
    
    private final Map<Name,String> messageHeaders;
    private final Map<String,String> eventHeaders;
    private final List<String> eventBody;
    private boolean decodeEventHeaders = true;
    
    public EslEvent( EslMessage rawMessage )
    {
        this( rawMessage, false );
    }
    
    public EslEvent( EslMessage rawMessage, boolean parseCommandReply )
    {
        messageHeaders = rawMessage.getHeaders();
        eventHeaders = new HashMap<String,String>( rawMessage.getBodyLines().size() );
        eventBody = new ArrayList<String>();
        // plain or xml body
        if ( rawMessage.getContentType().equals( Value.TEXT_EVENT_PLAIN ) )
        {
            parsePlainBody( rawMessage.getBodyLines() );
        }
        else if ( rawMessage.getContentType().equals( Value.TEXT_EVENT_XML ) )
        {
            throw new IllegalStateException( ""XML events are not yet supported"" );
        }
        else if ( rawMessage.getContentType().equals( Value.COMMAND_REPLY ) && parseCommandReply )
        {
            parsePlainBody( rawMessage.getBodyLines() );
        }
        else
        {
            throw new IllegalStateException( ""Unexpected EVENT content-type: "" + 
                rawMessage.getContentType() );
        }
    }

    /**
     * The message headers of the original ESL message from which this event was decoded.
     * The message headers are stored in a map keyed by {@link EslHeaders.Name}. The string mapped value 
     * is the parsed content of the header line (ie, it does not include the header name).
     *  
     * @return map of header values
     */
    public Map<Name,String> getMessageHeaders()
    {
        return messageHeaders;
    }

    /**
     * The event headers of this event. The headers are parsed and stored in a map keyed by the string 
     * name of the header, and the string mapped value is the parsed content of the event header line 
     * (ie, it does not include the header name).
     *  
     * @return map of event header values
     */
    public Map<String, String> getEventHeaders()
    {
        return eventHeaders;
    }
    
    /**
     * Any event body lines that were present in the event.
     * 
     * @return list of decoded event body lines, may be an empty list.
     */
    public List<String> getEventBodyLines()
    {
        return eventBody;
    }
    
    /**
     * Convenience method.
     * 
     * @return the string value of the event header ""Event-Name""
     */
    public String getEventName()
    {
        return getEventHeaders().get( EslEventHeaderNames.EVENT_NAME ); 
    }
    
    /**
     * Convenience method.
     *
     * @return the string value of the event header ""Event-Subclass""
     */
    public String getEventSubclass()
    {
        String subClass = getEventHeaders().get( EslEventHeaderNames.EVENT_SUBCLASS );
        if(subClass == null){
            return ""NONE"";
        }
        return subClass;
    }

    /**
     * Convenience method.
     * 
     * @return long value of the event header ""Event-Date-Timestamp""
     */
    public long getEventDateTimestamp()
    {
        return Long.valueOf( getEventHeaders().get( EslEventHeaderNames.EVENT_DATE_TIMESTAMP ) );
    }

    /**
     * Convenience method.
     * 
     * @return long value of the event header ""Event-Date-Local""
     */
    public String getEventDateLocal()
    {
        return getEventHeaders().get( EslEventHeaderNames.EVENT_DATE_LOCAL );
    }

    /**
     * Convenience method.
     * 
     * @return long value of the event header ""Event-Date-GMT""
     */
    public String getEventDateGmt()
    {
        return getEventHeaders().get( EslEventHeaderNames.EVENT_DATE_GMT );
    }

    /**
     * Convenience method.
     * 
     * @return true if the eventBody list is not empty.
     */
    public boolean hasEventBody()
    {
        return ! eventBody.isEmpty();
    }
    
    private void parsePlainBody( final List<String> rawBodyLines )
    {
        boolean isEventBody = false;
        for ( String rawLine : rawBodyLines )
        {
            if ( ! isEventBody )
            {
                // split the line
                String[] headerParts = HeaderParser.splitHeader( rawLine );
                if ( decodeEventHeaders )
                {
                    try
                    {
                        String decodedValue = URLDecoder.decode( headerParts[1], ""UTF-8"" );
                        log.trace( ""decoded from: [{}]"", headerParts[1] );
                        log.trace( ""decoded   to: [{}]"", decodedValue );
                        eventHeaders.put( headerParts[0], decodedValue );
                    }
                    catch ( UnsupportedEncodingException e )
                    {
                        log.warn( ""Could not URL decode [{}]"", headerParts[1] );
                        eventHeaders.put( headerParts[0], headerParts[1] );
                    }
                }
                else
                {
                    eventHeaders.put( headerParts[0], headerParts[1] );
                }
                if ( headerParts[0].equals( EslEventHeaderNames.CONTENT_LENGTH ) )
                {
                    // the remaining lines will be considered body lines
                    isEventBody = true;
                }
            }
            else
            {
                // ignore blank line (always is one following the content-length
                if ( rawLine.length() > 0 )
                {
                    eventBody.add( rawLine );
                }
            }
        }

    }
    
    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder( ""EslEvent: name=["" );
        sb.append( getEventName() );
        sb.append( ""] subclass=["");
        sb.append( getEventSubclass() );
        sb.append( ""] headers="" );
        sb.append( messageHeaders.size() );
        sb.append( "", eventHeaders="" );
        sb.append( eventHeaders.size() );
        sb.append( "", eventBody="" );
        sb.append( eventBody.size() );
        sb.append( "" lines."" );
        
        return sb.toString();
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/transport/event/EslEventHeaderNames.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.transport.event;

/**
 * Convenience container class for some commonly used ESL event header names (note there are many more!).
 * <p>
 * These names are stored as strings (rather than an Enum) so that there is no necessity to keep up to
 * date with changes or additions to event header names.
 * 
 * @author  david varnes
 */
public class EslEventHeaderNames
{
    /**
     * {@code ""Event-Name""}
     */
    public static final String EVENT_NAME = ""Event-Name"";
    /**
     * {@code ""Event-Subclass""}     *
     */
    public static final String EVENT_SUBCLASS = ""Event-Subclass"";
    /**
     * {@code ""Event-Date-Local""}
     */
    public static final String EVENT_DATE_LOCAL = ""Event-Date-Local"";
    /**
     * {@code ""Event-Date-GMT""}
     */
    public static final String EVENT_DATE_GMT = ""Event-Date-GMT"";
    /**
     * {@code ""Event-Date-Timestamp""}
     */
    public static final String EVENT_DATE_TIMESTAMP = ""Event-Date-Timestamp"";
    /**
     * {@code ""Event-Calling-File""}
     */
    public static final String EVENT_CALLING_FILE = ""Event-Calling-File"";
    /**
     * {@code ""Event-Calling-Function""}
     */
    public static final String EVENT_CALLING_FUNCTION = ""Event-Calling-Function"";
    /**
     * {@code ""Event-Calling-Line-Number""}
     */
    public static final String EVENT_CALLING_LINE_NUMBER = ""Event-Calling-Line-Number"";
    /**
     * {@code ""FreeSWITCH-Hostname""}
     */
    public static final String FREESWITCH_HOSTNAME = ""FreeSWITCH-Hostname"";
    /**
     * {@code ""FreeSWITCH-IPv4""}
     */
    public static final String FREESWITCH_IPV4 = ""FreeSWITCH-IPv4"";
    /**
     * {@code ""FreeSWITCH-IPv6""}
     */
    public static final String FREESWITCH_IPV6 = ""FreeSWITCH-IPv6"";
    /**
     * {@code ""Core-UUID""}
     */
    public static final String CORE_UUID = ""Core-UUID"";
    /**
     * {@code ""Content-Length""}
     */
    public static final String CONTENT_LENGTH = ""Content-Length"";
    /**
     * {@code ""Job-Command""}
     */
    public static final String JOB_COMMAND = ""Job-Command"";
    /**
     * {@code ""Job-UUID""}
     */
    public static final String JOB_UUID = ""Job-UUID"";

    private EslEventHeaderNames()
    {
        /* private class */
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/transport/CommandResponse.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.transport;

import org.freeswitch.esl.client.transport.message.EslMessage;
import org.freeswitch.esl.client.transport.message.EslHeaders.Name;

/**
 * Result object to carry the results of a command sent to the FreeSWITCH Event Socket.
 * 
 * @author  david varnes
 */
public class CommandResponse
{
    private final String command;
    private final String replyText;
    private final EslMessage response;
    private final boolean success;
    
    public CommandResponse( String command, EslMessage response )
    {
        this.command = command;
        this.response = response;
        this.replyText = response.getHeaderValue( Name.REPLY_TEXT );
        this.success = replyText.startsWith( ""+OK"" );
    }
    
    /**
     * @return the original command sent to the server
     */
    public String getCommand()
    {
        return command;
    }
    
    /**
     * @return true if and only if the response Reply-Text line starts with ""+OK""
     */
    public boolean isOk()
    {
        return success;
    }
    
    /**
     * @return the full response Reply-Text line.
     */
    public String getReplyText()
    {
        return replyText;
    }
    
    /**
     * @return {@link EslMessage} the full response from the server 
     */
    public EslMessage getResponse()
    {
        return response;
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/example/ExampleClient.java,"package org.freeswitch.esl.client.example;
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
import org.freeswitch.esl.client.inbound.Client;
import org.freeswitch.esl.client.inbound.InboundConnectionFailure;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Scanner;

/**
 *
 * @author leif
 */
public class ExampleClient {
    private final Logger log = LoggerFactory.getLogger( this.getClass() );

    private String host = ""localhost"";
    private int port = 8021;
    private String password = ""ClueCon"";
    private Client client;
    private HeartbeatThread hbThread;
    
    public void do_connect() throws InterruptedException
    {
        client = new Client();
        client.addEventListener( new EslEventListener() );

        log.info( ""Client connecting .."" );
        try
        {
            client.connect( host, port, password, 2 );
        }
        catch ( InboundConnectionFailure e )
        {
            log.error( ""Connect failed"", e );
            return;
        }
        log.info( ""Client connected .."" );

        //client.setEventSubscriptions( ""plain"", ""heartbeat BACKGROUND_JOB CUSTOM"" );
        client.setEventSubscriptions( ""plain"", ""all"" );
        client.addEventFilter( ""Event-Name"", ""heartbeat"" );
        client.addEventFilter( ""Event-Name"", ""custom"" );
        client.addEventFilter( ""Event-Name"", ""background_job"" );

    }

    public void close_client() {
        stopHeartBeatThread();
        client.close();
    }

    public void startHeartBeatThread() {
        hbThread = new HeartbeatThread(client);
        new Thread(hbThread).start();
    }

    public void stopHeartBeatThread() {
        hbThread.shutdown();
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        ExampleClient test = new ExampleClient();
        try {
            test.do_connect();
            //FIXME.. the reconnect code that this is intended to implement requires refactoring.
            //test.startHeartBeatThread();
            Scanner myInput = new Scanner(System.in);
            boolean notDone = true;
            while(notDone){
                String Input1 = myInput.next();
                if(Input1.equalsIgnoreCase(""q"")){
                    notDone = false;
                }
                Thread.sleep( 25000 );
            }
            //test.stopHeartBeatThread();
            test.close_client();
        }catch(InterruptedException ie) {
            return;
        }
    }

}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/example/EslEventListener.java,"/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package org.freeswitch.esl.client.example;

import org.freeswitch.esl.client.IEslEventListener;
import org.freeswitch.esl.client.transport.event.EslEvent;
import org.jboss.netty.channel.ExceptionEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author leif
 */
public class EslEventListener implements IEslEventListener {
    private final Logger log = LoggerFactory.getLogger( this.getClass() );

    public void eventReceived( EslEvent event )
    {
        log.info( ""Event received [{}]"", event );
    }

    public void backgroundJobResultReceived( EslEvent event )
    {
        log.info( ""Background job result received [{}]"", event );
    }

    public void conferenceEventJoin(String uniqueId, String confName, int confSize, EslEvent event) {
        StringBuilder sb = new StringBuilder("""");
        sb.append(uniqueId);
        Object[] args = new Object[3];
        args[0] = confName;
        args[1] = confSize;
        args[2] = sb.toString();
        log.info (""Conference [{}]({}) JOIN [{}]"", args);
    }

    public void conferenceEventLeave(String uniqueId, String confName, int confSize, EslEvent event) {
        StringBuilder sb = new StringBuilder("""");
        sb.append(uniqueId);
        Object[] args = new Object[3];
        args[0] = confName;
        args[1] = confSize;
        args[2] = sb.toString();
        log.info (""Conference [{}]({}) LEAVE [{}]"", args);
    }

    public void conferenceEventMute(String uniqueId, String confName, int confSize, EslEvent event) {
        StringBuilder sb = new StringBuilder("""");
        sb.append(uniqueId);
        log.info (""Conference [{}] MUTE [{}]"", confName, sb.toString());
    }

    public void conferenceEventUnMute(String uniqueId, String confName, int confSize, EslEvent event) {
        StringBuilder sb = new StringBuilder("""");
        sb.append(uniqueId);
        log.info (""Conference [{}] UNMUTE [{}]"", confName, sb.toString());
    }

    public void conferenceEventAction(String uniqueId, String confName, int confSize, String action, EslEvent event) {
        StringBuilder sb = new StringBuilder("""");
        sb.append(uniqueId);
        sb.append("" action=["");
        sb.append(action);
        sb.append(""]"");
        log.info (""Conference [{}] Action [{}]"", confName, sb.toString());
    }

    public void conferenceEventTransfer(String uniqueId, String confName, int confSize, EslEvent event) {
        //Noop
    }

    public void conferenceEventRecord(String uniqueId, String confName, int confSize, EslEvent event) {
        //Noop
    }
    
    public void conferenceEventThreadRun(String uniqueId, String confName, int confSize, EslEvent event) {
        //Noop
    }

    public void conferenceEventPlayFile(String uniqueId, String confName, int confSize, EslEvent event) {
        //Noop
    }

    public void exceptionCaught(ExceptionEvent e) {
        //throw new UnsupportedOperationException(""Not supported yet."");
    }

}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/example/HeartbeatThread.java,"/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package org.freeswitch.esl.client.example;

import java.util.logging.Level;
import java.util.logging.Logger;
import org.freeswitch.esl.client.inbound.Client;
import org.freeswitch.esl.client.inbound.InboundConnectionFailure;
import org.slf4j.LoggerFactory;

/**
 *
 * @author leif
 */
public class HeartbeatThread implements Runnable {
    private final org.slf4j.Logger log = LoggerFactory.getLogger( this.getClass() );
    private Client client;
    private boolean shutdown = false;
    private String host = ""localhost"";
    private int port = 8021;
    private String password = ""ClueCon"";

    HeartbeatThread(Client c) {
        this.client = c;
    }

    HeartbeatThread(Client c, String h, int p, String pass) {
        this.client = c;
        this.host = h;
        this.port = p;
        this.password = pass;
    }

    public void shutdown() {
        this.shutdown = true;
    }

    public void gotHeartbeatEvent() {

    }
    
    public void run() {
        while(!shutdown) {
            try {
                String jobId = client.sendAsyncApiCommand( ""status"", """" );
                log.info( ""Job id [{}] for [status]"", jobId );
                Thread.sleep(25000);
            } catch (IllegalStateException is) {
                log.warn( ""ISE: [{}]"", is.getMessage());
                log.info( ""Client connecting .."" );
                try
                {
                    client.connect( host, port, password, 2 );
                    log.info( ""Client connected .."" );
                }
                catch ( InboundConnectionFailure e )
                {
                    log.warn( ""Connect failed [{}]"", e.getMessage() );
                    try {
                        Thread.sleep(25000);
                    } catch (InterruptedException ex) {
                        Logger.getLogger(HeartbeatThread.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            } catch (InterruptedException ex) {
                Logger.getLogger(HeartbeatThread.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/internal/HeaderParser.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.internal;

import org.jboss.netty.handler.codec.http.HttpMessageDecoder;

/**
 * This parser provides a static helper method to split a standard Header field
 * into the name and value parts.
 * <p>
 * This code was copied from the splitHeader() method in the {@link HttpMessageDecoder} class, which
 * is licensed under the Apache License version 2. (Original author: Trustin Lee.)
 *  
 * @author	 Trustin Lee
 * @author   david varnes
 */
public class HeaderParser
{
    /**
     * Split a header in the form 
     * <pre>
     *   Header-Name: Some_header-value
     * </pre>
     * into a String array.
     * 
     * @param  sb the string header to parse
     * @return a String[] array with header name at 0 and header value at 1
     */
    public static String[] splitHeader(String sb) {
        final int length = sb.length();
        int nameStart;
        int nameEnd;
        int colonEnd;
        int valueStart;
        int valueEnd;

        nameStart = findNonWhitespace(sb, 0);
        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {
            char ch = sb.charAt(nameEnd);
            if (ch == ':' || Character.isWhitespace(ch)) {
                break;
            }
        }

        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {
            if (sb.charAt(colonEnd) == ':') {
                colonEnd ++;
                break;
            }
        }

        valueStart = findNonWhitespace(sb, colonEnd);
        if (valueStart == length) {
            return new String[] {
                    sb.substring(nameStart, nameEnd),
                    """"
            };
        }

        valueEnd = findEndOfString(sb);
        return new String[] {
                sb.substring(nameStart, nameEnd),
                sb.substring(valueStart, valueEnd)
        };
    }

    private static int findNonWhitespace(String sb, int offset) {
        int result;
        for (result = offset; result < sb.length(); result ++) {
            if (!Character.isWhitespace(sb.charAt(result))) {
                break;
            }
        }
        return result;
    }

    private static int findEndOfString(String sb) {
        int result;
        for (result = sb.length(); result > 0; result --) {
            if (!Character.isWhitespace(sb.charAt(result - 1))) {
                break;
            }
        }
        return result;
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/internal/AbstractEslClientHandler.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.internal;

import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import org.freeswitch.esl.client.transport.event.EslEvent;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.freeswitch.esl.client.transport.message.EslHeaders.Name;
import org.freeswitch.esl.client.transport.message.EslHeaders.Value;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.ChannelUpstreamHandler;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
import org.jboss.netty.handler.execution.ExecutionHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Specialised {@link ChannelUpstreamHandler} that implements the logic of an ESL connection that
 * is common to both inbound and outbound clients. This 
 * handler expects to receive decoded {@link EslMessage} or {@link EslEvent} objects. The key 
 * responsibilities for this class are:
 * <ul><li>
 * To synthesise a synchronous command/response api.  All IO operations using the underlying Netty 
 * library are intrinsically asynchronous which provides for excellent response and scalability.  This 
 * class provides for a blocking wait mechanism for responses to commands issued to the server.  A 
 * key assumption here is that the FreeSWITCH server will process synchronous requests in the order they
 * are received.
 * </li><li>
 * Concrete sub classes are expected to 'terminate' the Netty IO processing pipeline (ie be the 'last'
 * handler). 
 * </li></ul>
 * Note: implementation requirement is that an {@link ExecutionHandler} is placed in the processing 
 * pipeline prior to this handler. This will ensure that each incoming message is processed in its
 * own thread (although still guaranteed to be processed in the order of receipt).
 * 
 * @author  david varnes
 */
public abstract class AbstractEslClientHandler extends SimpleChannelUpstreamHandler
{
    public static final String MESSAGE_TERMINATOR = ""\n\n"";  
    public static final String LINE_TERMINATOR = ""\n"";  

    protected final Logger log = LoggerFactory.getLogger( this.getClass() );

    private final Lock syncLock = new ReentrantLock();
    private final Queue<SyncCallback> syncCallbacks = new ConcurrentLinkedQueue<SyncCallback>();

    @Override
    public void messageReceived( ChannelHandlerContext ctx, MessageEvent e ) throws Exception
    {
        if ( e.getMessage() instanceof EslMessage )
        {
            EslMessage message = (EslMessage)e.getMessage();
            String contentType = message.getContentType();
            if ( contentType.equals( Value.TEXT_EVENT_PLAIN ) ||
                    contentType.equals( Value.TEXT_EVENT_XML ) )
            {
                //  transform into an event
                EslEvent eslEvent = new EslEvent( message );
                handleEslEvent( ctx, eslEvent );
            }
            else
            {
                handleEslMessage( ctx, (EslMessage)e.getMessage() );
            }
        }
        else
        {
            throw new IllegalStateException( ""Unexpected message type: "" + e.getMessage().getClass() );
        }
    }
    
    /**
     * Synthesise a synchronous command/response by creating a callback object which is placed in 
     * queue and blocks waiting for another IO thread to process an incoming {@link EslMessage} and
     * attach it to the callback.
     * 
     * @param channel
     * @param command single string to send
     * @return the {@link EslMessage} attached to this command's callback
     */
    public EslMessage sendSyncSingleLineCommand( Channel channel, final String command )
    {
        SyncCallback callback = new SyncCallback();
        syncLock.lock();
        try 
        {
            syncCallbacks.add( callback );
            channel.write( command + MESSAGE_TERMINATOR );
        } 
        finally 
        {
            syncLock.unlock();
        }
        
        //  Block until the response is available 
        return callback.get();
    }

    /**
     * Synthesise a synchronous command/response by creating a callback object which is placed in 
     * queue and blocks waiting for another IO thread to process an incoming {@link EslMessage} and
     * attach it to the callback.
     * 
     * @param channel
     * @param command List of command lines to send
     * @return the {@link EslMessage} attached to this command's callback
     */
    public EslMessage sendSyncMultiLineCommand( Channel channel, final List<String> commandLines )
    {
        SyncCallback callback = new SyncCallback();
        //  Build command with double line terminator at the end
        StringBuilder sb = new StringBuilder();
        for ( String line : commandLines )
        {
            sb.append( line );
            sb.append( LINE_TERMINATOR );
        }
        sb.append( LINE_TERMINATOR );
        
        syncLock.lock();
        try 
        {
            syncCallbacks.add( callback );
            channel.write( sb.toString() );
        } 
        finally 
        {
            syncLock.unlock();
        }
        
        //  Block until the response is available 
        return callback.get();
    }

    /**
     * Returns the Job UUID of that the response event will have.
     * 
     * @param channel
     * @param command
     * @return Job-UUID as a string
     */
    public String sendAsyncCommand( Channel channel, final String command )
    {
        /*
         * Send synchronously to get the Job-UUID to return, the results of the actual 
         * job request will be returned by the server as an async event.
         */
        EslMessage response = sendSyncSingleLineCommand( channel, command );
        if ( response.hasHeader( Name.JOB_UUID ) )
        {
            return response.getHeaderValue( Name.JOB_UUID );
        }
        else
        {
            throw new IllegalStateException( ""Missing Job-UUID header in bgapi response"" );
        }
    }
    
    protected void handleEslMessage( ChannelHandlerContext ctx, EslMessage message )
    {
        log.info( ""Received message: [{}]"", message );
        String contentType = message.getContentType();
        
        if ( contentType.equals( Value.API_RESPONSE ) )
        {
            log.debug( ""Api response received [{}]"", message );
            syncCallbacks.poll().handle( message );
        }
        else if ( contentType.equals( Value.COMMAND_REPLY ) )
        {
            log.debug( ""Command reply received [{}]"", message );
            syncCallbacks.poll().handle( message );
        }
        else if ( contentType.equals( Value.AUTH_REQUEST ) )
        {
            log.debug( ""Auth request received [{}]"", message );
            handleAuthRequest( ctx );
        }
        else if ( contentType.equals( Value.TEXT_DISCONNECT_NOTICE ) )
        {
            log.debug( ""Disconnect notice received [{}]"", message );
            handleDisconnectionNotice();
        }
        else
        {
            log.warn( ""Unexpected message content type [{}]"", contentType );
        }
    }

    protected abstract void handleEslEvent( ChannelHandlerContext ctx, EslEvent event );

    protected abstract void handleAuthRequest( ChannelHandlerContext ctx );

    protected abstract void handleDisconnectionNotice();
    
    private static class SyncCallback
    {
        private static final Logger log = LoggerFactory.getLogger( SyncCallback.class );
        private final CountDownLatch latch = new CountDownLatch( 1 );
        private EslMessage response;

        /**
         * Block waiting for the countdown latch to be released, then return the 
         * associated response object.
         * @return
         */
        EslMessage get()
        {
            try
            {
                log.trace( ""awaiting latch ... "" );
                if (latch.await(10, TimeUnit.SECONDS)) {
                    log.trace( ""returning response [{}]"", response );
                    return response;
                } else {
                    log.warn(""Timeout waiting for response from ESL command."");
                    throw new RuntimeException(""WAIT_FOR_ESL_RESPONSE_TIMEOUT"");
                }
            }
            catch ( InterruptedException e )
            {
                throw new RuntimeException( e );
            }
        }

        /**
         * Attach this response to the callback and release the countdown latch.
         * @param response
         */
        void handle( EslMessage response )
        {
            this.response = response;
            log.trace( ""releasing latch for response [{}]"", response );
            latch.countDown();
        }
    }

}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/internal/IEslProtocolListener.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.internal;

import org.freeswitch.esl.client.inbound.Client;
import org.freeswitch.esl.client.transport.CommandResponse;
import org.freeswitch.esl.client.transport.event.EslEvent;
import org.jboss.netty.channel.ExceptionEvent;

/**
 * End users of the {@link Client} should not need to use this class. 
 * <p>
 * Allow client implementations to observe events arriving from the server.
 * 
 * @author  david varnes
 */
public interface IEslProtocolListener
{
    void authResponseReceived( CommandResponse response );
    
    void eventReceived( EslEvent event );
    
    void disconnected();

    void exceptionCaught(ExceptionEvent e);

}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/internal/debug/ChannelEventRunnable.java,"package org.freeswitch.esl.client.internal.debug;
/*
 * Copyright 2009 Red Hat, Inc.
 *
 * Red Hat licenses this file to you under the Apache License, version 2.0
 * (the ""License""); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */


import java.util.concurrent.Executor;

import org.jboss.netty.channel.ChannelEvent;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.util.EstimatableObjectWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * a {@link Runnable} which sends the specified {@link ChannelEvent} upstream.
 * Most users will not see this type at all because it is used by
 * {@link Executor} implementors only
 *
 * @author The Netty Project (netty-dev@lists.jboss.org)
 * @author Trustin Lee (tlee@redhat.com)
 *
 * @version $Rev: 1685 $, $Date: 2009-08-28 16:15:49 +0900 $
 *
 */
public class ChannelEventRunnable implements Runnable, EstimatableObjectWrapper {
    
    private final Logger log = LoggerFactory.getLogger( this.getClass() );
    private final ChannelHandlerContext ctx;
    private final ChannelEvent e;
    volatile int estimatedSize;

    /**
     * Creates a {@link Runnable} which sends the specified {@link ChannelEvent}
     * upstream via the specified {@link ChannelHandlerContext}.
     */
    public ChannelEventRunnable(ChannelHandlerContext ctx, ChannelEvent e) {
        this.ctx = ctx;
        this.e = e;
    }

    /**
     * Returns the {@link ChannelHandlerContext} which will be used to
     * send the {@link ChannelEvent} upstream.
     */
    public ChannelHandlerContext getContext() {
        return ctx;
    }

    /**
     * Returns the {@link ChannelEvent} which will be sent upstream.
     */
    public ChannelEvent getEvent() {
        return e;
    }

    /**
     * Sends the event upstream.
     */
    public void run() {
//        log.info( ""Sending [{}] upstream in [{}]"", e, ctx );
        try
        {
            ctx.sendUpstream(e);
        }
        catch ( Throwable t )
        {
            log.error( ""Caught -->"", t );
        }
    }

    public Object unwrap() {
        return e;
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/internal/debug/ExecutionHandler.java,"package org.freeswitch.esl.client.internal.debug;

/*
 * Copyright 2009 Red Hat, Inc.
 *
 * Red Hat licenses this file to you under the Apache License, version 2.0
 * (the ""License""); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

import java.util.concurrent.Executor;

import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelDownstreamHandler;
import org.jboss.netty.channel.ChannelEvent;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.ChannelPipeline;
import org.jboss.netty.channel.ChannelState;
import org.jboss.netty.channel.ChannelStateEvent;
import org.jboss.netty.channel.ChannelUpstreamHandler;
import org.jboss.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor;
import org.jboss.netty.util.ExternalResourceReleasable;
import org.jboss.netty.util.internal.ExecutorUtil;

/**
 * Forwards an upstream {@link ChannelEvent} to an {@link Executor}.
 * <p>
 * You can implement various thread model by adding this handler to a
 * {@link ChannelPipeline}.  The most common use case of this handler is to
 * add a {@link ExecutionHandler} which was specified with
 * {@link OrderedMemoryAwareThreadPoolExecutor}:
 * <pre>
 * ChannelPipeline pipeline = ...;
 * pipeline.addLast(""decoder"", new MyProtocolDecoder());
 * pipeline.addLast(""encoder"", new MyProtocolEncoder());
 *
 * // HERE
 * <strong>pipeline.addLast(""executor"", new {@link ExecutionHandler}(new {@link OrderedMemoryAwareThreadPoolExecutor}(16, 1048576, 1048576)));</strong>
 *
 * pipeline.addLast(""handler"", new MyBusinessLogicHandler());
 * </pre>
 * to utilize more processors to handle {@link ChannelEvent}s.  You can also
 * use other {@link Executor} implementation than the recommended
 * {@link OrderedMemoryAwareThreadPoolExecutor}.
 *
 * @author The Netty Project (netty-dev@lists.jboss.org)
 * @author Trustin Lee (tlee@redhat.com)
 *
 * @version $Rev: 1685 $, $Date: 2009-08-28 16:15:49 +0900 $
 *
 * @apiviz.landmark
 * @apiviz.has java.util.concurrent.ThreadPoolExecutor
 */
public class ExecutionHandler implements ChannelUpstreamHandler, ChannelDownstreamHandler, ExternalResourceReleasable {

    private final Executor executor;

    /**
     * Creates a new instance with the specified {@link Executor}.
     * Specify an {@link OrderedMemoryAwareThreadPoolExecutor} if unsure.
     */
    public ExecutionHandler(Executor executor) {
        if (executor == null) {
            throw new NullPointerException(""executor"");
        }
        this.executor = executor;
    }

    /**
     * Returns the {@link Executor} which was specified with the constructor.
     */
    public Executor getExecutor() {
        return executor;
    }

    /**
     * Shuts down the {@link Executor} which was specified with the constructor
     * and wait for its termination.
     */
    public void releaseExternalResources() {
        ExecutorUtil.terminate(getExecutor());
    }

    public void handleUpstream(
            ChannelHandlerContext context, ChannelEvent e) throws Exception {
        executor.execute(new ChannelEventRunnable(context, e));
    }

    public void handleDownstream(
            ChannelHandlerContext ctx, ChannelEvent e) throws Exception {
        if (e instanceof ChannelStateEvent) {
            ChannelStateEvent cse = (ChannelStateEvent) e;
            if (cse.getState() == ChannelState.INTEREST_OPS &&
                (((Integer) cse.getValue()).intValue() & Channel.OP_READ) != 0) {

                // setReadable(true) requested
                boolean readSuspended = ctx.getAttachment() != null;
                if (readSuspended) {
                    // Drop the request silently if MemoryAwareThreadPool has
                    // set the flag.
                    e.getFuture().setSuccess();
                    return;
                }
            }
        }

        ctx.sendDownstream(e);
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/manager/internal/ManagerConnectionImpl.java,"package org.freeswitch.esl.client.manager.internal;

import java.util.logging.Level;
import java.util.logging.Logger;
import org.freeswitch.esl.client.inbound.Client;
import org.freeswitch.esl.client.inbound.InboundConnectionFailure;
import org.freeswitch.esl.client.manager.ManagerConnection;

public class ManagerConnectionImpl implements ManagerConnection
{
    private static final String DEFAULT_HOSTNAME = ""localhost"";
    private static final int DEFAULT_PORT = 8021;
    private static final int DEFAULT_TIMEOUT = 2;
    
    private Client esl_client;
    private String hostname = DEFAULT_HOSTNAME;
    private int port = DEFAULT_PORT;
    private int timeoutSeconds = DEFAULT_TIMEOUT;
    protected String password;

    public ManagerConnectionImpl() {
        esl_client = new Client();
    }

    public void setHostname(String hostname) {
        this.hostname = hostname;
    }

    public void setPort(int port) {
        if (port <= 0) {
            this.port = DEFAULT_PORT;
        } else {
            this.port = port;
        }
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public void setTimeout(int timeout) {
        this.timeoutSeconds = timeout;
    }

    public String getHostname() {
        return hostname;
    }

    public int getPort() {
        return port;
    }

    public String getPassword() {
        return password;
    }

    public Client getESLClient() {
        return esl_client;
    }

    public void connect() throws InboundConnectionFailure {
        esl_client.connect(hostname, port, password, timeoutSeconds);
        esl_client.setEventSubscriptions( ""plain"", ""all"" );
        esl_client.addEventFilter( ""Event-Name"", ""heartbeat"" );
        esl_client.addEventFilter( ""Event-Name"", ""custom"" );
        esl_client.addEventFilter( ""Event-Name"", ""background_job"" );
        
        try {
            Thread.sleep(5000);
        } catch (InterruptedException ex) {
            Logger.getLogger(ManagerConnectionImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public void disconnect() {
        esl_client.close();
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/manager/ManagerConnection.java,"package org.freeswitch.esl.client.manager;

import org.freeswitch.esl.client.inbound.Client;
import org.freeswitch.esl.client.inbound.InboundConnectionFailure;

public interface ManagerConnection
{
    String getHostname();
    int getPort();
    String getPassword();
    Client getESLClient();
    void connect() throws InboundConnectionFailure;
    void disconnect();
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/manager/DefaultManagerConnection.java,"package org.freeswitch.esl.client.manager;

import org.freeswitch.esl.client.inbound.Client;
import org.freeswitch.esl.client.inbound.InboundConnectionFailure;
import org.freeswitch.esl.client.manager.internal.ManagerConnectionImpl;

public class DefaultManagerConnection implements ManagerConnection
{
    private ManagerConnectionImpl impl;

    /**
     * Creates a new instance.
     */
    public DefaultManagerConnection()
    {
        this.impl = new ManagerConnectionImpl();
    }

    public DefaultManagerConnection(String hostname, String password)
    {
        this();
        impl.setHostname(hostname);
        impl.setPassword(password);
    }

    public DefaultManagerConnection(String hostname, int port, String password)
    {
        this();
        impl.setHostname(hostname);
        impl.setPort(port);
        impl.setPassword(password);
    }

    public DefaultManagerConnection(String hostname, int port, String password, int timeout)
    {
        this();
        impl.setHostname(hostname);
        impl.setPort(port);
        impl.setPassword(password);
        impl.setTimeout(timeout);
    }

    public void setHostname(String hostname)
    {
        impl.setHostname(hostname);
    }

    public void setPort(int port)
    {
        impl.setPort(port);
    }

    public void setTimeout(int timeout)
    {
        impl.setTimeout(timeout);
    }

    public void setPassword(String password)
    {
        impl.setPassword(password);
    }

    public String getHostname()
    {
        return impl.getHostname();
    }

    public int getPort()
    {
        return impl.getPort();
    }

    public String getPassword()
    {
        return impl.getPassword();
    }

    public Client getESLClient()
    {
	return impl.getESLClient();
    }

    @Override
    public String toString()
    {
        final StringBuilder sb = new StringBuilder(""DefaultManagerConnection["");
        sb.append(""hostname='"").append(getHostname()).append(""',"");
        sb.append(""port="").append(getPort()).append(""]"");
        return sb.toString();
    }

    public void connect() throws InboundConnectionFailure {
        impl.connect();
    }

    public void disconnect() {
        impl.disconnect();
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/inbound/InboundConnectionFailure.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.inbound;

/**
 * Checked exception to handle connection failures.
 * 
 * @author  david varnes
 */
public class InboundConnectionFailure extends Exception
{
    private static final long serialVersionUID = 1L;

    public InboundConnectionFailure( String message )
    {
        super( message );
    }
    
    public InboundConnectionFailure( String message, Throwable cause )
    {
        super( message, cause );
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/inbound/Client.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.inbound;

import java.net.InetSocketAddress;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Iterator;
import org.freeswitch.esl.client.IEslEventListener;
import org.freeswitch.esl.client.internal.IEslProtocolListener;
import org.freeswitch.esl.client.transport.CommandResponse;
import org.freeswitch.esl.client.transport.SendMsg;
import org.freeswitch.esl.client.transport.event.EslEvent;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.jboss.netty.bootstrap.ClientBootstrap;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelFuture;
import org.jboss.netty.channel.ExceptionEvent;
import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Entry point to connect to a running FreeSWITCH Event Socket Library module, as a client.
 * <p>
 * This class provides what the FreeSWITCH documentation refers to as an 'Inbound' connection
 * to the Event Socket module. That is, with reference to the socket listening on the FreeSWITCH
 * server, this client occurs as an inbound connection to the server.
 * <p>
 * See <a href=""http://wiki.freeswitch.org/wiki/Mod_event_socket"">http://wiki.freeswitch.org/wiki/Mod_event_socket</a>
 * 
 * @author  david varnes
 */
public class Client
{
    private final Logger log = LoggerFactory.getLogger( this.getClass() );
    
    private final List<IEslEventListener> eventListeners = new CopyOnWriteArrayList<IEslEventListener>();
    private final Executor eventListenerExecutor = Executors.newSingleThreadExecutor( 
        new ThreadFactory()
        {
            AtomicInteger threadNumber = new AtomicInteger( 1 );
            public Thread newThread( Runnable r )
            {
                return new Thread( r, ""EslEventNotifier-"" + threadNumber.getAndIncrement() );
            }
        });
    private final Executor backgroundJobListenerExecutor = Executors.newSingleThreadExecutor( 
        new ThreadFactory()
        {
            AtomicInteger threadNumber = new AtomicInteger( 1 );
            public Thread newThread( Runnable r )
            {
                return new Thread( r, ""EslBackgroundJobNotifier-"" + threadNumber.getAndIncrement() );
            }
        });
    
    private AtomicBoolean authenticatorResponded = new AtomicBoolean( false );
    private boolean authenticated;
    private CommandResponse authenticationResponse;
    private Channel channel;
    
    public boolean canSend() {
        return channel != null && channel.isConnected() && authenticated; 
    }
    
    public void addEventListener( IEslEventListener listener ) {
        if ( listener != null ) {
            eventListeners.add( listener );
        }
    }

    /**
     * Attempt to establish an authenticated connection to the nominated FreeSWITCH ESL server socket.
     * This call will block, waiting for an authentication handshake to occur, or timeout after the
     * supplied number of seconds.  
     *  
     * @param host can be either ip address or hostname
     * @param port tcp port that server socket is listening on (set in event_socket_conf.xml)
     * @param password server event socket is expecting (set in event_socket_conf.xml) 
     * @param timeoutSeconds number of seconds to wait for the server socket before aborting
     */
    public void connect( String host, int port, String password, int timeoutSeconds ) throws InboundConnectionFailure {
        // If already connected, disconnect first
        if ( canSend() ) {
            close();
        }
        
        // Configure this client
        ClientBootstrap bootstrap = new ClientBootstrap(
            new NioClientSocketChannelFactory( 
                Executors.newCachedThreadPool(), 
                Executors.newCachedThreadPool() ) ); 
        
        // Add ESL handler and factory
        InboundClientHandler handler = new InboundClientHandler( password, protocolListener );
        bootstrap.setPipelineFactory( new InboundPipelineFactory( handler ) );
        
        // Attempt connection
        ChannelFuture future = bootstrap.connect( new InetSocketAddress( host, port ) );
        
        // Wait till attempt succeeds, fails or timeouts
        if ( ! future.awaitUninterruptibly( timeoutSeconds, TimeUnit.SECONDS ) ) {
            throw new InboundConnectionFailure( ""Timeout connecting to "" + host + "":"" + port );
        }
        
        // Did not timeout 
        channel = future.getChannel();
        
        // But may have failed anyway
        if ( !future.isSuccess() ) {
            log.warn( ""Failed to connect to [{}:{}]"", host, port );
            log.warn( ""  * reason: {}"", future.getCause() );
            
            channel = null;
            bootstrap.releaseExternalResources();
            
            throw new InboundConnectionFailure( ""Could not connect to "" + host + "":"" + port, future.getCause() );
        }
        
        //  Wait for the authentication handshake to call back
        while ( ! authenticatorResponded.get() ) {
            try {
                Thread.sleep( 250 );
            } 
            catch ( InterruptedException e ) {
                // ignore
            }
        }
        
        if ( ! authenticated ) {
            throw new InboundConnectionFailure( ""Authentication failed: "" + authenticationResponse.getReplyText() );
        }
    }
    
    /**
     * Sends a FreeSWITCH API command to the server and blocks, waiting for an immediate response from the 
     * server.
     * <p/>
     * The outcome of the command from the server is retured in an {@link EslMessage} object.
     * 
     * @param command API command to send
     * @param arg command arguments
     * @return an {@link EslMessage} containing command results
     */
    public EslMessage sendSyncApiCommand( String command, String arg ) {
        checkConnected();
        
        InboundClientHandler handler = (InboundClientHandler)channel.getPipeline().getLast();
        StringBuilder sb = new StringBuilder();
        
        if ( command != null && !command.isEmpty() ) {
            sb.append( ""api "" );
            sb.append( command );
        }
        
        if ( arg != null && !arg.isEmpty() ) {
            sb.append( ' ' );
            sb.append( arg );
        }

        return handler.sendSyncSingleLineCommand( channel, sb.toString() );
    }
    
    /**
     * Submit a FreeSWITCH API command to the server to be executed in background mode. A synchronous 
     * response from the server provides a UUID to identify the job execution results. When the server
     * has completed the job execution it fires a BACKGROUND_JOB Event with the execution results.<p/>
     * Note that this Client must be subscribed in the normal way to BACKGOUND_JOB Events, in order to 
     * receive this event.
     *     
     * @param command API command to send
     * @param arg command arguments
     * @return String Job-UUID that the server will tag result event with.
     */
    public String sendAsyncApiCommand( String command, String arg ) {
        checkConnected();
        
        InboundClientHandler handler = (InboundClientHandler)channel.getPipeline().getLast();
        StringBuilder sb = new StringBuilder();
        
        if ( command != null && !command.isEmpty() ) {
            sb.append( ""bgapi "" );
            sb.append( command );
        }
        
        if ( arg != null && !arg.isEmpty() ) {
            sb.append( ' ' );
            sb.append( arg );
        }
        
        return handler.sendAsyncCommand( channel, sb.toString() );
    }
    
    /**
     * Set the current event subscription for this connection to the server.  Examples of the events 
     * argument are:
     * <pre>
     *   ALL
     *   CHANNEL_CREATE CHANNEL_DESTROY HEARTBEAT
     *   CUSTOM conference::maintenance
     *   CHANNEL_CREATE CHANNEL_DESTROY CUSTOM conference::maintenance sofia::register sofia::expire
     * </pre> 
     * Subsequent calls to this method replaces any previous subscriptions that were set.
     * </p>
     * Note: current implementation can only process 'plain' events.
     * 
     * @param format can be { plain | xml }
     * @param events { all | space separated list of events } 
     * @return a {@link CommandResponse} with the server's response.
     */
    public CommandResponse setEventSubscriptions( String format, String events )
    {
        // temporary hack
        if ( ! format.equals( ""plain"" ) ) {
            throw new IllegalStateException( ""Only 'plain' event format is supported at present"" );
        }
        
        checkConnected();
        InboundClientHandler handler = (InboundClientHandler)channel.getPipeline().getLast();
        StringBuilder sb = new StringBuilder();
        
        if ( format != null && !format.isEmpty() ) {
            sb.append( ""event "" );
            sb.append( format );
        }
        
        if ( events != null && !events.isEmpty() ) {
            sb.append( ' ' );
            sb.append( events );
        }
        
        EslMessage response = handler.sendSyncSingleLineCommand( channel, sb.toString() );

        return new CommandResponse( sb.toString(), response );
    }
    
    /**
     * Cancel any existing event subscription.
     * 
     * @return a {@link CommandResponse} with the server's response.
     */
    public CommandResponse cancelEventSubscriptions()
    {
        checkConnected();
        
        InboundClientHandler handler = (InboundClientHandler)channel.getPipeline().getLast();
        EslMessage response = handler.sendSyncSingleLineCommand( channel, ""noevents"" );

        return new CommandResponse( ""noevents"", response );
    }

    /**
     * Add an event filter to the current set of event filters on this connection. Any of the event headers
     * can be used as a filter.
     * </p>
     * Note that event filters follow 'filter-in' semantics. That is, when a filter is applied
     * only the filtered values will be received. Multiple filters can be added to the current
     * connection.
     * </p>
     * Example filters:
     * <pre>
     *    eventHeader        valueToFilter
     *    ----------------------------------
     *    Event-Name         CHANNEL_EXECUTE
     *    Channel-State      CS_NEW
     * </pre>
     * 
     * @param eventHeader to filter on
     * @param valueToFilter the value to match
     * @return a {@link CommandResponse} with the server's response.
     */
    public CommandResponse addEventFilter( String eventHeader, String valueToFilter )
    {
        checkConnected();
        
        InboundClientHandler handler = (InboundClientHandler)channel.getPipeline().getLast();
        StringBuilder sb = new StringBuilder();
        
        if ( eventHeader != null && !eventHeader.isEmpty() ) {
            sb.append( ""filter "" );
            sb.append( eventHeader );
        }
        
        if ( valueToFilter != null && !valueToFilter.isEmpty() )
        {
            sb.append( ' ' );
            sb.append( valueToFilter );
        }
        
        EslMessage response = handler.sendSyncSingleLineCommand( channel, sb.toString() );
        
        return new CommandResponse( sb.toString(), response );
    }
    
    /**
     * Delete an event filter from the current set of event filters on this connection.  See  
     * {@link Client.addEventFilter}   
     * 
     * @param eventHeader   to remove
     * @param valueToFilter to remove
     * @return a {@link CommandResponse} with the server's response.
     */
    public CommandResponse deleteEventFilter( String eventHeader, String valueToFilter )
    {
        checkConnected();
        
        InboundClientHandler handler = (InboundClientHandler)channel.getPipeline().getLast();
        StringBuilder sb = new StringBuilder();
        
        if ( eventHeader != null && !eventHeader.isEmpty() ) {
            sb.append( ""filter delete "" );
            sb.append( eventHeader );
        }
        
        if ( valueToFilter != null && !valueToFilter.isEmpty() ) {
            sb.append( ' ' );
            sb.append( valueToFilter );
        }
        EslMessage response = handler.sendSyncSingleLineCommand( channel, sb.toString() );

        return new CommandResponse( sb.toString(), response );
    }

    /**
     * Send a {@link SendMsg} command to FreeSWITCH.  This client requires that the {@link SendMsg}
     * has a call UUID parameter.
     *  
     * @param sendMsg a {@link SendMsg} with call UUID
     * @return a {@link CommandResponse} with the server's response.
     */
    public CommandResponse sendMessage( SendMsg sendMsg )
    {
        checkConnected();
        
        InboundClientHandler handler = (InboundClientHandler)channel.getPipeline().getLast();
        EslMessage response = handler.sendSyncMultiLineCommand( channel, sendMsg.getMsgLines() );
        
        return new CommandResponse( sendMsg.toString(), response );
    }
    
    /**
     * Enable log output.
     * 
     * @param level using the same values as in console.conf
     * @return a {@link CommandResponse} with the server's response.
     */
    public CommandResponse setLoggingLevel( String level )
    {
        checkConnected();
        
        InboundClientHandler handler = (InboundClientHandler)channel.getPipeline().getLast();
        StringBuilder sb = new StringBuilder();
        
        if ( level != null && !level.isEmpty() )
        {
            sb.append( ""log "" );
            sb.append( level );
        }
        EslMessage response = handler.sendSyncSingleLineCommand( channel, sb.toString() );

        return new CommandResponse( sb.toString(), response );
    }

    /**
     * Disable any logging previously enabled with setLogLevel().
     * 
     * @return a {@link CommandResponse} with the server's response.
     */
    public CommandResponse cancelLogging()
    {
        checkConnected();
        
        InboundClientHandler handler = (InboundClientHandler)channel.getPipeline().getLast();
        EslMessage response = handler.sendSyncSingleLineCommand( channel, ""nolog"" );

        return new CommandResponse( ""nolog"", response );
    }

    /**
     * Close the socket connection
     * 
     * @return a {@link CommandResponse} with the server's response.
     */
    public CommandResponse close()
    {
        checkConnected();
        
        InboundClientHandler handler = (InboundClientHandler)channel.getPipeline().getLast();
        EslMessage response = handler.sendSyncSingleLineCommand( channel, ""exit"" );

        return new CommandResponse( ""exit"", response );
    }
    
    /*
     *  Internal observer of the ESL protocol 
     */
    private final IEslProtocolListener protocolListener = new IEslProtocolListener()
    {
        public void authResponseReceived( CommandResponse response )
        {
            authenticatorResponded.set( true );
            authenticated = response.isOk();
            authenticationResponse = response;
            log.debug( ""Auth response success={}, message=[{}]"", authenticated, response.getReplyText() );
        }
        
        public void eventReceived( final EslEvent event )
        {
            log.debug( ""Event received [{}]"", event );

            /*
             *  Notify listeners in a different thread in order to:
             *    - not to block the IO threads with potentially long-running listeners
             *    - generally be defensive running other people's code
             *  Use a different worker thread pool for async job results than for event driven
             *  events to keep the latency as low as possible.
             */
            if ( event.getEventName().equals( ""BACKGROUND_JOB"" ) ) {
                for ( final IEslEventListener listener : eventListeners ) {
                    backgroundJobListenerExecutor.execute( new Runnable() {
                        public void run() {
                            try {
                                listener.backgroundJobResultReceived( event );
                            } catch ( Throwable t ) {
                                log.error( ""Error caught notifying listener of job result ["" + event + ']', t );
                            }
                        }
                    } );
                }
            } else {
                for ( final IEslEventListener listener : eventListeners ) {
                    eventListenerExecutor.execute( new Runnable() {
                        public void run() {
                            try {
                                /**
                                 * Custom extra parsing to get conference Events for BigBlueButton / FreeSwitch intergration
                                 */
                                //FIXME: make the conference headers constants
                                if (event.getEventSubclass().equals(""conference::maintenance"")) {
                                    Map<String, String> eventHeaders = event.getEventHeaders();
                                    String eventFunc = eventHeaders.get(""Event-Calling-Function"");
                                    String uniqueId = eventHeaders.get(""Caller-Unique-ID"");
                                    String confName = eventHeaders.get(""Conference-Name"");
                                    String eventAction = eventHeaders.get(""Action"");
                                    int confSize = Integer.parseInt(eventHeaders.get(""Conference-Size""));
/**
                                    StringBuilder sb = new StringBuilder("""");
                                    sb.append(""\n"");
                                    for (Iterator it = eventHeaders.entrySet().iterator(); it.hasNext(); ) {
                                        Map.Entry entry = (Map.Entry)it.next();
                                        sb.append(entry.getKey());
                                        sb.append("" => '"");
                                        sb.append(entry.getValue());
                                        sb.append(""'\n"");
                                    }

                                    System.out.println(""##### Received Event for "" + confName);
                                    System.out.println(""##### "" + sb.toString());
**/
                                    if (eventFunc == null || eventAction == null) {
                                        //Noop...
                                    } else if (eventAction.equals(""conference-create"")) {
                                        listener.conferenceEventAction(uniqueId, confName, confSize, eventAction, event);
                                        return;
                                    } else if (eventAction.equals(""conference-destroy"")) {
                                        listener.conferenceEventAction(uniqueId, confName, confSize, eventAction, event);
                                        return;
                                    } else if (eventFunc.equals(""conference_thread_run"")) {
                                        System.out.println(""##### Client conference_thread_run"");
                                        listener.conferenceEventThreadRun(uniqueId, confName, confSize, event);
                                        return;
                                    } else if (eventFunc.equals(""member_add_file_data"")) {
                                        System.out.println(""##### Client member_add_file_data"");
                                        listener.conferenceEventPlayFile(uniqueId, confName, confSize, event);
                                        return;
                                    } else if (eventFunc.equals(""conf_api_sub_transfer"") || eventFunc.equals(""conference_api_sub_transfer"")) {
                                        //Member transfered to another conf...
                                        listener.conferenceEventTransfer(uniqueId, confName, confSize, event);
                                        return;
                                    } else if (eventFunc.equals(""conference_add_member"") || eventFunc.equals(""conference_member_add"")) {
                                        System.out.println(""##### Client conference_add_member"");
                                        listener.conferenceEventJoin(uniqueId, confName, confSize, event);
                                        return;
                                    } else if (eventFunc.equals(""conference_del_member"") || eventFunc.equals(""conference_member_del"")) {
                                        System.out.println(""##### Client conference_del_member"");
                                        listener.conferenceEventLeave(uniqueId, confName, confSize, event);
                                        return;
                                    } else if (eventFunc.equals(""conf_api_sub_mute"") || eventFunc.equals(""conference_api_sub_mute"")) {
                                        listener.conferenceEventMute(uniqueId, confName, confSize, event);
                                        return;
                                    } else if (eventFunc.equals(""conf_api_sub_unmute"") || eventFunc.equals(""conference_api_sub_unmute"")) {
                                        listener.conferenceEventUnMute(uniqueId, confName, confSize, event);
                                        return;
                                    } else if (eventFunc.equals(""conference_record_thread_run"")) {
                                        System.out.println(""##### Client conference_record_thread_run"");
                                        listener.conferenceEventRecord(uniqueId, confName, confSize, event);
                                        return;
                                    } else if (eventFunc.equals(""conference_loop_input"")) {
                                        listener.conferenceEventAction(uniqueId, confName, confSize, eventAction, event);
                                        return;
                                    } else if (eventFunc.equals(""conference_member_set_floor_holder"")) {
                                        listener.conferenceEventAction(uniqueId, confName, confSize, eventAction, event);
                                        return;
                                    } else if (eventFunc.equals(""conference_video_set_floor_holder"")) {
                                        listener.conferenceEventAction(uniqueId, confName, confSize, eventAction, event);
                                        return;
                                    } else if (eventFunc.equals(""stop_talking_handler"")) {
                                        listener.conferenceEventAction(uniqueId, confName, confSize, eventAction, event);
                                        return;
                                    }  else {
                                        /**
                                      StringBuilder sb = new StringBuilder("""");
                                        sb.append(""\n"");
                                        for (Iterator it = eventHeaders.entrySet().iterator(); it.hasNext(); ) {
                                            Map.Entry entry = (Map.Entry)it.next();
                                            sb.append(entry.getKey());
                                            sb.append("" => '"");
                                            sb.append(entry.getValue());
                                            sb.append(""'\n"");
                                        }
                                        log.info (""Unknown Conference Event [{}] [{}]"", confName, sb.toString());
                                        System.out.println(""##### unhandled Event for "" + confName);
                                        System.out.println(""##### "" + sb.toString());
                                         **/
                                    }
                                } else {
                                    listener.eventReceived( event );
                                }

                            } catch ( Throwable t ) {
                                log.error( ""Error caught notifying listener of event ["" + event + ']', t );
                            }
                        }
                    } );
                }
            }
        }

        public void disconnected() {
            log.info( ""Disconnected .."" );
        }

        public void exceptionCaught(final ExceptionEvent e) {
            log.debug( ""exceptionCaught [{}]"", e );

            for ( final IEslEventListener listener : eventListeners ) {
                    eventListenerExecutor.execute( new Runnable() {
                        public void run() {
                            try {
                                listener.exceptionCaught( e );
                            } catch ( Throwable t ) {
                                log.error( ""Error caught notifying listener of exception ["" + e + ']', t );
                            }
                        }
                    } );
                }

        }
    };
    
    private void checkConnected() {
        if ( ! canSend() ) {
            throw new IllegalStateException( ""Not connected to FreeSWITCH Event Socket"" );
        }
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/inbound/InboundPipelineFactory.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.inbound;

import org.freeswitch.esl.client.internal.debug.ExecutionHandler;
import org.freeswitch.esl.client.transport.message.EslFrameDecoder;
import org.jboss.netty.channel.ChannelHandler;
import org.jboss.netty.channel.ChannelPipeline;
import org.jboss.netty.channel.ChannelPipelineFactory;
import org.jboss.netty.channel.Channels;
import org.jboss.netty.handler.codec.string.StringEncoder;
import org.jboss.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor;

/**
 * End users of the {@link Client} should not need to use this class. 
 * <p>
 * Convenience factory to assemble a Netty processing pipeline for inbound clients.
 * 
 * @author  david varnes
 */
public class InboundPipelineFactory implements ChannelPipelineFactory
{
    private final ChannelHandler handler;
    
    public InboundPipelineFactory( ChannelHandler handler )
    {
        this.handler = handler;
    }
    
    public ChannelPipeline getPipeline() throws Exception
    {
        ChannelPipeline pipeline = Channels.pipeline(); 
        pipeline.addLast( ""encoder"", new StringEncoder() );
        pipeline.addLast( ""decoder"", new EslFrameDecoder( 8192 ) );
        // Add an executor to ensure separate thread for each upstream message from here
        pipeline.addLast( ""executor"", new ExecutionHandler( 
            new OrderedMemoryAwareThreadPoolExecutor( 16, 1048576, 1048576 ) ) );

        // now the inbound client logic
        pipeline.addLast( ""clientHandler"", handler );
        
        return pipeline;
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/inbound/InboundClientHandler.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.inbound;

import org.freeswitch.esl.client.internal.AbstractEslClientHandler;
import org.freeswitch.esl.client.internal.IEslProtocolListener;
import org.freeswitch.esl.client.transport.CommandResponse;
import org.freeswitch.esl.client.transport.event.EslEvent;
import org.freeswitch.esl.client.transport.message.EslHeaders.Value;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.handler.execution.ExecutionHandler;
import org.jboss.netty.channel.ExceptionEvent;

/**
 * End users of the inbound {@link Client} should not need to use this class. 
 * <p>
 * Specialised {@link AbstractEslClientHandler} that implements the connection logic for an 
 * 'Inbound' FreeSWITCH Event Socket connection.  The responsibilities for this class are:
 * <ul><li>
 * To handle the auth request that the FreeSWITCH server will send immediately following a new 
 * connection when mode is Inbound.
 * <li>
 * To signal the observing {@link IEslProtocolListener} (expected to be the Inbound client 
 * implementation) when ESL events are received.
 * </ul>
 * Note: implementation requirement is that an {@link ExecutionHandler} is placed in the processing 
 * pipeline prior to this handler. This will ensure that each incoming message is processed in its
 * own thread (although still guaranteed to be processed in the order of receipt).
 * 
 * @author  david varnes
 */
public class InboundClientHandler extends AbstractEslClientHandler
{
    private final String password;
    private final IEslProtocolListener listener;
    
    public InboundClientHandler( String password, IEslProtocolListener listener )
    {
        this.password = password;
        this.listener = listener;
    }
    
    protected void handleEslEvent( ChannelHandlerContext ctx, EslEvent event )
    {
        log.debug( ""Received event: [{}]"", event );
        listener.eventReceived( event );
    }

    protected void handleAuthRequest( ChannelHandlerContext ctx )
    {
        log.debug( ""Auth requested, sending [auth {}]"", ""*****"" );
        EslMessage response = sendSyncSingleLineCommand( ctx.getChannel(), ""auth "" + password );
        log.debug( ""Auth response [{}]"", response );
        if ( response.getContentType().equals( Value.COMMAND_REPLY ) )
        {
            CommandResponse commandResponse = new CommandResponse( ""auth "" + password, response );
            listener.authResponseReceived( commandResponse );
        }
        else
        {
            log.error( ""Bad auth response message [{}]"", response );
            throw new IllegalStateException( ""Incorrect auth response"" ); 
        }
    }

    @Override
    protected void handleDisconnectionNotice()
    {
        log.debug( ""Received disconnection notice"" );
        listener.disconnected();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception
    {
        if (""WAIT_FOR_ESL_RESPONSE_TIMEOUT"".equals(e.getCause().getMessage())) {
            throw new RuntimeException(""WAIT_FOR_ESL_RESPONSE_TIMEOUT"");
        } else {
            log.warn(e.getCause().getMessage());
        }

    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/outbound/AbstractOutboundPipelineFactory.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.outbound;

import org.freeswitch.esl.client.internal.debug.ExecutionHandler;
import org.freeswitch.esl.client.transport.message.EslFrameDecoder;
import org.jboss.netty.channel.ChannelPipeline;
import org.jboss.netty.channel.ChannelPipelineFactory;
import org.jboss.netty.channel.Channels;
import org.jboss.netty.handler.codec.string.StringEncoder;
import org.jboss.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor;

/**
 * An abstract factory to assemble a Netty processing pipeline for outbound clients.
 * 
 * @author  david varnes
 */
public abstract class AbstractOutboundPipelineFactory implements ChannelPipelineFactory
{
    public ChannelPipeline getPipeline() throws Exception
    {
        ChannelPipeline pipeline = Channels.pipeline(); 
        // Add the text line codec combination first
        pipeline.addLast( ""encoder"", new StringEncoder() );
        // Note that outbound mode requires the decoder to treat many 'headers' as body lines
        pipeline.addLast( ""decoder"", new EslFrameDecoder( 8092, true ) );
        // Add an executor to ensure separate thread for each upstream message from here
        pipeline.addLast( ""executor"", new ExecutionHandler( 
            new OrderedMemoryAwareThreadPoolExecutor( 16, 1048576, 1048576 ) ) );

        // now the outbound client logic
        pipeline.addLast( ""clientHandler"", makeHandler() );
        
        return pipeline;
    }

    protected abstract AbstractOutboundClientHandler makeHandler();
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/outbound/AbstractOutboundClientHandler.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.outbound;

import org.freeswitch.esl.client.internal.AbstractEslClientHandler;
import org.freeswitch.esl.client.transport.event.EslEvent;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.ChannelStateEvent;
import org.jboss.netty.handler.execution.ExecutionHandler;

/**
 * Specialised {@link AbstractEslClientHandler} that implements the base connecction logic for an 
 * 'Outbound' FreeSWITCH Event Socket connection.  The responsibilities for this class are:
 * <ul><li>
 * To send a 'connect' command when the FreeSWITCH server first establishes a new connection with
 * the socket client in Outbound mode.  This will result in an incoming {@link EslMessage} that is
 * transformed into an {@link EslEvent} that sub classes can handle.
 * </ul>
 * Note: implementation requirement is that an {@link ExecutionHandler} is placed in the processing 
 * pipeline prior to this handler. This will ensure that each incoming message is processed in its
 * own thread (although still guaranteed to be processed in the order of receipt).
 * 
 * @author  david varnes
 */
public abstract class AbstractOutboundClientHandler extends AbstractEslClientHandler
{

    @Override
    public void channelConnected( ChannelHandlerContext ctx, ChannelStateEvent e ) throws Exception
    {
        // Have received a connection from FreeSWITCH server, send connect response
        log.debug( ""Received new connection from server, sending connect message"" );
        
        EslMessage response = sendSyncSingleLineCommand( ctx.getChannel(), ""connect"" );
        // The message decoder for outbound, treats most of this incoming message as an 'event' in 
        // message body, so it parse now
        EslEvent channelDataEvent = new EslEvent( response, true );
        // Let implementing sub classes choose what to do next
        handleConnectResponse( ctx, channelDataEvent );
    }

    protected abstract void handleConnectResponse( ChannelHandlerContext ctx, EslEvent event );

    @Override
    protected void handleAuthRequest( ChannelHandlerContext ctx )
    {
        // This should not happen in outbound mode
        log.warn( ""Auth request received in outbound mode, ignoring"" ); 
    }

    @Override
    protected void handleDisconnectionNotice()
    {
        log.debug( ""Received disconnection notice"" );
    }    
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/outbound/example/SimpleHangupPipelineFactory.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.outbound.example;

import org.freeswitch.esl.client.outbound.AbstractOutboundClientHandler;
import org.freeswitch.esl.client.outbound.AbstractOutboundPipelineFactory;

/**
 * Factory for the simple hangup handler
 * 
 * @author  david varnes
 */
public class SimpleHangupPipelineFactory extends AbstractOutboundPipelineFactory
{

    @Override
    protected AbstractOutboundClientHandler makeHandler()
    {
        return new SimpleHangupOutboundHandler();
    }

}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/outbound/example/SimpleHangupOutboundHandler.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.outbound.example;

import org.freeswitch.esl.client.outbound.AbstractOutboundClientHandler;
import org.freeswitch.esl.client.transport.SendMsg;
import org.freeswitch.esl.client.transport.event.EslEvent;
import org.freeswitch.esl.client.transport.message.EslMessage;
import org.freeswitch.esl.client.transport.message.EslHeaders.Name;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelHandlerContext;

/**
 * Simple example of a handler for outbound connection from FreeSWITCH server.
 * This class will log some of the FreeSWTICH call channel variables and 
 * then hangup the call.  
 * 
 * @author  david varnes
 */
public class SimpleHangupOutboundHandler extends AbstractOutboundClientHandler
{
    
    @Override
    protected void handleConnectResponse( ChannelHandlerContext ctx, EslEvent event )
    {
        log.info( ""Received connect response [{}]"", event );
        if ( event.getEventName().equalsIgnoreCase( ""CHANNEL_DATA"" ) )
        {
            // this is the response to the initial connect 
            log.info( ""=======================  incoming channel data  ============================="" );
            log.info( ""Event-Date-Local: [{}]"", event.getEventDateLocal() );
            log.info( ""Unique-ID: [{}]"", event.getEventHeaders().get( ""Unique-ID"" ) );
            log.info( ""Channel-ANI: [{}]"", event.getEventHeaders().get( ""Channel-ANI"" ) );
            log.info( ""Answer-State: [{}]"", event.getEventHeaders().get( ""Answer-State"" ) );
            log.info( ""Caller-Destination-Number: [{}]"", event.getEventHeaders().get( ""Caller-Destination-Number"" ) );
            log.info( ""=======================  = = = = = = = = = = =  ============================="" );
            
            // now hangup the call
            hangupCall( ctx.getChannel() );
        }
        else
        {
            throw new IllegalStateException( ""Unexpected event after connect: ["" + event.getEventName() + ']' );
        }
    }

    @Override
    protected void handleEslEvent( ChannelHandlerContext ctx, EslEvent event )
    {
        log.info( ""Received event [{}]"", event );
    }
    
    private void hangupCall( Channel channel )
    {
        SendMsg hangupMsg = new SendMsg();
        hangupMsg.addCallCommand( ""execute"" );
        hangupMsg.addExecuteAppName( ""hangup"" );
        
        EslMessage response = sendSyncMultiLineCommand( channel, hangupMsg.getMsgLines() );
        
        if ( response.getHeaderValue( Name.REPLY_TEXT ).startsWith( ""+OK"" ) )
        {
            log.info( ""Call hangup successful"" );
        }
        else
        {
            log.error( ""Call hangup failed: [{}}"", response.getHeaderValue( Name.REPLY_TEXT ) );
        }
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/outbound/SocketClient.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client.outbound;

import java.net.InetSocketAddress;
import java.util.concurrent.Executors;

import org.jboss.netty.bootstrap.ServerBootstrap;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelFactory;
import org.jboss.netty.channel.group.ChannelGroup;
import org.jboss.netty.channel.group.ChannelGroupFuture;
import org.jboss.netty.channel.group.DefaultChannelGroup;
import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Entry point to run a socket client that a running FreeSWITCH Event Socket Library module can
 * make outbound connections to.
 * <p>
 * This class provides for what the FreeSWITCH documentation refers to as 'Outbound' connections
 * from the Event Socket module. That is, with reference to the module running on the FreeSWITCH
 * server, this client accepts an outbound connection from the server module.
 * <p>
 * See <a href=""http://wiki.freeswitch.org/wiki/Mod_event_socket"">http://wiki.freeswitch.org/wiki/Mod_event_socket</a>
 * 
 * @author  david varnes
 */
public class SocketClient
{
    private final Logger log = LoggerFactory.getLogger( this.getClass() );

    private final ChannelGroup allChannels = new DefaultChannelGroup( ""esl-socket-client"" );
    
    private final int port;
    private final ChannelFactory channelFactory;
    private final AbstractOutboundPipelineFactory pipelineFactory;
    
    public SocketClient( int port, AbstractOutboundPipelineFactory pipelineFactory )
    {
        this.port = port;
        this.pipelineFactory = pipelineFactory;
        this.channelFactory =  new NioServerSocketChannelFactory( 
            Executors.newCachedThreadPool(), 
            Executors.newCachedThreadPool() ); 
    }
    
    public void start()
    {
        ServerBootstrap bootstrap = new ServerBootstrap( channelFactory );
        
        bootstrap.setPipelineFactory( pipelineFactory );
        bootstrap.setOption( ""child.tcpNoDelay"", true );
        bootstrap.setOption( ""child.keepAlive"", true );
        
        Channel serverChannel = bootstrap.bind( new InetSocketAddress( port ) );
        allChannels.add( serverChannel );
        log.info( ""SocketClient waiting for connections on port [{}] ..."", port );
    }
    
    public void stop()
    {
        ChannelGroupFuture future = allChannels.close();
        future.awaitUninterruptibly();
        channelFactory.releaseExternalResources();
        log.info( ""SocketClient stopped"" );
    }
}"
bbb-fsesl-client/src/main/java/org/freeswitch/esl/client/IEslEventListener.java,"/*
 * Copyright 2010 david varnes.
 *
 * Licensed under the Apache License, version 2.0 (the ""License""); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.freeswitch.esl.client;

import org.freeswitch.esl.client.transport.event.EslEvent;
import org.jboss.netty.channel.ExceptionEvent;

/**
 * Interface for observers wanting to be notified of incoming FreeSWITCH Event Socket events.
 * <p>
 * Incoming events arrive asynchronously and are processed into two queues, one for server 
 * initiated events, and one for the results of client requested background jobs.
 * <p>  
 * Each queue is serviced by a different thread pool (to ensure lowest latency for event-driven events) 
 * and each queue is guaranteed to be processed (and listeners notified) in the order in which the
 * events are received off the wire.
 * <p>
 * This design ensures that incoming event processing is not blocked by any long-running listener process.
 * However multiple listeners will be notified sequentially, and so one slow listener can cause latency
 * to other listeners.
 *   
 * @author  david varnes
 */
public interface IEslEventListener
{
    /**
     * Signal of a server initiated event.
     * 
     * @param event as an {@link EslEvent} 
     */
    void eventReceived( EslEvent event );

    /**
     *
     * @param uniqueId
     * @param confName
     * @param confSize
     * @param event as an {@link EslEvent}
     */
    void conferenceEventJoin(String uniqueId, String confName, int confSize, EslEvent event);

    /**
     *
     * @param uniqueId
     * @param confName
     * @param confSize
     * @param event as an {@link EslEvent}
     */
    void conferenceEventLeave(String uniqueId, String confName, int confSize, EslEvent event);

    /**
     *
     * @param uniqueId
     * @param confName
     * @param confSize
     * @param event as an {@link EslEvent}
     */
    void conferenceEventMute(String uniqueId, String confName, int confSize, EslEvent event);

    /**
     *
     * @param uniqueId
     * @param confName
     * @param confSize
     * @param event as an {@link EslEvent}
     */
    void conferenceEventUnMute(String uniqueId, String confName, int confSize, EslEvent event);

    /**
     *
     * @param uniqueId
     * @param confName
     * @param confSize
     * @param action
     * @param event as an {@link EslEvent}
     */
    void conferenceEventAction(String uniqueId, String confName, int confSize, String action, EslEvent event);

    /**
     *
     * @param uniqueId
     * @param confName
     * @param confSize
     * @param event as an {@link EslEvent}
     */
    void conferenceEventTransfer(String uniqueId, String confName, int confSize, EslEvent event);

    /**
     *
     * @param uniqueId
     * @param confName
     * @param confSize
     * @param event as an {@link EslEvent}
     */
    void conferenceEventThreadRun(String uniqueId, String confName, int confSize, EslEvent event);

    /**
    *
    * @param uniqueId
    * @param confName
    * @param confSize
    * @param event as an {@link EslEvent}
    */
   void conferenceEventRecord(String uniqueId, String confName, int confSize, EslEvent event);
   
    /**
     *
     * @param uniqueId
     * @param confName
     * @param confSize
     * @param event as an {@link EslEvent}
     */
    void conferenceEventPlayFile(String uniqueId, String confName, int confSize, EslEvent event);

    /**
     * Signal of an event containing the result of a client requested background job.  The Job-UUID will
     * be available as an event header of that name.
     * 
     * @param event as an {@link EslEvent}
     */
    void backgroundJobResultReceived( EslEvent event );

    /**
     * 
     * @param e as an {@link ExceptionEvent}
     */
    void exceptionCaught(ExceptionEvent e);

}"
bbb-fsesl-client/deploy.sh,"sbt clean publish publishLocal"
bbb-etherpad.placeholder.sh,"git clone --branch 1.8.17 --depth 1 https://github.com/ether/etherpad-lite bbb-etherpad
"
record-and-playback/deploy.sh,"#!/bin/bash
#
# BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
#
# Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
#
# This program is free software; you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free Software
# Foundation; either version 3.0 of the License, or (at your option) any later
# version.
#
# BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
#

set -xe

sudo cp core/Gemfile /usr/local/bigbluebutton/core/Gemfile
sudo rm -rf /usr/local/bigbluebutton/core/lib
sudo cp -r core/lib /usr/local/bigbluebutton/core/
sudo rm -rf /usr/local/bigbluebutton/core/scripts
sudo cp -r core/scripts /usr/local/bigbluebutton/core/
sudo rm -rf /var/bigbluebutton/playback/presentation/0.81/
sudo rm -rf /var/bigbluebutton/playback/presentation/0.9.0/
sudo rm -rf /var/bigbluebutton/playback/presentation/2.0/

function deploy_format() {
	local formats=$1
	for format in $formats
	do
		playback_dir=""$format/playback/$format""
		scripts_dir=""$format/scripts""
		if [ -d $playback_dir ]; then sudo cp -r $playback_dir /var/bigbluebutton/playback/; fi
		if [ -d $scripts_dir ]; then sudo cp -r $scripts_dir/* /usr/local/bigbluebutton/core/scripts/; fi
		sudo mkdir -p /var/log/bigbluebutton/$format /var/bigbluebutton/published/$format /var/bigbluebutton/recording/publish/$format
	done
}

deploy_format ""presentation""

CAPTIONS_DIR=/var/bigbluebutton/captions/
if [ ! -d ""$CAPTIONS_DIR"" ]; then
  sudo mkdir -p $CAPTIONS_DIR
fi

EVENTS_DIR=/var/bigbluebutton/events/
if [ ! -d ""$EVENTS_DIR"" ]; then
  sudo mkdir -p $EVENTS_DIR
fi

PLAYBACK_DIR=/var/bigbluebutton/playback/
if [ ! -d ""$PLAYBACK_DIR"" ]; then
  sudo mkdir -p $PLAYBACK_DIR
fi

REC_RAW_DIR=/var/bigbluebutton/recording/raw/
if [ ! -d ""$REC_RAW_DIR"" ]; then
  sudo mkdir -p $REC_RAW_DIR
fi

REC_PROC_DIR=/var/bigbluebutton/recording/process/
if [ ! -d ""$REC_PROC_DIR"" ]; then
  sudo mkdir -p $REC_PROC_DIR
fi

REC_PUB_DIR=/var/bigbluebutton/recording/publish/
if [ ! -d ""$REC_PUB_DIR"" ]; then
  sudo mkdir -p $REC_PUB_DIR
fi

REC_STATUS_ENDED_DIR=/var/bigbluebutton/recording/status/ended/
if [ ! -d ""$REC_STATUS_ENDED_DIR"" ]; then
  sudo mkdir -p $REC_STATUS_ENDED_DIR
fi

REC_STATUS_RECORDED_DIR=/var/bigbluebutton/recording/status/recorded/
if [ ! -d ""$REC_STATUS_RECORDED_DIR"" ]; then
  sudo mkdir -p $REC_STATUS_RECORDED_DIR
fi

REC_STATUS_ARCHIVED_DIR=/var/bigbluebutton/recording/status/archived/
if [ ! -d ""$REC_STATUS_ARCHIVED_DIR"" ]; then
  sudo mkdir -p $REC_STATUS_ARCHIVED_DIR
fi

REC_STATUS_PROCESSED_DIR=/var/bigbluebutton/recording/status/processed/
if [ ! -d ""$REC_STATUS_PROCESSED_DIR"" ]; then
  sudo mkdir -p $REC_STATUS_PROCESSED_DIR
fi

REC_STATUS_SANITY_DIR=/var/bigbluebutton/recording/status/sanity/
if [ ! -d ""$REC_STATUS_SANITY_DIR"" ]; then
  sudo mkdir -p $REC_STATUS_SANITY_DIR
fi

sudo chown -R bigbluebutton:bigbluebutton /var/bigbluebutton/ /var/log/bigbluebutton/"
bigbluebutton-tests/puppeteer/import-tests-ci-resources.sh,"#!/bin/bash -e

testDir=$PWD/bigbluebutton-tests/puppeteer/;

echo ""Cloning bbb-ci-tests-resources repo..."";
git clone https://github.com/bigbluebutton/bbb-ci-test-resources.git;
echo ""bbb-ci-tests-resources has been imported."";

sleep 2;
echo ""Importing browser media files..."";
mv -f bbb-ci-test-resources/2.3/media $testDir;

if [[ $REGRESSION_TESTING = true ]]; then
    echo ""Importing Visual Regressions Testing Files..."";
    sleep 1;
    mv -f bbb-ci-test-resources/2.3/__image_snapshots__ $testDir;
    echo ""Visual Regressions Testing Files has been imported.""
fi
rm -rf bbb-ci-test-resources;"
bigbluebutton-tests/puppeteer/run.sh,"#!/bin/bash -e

usage() {
    set +x
    cat 1>&2 <<HERE
BBB Health Check

OPTIONS:
  -t <test name: whiteboard/webcam/virtualizedlist/user/trigger/sharednotes/screenshare/presentation/polling/notifications/customparameters/chat/breakout/audio/all>

  -u Print usage
HERE

}

err() {
	echo ""----"";
	echo ERROR: $@
	echo ""----"";
}

main() {
  export DEBIAN_FRONTEND=noninteractive

  while builtin getopts ""ut:"" opt ""${@}""; do

    case $opt in
      t)
	TEST=$OPTARG
	;;

      u)
        usage
        exit 0
        ;;

      :)
        err ""Missing option argument for -$OPTARG""
        exit 1
        ;;

      \?)
        err ""Invalid option: -$OPTARG"" >&2
        usage
        ;;
    esac
  done

  if [ -z ""$TEST"" ]; then
    err ""No test provided"";
    usage
    exit 1
  fi

echo ""Test is starting in 5 seconds..."" && sleep 5;echo $Test "" Test has started.""
echo $PWD
env $(cat .env | xargs)  jest $TEST.test.js --color --detectOpenHandles --forceExit
}


main ""$@"" || exit 1
"
bigbluebutton-tests/puppeteer/trigger/stop-network.sh,"#!/bin/bash -e

echo ""Cutting Network OFF"";
sudo nmcli networking off;"
bigbluebutton-tests/puppeteer/trigger/restart-network.sh,"#!/bin/bash -e

echo ""Restarting Network Service..."";
sudo nmcli networking on;"
bigbluebutton-tests/gns3/testserver.sh,"#!/bin/bash
#
# Install a Big Blue Button testing server on a VM

# if these are running, our apt operations may error out unable to get a lock
sudo systemctl stop unattended-upgrades.service
echo Waiting for apt-daily.service and apt-daily-upgrade.service
sudo systemd-run --property=""After=apt-daily.service apt-daily-upgrade.service"" --wait /bin/true

sudo apt update
sudo DEBIAN_FRONTEND=noninteractive apt -y upgrade

DOMAIN=$(hostname --domain)
FQDN=$(hostname --fqdn)

EMAIL=""root@$FQDN""

# /bbb-install.sh (the proper version; either 2.4, 2.5 or 2.6) is created by gns3-bbb.py
# INSTALL_OPTIONS and RELEASE get passed in the environment from gns3-bbb.py
#
# INSTALL_OPTIONS can include -w (firewall) -a (api demos; deprecated in 2.6) -r (repository)

sudo /bbb-install.sh -v $RELEASE -s $FQDN -e $EMAIL $INSTALL_OPTIONS

sudo bbb-conf --salt bbbci
echo ""NODE_EXTRA_CA_CERTS=/usr/local/share/ca-certificates/bbb-dev/bbb-dev-ca.crt"" | sudo tee -a /usr/share/meteor/bundle/bbb-html5-with-roles.conf

# bbb-conf --salt doesn't set the shared secret on the web demo
if [ -r /var/lib/tomcat9/webapps/demo/bbb_api_conf.jsp ]; then
   sudo sed -i '/salt/s/""[^""]*""/""bbbci""/'  /var/lib/tomcat9/webapps/demo/bbb_api_conf.jsp
fi

# if nginx didn't start because of a hash bucket size issue,
# certbot didn't work properly and we need to re-run the entire install script
if systemctl -q is-failed nginx; then
    sudo sed -i '/server_names_hash_bucket_size/s/^\(\s*\)# /\1/' /etc/nginx/nginx.conf
    sudo /bbb-install.sh -v $RELEASE -s $FQDN -e $EMAIL $INSTALL_OPTIONS
fi

# We can't restart if nginx isn't running.  It'll just complain ""nginx.service is not active, cannot reload""
# sudo bbb-conf --restart
sudo bbb-conf --stop
sudo bbb-conf --start"
bigbluebutton-tests/gns3/NPDC.placeholder.sh,"git clone --branch master --depth 1 https://github.com/BrentBaccala/NPDC NPDC"
bigbluebutton-tests/gns3/testcreds.sh,"#!/bin/bash

SECRET=$(grep sharedSecret /etc/bigbluebutton/bbb-apps-akka.conf | sed 's/^.*=//')
URL=$(grep bigbluebutton.web.serverURL= /etc/bigbluebutton/bbb-web.properties | sed 's/^.*=//')

echo BBB_URL=""$URL/bigbluebutton/api""
echo BBB_SECRET=$SECRET"
bigbluebutton-tests/gns3/testclient.sh,"#!/bin/bash
#
# Install Big Blue Button testing client
#
# This script runs once as 'ubuntu'

# Make some changes to .bashrc, but they won't affect the shell that is already
# running in the GUI, so the user will need to '. ~/.bashrc' there.
#
# We need NODE_EXTRA_CA_CERTS so that the playwright tests can make API calls
# without getting certificate errors.

cat >> ~/.bashrc <<EOF
export NODE_EXTRA_CA_CERTS=/usr/local/share/ca-certificates/bbb-dev/bbb-dev-ca.crt
export ACTIONS_RUNNER_DEBUG=true
export BBB_URL=https://bbb-ci.test/bigbluebutton/api
export BBB_SECRET=bbbci
EOF

# Which version of the repository should we use for the client test cases

BRANCH=v2.5.x-release

# if these are running, our apt operations may error out unable to get a lock
sudo systemctl stop unattended-upgrades.service
echo Waiting for apt-daily.service and apt-daily-upgrade.service
sudo systemd-run --property=""After=apt-daily.service apt-daily-upgrade.service"" --wait /bin/true

sudo apt update
sudo DEBIAN_FRONTEND=noninteractive apt -y upgrade

# git, since we're about to use it
# linux-image-extra-virtual to get snd-aloop module for dummy audio
# v4l2loopback-dkms to get video loopback for dummy webcam
# sudo apt -y install git-core ant ant-contrib openjdk-8-jdk-headless zip unzip linux-image-extra-virtual
sudo apt -y install git-core linux-image-extra-virtual v4l2loopback-dkms

# We don't need the whole git history, like this command would do:
#    git clone https://github.com/bigbluebutton/bigbluebutton.git
# so instead we do this to pick up a single revision:
cd
mkdir bigbluebutton-$BRANCH
cd bigbluebutton-$BRANCH
git init
git remote add origin https://github.com/bigbluebutton/bigbluebutton.git
git fetch --depth 1 origin $BRANCH
git checkout FETCH_HEAD

# Focal distributes nodejs 10, which is too old for our playwright test suite.  Use nodejs 16.
curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -
sudo apt install -y nodejs

cd ~/bigbluebutton-$BRANCH/bigbluebutton-tests/playwright
npm install
npx --yes playwright install

# patch playwright's firefox so that it uses the system's root certificate authority
find /home/ubuntu/.cache/ms-playwright -name libnssckbi.so -exec mv {} {}.distrib \; -exec ln -s /usr/lib/x86_64-linux-gnu/pkcs11/p11-kit-trust.so {} \;

# playwright webkit doesn't have a fake audio device, but Linux does
#   no point in enabling this since playwright can't grant permissions to use microphone on webkit (playwright issue #2973)
# sudo modprobe snd-aloop
# echo snd-aloop | sudo tee -a /etc/modules

# this is required to run webkit tests, but conflicts with BBB server dependencies,
# so can't be installed on the same machine as a BBB server
sudo npx playwright install-deps

# still need to either install an .env file or set environment variables in ~/.bashrc

# In addition to the system root CA store in /usr/local/share/ca-certificates (used by curl and others),
# we need to deal with two common browsers that don't use the system store.

# Get Firefox (already installed) to use system's root certificate authority
# Method suggested by https://askubuntu.com/a/1036637/71866
# Earlier this this script, we did something similar to modify playwright's version of firefox.
# This handles the standard system firefox.

sudo mv /usr/lib/firefox/libnssckbi.so /usr/lib/firefox/libnssckbi.so.distrib
sudo dpkg-divert --no-rename --add /usr/lib/firefox/libnssckbi.so
sudo ln -s /usr/lib/x86_64-linux-gnu/pkcs11/p11-kit-trust.so /usr/lib/firefox/libnssckbi.so

# Install chromium and the tools we need to install our certificate into Chromium's private store
sudo DEBIAN_FRONTEND=noninteractive apt -y install chromium-browser libnss3-tools jq

# chromium snap - we now need to install nssdb in ~/snap/chromium/2051/.pki instead of ~/.pki
# NSSDB=/home/ubuntu/.pki/nssdb
for CHROMIUM_SNAP in $(find /home/ubuntu/snap/chromium/ -mindepth 1 -maxdepth 1 -type d); do
    NSSDB=$CHROMIUM_SNAP/.pki/nssdb
    if [ ! -r $NSSDB ]; then
	mkdir --parents $NSSDB
	certutil -d sql:$NSSDB -N --empty-password
    fi
    certutil -d sql:$NSSDB -A -t 'C,,' -n bbb-dev-ca -i /usr/local/share/ca-certificates/bbb-dev/bbb-dev-ca.crt
done"
bbb-common-web/src/main/java/org/bigbluebutton/api/pub/IPublisherService.java,"package org.bigbluebutton.api.pub;

import java.util.Map;
import java.util.Set;

import org.bigbluebutton.web.services.turn.StunServer;
import org.bigbluebutton.web.services.turn.TurnEntry;

public interface IPublisherService {
    void destroyMeeting(String meetingID);
    void createMeeting(String meetingID, String externalMeetingID,
                       String parentMeetingID, String meetingName, Boolean recorded,
                       String voiceBridge, Integer duration, Boolean autoStartRecording,
                       Boolean allowStartStopRecording, Boolean webcamsOnlyForModerator,
                       Integer userCameraCap,
                       String moderatorPass, String viewerPass, Long createTime,
                       String createDate, Boolean isBreakout, Integer sequence,
                       Boolean freeJoin, Map<String, String> metadata, String guestPolicy);
    void endMeeting(String meetingId);
    void send(String channel, String message);
    void registerUser(String meetingID, String internalUserId, String fullname, String role, String externUserID,
                      String authToken, String avatarURL, Boolean guest, Boolean excludeFromDashboard, Boolean authed);
    void sendKeepAlive(String system, Long bbbWebTimestamp, Long akkaAppsTimestamp);
    void sendStunTurnInfo(String meetingId, String internalUserId, Set<StunServer> stuns, Set<TurnEntry> turns);
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/RecordingServiceHelper.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.api;

import java.io.File;

import org.bigbluebutton.api.domain.Recording;

public interface RecordingServiceHelper {
	public Recording getRecordingInfo(File dir);
	public void writeRecordingInfo(String path, Recording info);
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/ParamsProcessorUtil.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
*
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.api;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.ResponseHandler;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.util.EntityUtils;
import org.bigbluebutton.api.domain.BreakoutRoomsParams;
import org.bigbluebutton.api.domain.LockSettingsParams;
import org.bigbluebutton.api.domain.Meeting;
import org.bigbluebutton.api.domain.Group;
import org.bigbluebutton.api.service.ServiceUtils;
import org.bigbluebutton.api.util.ParamsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ParamsProcessorUtil {
    private static Logger log = LoggerFactory.getLogger(ParamsProcessorUtil.class);

    private static final String URLDECODER_SEPARATOR="","";
    private static final String FILTERDECODER_SEPARATOR_ELEMENTS="":"";
    private static final String FILTERDECODER_SEPARATOR_OPERATORS=""\\|"";

    private static final String SERVER_URL = ""%%SERVERURL%%"";
    private static final String DIAL_NUM = ""%%DIALNUM%%"";
    private static final String CONF_NUM = ""%%CONFNUM%%"";
    private static final String CONF_NAME = ""%%CONFNAME%%"";

    private String apiVersion;
    private boolean serviceEnabled = false;
    private String securitySalt;
    private String supportedChecksumAlgorithms;
    private String checksumHash;
    private int defaultMaxUsers = 20;
    private String defaultWelcomeMessage;
    private String defaultWelcomeMessageFooter;
    private String defaultDialAccessNumber;
    private String testVoiceBridge;
    private String testConferenceMock;
    private String defaultLogoutUrl;
    private String defaultServerUrl;
    private int defaultNumDigitsForTelVoice;
    private String defaultHTML5ClientUrl;
    private String defaultGuestWaitURL;
    private Boolean allowRequestsWithoutSession = false;
    private Integer defaultHttpSessionTimeout = 14400;
    private Boolean useDefaultAvatar = false;
    private String defaultAvatarURL;
    private String defaultGuestPolicy;
    private Boolean authenticatedGuest;
    private String defaultMeetingLayout;
    private int defaultMeetingDuration;
    private boolean disableRecordingDefault;
    private boolean autoStartRecording;
    private boolean allowStartStopRecording;
    private boolean learningDashboardEnabled = true;
    private int learningDashboardCleanupDelayInMinutes;
    private boolean webcamsOnlyForModerator;
    private Integer defaultMeetingCameraCap = 0;
    private Integer defaultUserCameraCap = 0;
    private Integer defaultMaxPinnedCameras = 3;
    private boolean defaultMuteOnStart = false;
    private boolean defaultAllowModsToUnmuteUsers = false;
    private boolean defaultAllowModsToEjectCameras = false;
    private String defaultDisabledFeatures;
    private boolean defaultNotifyRecordingIsOn = false;
    private boolean defaultKeepEvents = false;
    private Boolean useDefaultLogo;
    private String defaultLogoURL;
    private String defaultPresentationUploadExternalDescription = """";
    private String defaultPresentationUploadExternalUrl = """";

		private boolean defaultBreakoutRoomsEnabled = true;
		private boolean defaultBreakoutRoomsRecord;
        private boolean defaultBreakoutRoomsCaptureSlides = false;
        private boolean defaultBreakoutRoomsCaptureNotes = false;
        private String  defaultBreakoutRoomsCaptureSlidesFilename = CONF_NAME;
        private String  defaultBreakoutRoomsCaptureNotesFilename = CONF_NAME;
		private boolean defaultbreakoutRoomsPrivateChatEnabled;

		private boolean defaultLockSettingsDisableCam;
		private boolean defaultLockSettingsDisableMic;
		private boolean defaultLockSettingsDisablePrivateChat;
		private boolean defaultLockSettingsDisablePublicChat;
		private boolean defaultLockSettingsDisableNotes;
		private boolean defaultLockSettingsHideUserList;
		private boolean defaultLockSettingsLockOnJoin;
		private boolean defaultLockSettingsLockOnJoinConfigurable;
		private boolean defaultLockSettingsHideViewersCursor;

    private Long maxPresentationFileUpload = 30000000L; // 30MB

    private Integer clientLogoutTimerInMinutes = 0;
    private Integer defaultMeetingExpireIfNoUserJoinedInMinutes = 5;
    private Integer defaultMeetingExpireWhenLastUserLeftInMinutes = 1;
  	private Integer userInactivityInspectTimerInMinutes = 120;
  	private Integer userInactivityThresholdInMinutes = 30;
    private Integer userActivitySignResponseDelayInMinutes = 5;
    private Boolean defaultAllowDuplicateExtUserid = true;

    private Integer maxUserConcurrentAccesses = 0;
  	private Boolean defaultEndWhenNoModerator = false;
  	private Integer defaultEndWhenNoModeratorDelayInMinutes = 1;
  	private Integer defaultHtml5InstanceId = 1;

    private String bbbVersion = """";
    private Boolean allowRevealOfBBBVersion = false;

  	private String formatConfNum(String s) {
  		if (s.length() > 5) {
  			/* Reverse conference number.
  			* Put a whitespace every third char.
  			* Reverse it again to display it correctly.
  			* Trim leading whitespaces.
  			* */
  			String confNumReversed = new StringBuilder(s).reverse().toString();
  			String confNumSplit = confNumReversed.replaceAll(""(.{3})"", ""$1 "");
  			String confNumL = new StringBuilder(confNumSplit).reverse().toString().trim();
  			return confNumL;
  		}

  		return s;
  	}

    private String substituteKeywords(String message, String dialNumber, String telVoice, String meetingName) {
        String welcomeMessage = message;

        ArrayList<String> keywordList = new ArrayList<>();
        keywordList.add(DIAL_NUM);
        keywordList.add(CONF_NUM);
        keywordList.add(CONF_NAME);
        keywordList.add(SERVER_URL);

        for (String keyword : keywordList) {
            if (keyword.equals(DIAL_NUM)) {
                welcomeMessage = welcomeMessage.replaceAll(
                        Pattern.quote(DIAL_NUM),
                        Matcher.quoteReplacement(dialNumber));
            } else if (keyword.equals(CONF_NUM)) {
                welcomeMessage = welcomeMessage.replaceAll(
                        Pattern.quote(CONF_NUM),
                        Matcher.quoteReplacement(formatConfNum(telVoice)));
            } else if (keyword.equals(CONF_NAME)) {
                welcomeMessage = welcomeMessage.replaceAll(
                        Pattern.quote(CONF_NAME),
                        Matcher.quoteReplacement(ParamsUtil.escapeHTMLTags(meetingName)));
            } else if (keyword.equals(SERVER_URL)) {
                welcomeMessage = welcomeMessage.replaceAll(
                        Pattern.quote(SERVER_URL),
                        Matcher.quoteReplacement(defaultServerUrl));
            }
        }
        return  welcomeMessage;
    }

    public void processRequiredCreateParams(Map<String, String> params, ApiErrors errors) {
        // Do we have a checksum? If not, complain.
        if (StringUtils.isEmpty(params.get(ApiParams.CHECKSUM))) {
            errors.missingParamError(ApiParams.CHECKSUM);
        }

        // Do we have a meeting id? If not, complain.
        if (!StringUtils.isEmpty(params.get(ApiParams.MEETING_ID))) {
            String meetingId = StringUtils.strip(params.get(ApiParams.MEETING_ID));
            if (StringUtils.isEmpty(meetingId)) {
                errors.missingParamError(ApiParams.MEETING_ID);
            } else {
                if (!ParamsUtil.isValidMeetingId(meetingId)) {
                    errors.addError(new String[] { ""invalidFormat"", ""Meeting id contains invalid characters."" });
                }
            }
        } else {
            errors.missingParamError(ApiParams.MEETING_ID);
        }
    }

	public Map<String, Object> processUpdateCreateParams(Map<String, String> params) {
		Map<String, Object> newParams = new HashMap<>();

        String[] createParams = { ApiParams.NAME, ApiParams.ATTENDEE_PW, ApiParams.MODERATOR_PW, ApiParams.VOICE_BRIDGE,
                ApiParams.WEB_VOICE, ApiParams.DIAL_NUMBER, ApiParams.LOGOUT_URL, ApiParams.RECORD,
                ApiParams.MAX_PARTICIPANTS, ApiParams.DURATION, ApiParams.WELCOME };

        for (String paramName : createParams) {
            String parameter = params.get(paramName);
            if (!StringUtils.isEmpty(parameter)) {
                newParams.put(paramName, parameter);
            }
        }

	    // Collect metadata for this meeting that the third-party application wants to store if meeting is recorded.
	    Map<String, String> meetingInfo = new HashMap<>();
	    for (Map.Entry<String, String> entry : params.entrySet()) {
	    	if (entry.getKey().contains(ApiParams.META)){
	    		String[] meta = entry.getKey().split(""_"");
			    if(meta.length == 2){
			    	meetingInfo.put(meta[1], entry.getValue());
			    }
			}
	    }

        if (!meetingInfo.isEmpty()) {
            newParams.put(""metadata"", meetingInfo);
        }

	    return newParams;
	}

	private static final Pattern META_VAR_PATTERN = Pattern.compile(""meta_[a-zA-Z][a-zA-Z0-9-]*$"");
	public static Boolean isMetaValid(String param) {
		Matcher metaMatcher = META_VAR_PATTERN.matcher(param);
    if (metaMatcher.matches()) {
    	return true;
    }
		return false;
	}

	public static String removeMetaString(String param) {
		return StringUtils.removeStart(param, ""meta_"");
	}

    public static Map<String, String> processMetaParam(Map<String, String> params) {
        Map<String, String> metas = new HashMap<>();
        for (Map.Entry<String, String> entry : params.entrySet()) {
            if (isMetaValid(entry.getKey())) {
                // Need to lowercase to maintain backward compatibility with
                // 0.81
                String metaName = removeMetaString(entry.getKey()).toLowerCase();
                metas.put(metaName, entry.getValue());
            }
        }

        return metas;
    }

		private BreakoutRoomsParams processBreakoutRoomsParams(Map<String, String> params) {
			Boolean breakoutRoomsRecord = defaultBreakoutRoomsRecord;
			String breakoutRoomsRecordParam = params.get(ApiParams.BREAKOUT_ROOMS_RECORD);
			if (!StringUtils.isEmpty(breakoutRoomsRecordParam)) {
				breakoutRoomsRecord = Boolean.parseBoolean(breakoutRoomsRecordParam);
			}

			Boolean breakoutRoomsPrivateChatEnabled =  defaultbreakoutRoomsPrivateChatEnabled;
			String breakoutRoomsPrivateChatEnabledParam = params.get(ApiParams.BREAKOUT_ROOMS_PRIVATE_CHAT_ENABLED);
			if (!StringUtils.isEmpty(breakoutRoomsPrivateChatEnabledParam)) {
				breakoutRoomsPrivateChatEnabled = Boolean.parseBoolean(breakoutRoomsPrivateChatEnabledParam);
			}

            Boolean breakoutRoomsCaptureSlides = defaultBreakoutRoomsCaptureSlides;
            String breakoutRoomsCaptureParam = params.get(ApiParams.BREAKOUT_ROOMS_CAPTURE_SLIDES);
            if (!StringUtils.isEmpty(breakoutRoomsCaptureParam)) {
				breakoutRoomsCaptureSlides = Boolean.parseBoolean(breakoutRoomsCaptureParam);
			}

            Boolean breakoutRoomsCaptureNotes = defaultBreakoutRoomsCaptureNotes;
            String breakoutRoomsCaptureNotesParam = params.get(ApiParams.BREAKOUT_ROOMS_CAPTURE_NOTES);
            if (!StringUtils.isEmpty(breakoutRoomsCaptureNotesParam)) {
				breakoutRoomsCaptureNotes = Boolean.parseBoolean(breakoutRoomsCaptureNotesParam);
			}

            String breakoutRoomsCaptureNotesFilename = defaultBreakoutRoomsCaptureNotesFilename;
            String breakoutRoomsCaptureNotesFilenameParam = params.get(ApiParams.BREAKOUT_ROOMS_CAPTURE_NOTES_FILENAME);
            if (!StringUtils.isEmpty(breakoutRoomsCaptureNotesFilenameParam)) {
                breakoutRoomsCaptureNotesFilename = breakoutRoomsCaptureNotesFilenameParam;
            }

            String breakoutRoomsCaptureSlidesFilename = defaultBreakoutRoomsCaptureSlidesFilename;
            String breakoutRoomsCaptureSlidesFilenameParam = params.get(ApiParams.BREAKOUT_ROOMS_CAPTURE_SLIDES_FILENAME);
            if (!StringUtils.isEmpty(breakoutRoomsCaptureSlidesFilenameParam)) {
                breakoutRoomsCaptureSlidesFilename = breakoutRoomsCaptureSlidesFilenameParam;
            }

			return new BreakoutRoomsParams(breakoutRoomsRecord, breakoutRoomsPrivateChatEnabled, breakoutRoomsCaptureNotes, breakoutRoomsCaptureSlides, breakoutRoomsCaptureNotesFilename, breakoutRoomsCaptureSlidesFilename);
		}

		private LockSettingsParams processLockSettingsParams(Map<String, String> params) {
			Boolean lockSettingsDisableCam = defaultLockSettingsDisableCam;
			String lockSettingsDisableCamParam = params.get(ApiParams.LOCK_SETTINGS_DISABLE_CAM);
			if (!StringUtils.isEmpty(lockSettingsDisableCamParam)) {
				lockSettingsDisableCam = Boolean.parseBoolean(lockSettingsDisableCamParam);
			}

			Boolean lockSettingsDisableMic = defaultLockSettingsDisableMic;
			String lockSettingsDisableMicParam = params.get(ApiParams.LOCK_SETTINGS_DISABLE_MIC);
			if (!StringUtils.isEmpty(lockSettingsDisableMicParam)) {
				lockSettingsDisableMic = Boolean.parseBoolean(lockSettingsDisableMicParam);
			}

			Boolean lockSettingsDisablePrivateChat = defaultLockSettingsDisablePrivateChat;
			String lockSettingsDisablePrivateChatParam = params.get(ApiParams.LOCK_SETTINGS_DISABLE_PRIVATE_CHAT);
			if (!StringUtils.isEmpty(lockSettingsDisablePrivateChatParam)) {
				lockSettingsDisablePrivateChat = Boolean.parseBoolean(lockSettingsDisablePrivateChatParam);
			}

			Boolean lockSettingsDisablePublicChat = defaultLockSettingsDisablePublicChat;
			String lockSettingsDisablePublicChatParam = params.get(ApiParams.LOCK_SETTINGS_DISABLE_PUBLIC_CHAT);
			if (!StringUtils.isEmpty(lockSettingsDisablePublicChatParam)) {
				lockSettingsDisablePublicChat = Boolean.parseBoolean(lockSettingsDisablePublicChatParam);
			}

			Boolean lockSettingsDisableNotes = defaultLockSettingsDisableNotes;
			String lockSettingsDisableNotesParam = params.get(ApiParams.LOCK_SETTINGS_DISABLE_NOTES);
			if (!StringUtils.isEmpty(lockSettingsDisableNotesParam)) {
				lockSettingsDisableNotes = Boolean.parseBoolean(lockSettingsDisableNotesParam);
			} else {
				// To be removed after deprecation period
				lockSettingsDisableNotesParam = params.get(ApiParams.DEPRECATED_LOCK_SETTINGS_DISABLE_NOTES);
				if (!StringUtils.isEmpty(lockSettingsDisableNotesParam)) {
					log.warn(""[DEPRECATION] use lockSettingsDisableNotes instead of lockSettingsDisableNote"");
					lockSettingsDisableNotes = Boolean.parseBoolean(lockSettingsDisableNotesParam);
				}
			}

			Boolean lockSettingsHideUserList = defaultLockSettingsHideUserList;
			String lockSettingsHideUserListParam = params.get(ApiParams.LOCK_SETTINGS_HIDE_USER_LIST);
			if (!StringUtils.isEmpty(lockSettingsHideUserListParam)) {
				lockSettingsHideUserList = Boolean.parseBoolean(lockSettingsHideUserListParam);
			}

			Boolean lockSettingsLockOnJoin = defaultLockSettingsLockOnJoin;
			String lockSettingsLockOnJoinParam = params.get(ApiParams.LOCK_SETTINGS_LOCK_ON_JOIN);
			if (!StringUtils.isEmpty(lockSettingsLockOnJoinParam)) {
				lockSettingsLockOnJoin = Boolean.parseBoolean(lockSettingsLockOnJoinParam);
			}

			Boolean lockSettingsLockOnJoinConfigurable = defaultLockSettingsLockOnJoinConfigurable;
			String lockSettingsLockOnJoinConfigurableParam = params.get(ApiParams.LOCK_SETTINGS_LOCK_ON_JOIN_CONFIGURABLE);
			if (!StringUtils.isEmpty(lockSettingsLockOnJoinConfigurableParam)) {
				lockSettingsLockOnJoinConfigurable = Boolean.parseBoolean(lockSettingsLockOnJoinConfigurableParam);
			}

			Boolean lockSettingsHideViewersCursor = defaultLockSettingsHideViewersCursor;
			String lockSettingsHideViewersCursorParam = params.get(ApiParams.LOCK_SETTINGS_HIDE_VIEWERS_CURSOR);
			if (!StringUtils.isEmpty(lockSettingsHideViewersCursorParam)) {
                lockSettingsHideViewersCursor = Boolean.parseBoolean(lockSettingsHideViewersCursorParam);
			}

			return new LockSettingsParams(lockSettingsDisableCam,
							lockSettingsDisableMic,
							lockSettingsDisablePrivateChat,
							lockSettingsDisablePublicChat,
							lockSettingsDisableNotes,
							lockSettingsHideUserList,
							lockSettingsLockOnJoin,
							lockSettingsLockOnJoinConfigurable,
                            lockSettingsHideViewersCursor);
		}

    private ArrayList<Group> processGroupsParams(Map<String, String> params) {
        ArrayList<Group> groups = new ArrayList<Group>();

        String groupsParam = params.get(ApiParams.GROUPS);
        if (!StringUtils.isEmpty(groupsParam)) {
            JsonElement groupParamsJson = new Gson().fromJson(groupsParam, JsonElement.class);

            if(groupParamsJson != null && groupParamsJson.isJsonArray()) {
                JsonArray groupsJson = groupParamsJson.getAsJsonArray();
                for (JsonElement groupJson : groupsJson) {
                    if(groupJson.isJsonObject()) {
                        JsonObject groupJsonObj = groupJson.getAsJsonObject();
                        if(groupJsonObj.has(""id"")) {
                            String groupId = groupJsonObj.get(""id"").getAsString();
                            String groupName = """";
                            if(groupJsonObj.has(""name"")) {
                                groupName = groupJsonObj.get(""name"").getAsString();
                            }

                            Vector<String> groupUsers = new Vector<>();
                            if(groupJsonObj.has(""roster"") && groupJsonObj.get(""roster"").isJsonArray()) {
                                for (JsonElement userExtId : groupJsonObj.get(""roster"").getAsJsonArray()) {
                                    groupUsers.add(userExtId.getAsString());
                                }
                            }
                            groups.add(new Group(groupId,groupName,groupUsers));
                        }
                    }
                }
            }
        }

        return groups;
    }

    public Meeting processCreateParams(Map<String, String> params) {

        String meetingName = params.get(ApiParams.NAME);
        if (meetingName == null) {
            meetingName = """";
        }

        meetingName = ParamsUtil.stripControlChars(meetingName);

        String externalMeetingId = params.get(ApiParams.MEETING_ID);

        String viewerPass = processPassword(params.get(ApiParams.ATTENDEE_PW));
        String modPass = processPassword(params.get(ApiParams.MODERATOR_PW));

        // Get the digits for voice conference for users joining through the
        // phone.
        // If none is provided, generate one.
        String telVoice = processTelVoice(params.get(ApiParams.VOICE_BRIDGE));

        // Get the voice conference digits/chars for users joing through VOIP on
        // the client.
        // If none is provided, make it the same as the telVoice. If one has
        // been provided,
        // we expect that the users will be joined in the same voice conference.
        String webVoice = params.get(ApiParams.WEB_VOICE);
        if (StringUtils.isEmpty(webVoice)) {
            webVoice = telVoice;
        }

        // Get all the other relevant parameters and generate defaults if none
        // has been provided.
        String dialNumber = processDialNumber(params.get(ApiParams.DIAL_NUMBER));
        String logoutUrl = processLogoutUrl(params.get(ApiParams.LOGOUT_URL));
        boolean record = processRecordMeeting(params.get(ApiParams.RECORD));
        int maxUsers = processMaxUser(params.get(ApiParams.MAX_PARTICIPANTS));
        int meetingDuration = processMeetingDuration(params.get(ApiParams.DURATION));
        int logoutTimer = processLogoutTimer(params.get(ApiParams.LOGOUT_TIMER));

        // Banner parameters
        String bannerText = params.get(ApiParams.BANNER_TEXT);
        String bannerColor = params.get(ApiParams.BANNER_COLOR);

        // set is breakout room property
        boolean isBreakout = false;
        if (!StringUtils.isEmpty(params.get(ApiParams.IS_BREAKOUT))) {
            isBreakout = Boolean.valueOf(params.get(ApiParams.IS_BREAKOUT));
        }

        String welcomeMessageTemplate = processWelcomeMessage(
                params.get(ApiParams.WELCOME), isBreakout);
        String welcomeMessage = substituteKeywords(welcomeMessageTemplate,
                dialNumber, telVoice, meetingName);

        String internalMeetingId = convertToInternalMeetingId(externalMeetingId);

        // Check if this is a test meeting. NOTE: This should not belong here.
        // Extract this out.
        if (isTestMeeting(telVoice)) {
            internalMeetingId = getIntMeetingIdForTestMeeting(telVoice);
        }

        boolean autoStartRec = autoStartRecording;
        if (!StringUtils.isEmpty(params.get(ApiParams.AUTO_START_RECORDING))) {
            try {
                autoStartRec = Boolean.parseBoolean(params
                        .get(ApiParams.AUTO_START_RECORDING));
            } catch (Exception ex) {
                log.warn(""Invalid param [autoStartRecording] for meeting=[{}]"",
                        internalMeetingId);
            }
        }

        boolean allowStartStoptRec = allowStartStopRecording;
        if (!StringUtils.isEmpty(params.get(ApiParams.ALLOW_START_STOP_RECORDING))) {
            try {
                allowStartStoptRec = Boolean.parseBoolean(params
                        .get(ApiParams.ALLOW_START_STOP_RECORDING));
            } catch (Exception ex) {
                log.warn(
                        ""Invalid param [allowStartStopRecording] for meeting=[{}]"",
                        internalMeetingId);
            }
        }

        // Check Disabled Features
        ArrayList<String> listOfDisabledFeatures=new ArrayList(Arrays.asList(defaultDisabledFeatures.split("","")));
        if (!StringUtils.isEmpty(params.get(ApiParams.DISABLED_FEATURES))) {
            String disabledFeaturesParam = params.get(ApiParams.DISABLED_FEATURES);
            listOfDisabledFeatures.addAll(Arrays.asList(disabledFeaturesParam.split("","")));
        }
        listOfDisabledFeatures.removeAll(Arrays.asList("""", null));
        listOfDisabledFeatures.replaceAll(String::trim);
        listOfDisabledFeatures = new ArrayList<>(new HashSet<>(listOfDisabledFeatures));

        // Check if VirtualBackgrounds is disabled
        if (!StringUtils.isEmpty(params.get(ApiParams.VIRTUAL_BACKGROUNDS_DISABLED))) {
            boolean virtualBackgroundsDisabled = Boolean.valueOf(params.get(ApiParams.VIRTUAL_BACKGROUNDS_DISABLED));
            if(virtualBackgroundsDisabled == true && !listOfDisabledFeatures.contains(""virtualBackgrounds"")) {
                log.warn(""[DEPRECATION] use disabledFeatures=virtualBackgrounds instead of virtualBackgroundsDisabled=true"");
                listOfDisabledFeatures.add(""virtualBackgrounds"");
            }
        }

        boolean learningDashboardEn = learningDashboardEnabled;
        if (!StringUtils.isEmpty(params.get(ApiParams.LEARNING_DASHBOARD_ENABLED))) {
            try {
                learningDashboardEn = Boolean.parseBoolean(params.get(ApiParams.LEARNING_DASHBOARD_ENABLED));
            } catch (Exception ex) {
                log.warn(""Invalid param [learningDashboardEnabled] for meeting=[{}]"",internalMeetingId);
            }
        }
        if(learningDashboardEn == false && !listOfDisabledFeatures.contains(""learningDashboard"")) {
            log.warn(""[DEPRECATION] use disabledFeatures=learningDashboard instead of learningDashboardEnabled=false"");
            listOfDisabledFeatures.add(""learningDashboard"");
        }

        int learningDashboardCleanupMins = 0;

        // Learning Dashboard not allowed for Breakout Rooms
        if(!isBreakout) {
            learningDashboardCleanupMins = learningDashboardCleanupDelayInMinutes;
            if (!StringUtils.isEmpty(params.get(ApiParams.LEARNING_DASHBOARD_CLEANUP_DELAY_IN_MINUTES))) {
                try {
                    learningDashboardCleanupMins = Integer.parseInt(params
                            .get(ApiParams.LEARNING_DASHBOARD_CLEANUP_DELAY_IN_MINUTES));
                } catch (Exception ex) {
                    log.warn(
                            ""Invalid param [learningDashboardCleanupDelayInMinutes] for meeting=[{}]"",
                            internalMeetingId);
                }
            }
        }

        //Generate token to access Activity Report
        String learningDashboardAccessToken = """";
        if(listOfDisabledFeatures.contains(""learningDashboard"") == false) {
            learningDashboardAccessToken = RandomStringUtils.randomAlphanumeric(12).toLowerCase();
        }

        Boolean notifyRecordingIsOn = defaultNotifyRecordingIsOn;
        if (!StringUtils.isEmpty(params.get(ApiParams.NOTIFY_RECORDING_IS_ON))) {
            notifyRecordingIsOn = Boolean.parseBoolean(params.get(ApiParams.NOTIFY_RECORDING_IS_ON));
        }

        boolean webcamsOnlyForMod = webcamsOnlyForModerator;
        if (!StringUtils.isEmpty(params.get(ApiParams.WEBCAMS_ONLY_FOR_MODERATOR))) {
            try {
                webcamsOnlyForMod = Boolean.parseBoolean(params
                        .get(ApiParams.WEBCAMS_ONLY_FOR_MODERATOR));
            } catch (Exception ex) {
                log.warn(
                        ""Invalid param [webcamsOnlyForModerator] for meeting=[{}]"",
                        internalMeetingId);
            }
        }

        Integer meetingCameraCap = defaultMeetingCameraCap;
        if (!StringUtils.isEmpty(params.get(ApiParams.MEETING_CAMERA_CAP))) {
            try {
                Integer meetingCameraCapParam = Integer.parseInt(params.get(ApiParams.MEETING_CAMERA_CAP));
                if (meetingCameraCapParam >= 0) meetingCameraCap = meetingCameraCapParam;
            } catch (NumberFormatException e) {
                log.warn(""Invalid param [meetingCameraCap] for meeting=[{}]"", internalMeetingId);
            }
        }

        Integer userCameraCap = defaultUserCameraCap;
        if (!StringUtils.isEmpty(params.get(ApiParams.USER_CAMERA_CAP))) {
            try {
                Integer userCameraCapParam = Integer.parseInt(params.get(ApiParams.USER_CAMERA_CAP));
                if (userCameraCapParam >= 0) userCameraCap = userCameraCapParam;
            } catch (NumberFormatException e) {
                log.warn(""Invalid param [userCameraCap] for meeting=[{}]"", internalMeetingId);
            }
        }

        Integer maxPinnedCameras = defaultMaxPinnedCameras;
        if (!StringUtils.isEmpty(params.get(ApiParams.MAX_PINNED_CAMERAS))) {
          try {
            Integer maxPinnedCamerasParam = Integer.parseInt(params.get(ApiParams.MAX_PINNED_CAMERAS));
            if (maxPinnedCamerasParam > 0) maxPinnedCameras = maxPinnedCamerasParam;
          } catch (NumberFormatException e) {
            log.warn(""Invalid param [maxPinnedCameras] for meeting =[{}]"", internalMeetingId);
          }
        }

        Integer meetingExpireIfNoUserJoinedInMinutes = defaultMeetingExpireIfNoUserJoinedInMinutes;
        if (!StringUtils.isEmpty(params.get(ApiParams.MEETING_EXPIRE_IF_NO_USER_JOINED_IN_MINUTES))) {
            try {
                meetingExpireIfNoUserJoinedInMinutes = Integer.parseInt(params.get(ApiParams.MEETING_EXPIRE_IF_NO_USER_JOINED_IN_MINUTES));
            } catch (NumberFormatException e) {
                log.warn(""Invalid param [meetingExpireIfNoUserJoinedInMinutes] for meeting=[{}]"", internalMeetingId);
            }
        }

        Integer meetingExpireWhenLastUserLeftInMinutes = defaultMeetingExpireWhenLastUserLeftInMinutes;
        if (!StringUtils.isEmpty(params.get(ApiParams.MEETING_EXPIRE_WHEN_LAST_USER_LEFT_IN_MINUTES))) {
            try {
                meetingExpireWhenLastUserLeftInMinutes = Integer.parseInt(params.get(ApiParams.MEETING_EXPIRE_WHEN_LAST_USER_LEFT_IN_MINUTES));
            } catch (NumberFormatException e) {
                log.warn(""Invalid param [meetingExpireWhenLastUserLeftInMinutes] for meeting=[{}]"", internalMeetingId);
            }
        }

        boolean endWhenNoModerator = defaultEndWhenNoModerator;
        if (!StringUtils.isEmpty(params.get(ApiParams.END_WHEN_NO_MODERATOR))) {
          try {
	          endWhenNoModerator = Boolean.parseBoolean(params.get(ApiParams.END_WHEN_NO_MODERATOR));
          } catch (Exception ex) {
            log.warn(""Invalid param [endWhenNoModerator] for meeting=[{}]"", internalMeetingId);
          }
        }

        int endWhenNoModeratorDelayInMinutes = defaultEndWhenNoModeratorDelayInMinutes;
        if (!StringUtils.isEmpty(params.get(ApiParams.END_WHEN_NO_MODERATOR_DELAY_IN_MINUTES))) {
          try {
              endWhenNoModeratorDelayInMinutes = Integer.parseInt(params.get(ApiParams.END_WHEN_NO_MODERATOR_DELAY_IN_MINUTES));
          } catch (Exception ex) {
            log.warn(""Invalid param [endWhenNoModeratorDelayInMinutes] for meeting=[{}]"", internalMeetingId);
          }
        }

        String guestPolicy = defaultGuestPolicy;
        if (!StringUtils.isEmpty(params.get(ApiParams.GUEST_POLICY))) {
        	guestPolicy = params.get(ApiParams.GUEST_POLICY);
		    }

        String presentationUploadExternalDescription = defaultPresentationUploadExternalDescription;
        if (!StringUtils.isEmpty(params.get(ApiParams.PRESENTATION_UPLOAD_EXTERNAL_DESCRIPTION))) {
            presentationUploadExternalDescription = params.get(ApiParams.PRESENTATION_UPLOAD_EXTERNAL_DESCRIPTION);
        }

        String presentationUploadExternalUrl = defaultPresentationUploadExternalUrl;
        if (!StringUtils.isEmpty(params.get(ApiParams.PRESENTATION_UPLOAD_EXTERNAL_URL))) {
            presentationUploadExternalUrl = params.get(ApiParams.PRESENTATION_UPLOAD_EXTERNAL_URL);
        }

        String meetingLayout = defaultMeetingLayout;

        ArrayList<Group> groups = processGroupsParams(params);

        if (!StringUtils.isEmpty(params.get(ApiParams.MEETING_LAYOUT))) {
            meetingLayout = params.get(ApiParams.MEETING_LAYOUT);
        }

        Boolean breakoutRoomsEnabled = defaultBreakoutRoomsEnabled;
        String breakoutRoomsEnabledParam = params.get(ApiParams.BREAKOUT_ROOMS_ENABLED);
        if (!StringUtils.isEmpty(breakoutRoomsEnabledParam)) {
            breakoutRoomsEnabled = Boolean.parseBoolean(breakoutRoomsEnabledParam);
        }
        if(breakoutRoomsEnabled == false && !listOfDisabledFeatures.contains(""breakoutRooms"")) {
            log.warn(""[DEPRECATION] use disabledFeatures=breakoutRooms instead of breakoutRoomsEnabled=false"");
            listOfDisabledFeatures.add(""breakoutRooms"");
        }

        BreakoutRoomsParams breakoutParams = processBreakoutRoomsParams(params);
        LockSettingsParams lockSettingsParams = processLockSettingsParams(params);

        // Collect metadata for this meeting that the third-party app wants to
        // store if meeting is recorded.
        Map<String, String> meetingInfo = processMetaParam(params);

        // Create a unique internal id by appending the current time. This way,
        // the 3rd-party
        // app can reuse the external meeting id.
        long createTime = System.currentTimeMillis();
        internalMeetingId = internalMeetingId + ""-"" + Long.toString(createTime);

        // If this create meeting request is for a breakout room, we just used
        // we need to generate a unique internal and external id and keep
        // tracks of the parent meeting id
        String parentMeetingId = """";
        if (isBreakout) {
            internalMeetingId = params.get(ApiParams.MEETING_ID);
            parentMeetingId = ServiceUtils.findMeetingFromMeetingID(params.get(ApiParams.PARENT_MEETING_ID)).getInternalId();
            // We rebuild the the external meeting using the has of the parent
            // meeting, the shared timestamp and the sequence number
            String timeStamp = StringUtils.substringAfter(internalMeetingId, ""-"");
            String externalHash = DigestUtils
                    .sha1Hex((parentMeetingId + ""-"" + timeStamp + ""-"" + params.get(ApiParams.SEQUENCE)));
            externalMeetingId = externalHash + ""-"" + timeStamp;
        }

        String avatarURL = useDefaultAvatar ? defaultAvatarURL : """";

        int html5InstanceId = processHtml5InstanceId(params.get(ApiParams.HTML5_INSTANCE_ID));

        if(defaultAllowDuplicateExtUserid == false) {
            log.warn(""[DEPRECATION] use `maxUserConcurrentAccesses=1` instead of `allowDuplicateExtUserid=false`"");
            maxUserConcurrentAccesses = 1;
        }

        // Create the meeting with all passed in parameters.
        Meeting meeting = new Meeting.Builder(externalMeetingId,
                internalMeetingId, createTime).withName(meetingName)
                .withMaxUsers(maxUsers).withModeratorPass(modPass)
                .withViewerPass(viewerPass).withRecording(record)
                .withDuration(meetingDuration).withLogoutUrl(logoutUrl)
                .withLogoutTimer(logoutTimer)
                .withBannerText(bannerText).withBannerColor(bannerColor)
                .withTelVoice(telVoice).withWebVoice(webVoice)
                .withDialNumber(dialNumber)
                .withDefaultAvatarURL(avatarURL)
                .withAutoStartRecording(autoStartRec)
                .withAllowStartStopRecording(allowStartStoptRec)
                .withWebcamsOnlyForModerator(webcamsOnlyForMod)
                .withMeetingCameraCap(meetingCameraCap)
                .withUserCameraCap(userCameraCap)
                .withMaxPinnedCameras(maxPinnedCameras)
                .withMetadata(meetingInfo)
                .withWelcomeMessageTemplate(welcomeMessageTemplate)
                .withWelcomeMessage(welcomeMessage).isBreakout(isBreakout)
                .withGuestPolicy(guestPolicy)
                .withAuthenticatedGuest(authenticatedGuest)
                .withAllowRequestsWithoutSession(allowRequestsWithoutSession)
                .withMeetingLayout(meetingLayout)
				.withBreakoutRoomsParams(breakoutParams)
				.withLockSettingsParams(lockSettingsParams)
				.withMaxUserConcurrentAccesses(maxUserConcurrentAccesses)
                .withHTML5InstanceId(html5InstanceId)
                .withLearningDashboardCleanupDelayInMinutes(learningDashboardCleanupMins)
                .withLearningDashboardAccessToken(learningDashboardAccessToken)
                .withGroups(groups)
                .withDisabledFeatures(listOfDisabledFeatures)
                .withNotifyRecordingIsOn(notifyRecordingIsOn)
                .withPresentationUploadExternalDescription(presentationUploadExternalDescription)
                .withPresentationUploadExternalUrl(presentationUploadExternalUrl)
                .build();

        if (!StringUtils.isEmpty(params.get(ApiParams.MODERATOR_ONLY_MESSAGE))) {
            String moderatorOnlyMessageTemplate = params.get(ApiParams.MODERATOR_ONLY_MESSAGE);
            String moderatorOnlyMessage = substituteKeywords(moderatorOnlyMessageTemplate,
                    dialNumber, telVoice, meetingName);
            meeting.setModeratorOnlyMessage(moderatorOnlyMessage);
        }

        if (!StringUtils.isEmpty(params.get(ApiParams.MEETING_ENDED_CALLBACK_URL))) {
        	String meetingEndedCallbackURL = params.get(ApiParams.MEETING_ENDED_CALLBACK_URL);
        	meeting.setMeetingEndedCallbackURL(meetingEndedCallbackURL);
        }

        meeting.setMeetingExpireIfNoUserJoinedInMinutes(meetingExpireIfNoUserJoinedInMinutes);
		meeting.setMeetingExpireWhenLastUserLeftInMinutes(meetingExpireWhenLastUserLeftInMinutes);
		meeting.setUserInactivityInspectTimerInMinutes(userInactivityInspectTimerInMinutes);
		meeting.setUserActivitySignResponseDelayInMinutes(userActivitySignResponseDelayInMinutes);
		meeting.setUserInactivityThresholdInMinutes(userInactivityThresholdInMinutes);
//		meeting.setHtml5InstanceId(html5InstanceId);
        meeting.setEndWhenNoModerator(endWhenNoModerator);
        meeting.setEndWhenNoModeratorDelayInMinutes(endWhenNoModeratorDelayInMinutes);

        // Add extra parameters for breakout room
        if (isBreakout) {
            meeting.setSequence(Integer.parseInt(params.get(ApiParams.SEQUENCE)));
            meeting.setFreeJoin(Boolean.parseBoolean(params.get(ApiParams.FREE_JOIN)));
            meeting.setCaptureSlides(Boolean.parseBoolean(params.get(ApiParams.BREAKOUT_ROOMS_CAPTURE_SLIDES)));
            meeting.setCaptureNotes(Boolean.parseBoolean(params.get(ApiParams.BREAKOUT_ROOMS_CAPTURE_NOTES)));
            meeting.setCaptureNotesFilename(params.get(ApiParams.BREAKOUT_ROOMS_CAPTURE_NOTES_FILENAME));
            meeting.setCaptureSlidesFilename(params.get(ApiParams.BREAKOUT_ROOMS_CAPTURE_SLIDES_FILENAME));
            meeting.setParentMeetingId(parentMeetingId);
        }

		if (!StringUtils.isEmpty(params.get(ApiParams.LOGO))) {
			meeting.setCustomLogoURL(params.get(ApiParams.LOGO));
		} else if (this.getUseDefaultLogo()) {
			meeting.setCustomLogoURL(this.getDefaultLogoURL());
		}

		if (!StringUtils.isEmpty(params.get(ApiParams.COPYRIGHT))) {
			meeting.setCustomCopyright(params.get(ApiParams.COPYRIGHT));
		}
		Boolean muteOnStart = defaultMuteOnStart;
		if (!StringUtils.isEmpty(params.get(ApiParams.MUTE_ON_START))) {
        	muteOnStart = Boolean.parseBoolean(params.get(ApiParams.MUTE_ON_START));
        }

		// when a moderator joins in a breakout room only with the audio, and the muteOnStart is set to true,
		// the moderator is unable to unmute himself, because they don't have an icon to do so
		if (isBreakout) {
			muteOnStart = false;
		}

		meeting.setMuteOnStart(muteOnStart);

    Boolean meetingKeepEvents = defaultKeepEvents;
    if (!StringUtils.isEmpty(params.get(ApiParams.MEETING_KEEP_EVENTS))) {
      meetingKeepEvents = Boolean.parseBoolean(params.get(ApiParams.MEETING_KEEP_EVENTS));
    }
    meeting.setMeetingKeepEvents(meetingKeepEvents);

        Boolean allowModsToUnmuteUsers = defaultAllowModsToUnmuteUsers;
        if (!StringUtils.isEmpty(params.get(ApiParams.ALLOW_MODS_TO_UNMUTE_USERS))) {
            allowModsToUnmuteUsers = Boolean.parseBoolean(params.get(ApiParams.ALLOW_MODS_TO_UNMUTE_USERS));
        }
        meeting.setAllowModsToUnmuteUsers(allowModsToUnmuteUsers);

        if (!StringUtils.isEmpty(params.get(ApiParams.ALLOW_REQUESTS_WITHOUT_SESSION))) {
            meeting.setAllowRequestsWithoutSession(Boolean.parseBoolean(params.get(ApiParams.ALLOW_REQUESTS_WITHOUT_SESSION)));
        }

    Boolean allowModsToEjectCameras = defaultAllowModsToEjectCameras;
    if (!StringUtils.isEmpty(params.get(ApiParams.ALLOW_MODS_TO_EJECT_CAMERAS))) {
      allowModsToEjectCameras = Boolean.parseBoolean(params.get(ApiParams.ALLOW_MODS_TO_EJECT_CAMERAS));
    }
    meeting.setAllowModsToEjectCameras(allowModsToEjectCameras);

        return meeting;
    }

	public String getApiVersion() {
		return apiVersion;
	}

	public boolean isServiceEnabled() {
		return serviceEnabled;
	}

	public String getDefaultHTML5ClientUrl() {
		return defaultHTML5ClientUrl;
	}

	public String getDefaultGuestWaitURL() {
		return defaultGuestWaitURL;
        }

	public Boolean getUseDefaultLogo() {
		return useDefaultLogo;
	}

	public String getDefaultLogoURL() {
		return defaultLogoURL;
	}

	public Boolean getAllowRequestsWithoutSession() {
		return allowRequestsWithoutSession;
	}

  public Integer getDefaultHttpSessionTimeout() {
    return defaultHttpSessionTimeout;
  }

  public void setDefaultHttpSessionTimeout(Integer value) {
    this.defaultHttpSessionTimeout = value;
  }

	public String getDefaultLogoutUrl() {
		 if ((StringUtils.isEmpty(defaultLogoutUrl)) || ""default"".equalsIgnoreCase(defaultLogoutUrl)) {
     		return defaultServerUrl;
     	} else {
     		return defaultLogoutUrl;
     	}
	}

  public String getBbbVersion() {
    return bbbVersion;
  }

  public Boolean getAllowRevealOfBBBVersion() {
    return allowRevealOfBBBVersion;
  }

    public String processWelcomeMessage(String message, Boolean isBreakout) {
        String welcomeMessage = message;
        if (StringUtils.isEmpty(message)) {
            welcomeMessage = defaultWelcomeMessage;
        }
        if (!StringUtils.isEmpty(defaultWelcomeMessageFooter) && !isBreakout)
            welcomeMessage += ""<br><br>"" + defaultWelcomeMessageFooter;
        return welcomeMessage;
    }

	public String convertToInternalMeetingId(String extMeetingId) {
		return DigestUtils.sha1Hex(extMeetingId);
	}

    public String processPassword(String pass) {
        return StringUtils.isEmpty(pass) ? RandomStringUtils.randomAlphanumeric(8) : pass;
    }

    public boolean hasChecksumAndQueryString(String checksum, String queryString) {
		return (! StringUtils.isEmpty(checksum) && StringUtils.isEmpty(queryString));
	}

	public String processTelVoice(String telNum) {
		return StringUtils.isEmpty(telNum) ? RandomStringUtils.randomNumeric(defaultNumDigitsForTelVoice) : telNum;
	}

	public String processDialNumber(String dial) {
		return StringUtils.isEmpty(dial) ? defaultDialAccessNumber : dial;
	}

	public String processLogoutUrl(String logoutUrl) {
		if (StringUtils.isEmpty(logoutUrl)) {
	        if ((StringUtils.isEmpty(defaultLogoutUrl)) || ""default"".equalsIgnoreCase(defaultLogoutUrl)) {
        		return defaultServerUrl;
        	} else {
        		return defaultLogoutUrl;
        	}
		}

		return logoutUrl;
	}

	public boolean processRecordMeeting(String record) {
		// The administrator has turned off recording for all meetings.
		if (disableRecordingDefault) {
			log.info(""Recording is turned OFF by default."");
			return false;
		}

		boolean rec = false;
		if(! StringUtils.isEmpty(record)){
			try {
				rec = Boolean.parseBoolean(record);
			} catch(Exception ex){
				rec = false;
			}
		}

		return rec;
	}

	public int processHtml5InstanceId(String instanceId) {
		int html5InstanceId = 1;
		try {
            html5InstanceId = Integer.parseInt(instanceId);
		} catch(Exception ex) {
            html5InstanceId = defaultHtml5InstanceId;
		}

		return html5InstanceId;
	}

	public int processMaxUser(String maxUsers) {
		int mUsers = -1;

		try {
			mUsers = Integer.parseInt(maxUsers);
		} catch(Exception ex) {
			mUsers = defaultMaxUsers;
		}

		return mUsers;
	}

  public int processMeetingDuration(String duration) {
    int mDuration = -1;

    try {
      mDuration = Integer.parseInt(duration);
    } catch(Exception ex) {
      mDuration = defaultMeetingDuration;
    }

    return mDuration;
  }

	public int processLogoutTimer(String logoutTimer) {
		int mDuration = clientLogoutTimerInMinutes;

		try {
			mDuration = Integer.parseInt(logoutTimer);
		} catch(Exception ex) {
			mDuration = clientLogoutTimerInMinutes;
		}

		return mDuration;
	}

    public boolean isTestMeeting(String telVoice) {
        return ((!StringUtils.isEmpty(telVoice)) && (!StringUtils.isEmpty(testVoiceBridge))
                && (telVoice.equals(testVoiceBridge)));
    }

    public String getIntMeetingIdForTestMeeting(String telVoice) {
        if ((testVoiceBridge != null) && (testVoiceBridge.equals(telVoice))
                && StringUtils.isEmpty(testConferenceMock)) {
            return testConferenceMock;
        }

        return """";
    }

	// Can be removed. Checksum validation is performed by the ChecksumValidator
	public boolean isChecksumSame(String apiCall, String checksum, String queryString) {
		if (StringUtils.isEmpty(securitySalt)) {
			log.warn(""Security is disabled in this service. Make sure this is intentional."");
			return true;
		}

		if( queryString == null ) {
		    queryString = """";
		} else {
		    // handle either checksum as first or middle / end parameter
		    // TODO: this is hackish - should be done better
		    queryString = queryString.replace(""&checksum="" + checksum, """");
		    queryString = queryString.replace(""checksum="" + checksum + ""&"", """");
		    queryString = queryString.replace(""checksum="" + checksum, """");
		}

		log.info(""CHECKSUM={} length={}"", checksum, checksum.length());

		String data = apiCall + queryString + securitySalt;

		int checksumLength = checksum.length();
        String cs = null;

        switch(checksumLength) {
            case 40:
                if(supportedChecksumAlgorithms.contains(""sha1"")) {
                    cs = DigestUtils.sha1Hex(data);
                    log.info(""SHA1 {}"", cs);
                }
                break;
            case 64:
                if(supportedChecksumAlgorithms.contains(""sha256"")) {
                    cs = DigestUtils.sha256Hex(data);
                    log.info(""SHA256 {}"", cs);
                }
                break;
            case 96:
                if(supportedChecksumAlgorithms.contains(""sha384"")) {
                    cs = DigestUtils.sha384Hex(data);
                    log.info(""SHA384 {}"", cs);
                }
                break;
            case 128:
                if(supportedChecksumAlgorithms.contains(""sha512"")) {
                    cs = DigestUtils.sha512Hex(data);
                    log.info(""SHA512 {}"", cs);
                }
                break;
            default:
                log.info(""No algorithm could be found that matches the provided checksum length"");
        }

		if (cs == null || !cs.equalsIgnoreCase(checksum)) {
			log.info(""query string after checksum removed: [{}]"", queryString);
			log.info(""checksumError: query string checksum failed. our: [{}], client: [{}]"", cs, checksum);
			return false;
		}

		return true;
	}

	public boolean isPostChecksumSame(String apiCall, Map<String, String[]> params) {
		if (StringUtils.isEmpty(securitySalt)) {
			log.warn(""Security is disabled in this service. Make sure this is intentional."");
			return true;
		}

		StringBuilder csbuf = new StringBuilder();
		csbuf.append(apiCall);

		SortedSet<String> keys = new TreeSet<>(params.keySet());

		boolean first = true;
		String checksum = null;
		for (String key: keys) {
			if (ApiParams.CHECKSUM.equals(key)) {
				// Don't include the ""checksum"" parameter in the checksum
				checksum = params.get(key)[0];
				continue;
			}

			for (String value: params.get(key)) {
				if (first) {
					first = false;
				} else {
					csbuf.append(""&"");
				}
				csbuf.append(key);
				csbuf.append(""="");
				String encResult;

				encResult = value;

/*****
 * Seems like Grails 2.3.6 decodes the string. So we need to re-encode it.
 * We'll remove this later. richard (aug 5, 2014)
*/				try {
					// we need to re-encode the values because Grails unencoded it
					// when it received the 'POST'ed data. Might not need to do in a GET request.
					encResult = URLEncoder.encode(value, StandardCharsets.UTF_8.name());
				} catch (UnsupportedEncodingException e) {
					encResult = value;
				}

				csbuf.append(encResult);
			}
		}
		csbuf.append(securitySalt);

		String baseString = csbuf.toString();
		String cs = DigestUtils.sha1Hex(baseString);

		if (cs == null || !cs.equalsIgnoreCase(checksum)) {
			log.info(""POST basestring = {}"", baseString);
			log.info(""checksumError: failed checksum. our checksum: [{}], client: [{}]"", cs, checksum);
			return false;
		}

		return true;
	}

	/*************************************************
	 * Setters
	 ************************************************/

	public void setApiVersion(String apiVersion) {
		this.apiVersion = apiVersion;
	}

	public void setServiceEnabled(boolean e) {
		serviceEnabled = e;
	}

	public void setSecuritySalt(String securitySalt) {
		this.securitySalt = securitySalt;
	}

    public void setSupportedChecksumAlgorithms(String supportedChecksumAlgorithms) { this.supportedChecksumAlgorithms = supportedChecksumAlgorithms; }

	public void setChecksumHash(String checksumHash) { this.checksumHash = checksumHash; }

	public void setDefaultMaxUsers(int defaultMaxUsers) {
		this.defaultMaxUsers = defaultMaxUsers;
	}

	public void setDefaultWelcomeMessage(String defaultWelcomeMessage) {
		this.defaultWelcomeMessage = defaultWelcomeMessage;
	}

	public void setDefaultWelcomeMessageFooter(String defaultWelcomeMessageFooter) {
	    this.defaultWelcomeMessageFooter = defaultWelcomeMessageFooter;
	}

	public void setDefaultDialAccessNumber(String defaultDialAccessNumber) {
		this.defaultDialAccessNumber = defaultDialAccessNumber;
	}

	public void setTestVoiceBridge(String testVoiceBridge) {
		this.testVoiceBridge = testVoiceBridge;
	}

	public void setTestConferenceMock(String testConferenceMock) {
		this.testConferenceMock = testConferenceMock;
	}

	public void setDefaultLogoutUrl(String defaultLogoutUrl) {
		this.defaultLogoutUrl = defaultLogoutUrl;
	}

	public void setDefaultServerUrl(String defaultServerUrl) {
		this.defaultServerUrl = defaultServerUrl;
	}

	public void setDefaultNumDigitsForTelVoice(int defaultNumDigitsForTelVoice) {
		this.defaultNumDigitsForTelVoice = defaultNumDigitsForTelVoice;
	}

	public void setDefaultHTML5ClientUrl(String defaultHTML5ClientUrl) {
		this.defaultHTML5ClientUrl = defaultHTML5ClientUrl;
	}

	public void setDefaultGuestWaitURL(String url) {
		this.defaultGuestWaitURL = url;
        }

	public void setUseDefaultLogo(Boolean value) {
		this.useDefaultLogo = value;
	}

	public void setDefaultLogoURL(String url) {
		this.defaultLogoURL = url;
	}

	public void setAllowRequestsWithoutSession(Boolean allowRequestsWithoutSession) {
		this.allowRequestsWithoutSession = allowRequestsWithoutSession;
	}

	public void setDefaultMeetingDuration(int defaultMeetingDuration) {
		this.defaultMeetingDuration = defaultMeetingDuration;
	}

	public void setDisableRecordingDefault(boolean disabled) {
		this.disableRecordingDefault = disabled;
	}

	public void setAutoStartRecording(boolean start) {
		this.autoStartRecording = start;
	}

    public void setAllowStartStopRecording(boolean allowStartStopRecording) {
        this.allowStartStopRecording = allowStartStopRecording;
    }

    public void setLearningDashboardEnabled(boolean learningDashboardEnabled) {
        this.learningDashboardEnabled = learningDashboardEnabled;
    }

    public void setLearningDashboardCleanupDelayInMinutes(int learningDashboardCleanupDelayInMinutes) {
        this.learningDashboardCleanupDelayInMinutes = learningDashboardCleanupDelayInMinutes;
    }

    public void setWebcamsOnlyForModerator(boolean webcamsOnlyForModerator) {
        this.webcamsOnlyForModerator = webcamsOnlyForModerator;
    }

    public void setDefaultMeetingCameraCap(Integer meetingCameraCap) {
        this.defaultMeetingCameraCap = meetingCameraCap;
    }

    public void setDefaultUserCameraCap(Integer userCameraCap) {
        this.defaultUserCameraCap = userCameraCap;
    }

    public void setDefaultMaxPinnedCameras(Integer maxPinnedCameras) {
        this.defaultMaxPinnedCameras = maxPinnedCameras;
    }

	public void setUseDefaultAvatar(Boolean value) {
		this.useDefaultAvatar = value;
	}

	public void setdefaultAvatarURL(String url) {
		this.defaultAvatarURL = url;
	}

	public void setDefaultGuestPolicy(String guestPolicy) {
		this.defaultGuestPolicy =  guestPolicy;
	}

	public void setAuthenticatedGuest(Boolean value) {
		this.authenticatedGuest = value;
	}

  public void setDefaultMeetingLayout(String meetingLayout) {
		this.defaultMeetingLayout =  meetingLayout;
	}

	public void setClientLogoutTimerInMinutes(Integer value) {
		clientLogoutTimerInMinutes = value;
	}

	public void setMeetingExpireWhenLastUserLeftInMinutes(Integer value) {
        defaultMeetingExpireWhenLastUserLeftInMinutes = value;
	}

	public void setMeetingExpireIfNoUserJoinedInMinutes(Integer value) {
        defaultMeetingExpireIfNoUserJoinedInMinutes = value;
	}

	public Integer getUserInactivityInspectTimerInMinutes() {
        return userInactivityInspectTimerInMinutes;
    }

    public void setUserInactivityInspectTimerInMinutes(Integer userInactivityInspectTimerInMinutes) {
        this.userInactivityInspectTimerInMinutes = userInactivityInspectTimerInMinutes;
    }

    public Integer getUserInactivityThresholdInMinutes() {
        return userInactivityThresholdInMinutes;
    }

    public void setUserInactivityThresholdInMinutes(Integer userInactivityThresholdInMinutes) {
        this.userInactivityThresholdInMinutes = userInactivityThresholdInMinutes;
    }

    public Integer getUserActivitySignResponseDelayInMinutes() {
        return userActivitySignResponseDelayInMinutes;
    }

    public void setUserActivitySignResponseDelayInMinutes(Integer userActivitySignResponseDelayInMinutes) {
        this.userActivitySignResponseDelayInMinutes = userActivitySignResponseDelayInMinutes;
    }

	public void setMaxPresentationFileUpload(Long maxFileSize) {
		maxPresentationFileUpload = maxFileSize;
	}

	public Long getMaxPresentationFileUpload() {
		return maxPresentationFileUpload;
	}

	public void setMuteOnStart(Boolean mute) {
		defaultMuteOnStart = mute;
	}

	public Boolean getMuteOnStart() {
		return defaultMuteOnStart;
	}

	public void setDefaultKeepEvents(Boolean mke) {
		defaultKeepEvents = mke;
	}

	public void setAllowModsToUnmuteUsers(Boolean value) {
		defaultAllowModsToUnmuteUsers = value;
	}

	public Boolean getAllowModsToUnmuteUsers() {
		return defaultAllowModsToUnmuteUsers;
	}

  public void setAllowModsToEjectCameras(Boolean value) {
    defaultAllowModsToEjectCameras = value;
  }

  public Boolean getAllowModsToEjectCameras() {
    return defaultAllowModsToEjectCameras;
  }

	public List<String> decodeIds(String encodeid) {
		ArrayList<String> ids=new ArrayList<>();
		try {
			ids.addAll(Arrays.asList(URLDecoder.decode(encodeid, StandardCharsets.UTF_8.name()).split(URLDECODER_SEPARATOR)));
		} catch (UnsupportedEncodingException e) {
			log.error(""Couldn't decode the IDs"");
		}

		return ids;
	}

    public List<String> convertToInternalMeetingId(List<String> extMeetingIds) {
        ArrayList<String> internalMeetingIds = new ArrayList<>();
        for (String extid : extMeetingIds) {
            internalMeetingIds.add(convertToInternalMeetingId(extid));
        }
        return internalMeetingIds;
    }

    public Map<String, String> getUserCustomData(Map<String, String> params) {
        Map<String, String> resp = new HashMap<>();

        for (String key : params.keySet()) {
            if (key.contains(""userdata"") && key.indexOf(""userdata"") == 0) {
                String[] userdata = key.split(""-"");
                if (userdata.length == 2) {
                    log.debug(""Got user custom data {} = {}"", key, params.get(key));
                    resp.put(userdata[1], params.get(key));
                }
            }
        }

        return resp;
    }

	public Map<String, Map<String, Object>> decodeFilters(String encodedFilters) {
        Map<String, Map<String, Object>> filters = new LinkedHashMap<>();

        try {
            String[] sFilters = encodedFilters.split(URLDECODER_SEPARATOR);
            for( String sFilter: sFilters) {
                String[] filterElements = sFilter.split(FILTERDECODER_SEPARATOR_ELEMENTS, 3);
                Map<String, Object> filter = new LinkedHashMap<>();
                filter.put(""op"", filterElements[1]);
                String[] fValues = filterElements[2].split(FILTERDECODER_SEPARATOR_OPERATORS);
                filter.put(""values"", fValues );
                filters.put(filterElements[0], filter);
            }
        } catch (Exception e) {
            log.error(""Couldn't decode the filters"");
        }

        return filters;
    }

	public void setBreakoutRoomsEnabled(Boolean breakoutRoomsEnabled) {
		this.defaultBreakoutRoomsEnabled = breakoutRoomsEnabled;
	}

	public void setBreakoutRoomsRecord(Boolean breakoutRoomsRecord) {
		this.defaultBreakoutRoomsRecord = breakoutRoomsRecord;
	}

	public void setBreakoutRoomsPrivateChatEnabled(Boolean breakoutRoomsPrivateChatEnabled) {
		this.defaultbreakoutRoomsPrivateChatEnabled = breakoutRoomsPrivateChatEnabled;
	}

	public void setLockSettingsDisableCam(Boolean lockSettingsDisableCam) {
		this.defaultLockSettingsDisableCam = lockSettingsDisableCam;
	}

	public void setLockSettingsDisableMic(Boolean lockSettingsDisableMic) {
		this.defaultLockSettingsDisableMic = lockSettingsDisableMic;
	}

	public void setLockSettingsDisablePrivateChat(Boolean lockSettingsDisablePrivateChat) {
		this.defaultLockSettingsDisablePrivateChat = lockSettingsDisablePrivateChat;
	}

	public void setLockSettingsDisablePublicChat(Boolean lockSettingsDisablePublicChat) {
		this.defaultLockSettingsDisablePublicChat = lockSettingsDisablePublicChat;
	}

	public void setLockSettingsDisableNotes(Boolean lockSettingsDisableNotes) {
		this.defaultLockSettingsDisableNotes = lockSettingsDisableNotes;
	}

	public void setLockSettingsHideUserList(Boolean lockSettingsHideUserList) {
		this.defaultLockSettingsHideUserList = lockSettingsHideUserList;
	}

	public void setLockSettingsLockOnJoin(Boolean lockSettingsLockOnJoin) {
		this.defaultLockSettingsLockOnJoin = lockSettingsLockOnJoin;
	}

	public void setLockSettingsLockOnJoinConfigurable(Boolean lockSettingsLockOnJoinConfigurable) {
		this.defaultLockSettingsLockOnJoinConfigurable = lockSettingsLockOnJoinConfigurable;
	}

	public void setLockSettingsHideViewersCursor(Boolean lockSettingsHideViewersCursor) {
		this.defaultLockSettingsHideViewersCursor = lockSettingsHideViewersCursor;
	}

	public void setAllowDuplicateExtUserid(Boolean allow) {
		this.defaultAllowDuplicateExtUserid = allow;
	}

    public void setMaxUserConcurrentAccesses(Integer maxUserConcurrentAccesses) {
		this.maxUserConcurrentAccesses = maxUserConcurrentAccesses;
	}

	public void setEndWhenNoModerator(Boolean val) {
		this.defaultEndWhenNoModerator = val;
	}

  public void setEndWhenNoModeratorDelayInMinutes(Integer value) {
      this.defaultEndWhenNoModeratorDelayInMinutes = value;
  }

  public void setDisabledFeatures(String disabledFeatures) {
        this.defaultDisabledFeatures = disabledFeatures;
    }

  public void setNotifyRecordingIsOn(Boolean notifyRecordingIsOn) {
      this.defaultNotifyRecordingIsOn = notifyRecordingIsOn;
  }

  public void setPresentationUploadExternalDescription(String presentationUploadExternalDescription) {
    this.defaultPresentationUploadExternalDescription = presentationUploadExternalDescription;
  }

  public void setPresentationUploadExternalUrl(String presentationUploadExternalUrl) {
    this.defaultPresentationUploadExternalUrl = presentationUploadExternalUrl;
  }

  public void setBbbVersion(String version) {
      this.bbbVersion = this.allowRevealOfBBBVersion ? version : """";
  }

  public void setAllowRevealOfBBBVersion(Boolean allowVersion) {
    this.allowRevealOfBBBVersion = allowVersion;
  }

}"
bbb-common-web/src/main/java/org/bigbluebutton/api/util/MeetingsResponse.java,"package org.bigbluebutton.api.util;

import java.util.Collection;

public class MeetingsResponse {

  public final Collection<MeetingResponseDetail> meetings;

  public MeetingsResponse(Collection<MeetingResponseDetail> meetings) {
    this.meetings = meetings;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/util/ParamsUtil.java,"package org.bigbluebutton.api.util;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringEscapeUtils;

public class ParamsUtil {
  private static Logger log = LoggerFactory.getLogger(ParamsUtil.class);

  private static final Pattern VALID_ID_PATTERN = Pattern.compile(""[a-zA-Z][a-zA-Z0-9- ]*$"");

  public static final String INVALID_CHARS = "","";

  public static String stripControlChars(String text) {
    return text.replaceAll(""\\p{Cc}"", """").trim();
  }

  public static String escapeHTMLTags(String value) {
    return StringEscapeUtils.escapeHtml4(value);
  }

  public static boolean isValidMeetingId(String meetingId) {
    //return  VALID_ID_PATTERN.matcher(meetingId).matches();
    return !containsChar(meetingId, INVALID_CHARS);
  }

  public static boolean containsChar(String text, String chars) {
    return StringUtils.containsAny(text, chars);
  }

  public static String getSessionToken(String url) {
    String token = ""undefined"";
    try {
      String decodedURL = URLDecoder.decode(url, ""UTF-8"");
      String[] splitURL = decodedURL.split(""\\?"");
      if (splitURL.length == 2) {
        String params = splitURL[1];
        for (String param : params.split(""\\&"")) {
          if (param.startsWith(""sessionToken="")) {
            token = param.split(""\\="")[1];
          }
        }
      }
    } catch (UnsupportedEncodingException e) {
      log.error(e.toString());
    }
    return token;
  }

  public static String sanitizeString(String inputString) {
    if(inputString == null) {
      return """";
    }

    String sanitizedString = stripControlChars(inputString);
    String trimmedString = sanitizedString.trim();
    return trimmedString;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/util/ResponseBuilder.java,"package org.bigbluebutton.api.util;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.io.StringWriter;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.bigbluebutton.api.domain.Meeting;
import org.bigbluebutton.api.domain.RecordingMetadata;
import org.bigbluebutton.api.domain.UserSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import freemarker.template.TemplateExceptionHandler;

public class ResponseBuilder {
    private static Logger log = LoggerFactory.getLogger(ResponseBuilder.class);

    Configuration cfg = new Configuration(Configuration.VERSION_2_3_23);

    public ResponseBuilder(ClassLoader classLoader, String basePackagePath) {
        cfg.setClassLoaderForTemplateLoading(classLoader, basePackagePath);
        setUpConfiguration();
    }

    public ResponseBuilder(File templatesLoc) {
        try {
            cfg.setDirectoryForTemplateLoading(templatesLoc);
        } catch (IOException e) {
            log.error(""Exception occured creating ResponseBuilder"", e);
        }
        setUpConfiguration();
    }

    private void setUpConfiguration() {
        cfg.setDefaultEncoding(StandardCharsets.UTF_8.name());
        cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
        cfg.setLogTemplateExceptions(false);
    }

    public String formatPrettyDate(Long timestamp) {
        return new Date(timestamp).toString();
    }

    public String buildMeetingVersion(String apiVersion, String bbbVersion, String returnCode) {
        StringWriter xmlText = new StringWriter();

        Map<String, Object> data = new HashMap<String, Object>();
        data.put(""returnCode"", returnCode);
        data.put(""version"", apiVersion);
        data.put(""apiVersion"", apiVersion);
        data.put(""bbbVersion"", bbbVersion);

        processData(getTemplate(""api-version.ftlx""), data, xmlText);

        return xmlText.toString();
    }

    public String buildMeeting(Meeting meeting, String msgKey, String msg, String returnCode) {
        StringWriter xmlText = new StringWriter();

        String createdOn = formatPrettyDate(meeting.getCreateTime());

        Map<String, Object> data = new HashMap<String, Object>();
        data.put(""returnCode"", returnCode);
        data.put(""meeting"", meeting);
        data.put(""createdOn"", createdOn);
        data.put(""msgKey"", msgKey);
        data.put(""msg"", msg);

        processData(getTemplate(""create-meeting.ftlx""), data, xmlText);

        return xmlText.toString();
    }

    public String buildError(String key, String msg, String returnCode) {
        StringWriter xmlText = new StringWriter();

        Map<String, Object> data = new HashMap<String, Object>();
        data.put(""returnCode"", returnCode);
        data.put(""key"", key);
        data.put(""msg"", msg);

        processData(getTemplate(""api-error.ftlx""), data, xmlText);

        return xmlText.toString();
    }

    public String buildErrors(ArrayList erros, String returnCode) {
        StringWriter xmlText = new StringWriter();

        Map<String, Object> data = new HashMap<String, Object>();
        data.put(""returnCode"", returnCode);
        data.put(""errorsList"", erros);

        processData(getTemplate(""api-errors.ftlx""), data, xmlText);

        return xmlText.toString();
    }

    public String buildGetMeetingInfoResponse(Meeting meeting, String returnCode) {
        String createdOn = formatPrettyDate(meeting.getCreateTime());

        StringWriter xmlText = new StringWriter();

        Map<String, Object> data = new HashMap<String, Object>();
        data.put(""returnCode"", returnCode);
        data.put(""createdOn"", createdOn);
        data.put(""meeting"", meeting);

        processData(getTemplate(""get-meeting-info.ftlx""), data, xmlText);

        return xmlText.toString();
    }

    public String buildJoinMeeting(UserSession userSession, String sessionToken, String guestStatusVal, String destUrl,
            String msgKey, String msg, String returnCode) {
        StringWriter xmlText = new StringWriter();

        Map<String, Object> data = new HashMap<String, Object>();
        data.put(""returnCode"", returnCode);
        data.put(""meetingID"", userSession.meetingID);
        data.put(""authToken"", userSession.authToken);
        data.put(""internalUserId"", userSession.internalUserId);
        data.put(""sessionToken"", sessionToken);
        data.put(""guestStatusVal"", guestStatusVal);
        data.put(""destUrl"", destUrl);
        data.put(""msgKey"", msgKey);
        data.put(""msg"", msg);

        processData(getTemplate(""join-meeting.ftlx""), data, xmlText);

        return xmlText.toString();
    }

    public String buildGetMeetingsResponse(Collection<Meeting> meetings, String msgKey, String msg, String returnCode) {

        ArrayList<MeetingResponseDetail> meetingResponseDetails = new ArrayList<MeetingResponseDetail>();

        for (Meeting meeting : meetings) {
            String createdOn = formatPrettyDate(meeting.getCreateTime());
            MeetingResponseDetail details = new MeetingResponseDetail(createdOn, meeting);
            meetingResponseDetails.add(details);
        }

        StringWriter xmlText = new StringWriter();

        Map<String, Serializable> data = new HashMap<String, Serializable>();
        data.put(""returnCode"", returnCode);
        data.put(""meetingDetailsList"", meetingResponseDetails);
        data.put(""msgKey"", msgKey);
        data.put(""msg"", msg);

        processData(getTemplate(""get-meetings.ftlx""), data, xmlText);

        return xmlText.toString();
    }

    public String buildIsMeetingRunning(Boolean isRunning, String returnCode) {
        StringWriter xmlText = new StringWriter();

        Map<String, Object> data = new HashMap<String, Object>();
        data.put(""returnCode"", returnCode);
        data.put(""isRunning"", isRunning);

        processData(getTemplate(""is-meeting-running.ftlx""), data, xmlText);

        return xmlText.toString();
    }

    public String buildEndRunning(String msgKey, String msg, String returnCode) {
        StringWriter xmlText = new StringWriter();

        Map<String, Object> data = new HashMap<String, Object>();
        data.put(""returnCode"", returnCode);
        data.put(""msgKey"", msgKey);
        data.put(""msg"", msg);

        processData(getTemplate(""end-meeting.ftlx""), data, xmlText);

        return xmlText.toString();
    }

    public String buildGetSessionsResponse(Collection<UserSession> sessions, String msgKey, String msg,
            String returnCode) {
        StringWriter xmlText = new StringWriter();

        Map<String, Serializable> data = new HashMap<String, Serializable>();
        data.put(""returnCode"", returnCode);
        data.put(""sessionsList"", new ArrayList<>(sessions));
        data.put(""msgKey"", msgKey);
        data.put(""msg"", msg);

        processData(getTemplate(""get-sessions.ftlx""), data, xmlText);

        return xmlText.toString();
    }

    public String buildGetRecordingsResponse(List<RecordingMetadata> recordings, String returnCode) {

        StringWriter xmlText = new StringWriter();

        Map<String, Object> data = new HashMap<String, Object>();
        data.put(""returnCode"", returnCode);
        data.put(""recordings"", recordings);

        processData(getTemplate(""get-recordings.ftlx""), data, xmlText);
        return xmlText.toString();
    }

    public String buildInsertDocumentResponse(String message, String returnCode) {

        StringWriter xmlText = new StringWriter();

        Map<String, Object> data = new HashMap<String, Object>();
        data.put(""returnCode"", returnCode);
        data.put(""message"", message);

        processData(getTemplate(""insert-document.ftlx""), data, xmlText);

        return xmlText.toString();
    }

    private Template getTemplate(String templateName) {
        Template ftl = null;
        try {
            ftl = cfg.getTemplate(templateName);
        } catch (IOException e) {
            log.error(""IO exception for {} : "", templateName, e);
        }
        return ftl;
    }

    private void processData(Template template, Map data, StringWriter out) {
        try {
            template.process(data, out);
        } catch (TemplateException e) {
            log.error(""Template exception : "", e);
        } catch (IOException e) {
            log.error(""IO exception for get-recordings.ftlx : "", e);
        }
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/util/DataStore.java,"package org.bigbluebutton.api.util;

import org.bigbluebutton.api.model.entity.*;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.*;
import java.util.List;

public class DataStore {

    private static final Logger logger = LoggerFactory.getLogger(DataStore.class);

    private SessionFactory sessionFactory;
    private static DataStore instance;

    private DataStore() {
        openConnection();
    }

    private void openConnection() {
        sessionFactory = new Configuration()
                .configure()
                .addAnnotatedClass(Recording.class)
                .addAnnotatedClass(Metadata.class)
                .addAnnotatedClass(PlaybackFormat.class)
                .addAnnotatedClass(Thumbnail.class)
                .addAnnotatedClass(CallbackData.class)
                .buildSessionFactory();
    }

    public static DataStore getInstance() {
        if(instance == null) {
            instance = new DataStore();
        }
        return instance;
    }

    public <T> void save(T entity) {
        logger.info(""Attempting to save {}"", entity);
        Session session = sessionFactory.openSession();
        Transaction transaction = null;

        try {
            transaction = session.beginTransaction();
            session.saveOrUpdate(entity);
            transaction.commit();
        } catch(Exception e) {
            if(transaction != null) {
                transaction.rollback();
                e.printStackTrace();
            }
        } finally {
            session.close();
        }
    }

    public <T> T find(String id, Class<T> entityClass) {
        logger.info(""Attempting to find {} with ID {}"", entityClass.getSimpleName(), id);
        Session session = sessionFactory.openSession();
        Transaction transaction = null;
        T result = null;

        try {
            transaction = session.beginTransaction();
            result = session.find(entityClass, Long.parseLong(id));
            transaction.commit();
        } catch(Exception e) {
            if(transaction != null) {
                transaction.rollback();

                if(e instanceof NoResultException) logger.info(""No result found."");
                else e.printStackTrace();
            }
        } finally {
            session.close();
        }

        return result;
    }

    public <T> List<T> findAll(Class<T> entityClass) {
        logger.info(""Attempting to fetch all {}"", entityClass.getSimpleName());
        Session session = sessionFactory.openSession();
        Transaction transaction = null;
        List<T> result = null;

        try {
            transaction = session.beginTransaction();
            CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();
            CriteriaQuery<T> criteriaQuery = criteriaBuilder.createQuery(entityClass);
            Root<T> root = criteriaQuery.from(entityClass);
            CriteriaQuery<T> allEntities = criteriaQuery.select(root);
            result = session.createQuery(allEntities).getResultList();
        } catch(Exception e) {
            if(transaction != null) {
                transaction.rollback();

                if(e instanceof NoResultException) logger.info(""No result found."");
                else e.printStackTrace();
            }
        } finally {
            session.close();
        }

        return result;
    }

    public Recording findRecordingByRecordId(String recordId) {
        logger.info(""Attempting to find recording with recordId {}"", recordId);
        Session session = sessionFactory.openSession();
        Transaction transaction = null;
        Recording result = null;

        try {
            transaction = session.beginTransaction();
            CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();
            CriteriaQuery<Recording> criteriaQuery = criteriaBuilder.createQuery(Recording.class);
            Root<Recording> recordingRoot = criteriaQuery.from(Recording.class);
            criteriaQuery.where(criteriaBuilder.equal(recordingRoot.get(""recordId""), recordId));
            result = session.createQuery(criteriaQuery).getSingleResult();
            transaction.commit();
        } catch(Exception e) {
            if(transaction != null) {
                transaction.rollback();

                if(e instanceof NoResultException) logger.info(""No result found."");
                else e.printStackTrace();
            }
        } finally {
            session.close();
        }

        return result;
    }

    public List<Recording> findRecordingsByMeetingId(String meetingId) {
        logger.info(""Attempting to find recordings with meetingID {}"", meetingId);
        Session session = sessionFactory.openSession();
        Transaction transaction = null;
        List<Recording> result = null;

        try {
            transaction = session.beginTransaction();
            CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();
            CriteriaQuery<Recording> criteriaQuery = criteriaBuilder.createQuery(Recording.class);
            Root<Recording> recordingRoot = criteriaQuery.from(Recording.class);
            criteriaQuery.where(criteriaBuilder.equal(recordingRoot.get(""meetingId""), meetingId));
            result = session.createQuery(criteriaQuery).getResultList();
            transaction.commit();
        } catch(Exception e) {
            if(transaction != null) {
                transaction.rollback();

                if(e instanceof NoResultException) logger.info(""No results found."");
                else e.printStackTrace();
            }
        } finally {
            session.close();
        }

        return result;
    }

    public List<Recording> findRecordingsByState(String state) {
        logger.info(""Attempting to find recordings with state {}"", state);
        Session session = sessionFactory.openSession();
        Transaction transaction = null;
        List<Recording> result = null;

        try {
            transaction = session.beginTransaction();
            CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();
            CriteriaQuery<Recording> criteriaQuery = criteriaBuilder.createQuery(Recording.class);
            Root<Recording> recordingRoot = criteriaQuery.from(Recording.class);
            criteriaQuery.where(criteriaBuilder.equal(recordingRoot.get(""state""), state));
            result = session.createQuery(criteriaQuery).getResultList();
            transaction.commit();
        } catch(Exception e) {
            if(transaction != null) {
                transaction.rollback();

                if(e instanceof NoResultException) logger.info(""No results found."");
                else e.printStackTrace();
            }
        } finally {
            session.close();
        }

        return result;
    }

    public List<Metadata> findMetadataByFilter(String key, String value) {
        logger.info(""Attempting to find metadata with key {} and value {}"", key, value);
        Session session = sessionFactory.openSession();
        Transaction transaction = null;
        List<Metadata> result = null;

        try {
            transaction = session.beginTransaction();
            CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();
            CriteriaQuery<Metadata> criteriaQuery = criteriaBuilder.createQuery(Metadata.class);
            Root<Metadata> metadataRoot = criteriaQuery.from(Metadata.class);
            Predicate predicateForKey = criteriaBuilder.equal(metadataRoot.get(""key""), key);
            Predicate predicateForValue = criteriaBuilder.equal(metadataRoot.get(""value""), value);
            criteriaQuery.where(criteriaBuilder.and(predicateForKey, predicateForValue));
            result = session.createQuery(criteriaQuery).getResultList();
            transaction.commit();
        } catch(Exception e) {
            if(transaction != null) {
                transaction.rollback();

                if(e instanceof NoResultException) logger.info(""No result found."");
                else e.printStackTrace();
            }
        } finally {
            session.close();
        }

        return result;
    }

    public <T> void delete(T entity) {
        logger.info(""Attempting to delete {}"", entity);
        Session session = sessionFactory.openSession();
        Transaction transaction = null;

        try {
            transaction = session.beginTransaction();
            session.delete(entity);
            transaction.commit();
        } catch(Exception e) {
            if(transaction != null) {
                transaction.rollback();
                e.printStackTrace();
            }
        } finally {
            session.close();
        }
    }

    public void truncateTables() {
        logger.info(""Attempting to truncate tables"");

        List<Recording> recordings = findAll(Recording.class);

        if(recordings != null) {
            for(Recording recording: recordings) {
                delete(recording);
            }
        }
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/util/HTML5ProcessLine.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2020 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */

package org.bigbluebutton.api.util;

public class HTML5ProcessLine {

    public int instanceId;
    public double percentageCPU;

    public static final String BBB_HTML5_PROCESS_IDENTIFIER = ""NODEJS_BACKEND_INSTANCE_ID"";

    public HTML5ProcessLine(String input) {
        // $ ps -u meteor -o pcpu,cmd= | grep NODEJS_BACKEND_INSTANCE_ID
        // 1.1 /usr/lib/bbb-html5/node/bin/node --max-old-space-size=2048 --max_semi_space_size=128 main.js NODEJS_BACKEND_INSTANCE_ID=1
        // 1.0 /usr/lib/bbb-html5/node/bin/node --max-old-space-size=2048 --max_semi_space_size=128 main.js NODEJS_BACKEND_INSTANCE_ID=2

        String[] a = input.trim().split("" "");
        this.percentageCPU = Double.parseDouble(a[0]);

        for (int i = 0; i < a.length; i++) {
            if (a[i].toString().indexOf(BBB_HTML5_PROCESS_IDENTIFIER) > -1) {
                this.instanceId = Integer.parseInt(a[i].replace(BBB_HTML5_PROCESS_IDENTIFIER + ""="", """"));
            }
        }
    }

    public String toString() {
        return ""instanceId:"" + this.instanceId + "" CPU:"" + this.percentageCPU;
    }


}"
bbb-common-web/src/main/java/org/bigbluebutton/api/util/RecordingMetadataReaderHelper.java,"package org.bigbluebutton.api.util;

import java.io.File;
import java.util.ArrayList;

import org.bigbluebutton.api.domain.RecordingMetadata;
import org.bigbluebutton.api2.RecordingServiceGW;
import org.bigbluebutton.api2.domain.UploadedTrack;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import scala.Option;

public class RecordingMetadataReaderHelper {
  private static Logger log = LoggerFactory.getLogger(RecordingMetadataReaderHelper.class);

  private RecordingServiceGW recordingServiceGW;

  public Boolean validateTextTrackSingleUseToken(String recordId, String caption, String token) {
    return recordingServiceGW.validateTextTrackSingleUseToken(recordId, caption, token);
  }

  public String getRecordingTextTracks(String recordId, String captionsDir, String captionsBaseUrl) {
    return recordingServiceGW.getRecordingTextTracks(recordId, captionsDir, captionsBaseUrl);
  }

  public String putRecordingTextTrack(UploadedTrack track) {
    return recordingServiceGW.putRecordingTextTrack(track);
  }

  public String getRecordings2x(ArrayList<RecordingMetadata> recs) {
    return recordingServiceGW.getRecordings2x(recs);
  }

  public RecordingMetadata getRecordingMetadata(File metadataXml) {

    RecordingMetadata recMeta = null;

    Option<RecordingMetadata> rm = recordingServiceGW.getRecordingMetadata(metadataXml);
    if (rm.isDefined()) {
      return rm.get();
    }

    return recMeta;
  }

  public File getMetadataXmlLocation(String destDir) {
    return new File(destDir + File.separatorChar + ""metadata.xml"");
  }

  public boolean saveRecordingMetadata(File metadataXml, RecordingMetadata recordingMetadata) {
    return recordingServiceGW.saveRecordingMetadata(metadataXml, recordingMetadata);
  }

  public void setRecordingServiceGW(RecordingServiceGW recordingServiceGW) {
    this.recordingServiceGW = recordingServiceGW;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/util/MeetingResponseDetail.java,"package org.bigbluebutton.api.util;


import org.bigbluebutton.api.domain.Meeting;

public class MeetingResponseDetail {

  private final String createdOn;
  private final Meeting meeting;

  public MeetingResponseDetail(String createdOn, Meeting meeting) {
    this.createdOn = createdOn;
    this.meeting = meeting;
  }

  public String getCreatedOn() {
    return createdOn;
  }

  public Meeting getMeeting() {
    return meeting;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/ApiErrors.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
*
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.api;

import java.util.ArrayList;

public class ApiErrors {
	private ArrayList<String[]> errors = new ArrayList<String[]>();

	public void missingParamError(String param) {
		errors.add(new String[] {""MissingParam"", ""You did not pass a "" + param + "" parameter.""});
	}

	public void checksumError() {
		errors.add( new String[] {""checksumError"", ""You did not pass the checksum security check""});
	}

	public void nonUniqueMeetingIdError() {
		errors.add(new String[] {""NotUniqueMeetingID"", ""A meeting already exists with that meeting ID.  Please use a different meeting ID.""});
	}

	public void nonUniqueVoiceBridgeError() {
		errors.add(new String[] {""nonUniqueVoiceBridge"", ""The selected voice bridge is already in use.""});
	}

	public void invalidMeetingIdError() {
		errors.add(new String[] {""invalidMeetingId"", ""The meeting ID that you supplied did not match any existing meetings""});
	}

	public void meetingForciblyEndedError() {
		errors.add(new String[] {""meetingForciblyEnded"", ""You can not re-join a meeting that has already been forcibly ended.""});
	}

	public void invalidPasswordError() {
		errors.add(new String[] {""invalidPassword"", ""The password you submitted is not valid.""});
	}

	public void mismatchCreateTimeParam() {
		errors.add(new String[] {""mismatchCreateTime"", ""The createTime parameter submitted mismatches with the current meeting.""});
	}

	public void recordingNotFound() {
		errors.add(new String[] {""recordingNotFound"", ""We could not find a recording with that recordID.""});
	}

	public void noConfigFoundForToken(String token) {
		errors.add(new String[] {""configNotFound"", ""We could not find a config for token ["" + token + ""].""});
	}

	public void noConfigFound() {
		errors.add(new String[] {""noConfigFound"", ""We could not find a config for this request.""});
	}

	public void maxParticipantsReached() {
		errors.add(new String[] {""maxParticipantsReached"", ""The number of participants allowed for this meeting has been reached.""});
	}

	public void guestDeniedAccess() {
		errors.add(new String[] {""guestDeniedAccess"", ""You have been denied access to this meeting based on the meeting's guest policy""});
	}

	public void addError(String[] error) {
		errors.add(error);
	}

	public boolean hasErrors() {
		return !errors.isEmpty();
	}

	public ArrayList<String[]> getErrors() {
		return errors;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/LearningDashboardService.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 *
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 *
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.bigbluebutton.api;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileOutputStream;
import java.util.Calendar;

public class LearningDashboardService {
    private static Logger log = LoggerFactory.getLogger(LearningDashboardService.class);
    private static String learningDashboardFilesDir = ""/var/bigbluebutton/learning-dashboard"";

    public File getJsonDataFile(String meetingId, String learningDashboardAccessToken) {
        File baseDir = new File(this.getDestinationBaseDirectoryName(meetingId,learningDashboardAccessToken));
        if (!baseDir.exists()) baseDir.mkdirs();

        File jsonFile = new File(baseDir.getAbsolutePath() + File.separatorChar + ""learning_dashboard_data.json"");
        return jsonFile;
    }

    public void writeJsonDataFile(String meetingId, String learningDashboardAccessToken, String activityJson) {

        try {
            if(learningDashboardAccessToken.length() == 0) {
                log.error(""LearningDashboard AccessToken not found. JSON file will not be saved for meeting {}."",meetingId);
                return;
            }

            File jsonFile = this.getJsonDataFile(meetingId,learningDashboardAccessToken);

            FileOutputStream fileOutput = new FileOutputStream(jsonFile);
            fileOutput.write(activityJson.getBytes());

            fileOutput.close();

            log.info(""Learning Dashboard ({}) updated for meeting {}."",jsonFile.getAbsolutePath(),meetingId);
        } catch(Exception e) {
            System.out.println(e);
        }
    }

    public void removeJsonDataFile(String meetingId, int cleanUpDelayMinutes) {

        Calendar cleanUpDelayCalendar = Calendar.getInstance();
        cleanUpDelayCalendar.add(Calendar.MINUTE, cleanUpDelayMinutes);

        //Delay `cleanUpDelayMinutes` then moderators can open the Dashboard before files has been removed
        new java.util.Timer().schedule(
                new java.util.TimerTask() {
                    @Override
                    public void run() {
                        File ldMeetingFilesDir = new File(learningDashboardFilesDir + File.separatorChar + meetingId);
                        LearningDashboardService.deleteDirectory(ldMeetingFilesDir);
                        log.info(""Learning Dashboard files removed for meeting {}."",meetingId);
                    }
                }, cleanUpDelayCalendar.getTime()
        );
    }

    private String getDestinationBaseDirectoryName(String meetingId, String learningDashboardAccessToken) {
        return learningDashboardFilesDir + File.separatorChar + meetingId + File.separatorChar + learningDashboardAccessToken;
    }

    private static void deleteDirectory(File directory) {
        /**
         * Go through each directory and check if it's not empty. We need to
         * delete files inside a directory before a directory can be deleted.
         **/
        File[] files = directory.listFiles();
        for (File file : files) {
            if (file.isDirectory()) {
                deleteDirectory(file);
            } else {
                file.delete();
            }
        }
        // Now that the directory is empty. Delete it.
        directory.delete();
    }

    public void setLearningDashboardFilesDir(String dir) {
        learningDashboardFilesDir = dir;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/RequestWithChecksum.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.shared.Checksum;

import javax.validation.Valid;
import java.util.Map;

public abstract class RequestWithChecksum<P extends Enum<P> & RequestParameters> implements Request<P> {

    @Valid
    protected Checksum checksum;

    protected RequestWithChecksum(Checksum checksum) {
        this.checksum = checksum;
    }

    public Checksum getChecksum() {
        return checksum;
    }

    public void setChecksum(Checksum checksum) {
        this.checksum = checksum;
    }

    public abstract void populateFromParamsMap(Map<String, String[]> params);

    public void convertParamsFromString() {

    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/MeetingRunning.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.constraint.MeetingIDConstraint;
import org.bigbluebutton.api.model.shared.Checksum;

import java.util.Map;

public class MeetingRunning extends RequestWithChecksum<MeetingRunning.Params> {

    public enum Params implements RequestParameters {
        MEETING_ID(""meetingID"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    @MeetingIDConstraint
    private String meetingID;

    public MeetingRunning(Checksum checksum) {
        super(checksum);
    }

    public String getMeetingID() {
        return meetingID;
    }

    public void setMeetingID(String meetingID) {
        this.meetingID = meetingID;
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {
        if(params.containsKey(Params.MEETING_ID.getValue())) setMeetingID(params.get(Params.MEETING_ID.getValue())[0]);
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/JoinMeeting.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.constraint.*;
import org.bigbluebutton.api.model.shared.Checksum;
import org.bigbluebutton.api.model.shared.JoinPassword;
import org.bigbluebutton.api.model.shared.Password;

import javax.validation.Valid;
import java.util.Map;

public class JoinMeeting extends RequestWithChecksum<JoinMeeting.Params> {

    public enum Params implements RequestParameters {
        MEETING_ID(""meetingID""),
        USER_ID(""userID""),
        FULL_NAME(""fullName""),
        PASSWORD(""password""),
        GUEST(""guest""),
        AUTH(""auth""),
        CREATE_TIME(""createTime""),
        ROLE(""role"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    @MeetingIDConstraint
    @MeetingExistsConstraint(key = ""invalidMeetingIdentifier"")
    @MeetingEndedConstraint
    private String meetingID;

    private String userID;

    @NotEmpty(key = ""missingParamFullName"", message = ""You must provide your name"")
    private String fullName;

    @PasswordConstraint
    private String password;

    @IsBooleanConstraint(message = ""Guest must be a boolean value (true or false)"")
    private String guestString;
    private Boolean guest;

    @IsBooleanConstraint(message = ""Auth must be a boolean value (true or false)"")
    private String authString;
    private Boolean auth;

    @IsIntegralConstraint
    private String createTimeString;
    private Long createTime;

    private String role;

    @Valid
    private Password joinPassword;

    public JoinMeeting(Checksum checksum) {
        super(checksum);
        joinPassword = new JoinPassword();
    }

    public String getMeetingID() {
        return meetingID;
    }

    public void setMeetingID(String meetingID) {
        this.meetingID = meetingID;
    }

    public String getUserID() {
        return userID;
    }

    public void setUserID(String userID) {
        this.userID = userID;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public void setGuestString(String guestString) { this.guestString = guestString; }

    public Boolean getGuest() {
        return guest;
    }

    public void setGuest(Boolean guest) {
        this.guest = guest;
    }

    public void setAuthString(String authString) { this.authString = authString; }

    public Boolean getAuth() {
        return auth;
    }

    public void setAuth(Boolean auth) {
        this.auth = auth;
    }

    public void setCreateTimeString(String createTimeString) { this.createTimeString = createTimeString; }

    public Long getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Long createTime) {
        this.createTime = createTime;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {
        if(params.containsKey(Params.MEETING_ID.getValue())) {
            setMeetingID(params.get(Params.MEETING_ID.getValue())[0]);
            joinPassword.setMeetingID(meetingID);
        }

        if(params.containsKey(Params.USER_ID.getValue())) setUserID(params.get(Params.USER_ID.getValue())[0]);
        if(params.containsKey(Params.FULL_NAME.getValue())) setFullName(params.get(Params.FULL_NAME.getValue())[0]);

        if(params.containsKey(Params.PASSWORD.getValue())) {
            setPassword(params.get(Params.PASSWORD.getValue())[0]);
            joinPassword.setPassword(password);
        }


        if(params.containsKey(Params.GUEST.getValue())) setGuestString(params.get(Params.GUEST.getValue())[0]);
        if(params.containsKey(Params.AUTH.getValue())) setAuthString(params.get(Params.AUTH.getValue())[0]);
        if(params.containsKey(Params.CREATE_TIME.getValue())) setCreateTimeString(params.get(Params.CREATE_TIME.getValue())[0]);
        if(params.containsKey(Params.ROLE.getValue())) setRole(params.get(Params.ROLE.getValue())[0]);
    }

    @Override
    public void convertParamsFromString() {
        guest = Boolean.parseBoolean(guestString);
        auth = Boolean.parseBoolean(authString);

        if(createTimeString != null) {
            createTime = Long.parseLong(createTimeString);
        }
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/InsertDocument.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.constraint.*;
import org.bigbluebutton.api.model.shared.Checksum;

import java.util.Map;


public class InsertDocument extends RequestWithChecksum<InsertDocument.Params> {

    public enum Params implements RequestParameters {
        MEETING_ID(""meetingID"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    @MeetingIDConstraint
    private String meetingID;

    public InsertDocument(Checksum checksum) {
        super(checksum);
    }

    public String getMeetingID() {
        return meetingID;
    }

    public void setMeetingID(String meetingID) {
        this.meetingID = meetingID;
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {
        if(params.containsKey(Params.MEETING_ID.getValue())) setMeetingID(params.get(Params.MEETING_ID.getValue())[0]);
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/Request.java,"package org.bigbluebutton.api.model.request;

import java.util.Map;

public interface Request<P extends Enum<P> & RequestParameters> {

    void populateFromParamsMap(Map<String, String[]> params);
    void convertParamsFromString();
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/RequestParameters.java,"package org.bigbluebutton.api.model.request;

public interface RequestParameters {

    String getValue();
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/EndMeeting.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.constraint.MeetingExistsConstraint;
import org.bigbluebutton.api.model.constraint.MeetingIDConstraint;
import org.bigbluebutton.api.model.constraint.NotEmpty;
import org.bigbluebutton.api.model.constraint.PasswordConstraint;
import org.bigbluebutton.api.model.shared.Checksum;
import org.bigbluebutton.api.model.shared.ModeratorPassword;
import org.bigbluebutton.api.model.shared.Password;

import javax.validation.Valid;
import java.util.Map;

public class EndMeeting extends RequestWithChecksum<EndMeeting.Params> {

    public enum Params implements RequestParameters {
        MEETING_ID(""meetingID""),
        PASSWORD(""password"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    @MeetingIDConstraint
    @MeetingExistsConstraint
    private String meetingID;

    @PasswordConstraint
    private String password;

    @Valid
    private Password moderatorPassword;

    public EndMeeting(Checksum checksum) {
        super(checksum);
        moderatorPassword = new ModeratorPassword();
    }

    public String getMeetingID() {
        return meetingID;
    }

    public void setMeetingID(String meetingID) {
        this.meetingID = meetingID;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {
        if(params.containsKey(Params.MEETING_ID.getValue())) {
            setMeetingID(params.get(Params.MEETING_ID.getValue())[0]);
            moderatorPassword.setMeetingID(meetingID);
        }

        if(params.containsKey(Params.PASSWORD.getValue())) {
            setPassword(params.get(Params.PASSWORD.getValue())[0]);
            moderatorPassword.setPassword(password);
        }
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/SignOut.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.constraint.UserSessionConstraint;

import javax.validation.constraints.NotNull;
import java.util.Map;

public class SignOut implements Request<SignOut.Params> {

    public enum Params implements RequestParameters {
        SESSION_TOKEN(""sessionToken"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    @UserSessionConstraint
    private String sessionToken;

    public String getSessionToken() {
        return sessionToken;
    }

    public void setSessionToken(String sessionToken) {
        this.sessionToken = sessionToken;
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {
        if(params.containsKey(Enter.Params.SESSION_TOKEN.getValue())) setSessionToken(params.get(Enter.Params.SESSION_TOKEN.getValue())[0]);
    }

    @Override
    public void convertParamsFromString() {

    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/MeetingInfo.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.constraint.MeetingExistsConstraint;
import org.bigbluebutton.api.model.constraint.MeetingIDConstraint;
import org.bigbluebutton.api.model.shared.Checksum;

import java.util.Map;

public class MeetingInfo extends RequestWithChecksum<MeetingInfo.Params> {

    public enum Params implements RequestParameters {
        MEETING_ID(""meetingID"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    @MeetingIDConstraint
    @MeetingExistsConstraint
    private String meetingID;

    public MeetingInfo(Checksum checksum) {
        super(checksum);
    }

    public String getMeetingID() {
        return meetingID;
    }

    public void setMeetingID(String meetingID) {
        this.meetingID = meetingID;
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {
        if(params.containsKey(Params.MEETING_ID.getValue())) {
            setMeetingID(params.get(Params.MEETING_ID.getValue())[0]);
        }
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/GetJoinUrl.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.constraint.UserSessionConstraint;

import java.util.Map;

public class GetJoinUrl implements Request<GetJoinUrl.Params> {

    public enum Params implements RequestParameters {
        SESSION_TOKEN(""sessionToken"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    @UserSessionConstraint
    private String sessionToken;

    public String getSessionToken() {
        return sessionToken;
    }

    public void setSessionToken(String sessionToken) {
        this.sessionToken = sessionToken;
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {
        if(params.containsKey(GetJoinUrl.Params.SESSION_TOKEN.getValue())) setSessionToken(params.get(GetJoinUrl.Params.SESSION_TOKEN.getValue())[0]);
    }

    @Override
    public void convertParamsFromString() {

    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/CreateMeeting.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.constraint.*;
import org.bigbluebutton.api.model.shared.Checksum;

import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;
import java.util.Map;

public class CreateMeeting extends RequestWithChecksum<CreateMeeting.Params> {

    public enum Params implements RequestParameters {
        NAME(""name""),
        MEETING_ID(""meetingID""),
        VOICE_BRIDGE(""voiceBridge""),
        ATTENDEE_PW(""attendeePW""),
        MODERATOR_PW(""moderatorPW""),
        IS_BREAKOUT_ROOM(""isBreakoutRoom""),
        RECORD(""record"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    @MeetingNameConstraint
    private String name;

    @MeetingIDConstraint
    private String meetingID;

    @IsIntegralConstraint(message = ""Voice bridge must be an integral value"")
    private String voiceBridgeString;
    private Integer voiceBridge;

    @PasswordConstraint
    private String attendeePW;

    @PasswordConstraint
    private String moderatorPW;

    //@NotEmpty(message = ""You must provide whether this meeting is breakout room"")
    @IsBooleanConstraint(message = ""You must provide a boolean value (true or false) for the breakout room"")
    private String isBreakoutRoomString;
    private Boolean isBreakoutRoom;

    //@NotEmpty(message = ""You must provide whether to record this meeting"")
    @IsBooleanConstraint(message = ""Record must be a boolean value (true or false)"")
    private String recordString;
    private Boolean record;

    public CreateMeeting(Checksum checksum) {
        super(checksum);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getMeetingID() {
        return meetingID;
    }

    public void setMeetingID(String meetingID) {
        this.meetingID = meetingID;
    }

    public String getVoiceBridgeString() {
        return voiceBridgeString;
    }

    public void setVoiceBridgeString(String voiceBridgeString) {
        this.voiceBridgeString = voiceBridgeString;
    }

    public Integer getVoiceBridge() { return voiceBridge; }

    public void setVoiceBridge(Integer voiceBridge) { this.voiceBridge = voiceBridge; }

    public String getAttendeePW() {
        return attendeePW;
    }

    public void setAttendeePW(String attendeePW) {
        this.attendeePW = attendeePW;
    }

    public String getModeratorPW() {
        return moderatorPW;
    }

    public void setModeratorPW(String moderatorPW) {
        this.moderatorPW = moderatorPW;
    }

    public void setBreakoutRoomString(String breakoutRoomString) { isBreakoutRoomString = breakoutRoomString; }

    public Boolean isBreakoutRoom() {
        return isBreakoutRoom;
    }

    public void setBreakoutRoom(boolean breakoutRoom) {
        isBreakoutRoom = breakoutRoom;
    }

    public void setRecordString(String recordString) { this.recordString = recordString; }

    public Boolean isRecord() {
        return record;
    }

    public void setRecord(boolean record) {
        this.record = record;
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {
        if(params.containsKey(Params.NAME.getValue())) setName(params.get(Params.NAME.getValue())[0]);
        if(params.containsKey(Params.MEETING_ID.getValue())) setMeetingID(params.get(Params.MEETING_ID.getValue())[0]);
        if(params.containsKey(Params.VOICE_BRIDGE.getValue())) setVoiceBridgeString(params.get(Params.VOICE_BRIDGE.getValue())[0]);
        if(params.containsKey(Params.ATTENDEE_PW.getValue())) setAttendeePW(params.get(Params.ATTENDEE_PW.getValue())[0]);
        if(params.containsKey(Params.MODERATOR_PW.getValue())) setModeratorPW(params.get(Params.MODERATOR_PW.getValue())[0]);
        if(params.containsKey(Params.IS_BREAKOUT_ROOM.getValue())) setBreakoutRoomString(params.get(Params.IS_BREAKOUT_ROOM.value)[0]);
        if(params.containsKey(Params.RECORD.getValue())) setRecordString(params.get(Params.RECORD.getValue())[0]);
    }

    @Override
    public void convertParamsFromString() {
        if (voiceBridge != null) {
            voiceBridge = Integer.parseInt(voiceBridgeString);
        }
        isBreakoutRoom = Boolean.parseBoolean(isBreakoutRoomString);
        record = Boolean.parseBoolean(recordString);
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/LearningDashboard.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.constraint.UserSessionConstraint;

import javax.validation.constraints.NotNull;
import java.util.Map;

public class LearningDashboard implements Request<LearningDashboard.Params> {

    public enum Params implements RequestParameters {
        SESSION_TOKEN(""sessionToken"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    @UserSessionConstraint
    private String sessionToken;

    public String getSessionToken() {
        return sessionToken;
    }

    public void setSessionToken(String sessionToken) {
        this.sessionToken = sessionToken;
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {
        if(params.containsKey(LearningDashboard.Params.SESSION_TOKEN.getValue())) setSessionToken(params.get(LearningDashboard.Params.SESSION_TOKEN.getValue())[0]);
    }

    @Override
    public void convertParamsFromString() {

    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/GuestWait.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.constraint.MeetingEndedConstraint;
import org.bigbluebutton.api.model.constraint.MeetingExistsConstraint;
import org.bigbluebutton.api.model.constraint.UserSessionConstraint;
import org.bigbluebutton.api.service.SessionService;

import javax.validation.constraints.NotNull;
import java.util.Map;

public class GuestWait implements Request<GuestWait.Params> {

    public enum Params implements RequestParameters {
        SESSION_TOKEN(""sessionToken"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    @UserSessionConstraint
    private String sessionToken;

    @MeetingExistsConstraint
    @MeetingEndedConstraint
    private String meetingID;

    private SessionService sessionService;

    public GuestWait() {
        sessionService = new SessionService();
    }

    public String getSessionToken() {
        return sessionToken;
    }

    public void setSessionToken(String sessionToken) {
        this.sessionToken = sessionToken;
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {
        if(params.containsKey(Params.SESSION_TOKEN.getValue())) {
            setSessionToken(params.get(Params.SESSION_TOKEN.getValue())[0]);
            sessionService.setSessionToken(sessionToken);
            meetingID = sessionService.getMeetingID();
        }
    }

    @Override
    public void convertParamsFromString() {

    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/Stuns.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.constraint.*;
import org.bigbluebutton.api.service.SessionService;

import java.util.Map;

public class Stuns implements Request<Stuns.Params> {

    public enum Params implements RequestParameters {
        SESSION_TOKEN(""sessionToken"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    @UserSessionConstraint
    private String sessionToken;

    @MeetingExistsConstraint
    @MeetingEndedConstraint
    private String meetingID;

    private SessionService sessionService;

    public Stuns() { sessionService = new SessionService(); }

    public String getSessionToken() {
        return sessionToken;
    }

    public void setSessionToken(String sessionToken) {
        this.sessionToken = sessionToken;
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {
        if(params.containsKey(Enter.Params.SESSION_TOKEN.getValue())) {
            setSessionToken(params.get(Enter.Params.SESSION_TOKEN.getValue())[0]);
            sessionService.setSessionToken(sessionToken);
            meetingID = sessionService.getMeetingID();
        }
    }

    @Override
    public void convertParamsFromString() {

    }

}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/Enter.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.constraint.*;
import org.bigbluebutton.api.service.SessionService;
import javax.validation.constraints.NotNull;
import java.util.Map;

public class Enter implements Request<Enter.Params> {

    public enum Params implements RequestParameters {
        SESSION_TOKEN(""sessionToken"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    @UserSessionConstraint
    @GuestPolicyConstraint
    private String sessionToken;

    @MeetingExistsConstraint
    @MeetingEndedConstraint
    private String meetingID;

    private SessionService sessionService;

    public Enter() {
        sessionService = new SessionService();
    }

    public String getSessionToken() {
        return sessionToken;
    }

    public void setSessionToken(String sessionToken) {
        this.sessionToken = sessionToken;
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {
        if(params.containsKey(Params.SESSION_TOKEN.getValue())) {
            setSessionToken(params.get(Params.SESSION_TOKEN.getValue())[0]);
            sessionService.setSessionToken(sessionToken);
            meetingID = sessionService.getMeetingID();
        }
    }

    @Override
    public void convertParamsFromString() {

    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/request/SimpleRequest.java,"package org.bigbluebutton.api.model.request;

import org.bigbluebutton.api.model.shared.Checksum;

import java.util.Map;

public class SimpleRequest extends RequestWithChecksum<SimpleRequest.Params> {

    public enum Params implements RequestParameters {
        NONE(""none"");

        private final String value;

        Params(String value) { this.value = value; }

        public String getValue() { return value; }
    }

    public SimpleRequest(Checksum checksum) {
        super(checksum);
    }

    @Override
    public void populateFromParamsMap(Map<String, String[]> params) {}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/GuestPolicyConstraint.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.validator.GuestPolicyValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Constraint(validatedBy = { GuestPolicyValidator.class })
@Target(FIELD)
@Retention(RUNTIME)
public @interface GuestPolicyConstraint {

    String key() default ""guestDeny"";
    String message() default ""User denied access for this session"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/MeetingEndedConstraint.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.validator.MeetingEndedValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Constraint(validatedBy = MeetingEndedValidator.class)
@Target(FIELD)
@Retention(RUNTIME)
public @interface MeetingEndedConstraint {

    String key() default ""meetingForciblyEnded"";
    String message() default ""You can not join a meeting that has already been forcibly ended"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/UserSessionConstraint.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.validator.UserSessionValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@NotNull(key = ""missingToken"", message = ""You must provide a session token"")
@Constraint(validatedBy = { UserSessionValidator.class })
@Target(FIELD)
@Retention(RUNTIME)
public @interface UserSessionConstraint {

    String key() default ""missingSession"";
    String message() default ""Invalid session token"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/PasswordConstraint.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.validator.PasswordValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Constraint(validatedBy = {PasswordValidator.class})
@Target(FIELD)
@Retention(RUNTIME)
public @interface PasswordConstraint {

    String key() default ""invalidPassword"";
    String message() default ""Invalid password"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/MeetingExistsConstraint.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.validator.MeetingExistsValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Constraint(validatedBy = MeetingExistsValidator.class)
@Target(FIELD)
@Retention(RUNTIME)
public @interface MeetingExistsConstraint {

    String key() default ""notFound"";
    String message() default ""A meeting with that ID does not exist"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/NotEmpty.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.constraint.list.NotEmptyList;
import org.bigbluebutton.api.model.validator.NotEmptyValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.*;

@Constraint(validatedBy = NotEmptyValidator.class)
@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(NotEmptyList.class)
public @interface NotEmpty {

    String key() default ""emptyError"";
    String message() default ""Field must contain a value"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/GetChecksumConstraint.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.validator.GetChecksumValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Constraint(validatedBy = GetChecksumValidator.class)
@Target(TYPE)
@Retention(RUNTIME)
public @interface GetChecksumConstraint {

    String key() default ""checksumError"";
    String message() default ""Checksums do not match"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/NotNull.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.constraint.list.NotNullList;
import org.bigbluebutton.api.model.validator.NotNullValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.*;

@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(NotNullList.class)
@Constraint(validatedBy = NotNullValidator.class)
public @interface NotNull {

    String key() default ""nullError"";
    String message() default ""Value cannot be null"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/Pattern.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.constraint.list.PatternList;
import org.bigbluebutton.api.model.validator.PatternValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.*;

@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(PatternList.class)
@Constraint(validatedBy = PatternValidator.class)
public @interface Pattern {

    String regexp();
    Flag[] flags() default {};
    String key() default ""validationError"";
    String message() default ""Value contains invalid characters"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};

    enum Flag {
        UNIX_LINES(1),
        CASE_INSENSITIVE(2),
        COMMENTS(4),
        MULTILINE(8),
        DOTALL(32),
        UNICODE_CASE(64),
        CANON_EQ(128);

        private final int value;

        private Flag(int value) {
            this.value = value;
        }

        public int getValue() {
            return this.value;
        }
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/IsBooleanConstraint.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.validator.IsBooleanValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Constraint(validatedBy = IsBooleanValidator.class)
@Target(FIELD)
@Retention(RUNTIME)
public @interface IsBooleanConstraint {

    String key() default ""validationError"";
    String message() default ""Value must be a boolean"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/PostChecksumConstraint.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.validator.PostChecksumValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Constraint(validatedBy = PostChecksumValidator.class)
@Target(TYPE)
@Retention(RUNTIME)
public @interface PostChecksumConstraint {

    String key() default ""checksumError"";
    String message() default ""Checksums do not match"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/list/SizeList.java,"package org.bigbluebutton.api.model.constraint.list;

import org.bigbluebutton.api.model.constraint.Size;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
public @interface SizeList {
    Size[] value();
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/list/NotNullList.java,"package org.bigbluebutton.api.model.constraint.list;

import org.bigbluebutton.api.model.constraint.NotNull;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
public @interface NotNullList {
    NotNull[] value();
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/list/PatternList.java,"package org.bigbluebutton.api.model.constraint.list;

import org.bigbluebutton.api.model.constraint.Pattern;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
public @interface PatternList {
    Pattern[] value();
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/list/NotEmptyList.java,"package org.bigbluebutton.api.model.constraint.list;

import org.bigbluebutton.api.model.constraint.NotEmpty;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
public @interface NotEmptyList {
    NotEmpty[] value();
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/MeetingIDConstraint.java,"package org.bigbluebutton.api.model.constraint;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@NotEmpty(key = ""missingParamMeetingID"", message = ""You must provide a meeting ID"")
@Size(min = 2, max = 256, message = ""Meeting ID must be between 2 and 256 characters"")
@Pattern(regexp = ""^[^,]+$"", message = ""Meeting ID cannot contain ','"")
@Constraint(validatedBy = {})
@Target(FIELD)
@Retention(RUNTIME)
public @interface MeetingIDConstraint {

    String key() default ""validationError"";
    String message() default ""Invalid meeting ID"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/Size.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.constraint.list.SizeList;
import org.bigbluebutton.api.model.validator.SizeValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.*;

@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(SizeList.class)
@Constraint(validatedBy = SizeValidator.class)
public @interface Size {

    String key() default ""sizeError"";
    String message() default ""Value does not conform to size restrictions"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
    int min() default 0;
    int max() default 2147483647;
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/MeetingNameConstraint.java,"package org.bigbluebutton.api.model.constraint;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@NotNull(message = ""You must provide a meeting name"")
@NotEmpty(message = ""You must provide a meeting name"")
@Size(min = 2, max = 256, message = ""Meeting name must be between 2 and 256 characters"")
@Constraint(validatedBy = {})
@Target(FIELD)
@Retention(RUNTIME)
public @interface MeetingNameConstraint {

    String key() default ""validationError"";
    String message() default ""Invalid meeting name"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/IsIntegralConstraint.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.validator.IsIntegralValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Constraint(validatedBy = IsIntegralValidator.class)
@Target(FIELD)
@Retention(RUNTIME)
public @interface IsIntegralConstraint {

    String key() default ""validationError"";
    String message() default ""Value must be an integral number"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/constraint/JoinPasswordConstraint.java,"package org.bigbluebutton.api.model.constraint;

import org.bigbluebutton.api.model.validator.JoinPasswordValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Constraint(validatedBy = JoinPasswordValidator.class)
@Target(TYPE)
@Retention(RUNTIME)
public @interface JoinPasswordConstraint {

    String key() default ""invalidPassword"";
    String message() default ""The provided password is neither a moderator or attendee password"";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/shared/Password.java,"package org.bigbluebutton.api.model.shared;

import javax.validation.constraints.NotEmpty;

public abstract class Password {

    @NotEmpty(message = ""You must provide the meeting ID"")
    protected String meetingID;

    protected String password;

    public String getMeetingID() {
        return meetingID;
    }

    public void setMeetingID(String meetingID) {
        this.meetingID = meetingID;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/shared/JoinPassword.java,"package org.bigbluebutton.api.model.shared;

import org.bigbluebutton.api.model.constraint.JoinPasswordConstraint;

@JoinPasswordConstraint
public class JoinPassword extends Password {}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/shared/Checksum.java,"package org.bigbluebutton.api.model.shared;

import org.bigbluebutton.api.model.constraint.NotEmpty;
import org.bigbluebutton.api.util.ParamsUtil;

public abstract class Checksum {

    @NotEmpty(message = ""You must provide the API call"", groups = ChecksumValidationGroup.class)
    protected String apiCall;

    @NotEmpty(key = ""checksumError"", message = ""You must provide the checksum"", groups = ChecksumValidationGroup.class)
    protected String checksum;

    protected String queryStringWithoutChecksum;

    public Checksum(String apiCall, String checksum) {
        this.apiCall = ParamsUtil.sanitizeString(apiCall);
        this.checksum = ParamsUtil.sanitizeString(checksum);
    }

    public String getApiCall() {
        return apiCall;
    }

    public void setApiCall(String apiCall) {
        this.apiCall = apiCall;
    }

    public String getChecksum() {
        return checksum;
    }

    public void setChecksum(String checksum) {
        this.checksum = checksum;
    }

    public String getQueryStringWithoutChecksum() {
        return queryStringWithoutChecksum;
    }

    public void setQueryStringWithoutChecksum(String queryStringWithoutChecksum) {
        this.queryStringWithoutChecksum = queryStringWithoutChecksum;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/shared/ModeratorPassword.java,"package org.bigbluebutton.api.model.shared;

public class ModeratorPassword extends Password {}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/shared/PostChecksum.java,"package org.bigbluebutton.api.model.shared;

import org.bigbluebutton.api.model.constraint.PostChecksumConstraint;
import org.bigbluebutton.api.service.ValidationService;

import java.util.Map;

@PostChecksumConstraint(groups = ChecksumValidationGroup.class)
public class PostChecksum extends Checksum {

    Map<String, String[]> params;

    public PostChecksum(String apiCall, String checksum, Map<String, String[]> params) {
        super(apiCall, checksum);
        this.params = params;
        queryStringWithoutChecksum = ValidationService.buildQueryStringFromParamsMap(params);
    }

    public Map<String, String[]> getParams() { return params; }

    public void setParams(Map<String, String[]> params) { this.params = params; }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/shared/ChecksumValidationGroup.java,"package org.bigbluebutton.api.model.shared;

public interface ChecksumValidationGroup {
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/shared/GetChecksum.java,"package org.bigbluebutton.api.model.shared;

import org.bigbluebutton.api.model.constraint.GetChecksumConstraint;
import org.bigbluebutton.api.util.ParamsUtil;

import javax.validation.constraints.NotEmpty;

@GetChecksumConstraint(groups = ChecksumValidationGroup.class)
public class GetChecksum extends Checksum {

    @NotEmpty(message = ""You must provide the query string"")
    private String queryString;

    public GetChecksum(String apiCall, String checksum, String queryString) {
        super(apiCall, checksum);
        this.queryString = ParamsUtil.sanitizeString(queryString);
        removeChecksumFromQueryString();
    }

    private void removeChecksumFromQueryString() {
        queryStringWithoutChecksum = queryString;
        queryStringWithoutChecksum = queryStringWithoutChecksum.replace(""&checksum="" + checksum, """");
        queryStringWithoutChecksum = queryStringWithoutChecksum.replace(""checksum="" + checksum + ""&"", """");
        queryStringWithoutChecksum = queryStringWithoutChecksum.replace(""checksum="" + checksum, """");
    }

    public String getQueryString() {
        return queryString;
    }

    public void setQueryString(String queryString) {
        this.queryString = queryString;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/UserSessionValidator.java,"package org.bigbluebutton.api.model.validator;

import org.bigbluebutton.api.domain.UserSession;
import org.bigbluebutton.api.model.constraint.UserSessionConstraint;
import org.bigbluebutton.api.service.ServiceUtils;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class UserSessionValidator implements ConstraintValidator<UserSessionConstraint, String> {

    @Override
    public void initialize(UserSessionConstraint constraintAnnotation) {}

    @Override
    public boolean isValid(String sessionToken, ConstraintValidatorContext constraintValidatorContext) {

        if(sessionToken == null) {
            return false;
        }

        UserSession userSession = ServiceUtils.getMeetingService().getUserSessionWithAuthToken(sessionToken);

        if(userSession == null) {
            return false;
        }

        return true;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/PatternValidator.java,"package org.bigbluebutton.api.model.validator;

import org.bigbluebutton.api.model.constraint.Pattern;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class PatternValidator implements ConstraintValidator<Pattern, String> {

    String regexp;

    @Override
    public void initialize(Pattern constraintAnnotation) {
        regexp = constraintAnnotation.regexp();
    }

    @Override
    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
        if(s == null) return true;
        return java.util.regex.Pattern.matches(regexp, s);
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/IsBooleanValidator.java,"package org.bigbluebutton.api.model.validator;

import org.bigbluebutton.api.model.constraint.IsBooleanConstraint;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import java.util.Locale;

public class IsBooleanValidator implements ConstraintValidator<IsBooleanConstraint, String> {

    @Override
    public void initialize(IsBooleanConstraint constraintAnnotation) {}

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {

        if(value == null || value.equals("""")) {
            return true;
        }

        Boolean isValid = false;
        value = value.toLowerCase();

        switch(value) {
            case ""true"":
            case ""false"":
            case ""0"":
            case ""1"":
                isValid = true;
                break;
            default:
                break;
        }

        return isValid;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/NotNullValidator.java,"package org.bigbluebutton.api.model.validator;

import org.bigbluebutton.api.model.constraint.NotNull;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class NotNullValidator implements ConstraintValidator<NotNull, Object> {

    @Override
    public void initialize(NotNull constraintAnnotation) {}

    @Override
    public boolean isValid(Object o, ConstraintValidatorContext constraintValidatorContext) {
        return !(o == null);
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/PostChecksumValidator.java,"package org.bigbluebutton.api.model.validator;

import org.apache.commons.codec.digest.DigestUtils;
import org.bigbluebutton.api.model.constraint.PostChecksumConstraint;
import org.bigbluebutton.api.model.shared.PostChecksum;
import org.bigbluebutton.api.service.ServiceUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class PostChecksumValidator implements ConstraintValidator<PostChecksumConstraint, PostChecksum> {

    private static Logger log = LoggerFactory.getLogger(PostChecksumValidator.class);

    @Override
    public void initialize(PostChecksumConstraint constraintAnnotation) {}

    @Override
    public boolean isValid(PostChecksum checksum, ConstraintValidatorContext context) {
        String securitySalt = ServiceUtils.getValidationService().getSecuritySalt();

        if (securitySalt.isEmpty()) {
            log.warn(""Security is disabled in this service. Make sure this is intentional."");
            return true;
        }

        String queryStringWithoutChecksum = checksum.getQueryStringWithoutChecksum();
        log.info(""query string after checksum removed: [{}]"", queryStringWithoutChecksum);

        if(queryStringWithoutChecksum == null) {
            return false;
        }

        String providedChecksum = checksum.getChecksum();
        log.info(""CHECKSUM={} length={}"", providedChecksum, providedChecksum.length());

        if(providedChecksum == null) {
            return false;
        }

        String data = checksum.getApiCall() + queryStringWithoutChecksum + securitySalt;
        String createdCheckSum = DigestUtils.sha1Hex(data);

        if (createdCheckSum == null || !createdCheckSum.equalsIgnoreCase(providedChecksum)) {
            log.info(""checksumError: failed checksum. our checksum: [{}], client: [{}]"", createdCheckSum, providedChecksum);
            return false;
        }

        return true;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/SizeValidator.java,"package org.bigbluebutton.api.model.validator;

import org.bigbluebutton.api.model.constraint.Size;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class SizeValidator implements ConstraintValidator<Size, String> {

    private int min;
    private int max;

    @Override
    public void initialize(Size constraintAnnotation) {
        min = constraintAnnotation.min();
        max = constraintAnnotation.max();
    }

    @Override
    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
        if(s == null) return true;
        return (s.length() >= min && s.length() <= max);
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/NotEmptyValidator.java,"package org.bigbluebutton.api.model.validator;

import org.bigbluebutton.api.model.constraint.NotEmpty;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class NotEmptyValidator implements ConstraintValidator<NotEmpty, String> {

    @Override
    public void initialize(NotEmpty constraintAnnotation) {}

    @Override
    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
        if(s == null) return true;
        return !s.isEmpty();
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/MeetingExistsValidator.java,"package org.bigbluebutton.api.model.validator;

import org.bigbluebutton.api.domain.Meeting;
import org.bigbluebutton.api.model.constraint.MeetingExistsConstraint;
import org.bigbluebutton.api.service.ServiceUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class MeetingExistsValidator implements ConstraintValidator<MeetingExistsConstraint, String> {

    private static Logger log = LoggerFactory.getLogger(MeetingExistsValidator.class);

    @Override
    public void initialize(MeetingExistsConstraint constraintAnnotation) {}

    @Override
    public boolean isValid(String meetingID, ConstraintValidatorContext context) {
        log.info(""Validating existence of meeting with ID {}"", meetingID);

        if(meetingID == null) {
            return false;
        }

        Meeting meeting = ServiceUtils.findMeetingFromMeetingID(meetingID);

        if(meeting == null) {
            log.info(""meetingExistsError: No meeting with the given ID {} could be found"", meetingID);
            return false;
        }

        return true;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/PasswordValidator.java,"package org.bigbluebutton.api.model.validator;

import org.bigbluebutton.api.model.constraint.PasswordConstraint;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class PasswordValidator implements ConstraintValidator<PasswordConstraint, String> {

    private static Logger log = LoggerFactory.getLogger(PasswordValidator.class);

    @Override
    public void initialize(PasswordConstraint constraintAnnotation) {
        ConstraintValidator.super.initialize(constraintAnnotation);
    }

    @Override
    public boolean isValid(String password, ConstraintValidatorContext context) {
        log.info(""Validating password [{}]"", password);
        if (password != null && !password.isEmpty()){
            if (password.length() < 2 || password.length() > 64) {
                log.info(""Passwords must be between 2 and 64 characters in length"");
                return false;
            }
        }

        return true;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/IsIntegralValidator.java,"package org.bigbluebutton.api.model.validator;

import org.bigbluebutton.api.model.constraint.IsIntegralConstraint;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class IsIntegralValidator implements ConstraintValidator<IsIntegralConstraint, String> {

    @Override
    public void initialize(IsIntegralConstraint constraintAnnotation) {}

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {

        if(value == null || value.equals("""")) {
            return true;
        }

        try {
            Long.parseLong(value);
        } catch(NumberFormatException e) {
            return false;
        }

        return true;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/JoinPasswordValidator.java,"package org.bigbluebutton.api.model.validator;

import org.bigbluebutton.api.domain.Meeting;
import org.bigbluebutton.api.model.constraint.JoinPasswordConstraint;
import org.bigbluebutton.api.model.shared.JoinPassword;
import org.bigbluebutton.api.service.ServiceUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class JoinPasswordValidator implements ConstraintValidator<JoinPasswordConstraint, JoinPassword> {

    private static Logger log = LoggerFactory.getLogger(JoinPasswordValidator.class);

    @Override
    public void initialize(JoinPasswordConstraint constraintAnnotation) {}

    @Override
    public boolean isValid(JoinPassword joinPassword, ConstraintValidatorContext constraintValidatorContext) {
        log.info(""Validating password {} for meeting with ID {}"",
                joinPassword.getPassword(), joinPassword.getMeetingID());

        if(joinPassword.getMeetingID() == null) {
            return false;
        }

        Meeting meeting = ServiceUtils.findMeetingFromMeetingID(joinPassword.getMeetingID());

        if(meeting == null) {
            return false;
        }

        String moderatorPassword = meeting.getModeratorPassword();
        String attendeePassword = meeting.getViewerPassword();
        String providedPassword = joinPassword.getPassword();

        log.info(""Moderator password: {}"", moderatorPassword);
        log.info(""Attendee password: {}"", attendeePassword);
        log.info(""Provided password: {}"", providedPassword);

        return true;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/GetChecksumValidator.java,"package org.bigbluebutton.api.model.validator;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

import org.apache.commons.codec.digest.DigestUtils;
import org.bigbluebutton.api.model.constraint.GetChecksumConstraint;
import org.bigbluebutton.api.model.shared.GetChecksum;
import org.bigbluebutton.api.service.ServiceUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class GetChecksumValidator implements ConstraintValidator<GetChecksumConstraint, GetChecksum> {

    private static Logger log = LoggerFactory.getLogger(GetChecksumValidator.class);

    @Override
    public void initialize(GetChecksumConstraint checksumConstraint) {}

    @Override
    public boolean isValid(GetChecksum checksum, ConstraintValidatorContext context) {
        String securitySalt = ServiceUtils.getValidationService().getSecuritySalt();
        String supportedChecksumAlgorithms = ServiceUtils.getValidationService().getSupportedChecksumAlgorithms();

        if (securitySalt.isEmpty()) {
            log.warn(""Security is disabled in this service. Make sure this is intentional."");
            return true;
        }

        String queryStringWithoutChecksum = checksum.getQueryStringWithoutChecksum();
        log.info(""query string after checksum removed: [{}]"", queryStringWithoutChecksum);

        if(queryStringWithoutChecksum == null) {
            return false;
        }

        String providedChecksum = checksum.getChecksum();
        log.info(""CHECKSUM={} length={}"", providedChecksum, providedChecksum.length());

        if(providedChecksum == null) {
            return false;
        }

        String data = checksum.getApiCall() + queryStringWithoutChecksum + securitySalt;

        int checksumLength = providedChecksum.length();
        String createdCheckSum = null;

        switch(checksumLength) {
            case 40:
                if(supportedChecksumAlgorithms.contains(""sha1"")) {
                    createdCheckSum = DigestUtils.sha1Hex(data);
                    log.info(""SHA1 {}"", createdCheckSum);
                }
                break;
            case 64:
                if(supportedChecksumAlgorithms.contains(""sha256"")) {
                    createdCheckSum = DigestUtils.sha256Hex(data);
                    log.info(""SHA256 {}"", createdCheckSum);
                }
                break;
            case 96:
                if(supportedChecksumAlgorithms.contains(""sha384"")) {
                    createdCheckSum = DigestUtils.sha384Hex(data);
                    log.info(""SHA384 {}"", createdCheckSum);
                }
                break;
            case 128:
                if(supportedChecksumAlgorithms.contains(""sha512"")) {
                    createdCheckSum = DigestUtils.sha512Hex(data);
                    log.info(""SHA512 {}"", createdCheckSum);
                }
                break;
            default:
                log.info(""No algorithm could be found that matches the provided checksum length"");
        }

        if (createdCheckSum == null || !createdCheckSum.equalsIgnoreCase(providedChecksum)) {
            log.info(""checksumError: query string checksum failed. our: [{}], client: [{}]"", createdCheckSum, providedChecksum);
            return false;
        }

        return true;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/GuestPolicyValidator.java,"package org.bigbluebutton.api.model.validator;

import org.bigbluebutton.api.MeetingService;
import org.bigbluebutton.api.domain.GuestPolicy;
import org.bigbluebutton.api.domain.UserSession;
import org.bigbluebutton.api.model.constraint.GuestPolicyConstraint;
import org.bigbluebutton.api.service.ServiceUtils;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class GuestPolicyValidator implements ConstraintValidator<GuestPolicyConstraint, String> {

    @Override
    public void initialize(GuestPolicyConstraint constraintAnnotation) {}

    @Override
    public boolean isValid(String sessionToken, ConstraintValidatorContext constraintValidatorContext) {

        if(sessionToken == null) {
            return false;
        }

        MeetingService meetingService = ServiceUtils.getMeetingService();
        UserSession userSession = meetingService.getUserSessionWithAuthToken(sessionToken);

        if(userSession == null || !userSession.guestStatus.equals(GuestPolicy.ALLOW)) {
            return false;
        }

        return true;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/validator/MeetingEndedValidator.java,"package org.bigbluebutton.api.model.validator;

import org.bigbluebutton.api.domain.Meeting;
import org.bigbluebutton.api.model.constraint.MeetingEndedConstraint;
import org.bigbluebutton.api.service.ServiceUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class MeetingEndedValidator implements ConstraintValidator<MeetingEndedConstraint, String> {

    private static Logger log = LoggerFactory.getLogger(MeetingEndedValidator.class);

    @Override
    public void initialize(MeetingEndedConstraint constraintAnnotation) {}

    @Override
    public boolean isValid(String meetingID, ConstraintValidatorContext context) {

        if(meetingID == null) {
            return false;
        }

        Meeting meeting = ServiceUtils.findMeetingFromMeetingID(meetingID);

        if(meeting == null) {
            return false;
        }

        return !meeting.isForciblyEnded();
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/entity/CallbackData.java,"package org.bigbluebutton.api.model.entity;

import javax.persistence.*;
import java.time.LocalDateTime;
import java.util.Objects;

@Entity
@Table(name = ""callback_data"")
public class CallbackData {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = ""id"")
    private Long id;

    @Column(name = ""meeting_id"")
    private String meetingId;

    @Column(name = ""callback_attributes"")
    private String callbackAttributes;

    @Column(name = ""created_at"")
    private LocalDateTime createdAt;

    @Column(name = ""updated_at"")
    private LocalDateTime updatedAt;

    @OneToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = ""recording_id"", referencedColumnName = ""id"")
    private Recording recording;

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getMeetingId() {
        return meetingId;
    }

    public void setMeetingId(String meetingId) {
        this.meetingId = meetingId;
    }

    public String getCallbackAttributes() {
        return callbackAttributes;
    }

    public void setCallbackAttributes(String callbackAttributes) {
        this.callbackAttributes = callbackAttributes;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Recording getRecording() { return recording; }

    public void setRecording(Recording recording) { this.recording = recording; }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        CallbackData callbackData = (CallbackData) o;
        return Objects.equals(this.id, callbackData.id) &&
                Objects.equals(this.meetingId, callbackData.meetingId) &&
                Objects.equals(this.callbackAttributes, callbackData.callbackAttributes) &&
                Objects.equals(this.createdAt, callbackData.createdAt) &&
                Objects.equals(this.updatedAt, callbackData.updatedAt);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, meetingId, callbackAttributes, createdAt, updatedAt);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(""class CallbackData {\n"");
        sb.append(""    id: "").append(toIndentedString(id)).append(""\n"");
        sb.append(""    meetingId: "").append(toIndentedString(meetingId)).append(""\n"");
        sb.append(""    callbackAttributes: "").append(toIndentedString(callbackAttributes)).append(""\n"");
        sb.append(""    createdAt: "").append(toIndentedString(createdAt)).append(""\n"");
        sb.append(""    updatedAt: "").append(toIndentedString(updatedAt)).append(""\n"");
        sb.append(""}"");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return ""null"";
        }
        return o.toString().replace(""\n"", ""\n    "");
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/entity/Thumbnail.java,"package org.bigbluebutton.api.model.entity;

import javax.persistence.*;
import java.util.Objects;

@Entity
@Table(name = ""thumbnails"")
public class Thumbnail implements Comparable<Thumbnail> {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = ""id"")
    private Long id;

    @Column(name = ""height"")
    private Integer height;

    @Column(name = ""width"")
    private Integer width;

    @Column(name = ""alt"")
    private String alt;

    @Column(name = ""url"")
    private String url;

    @Column(name = ""sequence"")
    private Integer sequence;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = ""playback_format_id"", referencedColumnName = ""id"")
    private PlaybackFormat playbackFormat;

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public PlaybackFormat getPlaybackFormat() { return playbackFormat; }

    public void setPlaybackFormat(PlaybackFormat playbackFormat) { this.playbackFormat = playbackFormat; }

    public Integer getHeight() {
        return height;
    }

    public void setHeight(Integer height) {
        this.height = height;
    }

    public Integer getWidth() {
        return width;
    }

    public void setWidth(Integer width) {
        this.width = width;
    }

    public String getAlt() {
        return alt;
    }

    public void setAlt(String alt) {
        this.alt = alt;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public Integer getSequence() {
        return sequence;
    }

    public void setSequence(Integer sequence) {
        this.sequence = sequence;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        Thumbnail thumbnail = (Thumbnail) o;
        return Objects.equals(this.id, thumbnail.id) &&
                Objects.equals(this.height, thumbnail.height) &&
                Objects.equals(this.width, thumbnail.width) &&
                Objects.equals(this.alt, thumbnail.alt) &&
                Objects.equals(this.url, thumbnail.url);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, height, width, alt, url);
    }

    @Override
    public int compareTo(Thumbnail t) {
        return this.getSequence().compareTo(t.getSequence());
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(""class Thumbnail {\n"");
        sb.append(""    Id: "").append(toIndentedString(id)).append(""\n"");
        sb.append(""    height: "").append(toIndentedString(height)).append(""\n"");
        sb.append(""    width: "").append(toIndentedString(width)).append(""\n"");
        sb.append(""    alt: "").append(toIndentedString(alt)).append(""\n"");
        sb.append(""    url: "").append(toIndentedString(url)).append(""\n"");
        sb.append(""}"");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return ""null"";
        }
        return o.toString().replace(""\n"", ""\n    "");
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/entity/Metadata.java,"package org.bigbluebutton.api.model.entity;

import javax.persistence.*;
import java.util.Objects;

@Entity
@Table(name = ""metadata"")

public class Metadata {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = ""id"")
    private Long id;

    @Column(name = ""key"")
    private String key;

    @Column(name = ""value"")
    private String value;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = ""recording_id"", referencedColumnName = ""id"")
    private Recording recording;

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public Recording getRecording() { return recording; }

    public void setRecording(Recording recording) { this.recording = recording; }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        Metadata metadata = (Metadata) o;
        return Objects.equals(this.id, metadata.id) &&
                Objects.equals(this.key, metadata.key) &&
                Objects.equals(this.value, metadata.value);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, key, value);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(""class Metadata {\n"");
        sb.append(""    id: "").append(toIndentedString(id)).append(""\n"");
        sb.append(""    key: "").append(toIndentedString(key)).append(""\n"");
        sb.append(""    value: "").append(toIndentedString(value)).append(""\n"");
        sb.append(""}"");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return ""null"";
        }
        return o.toString().replace(""\n"", ""\n    "");
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/entity/Recording.java,"package org.bigbluebutton.api.model.entity;

import javax.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = ""recordings"")
public class Recording {

    public enum State {
        STATE_PROCESSING(""processing""),
        STATE_PROCESSED(""processed""),
        STATE_PUBLISING(""publishing""),
        STATE_PUBLISHED(""published""),
        STATE_UNPUBLISING(""unpublishing""),
        STATE_UNPUBLISHED(""unpublished""),
        STATE_DELETING(""deleting""),
        STATE_DELETED(""deleted"");

        private String value;

        State(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }
    }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = ""id"")
    private Long id;

    @Column(name = ""record_id"")
    private String recordId;

    @Column(name = ""meeting_id"")
    private String meetingId;

    @Column(name = ""name"")
    private String name;

    @Column(name = ""published"")
    private Boolean published;

    @Column(name = ""participants"")
    private Integer participants;

    @Column(name = ""state"")
    private String state;

    @Column(name = ""start_time"")
    private LocalDateTime startTime;

    @Column(name = ""end_time"")
    private LocalDateTime endTime;

    @Column(name = ""deleted_at"")
    private LocalDateTime deletedAt;

    @Column(name = ""publish_updated"")
    private Boolean publishUpdated;

    @Column(name = ""protected"")
    private Boolean isProtected;

    @OneToMany(mappedBy = ""recording"", cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    private Set<Metadata> metadata;

    @OneToOne(mappedBy = ""recording"", cascade = CascadeType.ALL)
    private PlaybackFormat format;

    @OneToOne(mappedBy = ""recording"", cascade = CascadeType.ALL)
    private CallbackData callbackData;

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getRecordId() {
        return recordId;
    }

    public void setRecordId(String recordId) {
        this.recordId = recordId;
    }

    public String getMeetingId() {
        return meetingId;
    }

    public void setMeetingId(String meetingId) {
        this.meetingId = meetingId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Boolean getPublished() {
        return published;
    }

    public void setPublished(Boolean published) {
        this.published = published;
    }

    public Integer getParticipants() {
        return participants;
    }

    public void setParticipants(Integer participants) {
        this.participants = participants;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public LocalDateTime getStartTime() {
        return startTime;
    }

    public void setStartTime(LocalDateTime startTime) {
        this.startTime = startTime;
    }

    public LocalDateTime getEndTime() {
        return endTime;
    }

    public void setEndTime(LocalDateTime endTime) {
        this.endTime = endTime;
    }

    public LocalDateTime getDeletedAt() {
        return deletedAt;
    }

    public void setDeletedAt(LocalDateTime deletedAt) {
        this.deletedAt = deletedAt;
    }

    public Boolean getPublishUpdated() {
        return publishUpdated;
    }

    public void setPublishUpdated(Boolean publishUpdated) {
        this.publishUpdated = publishUpdated;
    }

    public Boolean getProtected() {
        return isProtected;
    }

    public void setProtected(Boolean aProtected) {
        isProtected = aProtected;
    }

    public Set<Metadata> getMetadata() { return metadata; }

    public void setMetadata(Set<Metadata> metadata) { this.metadata = metadata; }

    public void addMetadata(Metadata metadata) {
        if(this.metadata == null) {
            this.metadata = new HashSet<>();
        }

        metadata.setRecording(this);
        this.metadata.add(metadata);
    }

    public PlaybackFormat getFormat() {
        return format;
    }

    public void setFormat(PlaybackFormat format) {
        this.format = format;
    }

    public CallbackData getCallbackData() {
        return callbackData;
    }

    public void setCallbackData(CallbackData callbackData) {
        this.callbackData = callbackData;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        Recording recording = (Recording) o;
        return Objects.equals(this.id, recording.id) &&
                Objects.equals(this.recordId, recording.recordId) &&
                Objects.equals(this.meetingId, recording.meetingId) &&
                Objects.equals(this.name, recording.name) &&
                Objects.equals(this.published, recording.published) &&
                Objects.equals(this.participants, recording.participants) &&
                Objects.equals(this.state, recording.state) &&
                Objects.equals(this.startTime, recording.startTime) &&
                Objects.equals(this.endTime, recording.endTime) &&
                Objects.equals(this.deletedAt, recording.deletedAt) &&
                Objects.equals(this.publishUpdated, recording.publishUpdated) &&
                Objects.equals(this.isProtected, recording.isProtected) &&
                Objects.equals(this.metadata, recording.metadata) &&
                Objects.equals(this.format, recording.format) &&
                Objects.equals(this.callbackData, recording.callbackData);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, recordId, meetingId, name, published, participants, state, startTime, endTime,
                deletedAt, publishUpdated, isProtected, metadata, format, callbackData);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(""class Recording {\n"");
        sb.append(""    id: "").append(toIndentedString(id)).append(""\n"");
        sb.append(""    recordId: "").append(toIndentedString(recordId)).append(""\n"");
        sb.append(""    meetingId: "").append(toIndentedString(meetingId)).append(""\n"");
        sb.append(""    name: "").append(toIndentedString(name)).append(""\n"");
        sb.append(""    published: "").append(toIndentedString(published)).append(""\n"");
        sb.append(""    participants: "").append(toIndentedString(participants)).append(""\n"");
        sb.append(""    state: "").append(toIndentedString(state)).append(""\n"");
        sb.append(""    startTime: "").append(toIndentedString(startTime)).append(""\n"");
        sb.append(""    endTime: "").append(toIndentedString(endTime)).append(""\n"");
        sb.append(""    deletedAt: "").append(toIndentedString(deletedAt)).append(""\n"");
        sb.append(""    publishUpdated: "").append(toIndentedString(publishUpdated)).append(""\n"");
        sb.append(""    protected: "").append(toIndentedString(isProtected)).append(""\n"");
        sb.append(""    metadata: "").append(toIndentedString(metadata)).append(""\n"");
        sb.append(""    format: "").append(toIndentedString(format)).append(""\n"");
        sb.append(""    callBackData: "").append(toIndentedString(callbackData)).append(""\n"");
        sb.append(""}"");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return ""null"";
        }
        return o.toString().replace(""\n"", ""\n    "");
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/model/entity/PlaybackFormat.java,"package org.bigbluebutton.api.model.entity;

import javax.persistence.*;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = ""playback_formats"")
public class PlaybackFormat {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = ""id"")
    private Long id;

    @Column(name = ""format"")
    private String format;

    @Column(name = ""url"")
    private String url;

    @Column(name = ""length"")
    private Integer length;

    @Column(name = ""processing_time"")
    private Integer processingTime;

    @OneToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = ""recording_id"", referencedColumnName = ""id"")
    private Recording recording;

    @OneToMany(cascade = CascadeType.ALL, mappedBy = ""playbackFormat"", fetch = FetchType.EAGER)
    private Set<Thumbnail> thumbnails;

    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }

    public String getFormat() {
        return format;
    }

    public void setFormat(String format) {
        this.format = format;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public Integer getLength() {
        return length;
    }

    public void setLength(Integer length) {
        this.length = length;
    }

    public Integer getProcessingTime() {
        return processingTime;
    }

    public void setProcessingTime(Integer processingTime) {
        this.processingTime = processingTime;
    }

    public Recording getRecording() {
        return recording;
    }

    public void setRecording(Recording recording) {
        this.recording = recording;
    }

    public Set<Thumbnail> getThumbnails() { return thumbnails; }

    public void setThumbnails(Set<Thumbnail> thumbnails) { this.thumbnails = thumbnails; }

    public void addThumbnail(Thumbnail thumbnail) {
        if(thumbnails == null) {
            thumbnails = new HashSet<>();
        }

        thumbnail.setPlaybackFormat(this);
        thumbnails.add(thumbnail);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        PlaybackFormat format = (PlaybackFormat) o;
        return Objects.equals(this.id, format.id) &&
                Objects.equals(this.format, format.format) &&
                Objects.equals(this.url, format.url) &&
                Objects.equals(this.length, format.length) &&
                Objects.equals(this.processingTime, format.processingTime) &&
                Objects.equals(this.thumbnails, format.thumbnails);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, format, url, length, processingTime, thumbnails);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(""class PlaybackFormat {\n"");
        sb.append(""    id: "").append(toIndentedString(id)).append(""\n"");
        sb.append(""    format: "").append(toIndentedString(format)).append(""\n"");
        sb.append(""    url: "").append(toIndentedString(url)).append(""\n"");
        sb.append(""    length: "").append(toIndentedString(length)).append(""\n"");
        sb.append(""    processingTime: "").append(toIndentedString(processingTime)).append(""\n"");
        sb.append(""    thumbnails: "").append(toIndentedString(thumbnails)).append(""\n"");
        sb.append(""}"");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return ""null"";
        }
        return o.toString().replace(""\n"", ""\n    "");
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/RecordingService.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 *
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 *
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.bigbluebutton.api;

import org.bigbluebutton.api.messaging.messages.MakePresentationDownloadableMsg;
import org.bigbluebutton.api.model.entity.Recording;
import org.bigbluebutton.api2.domain.UploadedTrack;

import java.io.File;
import java.util.List;
import java.util.Map;

import org.springframework.data.domain.*;

public interface RecordingService {

    Boolean validateTextTrackSingleUseToken(String recordId, String caption, String token);
    String getRecordingTextTracks(String recordId);
    String putRecordingTextTrack(UploadedTrack track);
    String getCaptionTrackInboxDir();
    String getCaptionsDir();
    boolean isRecordingExist(String recordId);
    String getRecordings2x(List<String> idList, List<String> states, Map<String, String> metadataFilters, int offset, Pageable pageable);
    boolean existAnyRecording(List<String> idList);
    boolean changeState(String recordingId, String state);
    void updateMetaParams(List<String> recordIDs, Map<String,String> metaParams);
    void startIngestAndProcessing(String meetingId);
    void markAsEnded(String meetingId);
    void kickOffRecordingChapterBreak(String meetingId, Long timestamp);
    void processMakePresentationDownloadableMsg(MakePresentationDownloadableMsg msg);
    File getDownloadablePresentationFile(String meetingId, String presId, String presFilename);

    // Construct page using offset and limit parameters
    default <T> Page<T> listToPage(List<T> list, int offset, Pageable pageable) {
        int end = (int) (Math.min((offset + pageable.getPageSize()), list.size()));
        return new PageImpl<>(list.subList(offset, end), pageable, list.size());
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/ApiParams.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2017 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
*
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.api;

public class ApiParams {

    public static final String ALLOW_START_STOP_RECORDING = ""allowStartStopRecording"";
    public static final String ATTENDEE_PW = ""attendeePW"";
    public static final String AUTO_START_RECORDING = ""autoStartRecording"";
    public static final String BANNER_COLOR = ""bannerColor"";
    public static final String BANNER_TEXT = ""bannerText"";
    public static final String CHECKSUM = ""checksum"";
    public static final String COPYRIGHT = ""copyright"";
    public static final String DIAL_NUMBER = ""dialNumber"";
    public static final String DURATION = ""duration"";
    public static final String FREE_JOIN = ""freeJoin"";
    public static final String FULL_NAME = ""fullName"";
    public static final String GUEST_POLICY = ""guestPolicy"";
    public static final String MEETING_LAYOUT = ""meetingLayout"";
    public static final String IS_BREAKOUT = ""isBreakout"";
    public static final String LOGO = ""logo"";
    public static final String LOGOUT_TIMER = ""logoutTimer"";
    public static final String LOGOUT_URL = ""logoutURL"";
    public static final String MAX_PARTICIPANTS = ""maxParticipants"";
    public static final String MEETING_ID = ""meetingID"";
    public static final String META = ""meta"";
    public static final String MODERATOR_ONLY_MESSAGE = ""moderatorOnlyMessage"";
    public static final String MODERATOR_PW = ""moderatorPW"";
    public static final String MUTE_ON_START = ""muteOnStart"";
    public static final String MEETING_KEEP_EVENTS = ""meetingKeepEvents"";
    public static final String ALLOW_MODS_TO_UNMUTE_USERS = ""allowModsToUnmuteUsers"";
    public static final String ALLOW_REQUESTS_WITHOUT_SESSION = ""allowRequestsWithoutSession"";
    public static final String ALLOW_MODS_TO_EJECT_CAMERAS = ""allowModsToEjectCameras"";
    public static final String NAME = ""name"";
    public static final String PARENT_MEETING_ID = ""parentMeetingID"";
    public static final String PASSWORD = ""password"";
    public static final String RECORD = ""record"";
    public static final String RECORD_ID = ""recordID"";
    public static final String REDIRECT = ""redirect"";
    public static final String SEQUENCE = ""sequence"";
    public static final String VOICE_BRIDGE = ""voiceBridge"";
    public static final String WEB_VOICE = ""webVoice"";
    public static final String LEARNING_DASHBOARD_ENABLED = ""learningDashboardEnabled"";
    public static final String LEARNING_DASHBOARD_CLEANUP_DELAY_IN_MINUTES = ""learningDashboardCleanupDelayInMinutes"";
    public static final String VIRTUAL_BACKGROUNDS_DISABLED = ""virtualBackgroundsDisabled"";
    public static final String WEBCAMS_ONLY_FOR_MODERATOR = ""webcamsOnlyForModerator"";
    public static final String MEETING_CAMERA_CAP = ""meetingCameraCap"";
    public static final String USER_CAMERA_CAP = ""userCameraCap"";
    public static final String MAX_PINNED_CAMERAS = ""maxPinnedCameras"";
    public static final String MEETING_EXPIRE_IF_NO_USER_JOINED_IN_MINUTES = ""meetingExpireIfNoUserJoinedInMinutes"";
    public static final String MEETING_EXPIRE_WHEN_LAST_USER_LEFT_IN_MINUTES = ""meetingExpireWhenLastUserLeftInMinutes"";
    public static final String WELCOME = ""welcome"";
    public static final String HTML5_INSTANCE_ID = ""html5InstanceId"";
    public static final String ROLE = ""role"";
    public static final String GROUPS = ""groups"";
    public static final String DISABLED_FEATURES = ""disabledFeatures"";
    public static final String NOTIFY_RECORDING_IS_ON = ""notifyRecordingIsOn"";

    public static final String PRESENTATION_UPLOAD_EXTERNAL_DESCRIPTION = ""presentationUploadExternalDescription"";
    public static final String PRESENTATION_UPLOAD_EXTERNAL_URL = ""presentationUploadExternalUrl"";

    public static final String BREAKOUT_ROOMS_CAPTURE_SLIDES = ""breakoutRoomsCaptureSlides"";
    public static final String BREAKOUT_ROOMS_CAPTURE_NOTES  = ""breakoutRoomsCaptureNotes"";
    public static final String BREAKOUT_ROOMS_CAPTURE_SLIDES_FILENAME = ""breakoutRoomsCaptureSlidesFilename"";
    public static final String BREAKOUT_ROOMS_CAPTURE_NOTES_FILENAME = ""breakoutRoomsCaptureNotesFilename"";
    public static final String BREAKOUT_ROOMS_ENABLED = ""breakoutRoomsEnabled"";
    public static final String BREAKOUT_ROOMS_RECORD = ""breakoutRoomsRecord"";
    public static final String BREAKOUT_ROOMS_PRIVATE_CHAT_ENABLED = ""breakoutRoomsPrivateChatEnabled"";

    public static final String LOCK_SETTINGS_DISABLE_CAM = ""lockSettingsDisableCam"";
    public static final String LOCK_SETTINGS_DISABLE_MIC = ""lockSettingsDisableMic"";
    public static final String LOCK_SETTINGS_DISABLE_PRIVATE_CHAT = ""lockSettingsDisablePrivateChat"";
    public static final String LOCK_SETTINGS_DISABLE_PUBLIC_CHAT = ""lockSettingsDisablePublicChat"";
    public static final String DEPRECATED_LOCK_SETTINGS_DISABLE_NOTES = ""lockSettingsDisableNote"";
    public static final String LOCK_SETTINGS_DISABLE_NOTES = ""lockSettingsDisableNotes"";
    public static final String LOCK_SETTINGS_HIDE_USER_LIST = ""lockSettingsHideUserList"";
    public static final String LOCK_SETTINGS_LOCK_ON_JOIN = ""lockSettingsLockOnJoin"";
    public static final String LOCK_SETTINGS_LOCK_ON_JOIN_CONFIGURABLE = ""lockSettingsLockOnJoinConfigurable"";
    public static final String LOCK_SETTINGS_HIDE_VIEWERS_CURSOR = ""lockSettingsHideViewersCursor"";

    // New param passed on create call to callback when meeting ends.
    // This is a duplicate of the endCallbackUrl meta param as we want this
    // param to stay on the server and not propagated to client and recordings.
    public static final String MEETING_ENDED_CALLBACK_URL = ""meetingEndedURL"";

    // Param to end the meeting when there are no moderators after a certain period of time.
    // Needed for classes where teacher gets disconnected and can't get back in. Prevents
    // students from running amok.
    public static final String END_WHEN_NO_MODERATOR = ""endWhenNoModerator"";
    public static final String END_WHEN_NO_MODERATOR_DELAY_IN_MINUTES = ""endWhenNoModeratorDelayInMinutes"";

    private ApiParams() {
        throw new IllegalStateException(""ApiParams is a utility class. Instanciation is forbidden."");
    }

}"
bbb-common-web/src/main/java/org/bigbluebutton/api/HTML5LoadBalancingService.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2020 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */

package org.bigbluebutton.api;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.InputStreamReader;

import java.io.InputStream;
import java.io.OutputStream;

import org.apache.commons.io.IOUtils;

import java.util.ArrayList;
import java.util.List;

import org.bigbluebutton.api.util.HTML5ProcessLine;


public class HTML5LoadBalancingService {
    private static Logger log = LoggerFactory.getLogger(HTML5LoadBalancingService.class);
    private ArrayList<HTML5ProcessLine> list = new ArrayList<HTML5ProcessLine>();
    private final int MAX_NUMBER_OF_HTML5_INSTANCES = 20;
    private int lastSelectedInstanceId = 0;

    public void init() {
        log.info(""HTML5LoadBalancingService initialised"");
    }

    // Find nodejs processes associated with processing meeting events
    // $ ps -u meteor -o pcpu,cmd= | grep NODEJS_BACKEND_INSTANCE_ID
    // 1.1 /usr/lib/bbb-html5/node/bin/node --max-old-space-size=2048 --max_semi_space_size=128 main.js NODEJS_BACKEND_INSTANCE_ID=1
    // 1.0 /usr/lib/bbb-html5/node/bin/node --max-old-space-size=2048 --max_semi_space_size=128 main.js NODEJS_BACKEND_INSTANCE_ID=2
    public void scanHTML5processes() {
        try {
            this.list = new ArrayList<HTML5ProcessLine>();
            Process p1 = Runtime.getRuntime().exec(new String[]{""ps"", ""-u"", ""meteor"", ""-o"", ""pcpu,cmd=""});
            InputStream input1 = p1.getInputStream();
            Process p2 = Runtime.getRuntime().exec(new String[]{""grep"", HTML5ProcessLine.BBB_HTML5_PROCESS_IDENTIFIER});
            OutputStream output = p2.getOutputStream();
            IOUtils.copy(input1, output);
            output.close(); // signals grep to finish
            List<String> result = IOUtils.readLines(p2.getInputStream());
            for (String entry : result) {
                HTML5ProcessLine line = new HTML5ProcessLine(entry);
                list.add(line);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private boolean listItemWithIdExists(int id) {
        for (HTML5ProcessLine line : this.list) {
            if (line.instanceId == id) {
                return true;
            }
        }
        return false;
    }

    public int findSuitableHTML5ProcessByRoundRobin() {
        this.scanHTML5processes();
        if (list.isEmpty()) {
            log.warn(""Did not find any instances of html5 process running"");
            return 1;
        }

        for (int i = lastSelectedInstanceId + 1; i <= MAX_NUMBER_OF_HTML5_INSTANCES + lastSelectedInstanceId; i++) {
            int k = i % (MAX_NUMBER_OF_HTML5_INSTANCES + 1);
            if (this.listItemWithIdExists(k)) {
                this.lastSelectedInstanceId = k;
                return k;
            }
        }
        return 1;
    }

}"
bbb-common-web/src/main/java/org/bigbluebutton/api/MeetingService.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */

package org.bigbluebutton.api;

import java.io.File;
import java.net.URI;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

import com.google.gson.JsonObject;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.client.utils.URIBuilder;
import org.bigbluebutton.api.domain.*;
import org.bigbluebutton.api.messaging.MessageListener;
import org.bigbluebutton.api.messaging.converters.messages.DestroyMeetingMessage;
import org.bigbluebutton.api.messaging.converters.messages.EndMeetingMessage;
import org.bigbluebutton.api.messaging.converters.messages.PublishedRecordingMessage;
import org.bigbluebutton.api.messaging.converters.messages.UnpublishedRecordingMessage;
import org.bigbluebutton.api.messaging.converters.messages.DeletedRecordingMessage;
import org.bigbluebutton.api.messaging.messages.*;
import org.bigbluebutton.api2.IBbbWebApiGWApp;
import org.bigbluebutton.api2.domain.UploadedTrack;
import org.bigbluebutton.common2.redis.RedisStorageService;
import org.bigbluebutton.presentation.PresentationUrlDownloadService;
import org.bigbluebutton.presentation.imp.SlidesGenerationProgressNotifier;
import org.bigbluebutton.web.services.WaitingGuestCleanupTimerTask;
import org.bigbluebutton.web.services.UserCleanupTimerTask;
import org.bigbluebutton.web.services.EnteredUserCleanupTimerTask;
import org.bigbluebutton.web.services.callback.CallbackUrlService;
import org.bigbluebutton.web.services.callback.MeetingEndedEvent;
import org.bigbluebutton.web.services.turn.StunTurnService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;

import java.io.BufferedReader;
import java.io.InputStreamReader;

import org.springframework.data.domain.*;

public class MeetingService implements MessageListener {
  private static Logger log = LoggerFactory.getLogger(MeetingService.class);

  private BlockingQueue<IMessage> receivedMessages = new LinkedBlockingQueue<IMessage>();
  private volatile boolean processMessage = false;

  private final Executor msgProcessorExec = Executors.newSingleThreadExecutor();
  private final Executor runExec = Executors.newSingleThreadExecutor();

  /**
   * http://ria101.wordpress.com/2011/12/12/concurrenthashmap-avoid-a-common-misuse/
   */
  private final ConcurrentMap<String, Meeting> meetings;
  private final ConcurrentMap<String, UserSession> sessions;

  private RecordingService recordingService;
  private LearningDashboardService learningDashboardService;
  private WaitingGuestCleanupTimerTask waitingGuestCleaner;
  private UserCleanupTimerTask userCleaner;
  private EnteredUserCleanupTimerTask enteredUserCleaner;
  private StunTurnService stunTurnService;
  private RedisStorageService storeService;
  private CallbackUrlService callbackUrlService;
  private SlidesGenerationProgressNotifier notifier;

  private long usersTimeout;
  private long waitingGuestUsersTimeout;
  private long enteredUsersTimeout;

  private ParamsProcessorUtil paramsProcessorUtil;
  private PresentationUrlDownloadService presDownloadService;

  private IBbbWebApiGWApp gw;

  private  HashMap<String, PresentationUploadToken> uploadAuthzTokens;

  public MeetingService() {
    meetings = new ConcurrentHashMap<String, Meeting>(8, 0.9f, 1);
    sessions = new ConcurrentHashMap<String, UserSession>(8, 0.9f, 1);
    uploadAuthzTokens = new HashMap<String, PresentationUploadToken>();
  }

  public void addUserSession(String token, UserSession user) {
    sessions.put(token, user);
  }

  public String getTokenByUserId(String internalUserId) {
      String result = null;
      for (Entry<String, UserSession> e : sessions.entrySet()) {
          String token = e.getKey();
          UserSession userSession = e.getValue();
          if (userSession.internalUserId.equals(internalUserId)) {
              result = token;
          }
      }
      return result;
  }

  public void registerUser(String meetingID, String internalUserId,
                           String fullname, String role, String externUserID,
                           String authToken, String sessionToken, String avatarURL, Boolean guest,
                           Boolean authed, String guestStatus, Boolean excludeFromDashboard, Boolean leftGuestLobby) {
    handle(new RegisterUser(meetingID, internalUserId, fullname, role,
      externUserID, authToken, sessionToken, avatarURL, guest, authed, guestStatus, excludeFromDashboard, leftGuestLobby));

    Meeting m = getMeeting(meetingID);
    if (m != null) {
      RegisteredUser ruser = new RegisteredUser(authToken, internalUserId, guestStatus, excludeFromDashboard, leftGuestLobby);
      m.userRegistered(ruser);
    }
  }

  public UserSession getUserSessionWithUserId(String userId) {
    for (UserSession userSession : sessions.values()) {
      if (userSession.internalUserId.equals(userId)) {
        return userSession;
      }
    }

    return null;
  }

  public UserSession getUserSessionWithAuthToken(String token) {
    return sessions.get(token);
  }

  public Boolean getAllowRequestsWithoutSession(String token) {
    UserSession us = getUserSessionWithAuthToken(token);
    if (us == null) {
      return false;
    } else {
      Meeting meeting = getMeeting(us.meetingID);
      if (meeting == null || meeting.isForciblyEnded()) return false;
      return meeting.getAllowRequestsWithoutSession();
    }
  }

  public UserSession removeUserSessionWithAuthToken(String token) {
    UserSession user = sessions.remove(token);
    if (user != null) {
      log.debug(""Found user {} token={} to meeting {}"", user.fullname, token, user.meetingID);
    }
    return user;
  }

  /**
   * Remove users who did not successfully reconnected to the meeting.
   */
  public void purgeUsers() {
    for (AbstractMap.Entry<String, Meeting> entry : this.meetings.entrySet()) {
      Long now = System.currentTimeMillis();
      Meeting meeting = entry.getValue();

      for (AbstractMap.Entry<String, User> userEntry : meeting.getUsersMap().entrySet()) {
        String userId = userEntry.getKey();
        User user = userEntry.getValue();

        if (!user.hasLeft()) continue;

        long elapsedTime = now - user.getLeftOn();
        if (elapsedTime >= usersTimeout) {
          meeting.removeUser(userId);

          Map<String, Object> logData = new HashMap<>();
          logData.put(""meetingId"", meeting.getInternalId());
          logData.put(""userId"", userId);
          logData.put(""logCode"", ""removed_user"");
          logData.put(""description"", ""User left and was removed from the meeting."");

          Gson gson = new Gson();
          String logStr = gson.toJson(logData);

          log.info("" --analytics-- data={}"", logStr);
        }
      }
    }
  }

  /**
   * Remove entered users who did not join.
   */
  public void purgeEnteredUsers() {
    for (AbstractMap.Entry<String, Meeting> entry : this.meetings.entrySet()) {
      Long now = System.currentTimeMillis();
      Meeting meeting = entry.getValue();

      for (AbstractMap.Entry<String, Long> enteredUser : meeting.getEnteredUsers().entrySet()) {
        String userId = enteredUser.getKey();

        long elapsedTime = now - enteredUser.getValue();
        if (elapsedTime >= enteredUsersTimeout) {
          meeting.removeEnteredUser(userId);

          Map<String, Object> logData = new HashMap<>();
          logData.put(""meetingId"", meeting.getInternalId());
          logData.put(""userId"", userId);
          logData.put(""logCode"", ""purged_entered_user"");
          logData.put(""description"", ""Purged user that called ENTER from the API but never joined"");

          Gson gson = new Gson();
          String logStr = gson.toJson(logData);

          log.info("" --analytics-- data={}"", logStr);
        }
      }
    }
  }

  public void guestIsWaiting(String meetingId, String userId) {
    Meeting m = getMeeting(meetingId);
    if (m != null) {
      m.guestIsWaiting(userId);
    }
  }

  /**
   * Remove registered waiting guest users who left the waiting page.
   */
  public void purgeWaitingGuestUsers() {
    for (AbstractMap.Entry<String, Meeting> entry : this.meetings.entrySet()) {
      Long now = System.currentTimeMillis();
      Meeting meeting = entry.getValue();
      ConcurrentMap<String, User> users = meeting.getUsersMap();
      for (AbstractMap.Entry<String, RegisteredUser> registeredUser : meeting.getRegisteredUsers().entrySet()) {
        String registeredUserID = registeredUser.getKey();
        RegisteredUser ru = registeredUser.getValue();

        long elapsedTime = now - ru.getGuestWaitedOn();
        if (elapsedTime >= waitingGuestUsersTimeout && ru.getGuestStatus() == GuestPolicy.WAIT) {
          log.info(""Purging user [{}]"", registeredUserID);
          if (meeting.userUnregistered(registeredUserID) != null) {
            gw.guestWaitingLeft(meeting.getInternalId(), registeredUserID);
            meeting.setLeftGuestLobby(registeredUserID, true);
          };
        }
      }
    }
  }


  private void kickOffProcessingOfRecording(Meeting m) {
    if (m.isRecord() && m.getNumUsers() == 0) {
      processRecording(m);
    }
  }

  public Boolean authzTokenIsValid(String authzToken) { // Note we DO NOT expire the token
    return uploadAuthzTokens.containsKey(authzToken);
  }

  public Boolean authzTokenIsValidAndExpired(String authzToken) {  // Note we DO expire the token
    Boolean valid = uploadAuthzTokens.containsKey(authzToken);
    expirePresentationUploadToken(authzToken);
    return valid;
  }

  public PresentationUploadToken getPresentationUploadToken(String authzToken) {
    if(uploadAuthzTokens.containsKey(authzToken)) {
      return uploadAuthzTokens.get(authzToken);
    } else {
      return null;
    }
  }

  public void sendPresentationUploadMaxFilesizeMessage(PresentationUploadToken presUploadToken, int uploadedFileSize, int maxUploadFileSize) {
    notifier.sendUploadFileTooLargeMessage(presUploadToken, uploadedFileSize, maxUploadFileSize);
  }

  private void removeUserSessions(String meetingId) {
    Iterator<Map.Entry<String, UserSession>> iterator = sessions.entrySet().iterator();
    while (iterator.hasNext()) {
      Map.Entry<String, UserSession> entry = iterator.next();
      UserSession userSession = entry.getValue();

      if (userSession.meetingID.equals(meetingId)) {
        iterator.remove();
      }
    }
  }

  private void destroyMeeting(String meetingId) {
    gw.destroyMeeting(new DestroyMeetingMessage(meetingId));
  }

  public Collection<Meeting> getMeetings() {
    return meetings.isEmpty() ? Collections.<Meeting>emptySet()
      : Collections.unmodifiableCollection(meetings.values());
  }

  public Collection<UserSession> getSessions() {
    return sessions.isEmpty() ? Collections.<UserSession>emptySet()
      : Collections.unmodifiableCollection(sessions.values());
  }

  public synchronized boolean createMeeting(Meeting m) {
    String internalMeetingId = paramsProcessorUtil.convertToInternalMeetingId(m.getExternalId());
    Meeting existingId = getNotEndedMeetingWithId(internalMeetingId);
    Meeting existingTelVoice = getNotEndedMeetingWithTelVoice(m.getTelVoice());
    Meeting existingWebVoice = getNotEndedMeetingWithWebVoice(m.getWebVoice());
    if (existingId == null && existingTelVoice == null && existingWebVoice == null) {
      meetings.put(m.getInternalId(), m);
      handle(new CreateMeeting(m));
      return true;
    }

    return false;
  }

  private boolean storeEvents(Meeting m) {
    return m.isRecord() || m.getMeetingKeepEvents();
  }

  private void handleCreateMeeting(Meeting m) {
    if (m.isBreakout()) {
      Meeting parent = meetings.get(m.getParentMeetingId());
      parent.addBreakoutRoom(m.getExternalId());
      if (storeEvents(parent)) {
        storeService.addBreakoutRoom(parent.getInternalId(), m.getInternalId());
      }
    }

    if (storeEvents(m)) {
      Map<String, String> metadata = new TreeMap<>();
      metadata.putAll(m.getMetadata());
      // TODO: Need a better way to store these values for recordings
      metadata.put(""meetingId"", m.getExternalId());
      metadata.put(""meetingName"", m.getName());
      metadata.put(""isBreakout"", m.isBreakout().toString());

      storeService.recordMeetingInfo(m.getInternalId(), metadata);

      if (m.isBreakout()) {
        Map<String, String> breakoutMetadata = new TreeMap<>();
        breakoutMetadata.put(""meetingId"", m.getExternalId());
        breakoutMetadata.put(""sequence"", m.getSequence().toString());
        breakoutMetadata.put(""freeJoin"", m.isFreeJoin().toString());
        breakoutMetadata.put(""captureSlides"", m.isCaptureSlides().toString());
        breakoutMetadata.put(""captureNotes"", m.isCaptureNotes().toString());
        breakoutMetadata.put(""parentMeetingId"", m.getParentMeetingId());
        storeService.recordBreakoutInfo(m.getInternalId(), breakoutMetadata);
      }
    }

    Map<String, Object> logData = new HashMap<>();
    logData.put(""meetingId"", m.getInternalId());
    logData.put(""externalMeetingId"", m.getExternalId());
    if (m.isBreakout()) {
      logData.put(""sequence"", m.getSequence());
      logData.put(""freeJoin"", m.isFreeJoin());
      logData.put(""captureSlides"",  m.isCaptureSlides());
      logData.put(""captureNotes"", m.isCaptureNotes());
      logData.put(""parentMeetingId"", m.getParentMeetingId());
    }
    logData.put(""name"", m.getName());
    logData.put(""duration"", m.getDuration());
    logData.put(""isBreakout"", m.isBreakout());
    logData.put(""webcamsOnlyForModerator"", m.getWebcamsOnlyForModerator());
    logData.put(""meetingCameraCap"", m.getMeetingCameraCap());
    logData.put(""userCameraCap"", m.getUserCameraCap());
    logData.put(""maxPinnedCameras"", m.getMaxPinnedCameras());
    logData.put(""record"", m.isRecord());
    logData.put(""logCode"", ""create_meeting"");
    logData.put(""description"", ""Create meeting."");

    logData.put(""meetingKeepEvents"", m.getMeetingKeepEvents());
    logData.put(""meetingLayout"", m.getMeetingLayout());

    Gson gson = new Gson();
    String logStr = gson.toJson(logData);

    log.info("" --analytics-- data={}"", logStr);

    gw.createMeeting(m.getInternalId(), m.getExternalId(), m.getParentMeetingId(), m.getName(), m.isRecord(),
            m.getTelVoice(), m.getDuration(), m.getAutoStartRecording(), m.getAllowStartStopRecording(),
            m.getWebcamsOnlyForModerator(), m.getMeetingCameraCap(), m.getUserCameraCap(), m.getMaxPinnedCameras(), m.getModeratorPassword(), m.getViewerPassword(),
            m.getLearningDashboardAccessToken(), m.getCreateTime(),
            formatPrettyDate(m.getCreateTime()), m.isBreakout(), m.getSequence(), m.isFreeJoin(), m.getMetadata(),
            m.getGuestPolicy(), m.getAuthenticatedGuest(), m.getMeetingLayout(), m.getWelcomeMessageTemplate(), m.getWelcomeMessage(), m.getModeratorOnlyMessage(),
            m.getDialNumber(), m.getMaxUsers(), m.getMaxUserConcurrentAccesses(),
            m.getMeetingExpireIfNoUserJoinedInMinutes(), m.getMeetingExpireWhenLastUserLeftInMinutes(),
            m.getUserInactivityInspectTimerInMinutes(), m.getUserInactivityThresholdInMinutes(),
            m.getUserActivitySignResponseDelayInMinutes(), m.getEndWhenNoModerator(), m.getEndWhenNoModeratorDelayInMinutes(),
            m.getMuteOnStart(), m.getAllowModsToUnmuteUsers(), m.getAllowModsToEjectCameras(), m.getMeetingKeepEvents(),
            m.breakoutRoomsParams, m.lockSettingsParams, m.getHtml5InstanceId(),
            m.getGroups(), m.getDisabledFeatures(), m.getNotifyRecordingIsOn(),
            m.getPresentationUploadExternalDescription(), m.getPresentationUploadExternalUrl());
  }

  private String formatPrettyDate(Long timestamp) {
    return new Date(timestamp).toString();
  }

  private void processCreateMeeting(CreateMeeting message) {
    handleCreateMeeting(message.meeting);
  }

  private void processRegisterUser(RegisterUser message) {
    gw.registerUser(message.meetingID,
      message.internalUserId, message.fullname, message.role,
      message.externUserID, message.authToken, message.sessionToken, message.avatarURL, message.guest,
            message.authed, message.guestStatus, message.excludeFromDashboard);
  }

    public Meeting getMeeting(String meetingId) {
        if (meetingId == null)
            return null;
        for (Map.Entry<String, Meeting> entry : meetings.entrySet()) {
            String key = entry.getKey();
            if (key.startsWith(meetingId))
                return entry.getValue();
        }

        return null;
    }

  public Collection<Meeting> getMeetingsWithId(String meetingId) {
    if (meetingId == null)
      return Collections.<Meeting>emptySet();

    Collection<Meeting> m = new HashSet<>();

    for (Map.Entry<String, Meeting> entry : meetings.entrySet()) {
        String key = entry.getKey();
        if (key.startsWith(meetingId))
            m.add(entry.getValue());
    }

    return m;
  }

  public Meeting getNotEndedMeetingWithId(String meetingId) {
      if (meetingId == null)
          return null;
      for (Map.Entry<String, Meeting> entry : meetings.entrySet()) {
          String key = entry.getKey();
          if (key.startsWith(meetingId)) {
              Meeting m = entry.getValue();
              if (!m.isForciblyEnded())
                  return m;
          }
      }
      return null;
  }

  public Meeting getNotEndedMeetingWithTelVoice(String telVoice) {
      if (telVoice == null)
          return null;
      for (Map.Entry<String, Meeting> entry : meetings.entrySet()) {
          Meeting m = entry.getValue();
          if (telVoice.equals(m.getTelVoice())) {
              if (!m.isForciblyEnded())
                  return m;
          }
      }
      return null;
  }

  public Meeting getNotEndedMeetingWithWebVoice(String webVoice) {
      if (webVoice == null)
          return null;
      for (Map.Entry<String, Meeting> entry : meetings.entrySet()) {
          Meeting m = entry.getValue();
          if (webVoice.equals(m.getWebVoice())) {
              if (!m.isForciblyEnded())
                  return m;
          }
      }
      return null;
  }

  public Boolean validateTextTrackSingleUseToken(String recordId, String caption, String token) {
    return recordingService.validateTextTrackSingleUseToken(recordId, caption, token);
  }

  public String getRecordingTextTracks(String recordId) {
    return recordingService.getRecordingTextTracks(recordId);
  }

  public String putRecordingTextTrack(String recordId, String kind, String lang, File file, String label,
          String origFilename, String trackId, String contentType, String tempFilename) {

    Map<String, Object> logData = new HashMap<>();
    logData.put(""recordId"", recordId);
    logData.put(""kind"", kind);
    logData.put(""lang"", lang);
    logData.put(""label"", label);
    logData.put(""origFilename"", origFilename);
    logData.put(""contentType"", contentType);
    logData.put(""tempFilename"", tempFilename);
    logData.put(""logCode"", ""recording_captions_uploaded"");
    logData.put(""description"", ""Captions for recording uploaded."");

    Gson gson = new Gson();
    String logStr = gson.toJson(logData);
    log.info("" --analytics-- data={}"", logStr);

      UploadedTrack track = new UploadedTrack(recordId, kind, lang, label, origFilename, file, trackId,
              getCaptionTrackInboxDir(), contentType, tempFilename);
      return recordingService.putRecordingTextTrack(track);
  }

  public String getCaptionTrackInboxDir() {
  	return recordingService.getCaptionTrackInboxDir();
  }

  public String getCaptionsDir() {
    return recordingService.getCaptionsDir();
  }

  public boolean isRecordingExist(String recordId) {
    return recordingService.isRecordingExist(recordId);
  }

  public boolean isMeetingWithDisabledPresentation(String meetingId) {
    Meeting m = getMeeting(meetingId);
    return m.getDisabledFeatures().contains(""presentation"");
  }

  public String getRecordings2x(List<String> idList, List<String> states, Map<String, String> metadataFilters, String offset, String limit) {
    Pageable pageable = null;
    int o = -1;
    int l = -1;

    try {
      o = Integer.parseInt(offset);
      if(o < 0) o = 0;
    } catch(NumberFormatException e) {
      log.info(""Invalid offset parameter {}"", offset);
      o = 0;
    }

    try {
      l = Integer.parseInt(limit);
      if(l < 1) l = 1;
      else if(l > 100) l = 100;
    } catch(NumberFormatException e) {
      log.info(""Invalid limit parameter {}"", limit);
    }

    if(l != -1) pageable = PageRequest.ofSize(l);
    return recordingService.getRecordings2x(idList, states, metadataFilters, o, pageable);
  }

  public boolean existsAnyRecording(List<String> idList) {
    return recordingService.existAnyRecording(idList);
  }

  public void setPublishRecording(List<String> idList, boolean publish) {
    for (String id : idList) {
      if (publish) {
        if (recordingService.changeState(id, Recording.STATE_PUBLISHED)) {
          gw.publishedRecording(new PublishedRecordingMessage(id));
        }
      } else {
        if (recordingService.changeState(id, Recording.STATE_UNPUBLISHED)) {
          gw.unpublishedRecording(new UnpublishedRecordingMessage(id));
        }
      }
    }
  }

  public void deleteRecordings(List<String> idList) {
    for (String id : idList) {
      if (recordingService.changeState(id, Recording.STATE_DELETED)) {
        gw.deletedRecording(new DeletedRecordingMessage(id));
      }
    }
  }

  public void updateRecordings(List<String> idList, Map<String, String> metaParams) {
    recordingService.updateMetaParams(idList, metaParams);
  }

  public void processRecording(Meeting m) {
    if (m.isRecord()) {
      Map<String, Object> logData = new HashMap<String, Object>();
      logData.put(""meetingId"", m.getInternalId());
      logData.put(""externalMeetingId"", m.getExternalId());
      logData.put(""name"", m.getName());
      logData.put(""logCode"", ""kick_off_ingest_and_processing"");
      logData.put(""description"", ""Start processing of recording."");

      Gson gson = new Gson();
      String logStr = gson.toJson(logData);

      log.info("" --analytics-- data={}"", logStr);
      recordingService.startIngestAndProcessing(m.getInternalId());
    }
  }

  public void endMeeting(String meetingId) {
    handle(new EndMeeting(meetingId));
  }

  private void processCreateBreakoutRoom(CreateBreakoutRoom message) {
    Meeting parentMeeting = getMeeting(message.parentMeetingId);
    if (parentMeeting != null) {

      Map<String, String> params = new HashMap<>();
      params.put(ApiParams.NAME, message.name);
      params.put(ApiParams.MEETING_ID, message.meetingId);
      params.put(ApiParams.PARENT_MEETING_ID, message.parentMeetingId);
      params.put(ApiParams.IS_BREAKOUT, ""true"");
      params.put(ApiParams.SEQUENCE, message.sequence.toString());
      params.put(ApiParams.FREE_JOIN, message.freeJoin.toString());
      params.put(ApiParams.BREAKOUT_ROOMS_CAPTURE_SLIDES, message.captureSlides.toString());
      params.put(ApiParams.BREAKOUT_ROOMS_CAPTURE_NOTES, message.captureNotes.toString());
      params.put(ApiParams.BREAKOUT_ROOMS_CAPTURE_NOTES_FILENAME, message.captureNotesFilename.toString());
      params.put(ApiParams.BREAKOUT_ROOMS_CAPTURE_SLIDES_FILENAME, message.captureSlidesFilename.toString());
      params.put(ApiParams.ATTENDEE_PW, message.viewerPassword);
      params.put(ApiParams.MODERATOR_PW, message.moderatorPassword);
      params.put(ApiParams.DIAL_NUMBER, message.dialNumber);
      params.put(ApiParams.VOICE_BRIDGE, message.voiceConfId);
      params.put(ApiParams.DURATION, message.durationInMinutes.toString());
      params.put(ApiParams.RECORD, message.record.toString());
      params.put(ApiParams.WELCOME, getMeeting(message.parentMeetingId).getWelcomeMessageTemplate());
      params.put(ApiParams.NOTIFY_RECORDING_IS_ON,parentMeeting.getNotifyRecordingIsOn().toString());

      Map<String, String> parentMeetingMetadata = parentMeeting.getMetadata();

      String metaPrefix = ""meta_"";
      for (String key : parentMeetingMetadata.keySet()) {
        String metaName = metaPrefix + key;
        // Inject metadata from parent meeting into the breakout room.
        params.put(metaName, parentMeetingMetadata.get(key));
      }

      Meeting breakout = paramsProcessorUtil.processCreateParams(params);

      createMeeting(breakout);

      presDownloadService.extractPresentationPage(message.parentMeetingId,
        message.sourcePresentationId,
        message.sourcePresentationSlide, breakout.getInternalId());
    } else {
      Map<String, Object> logData = new HashMap<String, Object>();
      logData.put(""meetingId"", message.meetingId);
      logData.put(""parentMeetingId"", message.parentMeetingId);
      logData.put(""name"", message.name);
      logData.put(""logCode"", ""create_breakout_failed"");
      logData.put(""reason"", ""Parent not found."");
      logData.put(""description"", ""Create breakout failed."");

      Gson gson = new Gson();
      String logStr = gson.toJson(logData);

      log.error("" --analytics-- data={}"", logStr);
    }
  }

  private void processUpdateRecordingStatus(UpdateRecordingStatus message) {
    Meeting m = getMeeting(message.meetingId);
      // Set only once
      if (m != null && message.recording && !m.haveRecordingMarks()) {
          m.setHaveRecordingMarks(message.recording);
      }
  }

  private void processEndMeeting(EndMeeting message) {
    gw.endMeeting(new EndMeetingMessage(message.meetingId));
  }

  private void processRemoveEndedMeeting(MeetingEnded message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      m.setForciblyEnded(true);
      processRecording(m);
      if (m.getMeetingKeepEvents()) {
        // The creation of the ended tag must occur after the creation of the
        // recorded tag to avoid concurrency issues at the recording scripts
        recordingService.markAsEnded(m.getInternalId());
      }
      destroyMeeting(m.getInternalId());
      meetings.remove(m.getInternalId());
      removeUserSessions(m.getInternalId());

      Map<String, Object> logData = new HashMap<>();
      logData.put(""meetingId"", m.getInternalId());
      logData.put(""externalMeetingId"", m.getExternalId());
      logData.put(""name"", m.getName());
      logData.put(""duration"", m.getDuration());
      logData.put(""record"", m.isRecord());
      logData.put(""logCode"", ""meeting_removed_from_running"");
      logData.put(""description"", ""Meeting removed from list of running meetings."");

      Gson gson = new Gson();
      String logStr = gson.toJson(logData);

      log.info("" --analytics-- data={}"", logStr);
    }
  }

  private void processGuestStatusChangedEventMsg(GuestStatusChangedEventMsg message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      for (GuestsStatus guest : message.guests) {
        m.setGuestStatusWithId(guest.userId, guest.status);
      }
    }

    for (GuestsStatus guest : message.guests) {
      UserSession userSession = getUserSessionWithUserId(guest.userId);
      if (userSession != null) userSession.guestStatus = guest.status;
    }

  }

  private void processPresentationUploadToken(PresentationUploadToken message) {
    uploadAuthzTokens.put(message.authzToken, message);
  }

  private void expirePresentationUploadToken(String usedToken) {
    uploadAuthzTokens.remove(usedToken);
  }

  public void addUserCustomData(String meetingId, String userID,
                                Map<String, String> userCustomData) {
    Meeting m = getMeeting(meetingId);
    if (m != null) {
      m.addUserCustomData(userID, userCustomData);
    }
  }

  public Map<String, String> getUserCustomData(
      Meeting meeting,
      String externUserID,
      Map<String, String> params) {
    Map<String, String> resp = paramsProcessorUtil.getUserCustomData(params);

    // If is breakout room, merge with user's parent meeting userdata
    if (meeting.isBreakout()) {
      String parentMeetingId = meeting.getParentMeetingId();
      Meeting parentMeeting = getMeeting(parentMeetingId);

      if (parentMeeting != null) {
        // Get parent meeting user's internal id from it's breakout external id
        // parentUserInternalId-breakoutRoomNumber
        String parentUserId = externUserID.split(""-"")[0];
        User parentUser = parentMeeting.getUserById(parentUserId);

        if (parentUser != null) {
          // Custom data is stored indexed by user's external id
          Map<String, Object> customData = parentMeeting.getUserCustomData(parentUser.getExternalUserId());

          if (customData != null) {
            for (String key : customData.keySet()) {
              if (!resp.containsKey(key)) {
                resp.put(key, String.valueOf(customData.get(key)));
              }
            }
          }
        }
      }
    }

    return resp;
  }

  private void meetingStarted(MeetingStarted message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      if (m.getStartTime() == 0) {
        long now = System.currentTimeMillis();
        m.setStartTime(now);

        Map<String, Object> logData = new HashMap<>();
        logData.put(""meetingId"", m.getInternalId());
        logData.put(""externalMeetingId"", m.getExternalId());
        if (m.isBreakout()) {
          logData.put(""parentMeetingId"", m.getParentMeetingId());
        }
        logData.put(""name"", m.getName());
        logData.put(""duration"", m.getDuration());
        logData.put(""record"", m.isRecord());
        logData.put(""isBreakout"", m.isBreakout());
        logData.put(""logCode"", ""meeting_started"");
        logData.put(""description"", ""Meeting has started."");

        Gson gson = new Gson();
        String logStr = gson.toJson(logData);

        log.info("" --analytics-- data={}"", logStr);
      } else {
        Map<String, Object> logData = new HashMap<>();
        logData.put(""meetingId"", m.getInternalId());
        logData.put(""externalMeetingId"", m.getExternalId());
        if (m.isBreakout()) {
          logData.put(""parentMeetingId"", m.getParentMeetingId());
        }
        logData.put(""name"", m.getName());
        logData.put(""duration"", m.getDuration());
        logData.put(""record"", m.isRecord());
        logData.put(""isBreakout"", m.isBreakout());
        logData.put(""logCode"", ""meeting_restarted"");
        logData.put(""description"", ""Meeting has restarted."");

        Gson gson = new Gson();
        String logStr = gson.toJson(logData);

        log.info("" --analytics-- data={}"", logStr);
      }
    }
  }

  private void meetingDestroyed(MeetingDestroyed message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      long now = System.currentTimeMillis();
      m.setEndTime(now);

      Map<String, Object> logData = new HashMap<>();
      logData.put(""meetingId"", m.getInternalId());
      logData.put(""externalMeetingId"", m.getExternalId());
      logData.put(""name"", m.getName());
      logData.put(""duration"", m.getDuration());
      logData.put(""record"", m.isRecord());
      logData.put(""logCode"", ""meeting_destroyed"");
      logData.put(""description"", ""Meeting has been destroyed."");

      Gson gson = new Gson();
      String logStr = gson.toJson(logData);

      log.info("" --analytics-- data={}"", logStr);
    }
  }

  private void meetingEnded(MeetingEnded message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      long now = System.currentTimeMillis();
      m.setEndTime(now);

      Map<String, Object> logData = new HashMap<>();
      logData.put(""meetingId"", m.getInternalId());
      logData.put(""externalMeetingId"", m.getExternalId());
      logData.put(""name"", m.getName());
      logData.put(""duration"", m.getDuration());
      logData.put(""record"", m.isRecord());
      logData.put(""logCode"", ""meeting_ended"");
      logData.put(""description"", ""Meeting has ended."");

      Gson gson = new Gson();
      String logStr = gson.toJson(logData);

      log.info("" --analytics-- data={}"", logStr);

      String endCallbackUrl = ""endCallbackUrl"".toLowerCase();
      Map<String, String> metadata = m.getMetadata();
      if (!m.isBreakout()) {
        if (metadata.containsKey(endCallbackUrl)) {
          String callbackUrl = metadata.get(endCallbackUrl);
          try {
            callbackUrl = new URIBuilder(new URI(callbackUrl))
              .addParameter(""recordingmarks"", m.haveRecordingMarks() ? ""true"" : ""false"")
              .addParameter(""meetingID"", m.getExternalId()).build().toURL().toString();
            MeetingEndedEvent event = new MeetingEndedEvent(m.getInternalId(), m.getExternalId(), m.getName(), callbackUrl);
            processMeetingEndedCallback(event);
          } catch (Exception e) {
            log.error(""Error in callback url=[{}]"", callbackUrl, e);
          }
        }

        if (! StringUtils.isEmpty(m.getMeetingEndedCallbackURL())) {
          String meetingEndedCallbackURL = m.getMeetingEndedCallbackURL();
          callbackUrlService.handleMessage(new MeetingEndedEvent(m.getInternalId(), m.getExternalId(), m.getName(), meetingEndedCallbackURL));
        }
      }

      //Remove Learning Dashboard files
      if(!m.getDisabledFeatures().contains(""learningDashboard"") && m.getLearningDashboardCleanupDelayInMinutes() > 0) {
        learningDashboardService.removeJsonDataFile(message.meetingId, m.getLearningDashboardCleanupDelayInMinutes());
      }

      processRemoveEndedMeeting(message);
    }
  }

  private void processMeetingEndedCallback(MeetingEndedEvent event) {
    try {
      callbackUrlService.handleMessage(event);
    } catch (Exception e) {
      log.error(""Error in callback url=[{}]"", event.getCallbackUrl(), e);
    }
  }

  private void userJoined(UserJoined message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      if (m.getNumUsers() == 0) {
        // First user joins the meeting. Reset the end time to zero
        // in case the meeting has been rejoined.
        m.setEndTime(0);
      }

      User user = new User(message.userId, message.externalUserId,
        message.name, message.role, message.locked, message.avatarURL, message.guest, message.guestStatus,
              message.clientType);

      if(m.getMaxUsers() > 0 && m.countUniqueExtIds() >= m.getMaxUsers()) {
        m.removeEnteredUser(user.getInternalUserId());
        return;
      }

      m.userJoined(user);
      m.setGuestStatusWithId(user.getInternalUserId(), message.guestStatus);
      UserSession userSession = getUserSessionWithUserId(user.getInternalUserId());
      if (userSession != null) {
        userSession.guestStatus = message.guestStatus;
      }

      Map<String, Object> logData = new HashMap<>();
      logData.put(""meetingId"", m.getInternalId());
      logData.put(""externalMeetingId"", m.getExternalId());
      logData.put(""name"", m.getName());
      logData.put(""userId"", message.userId);
      logData.put(""externalUserId"", user.getExternalUserId());
      logData.put(""username"", user.getFullname());
      logData.put(""role"", user.getRole());
      logData.put(""guest"", user.isGuest());
      logData.put(""guestStatus"", user.getGuestStatus());
      logData.put(""logCode"", ""user_joined_message"");
      logData.put(""description"", ""User joined the meeting."");
      logData.put(""clientType"", user.getClientType());

      Gson gson = new Gson();
      String logStr = gson.toJson(logData);
      log.info("" --analytics-- data={}"", logStr);
    }
  }

  private void userLeft(UserLeft message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      User user = m.userLeft(message.userId);
      if (user != null) {

        Map<String, Object> logData = new HashMap<>();
        logData.put(""meetingId"", m.getInternalId());
        logData.put(""externalMeetingId"", m.getExternalId());
        logData.put(""name"", m.getName());
        logData.put(""userId"", message.userId);
        logData.put(""externalUserId"", user.getExternalUserId());
        logData.put(""username"", user.getFullname());
        logData.put(""role"", user.getRole());
        logData.put(""guest"", user.isGuest());
        logData.put(""guestStatus"", user.getGuestStatus());
        logData.put(""logCode"", ""user_left_message"");
        logData.put(""description"", ""User left the meeting."");

        Gson gson = new Gson();
        String logStr = gson.toJson(logData);

        log.info("" --analytics-- data={}"", logStr);

        if (m.getNumUsers() == 0) {
          // Last user the meeting. Mark this as the time
          // the meeting ended.
          m.setEndTime(System.currentTimeMillis());
        }
      }
    }
  }

  private void updatedStatus(UserStatusChanged message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      User user = m.getUserById(message.userId);
      if (user != null) {
        user.setStatus(message.status, message.value);
      }
    }
  }

  public void processLearningDashboard(LearningDashboard message) {
    //Get all data from Json instead of getMeeting(message.meetingId), to process messages received even after meeting ended
    JsonObject activityJsonObject = new Gson().fromJson(message.activityJson, JsonObject.class).getAsJsonObject();

    Map<String, Object> logData = new HashMap<String, Object>();
    logData.put(""meetingId"", activityJsonObject.get(""intId"").getAsString());
    logData.put(""externalMeetingId"", activityJsonObject.get(""extId"").getAsString());
    logData.put(""name"", activityJsonObject.get(""name"").getAsString());
    logData.put(""logCode"", ""update_activity_json"");
    logData.put(""description"", ""Updating activities json."");

    Gson gson = new Gson();
    String logStr = gson.toJson(logData);

    log.info("" --analytics-- data={}"", logStr);

    learningDashboardService.writeJsonDataFile(message.meetingId, message.learningDashboardAccessToken, message.activityJson);
  }

  @Override
  public void handle(IMessage message) {
    receivedMessages.add(message);
  }

  public void setParamsProcessorUtil(ParamsProcessorUtil util) {
    this.paramsProcessorUtil = util;
  }

  public void setPresDownloadService(
    PresentationUrlDownloadService presDownloadService) {
    this.presDownloadService = presDownloadService;
  }

  public void userJoinedVoice(UserJoinedVoice message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      User user = m.getUserById(message.userId);
      if (user != null) {
        user.setVoiceJoined(true);
      } else {
        if (message.userId.startsWith(""v_"")) {
          // A dial-in user joined the meeting. Dial-in users by convention has userId that starts with ""v_"".
                    User vuser = new User(message.userId, message.userId, message.name, ""DIAL-IN-USER"", true, """",
                            true, GuestPolicy.ALLOW, ""DIAL-IN"");
          vuser.setVoiceJoined(true);
          m.userJoined(vuser);
        }
      }
    }
  }

  public void userLeftVoice(UserLeftVoice message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      User user = m.getUserById(message.userId);
      if (user != null) {
        if (message.userId.startsWith(""v_"")) {
          // A dial-in user left the meeting. Dial-in users by convention has userId that starts with ""v_"".
          User vuser = m.userLeft(message.userId);
        } else {
          user.setVoiceJoined(false);
          // userLeftVoice is also used when user leaves Global (listenonly)
          // audio. Also tetting listenOnly to false is not a problem,
          // once user can't join both voice/mic and global/listenonly
          // at the same time.
          user.setListeningOnly(false);
        }
      }
    }
  }

  public void userListeningOnly(UserListeningOnly message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      User user = m.getUserById(message.userId);
      if (user != null) {
        user.setListeningOnly(message.listenOnly);
      }
    }
  }

  public void userSharedWebcam(UserSharedWebcam message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      User user = m.getUserById(message.userId);
      if (user != null) {
        user.addStream(message.stream);
      }
    }
  }

  public void userUnsharedWebcam(UserUnsharedWebcam message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      User user = m.getUserById(message.userId);
      if (user != null) {
        user.removeStream(message.stream);
      }
    }
  }

  private void userRoleChanged(UserRoleChanged message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      User user = m.getUserById(message.userId);
      if (user != null) {
        user.setRole(message.role);
        String sessionToken = getTokenByUserId(user.getInternalUserId());
        if (sessionToken != null) {
            UserSession userSession = getUserSessionWithAuthToken(sessionToken);
            userSession.role = message.role;
            sessions.replace(sessionToken, userSession);
        }
        log.debug(""Setting new role in meeting {} for participant: {}"", message.meetingId, user.getFullname());
        return;
      }
      log.warn(""The participant {} doesn't exist in the meeting {}"", message.userId, message.meetingId);
      return;
    }
    log.warn(""The meeting {} doesn't exist"", message.meetingId);
  }

  private void userLockedInMeeting(UserLockedInMeeting message) {
    Meeting m = getMeeting(message.meetingId);
    if (m != null) {
      User user = m.getUserById(message.userId);
      if (user != null) {
        user.setLocked(message.locked);
        log.debug(""Setting locked flag in meeting {} for participant: {}"", message.meetingId, user.getFullname());
        return;
      }
      log.warn(""The participant {} doesn't exist in the meeting {}"", message.userId, message.meetingId);
      return;
    }
    log.warn(""The meeting {} doesn't exist"", message.meetingId);
  }

  private void processMessage(final IMessage message) {
    Runnable task = new Runnable() {
      public void run() {
        if (message instanceof MeetingStarted) {
          meetingStarted((MeetingStarted) message);
        } else if (message instanceof MeetingDestroyed) {
          meetingDestroyed((MeetingDestroyed) message);
        } else if (message instanceof MeetingEnded) {
          meetingEnded((MeetingEnded) message);
        } else if (message instanceof UserJoined) {
          userJoined((UserJoined) message);
        } else if (message instanceof UserLeft) {
          userLeft((UserLeft) message);
        } else if (message instanceof UserStatusChanged) {
          updatedStatus((UserStatusChanged) message);
        } else if (message instanceof UserRoleChanged) {
          userRoleChanged((UserRoleChanged) message);
        } else if (message instanceof UserLockedInMeeting) {
          userLockedInMeeting((UserLockedInMeeting) message);
        } else if (message instanceof UserJoinedVoice) {
          userJoinedVoice((UserJoinedVoice) message);
        } else if (message instanceof UserLeftVoice) {
          userLeftVoice((UserLeftVoice) message);
        } else if (message instanceof UserListeningOnly) {
          userListeningOnly((UserListeningOnly) message);
        } else if (message instanceof UserSharedWebcam) {
          userSharedWebcam((UserSharedWebcam) message);
        } else if (message instanceof UserUnsharedWebcam) {
          userUnsharedWebcam((UserUnsharedWebcam) message);
        } else if (message instanceof CreateMeeting) {
          processCreateMeeting((CreateMeeting) message);
        } else if (message instanceof EndMeeting) {
          processEndMeeting((EndMeeting) message);
        } else if (message instanceof RegisterUser) {
          processRegisterUser((RegisterUser) message);
        } else if (message instanceof CreateBreakoutRoom) {
          processCreateBreakoutRoom((CreateBreakoutRoom) message);
        } else if (message instanceof PresentationUploadToken) {
          processPresentationUploadToken((PresentationUploadToken) message);
        } else if (message instanceof PositionInWaitingQueueUpdated) {
          processPositionInWaitingQueueUpdated((PositionInWaitingQueueUpdated) message);
        } else if (message instanceof GuestStatusChangedEventMsg) {
          processGuestStatusChangedEventMsg((GuestStatusChangedEventMsg) message);
        } else if (message instanceof GuestPolicyChanged) {
          processGuestPolicyChanged((GuestPolicyChanged) message);
        } else if (message instanceof GuestLobbyMessageChanged) {
          processGuestLobbyMessageChanged((GuestLobbyMessageChanged) message);
        } else if (message instanceof PrivateGuestLobbyMessageChanged) {
          processPrivateGuestLobbyMessageChanged((PrivateGuestLobbyMessageChanged) message); 
        } else if (message instanceof RecordChapterBreak) {
          processRecordingChapterBreak((RecordChapterBreak) message);
        } else if (message instanceof MakePresentationDownloadableMsg) {
          processMakePresentationDownloadableMsg((MakePresentationDownloadableMsg) message);
        } else if (message instanceof UpdateRecordingStatus) {
          processUpdateRecordingStatus((UpdateRecordingStatus) message);
        } else if (message instanceof LearningDashboard) {
          processLearningDashboard((LearningDashboard) message);
        }
      }
    };

    runExec.execute(task);
  }

  public void processGuestPolicyChanged(GuestPolicyChanged msg) {
    Meeting m = getMeeting(msg.meetingId);
    if (m != null) {
      m.setGuestPolicy(msg.policy);
    }
  }

  public void processPositionInWaitingQueueUpdated(PositionInWaitingQueueUpdated msg) {
    Meeting m = getMeeting(msg.meetingId);
    HashMap<String,String> guestUsers = msg.guests;
    if (m != null) {
      m.setWaitingPositionsInWaitingQueue(guestUsers);
    }
  }

  public void processGuestLobbyMessageChanged(GuestLobbyMessageChanged msg) {
    Meeting m = getMeeting(msg.meetingId);
    if (m != null) {
      m.setGuestLobbyMessage(msg.message);
    }
  }

  public void processPrivateGuestLobbyMessageChanged(PrivateGuestLobbyMessageChanged msg) {
    Meeting m = getMeeting(msg.meetingId);
    if (m != null) {
      m.setPrivateGuestLobbyMessage(msg.guestId, msg.message);
    }
  }

  public void processRecordingChapterBreak(RecordChapterBreak msg) {
    recordingService.kickOffRecordingChapterBreak(msg.meetingId, msg.timestamp);
  }

  private void processMakePresentationDownloadableMsg(MakePresentationDownloadableMsg msg) {
    recordingService.processMakePresentationDownloadableMsg(msg);
  }

  public File getDownloadablePresentationFile(String meetingId, String presId, String presFilename) {
    return recordingService.getDownloadablePresentationFile(meetingId, presId, presFilename);
  }

  public void start() {
    log.info(""Starting Meeting Service."");
    try {
      processMessage = true;
      Process p = Runtime.getRuntime().exec(new String[]{""/bin/sh"", ""-c"", ""cat /etc/bigbluebutton/bigbluebutton-release | cut -d '=' -f2""});

      BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));

      String apiVersionFromFile = reader.readLine();

      paramsProcessorUtil.setBbbVersion(apiVersionFromFile);
      Runnable messageReceiver = new Runnable() {
        public void run() {
          while (processMessage) {
            try {
              IMessage msg = receivedMessages.take();
              processMessage(msg);
            } catch (InterruptedException e) {
              log.error(""InterruptedException while starting Meeting Service"", e);
            } catch (Exception e) {
              log.error(""Handling unexpected exception"", e);
            }
          }
        }
      };

      msgProcessorExec.execute(messageReceiver);
    } catch (Exception e) {
      log.error(""Error PRocessing Message"");
    }
  }

  public void stop() {
    processMessage = false;
    waitingGuestCleaner.stop();
    userCleaner.stop();
    enteredUserCleaner.stop();
  }

  public void setRecordingService(RecordingService s) {
    recordingService = s;
  }

  public void setLearningDashboardService(LearningDashboardService s) {
    learningDashboardService = s;
  }

  public void setRedisStorageService(RedisStorageService mess) {
    storeService = mess;
  }

  public void setCallbackUrlService(CallbackUrlService service) {
    callbackUrlService = service;
  }

  public void setGw(IBbbWebApiGWApp gw) {
    this.gw = gw;
  }

  public void setWaitingGuestCleanupTimerTask(WaitingGuestCleanupTimerTask c) {
    waitingGuestCleaner = c;
    waitingGuestCleaner.setMeetingService(this);
    waitingGuestCleaner.start();
  }

  public void setEnteredUserCleanupTimerTask(EnteredUserCleanupTimerTask c) {
    enteredUserCleaner = c;
    enteredUserCleaner.setMeetingService(this);
    enteredUserCleaner.start();
  }

  public void setUserCleanupTimerTask(UserCleanupTimerTask c) {
    userCleaner = c;
    userCleaner.setMeetingService(this);
    userCleaner.start();
  }

  public void setStunTurnService(StunTurnService s) {
    stunTurnService = s;
  }

  public void setUsersTimeout(long value) {
    usersTimeout = value;
  }

  public void setWaitingGuestUsersTimeout(long value) {
    waitingGuestUsersTimeout = value;
  }

  public void setEnteredUsersTimeout(long value) {
    enteredUsersTimeout = value;
  }

  public void setSlidesGenerationProgressNotifier(SlidesGenerationProgressNotifier notifier) {
    this.notifier = notifier;
  }

}"
bbb-common-web/src/main/java/org/bigbluebutton/api/Util.java,"package org.bigbluebutton.api;

import java.io.File;
import java.io.IOException;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang3.StringUtils;

public final class Util {

	private static final Pattern MEETING_ID_PATTERN = Pattern.compile(""^[a-z0-9-]+$"");
	private static final Pattern PRES_ID_PATTERN = Pattern.compile(""^[a-z0-9-]+$"");
	// see https://www.baeldung.com/java-regexp-escape-char#1-escaping-using-backslash
	private static final Pattern PRES_FILE_ID_PATTERN = Pattern.compile(""^[a-z0-9-]+\\.[a-zA-Z]{3,4}$"");

	private Util() {
		throw new IllegalStateException(""Utility class"");
	}

	public static boolean isMeetingIdValidFormat(String id) {
		Matcher matcher = MEETING_ID_PATTERN.matcher(id);
		if (matcher.matches()) {
			return true;
		}
		return false;
	}

	public static boolean isPresIdValidFormat(String id) {
		Matcher matcher = PRES_ID_PATTERN.matcher(id);
		if (matcher.matches()) {
			return true;
		}
		return false;
	}

	public static boolean isPresFileIdValidFormat(String id) {
		Matcher matcher = PRES_FILE_ID_PATTERN.matcher(id);
		if (matcher.matches()) {
			return true;
		}
		return false;
	}

	public static String generatePresentationId(String presFilename) {
		long timestamp = System.currentTimeMillis();
		String uuid = UUID.randomUUID().toString();
		return DigestUtils.sha1Hex(presFilename + uuid) + ""-"" + timestamp;
	}

	public static String createNewFilename(String presId, String fileExt) {
		return presId + ""."" + fileExt;
	}
	
	public static File createPresentationDir(String meetingId, String presentationDir, String presentationId) {
		if (Util.isMeetingIdValidFormat(meetingId) && Util.isPresIdValidFormat(presentationId)) {
			String meetingPath = presentationDir + File.separatorChar + meetingId + File.separatorChar + meetingId;
			String presPath = meetingPath + File.separatorChar + presentationId;
			File dir = new File(presPath);
			if (dir.mkdirs()) {
				return dir;
			}
		}

		return null;
	}

	public static File getMeetingDirPath(String presentationBaseDir, String meetingId) {
		if (Util.isMeetingIdValidFormat(meetingId)) {
			String meetingPath = presentationBaseDir + File.separatorChar + meetingId + File.separatorChar + meetingId;
			File dir = new File(meetingPath);
			if (dir.isDirectory() && dir.exists()) {
				return dir;
			}
		}

		return null;
	}

	public static File getPresentationDir(String presentationBaseDir, String meetingId, String presentationId) {
		if (Util.isMeetingIdValidFormat(meetingId) && Util.isPresIdValidFormat(presentationId)) {
			String meetingPath = presentationBaseDir + File.separatorChar + meetingId + File.separatorChar + meetingId;
			String presPath = meetingPath + File.separatorChar + presentationId;
			File dir = new File(presPath);
			if (dir.isDirectory() && dir.exists()) {
				return dir;
			}
		}

		return null;
	}

	public String stripPresBaseDirFromPath(String presentationBaseDir, String path) {
		if (path.startsWith(presentationBaseDir)) {
			String presBaseDir = presentationBaseDir;
			if (! presBaseDir.endsWith(""/"")) {
				presBaseDir = presBaseDir.concat(""/"");
				return StringUtils.removeStart(path, presBaseDir);
			} else {
				return StringUtils.removeStart(path, presBaseDir);
			}
		}
		return path;
	}

	public static File getPresFileDownloadMarker(File presBaseDir, String presId) {
		if (presBaseDir != null) {
			String downloadMarker = presId.concat("".downloadable"");
			return new File(presBaseDir.getAbsolutePath() + File.separatorChar + downloadMarker);
		}
		return null;
	}

	public static void makePresentationDownloadable(
		File presFileDir,
		String presId,
		boolean downloadable
	) throws IOException {
		File downloadMarker = Util.getPresFileDownloadMarker(presFileDir, presId);
		if (downloadable && downloadMarker != null && ! downloadMarker.exists()) {
			downloadMarker.createNewFile();
		}
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/IReceivedOldMessageHandler.java,"package org.bigbluebutton.api;

import org.bigbluebutton.api.messaging.messages.IMessage;

public interface IReceivedOldMessageHandler {
    void handleMessage(IMessage msg);
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/MessageDistributor.java,"package org.bigbluebutton.api.messaging;

import java.util.Set;

import org.bigbluebutton.api.messaging.messages.IMessage;

public class MessageDistributor {
    private ReceivedMessageHandler handler;
    private Set<MessageListener> listeners;

    public void setMessageListeners(Set<MessageListener> listeners) {
        this.listeners = listeners;
    }

    public void setMessageHandler(ReceivedMessageHandler handler) {
        this.handler = handler;
        if (handler != null) {
            handler.setMessageDistributor(this);
        }
    }

    public void notifyListeners(IMessage message) {
        for (MessageListener listener : listeners) {
            listener.handle(message);
        }
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/converters/messages/PublishedRecordingMessage.java,"package org.bigbluebutton.api.messaging.converters.messages;

public class PublishedRecordingMessage {
	public static final String PUBLISHED_RECORDING_EVENT = ""published_recording_event"";
	public static final String VERSION = ""0.0.1"";

	public final String recordId;

	public PublishedRecordingMessage(String recordId) {
		this.recordId = recordId;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/converters/messages/EndMeetingMessage.java,"package org.bigbluebutton.api.messaging.converters.messages;

public class EndMeetingMessage {
  public static final String END_MEETING_REQUEST_EVENT = ""end_meeting_request_event"";
  public static final String VERSION = ""0.0.1"";

  public final String meetingId;

  public EndMeetingMessage(String meetingId) {
    this.meetingId = meetingId;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/converters/messages/KeepAliveMessage.java,"package org.bigbluebutton.api.messaging.converters.messages;

public class KeepAliveMessage {
	public static final String KEEP_ALIVE_REQUEST                 = ""keep_alive_request"";
	public static final String VERSION = ""0.0.1"";
	
	public final String keepAliveId;
	
	public KeepAliveMessage(String keepAliveId) {
		this.keepAliveId = keepAliveId;	
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/converters/messages/DestroyMeetingMessage.java,"package org.bigbluebutton.api.messaging.converters.messages;

public class DestroyMeetingMessage {
  public static final String DESTROY_MEETING_REQUEST_EVENT = ""destroy_meeting_request_event"";
  public static final String VERSION = ""0.0.1"";

  public final String meetingId;

  public DestroyMeetingMessage(String meetingId) {
    this.meetingId = meetingId;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/converters/messages/CreateMeetingMessage.java,"package org.bigbluebutton.api.messaging.converters.messages;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class CreateMeetingMessage {
	public static final String CREATE_MEETING_REQUEST_EVENT  = ""create_meeting_request"";
	public static final String VERSION = ""0.0.1"";
	
	public final String id;
	public final String externalId;
	public final String name;
	public final Boolean record;
	public final String voiceBridge;
	public final Long duration;
	public boolean autoStartRecording;
	public boolean allowStartStopRecording;
	public boolean webcamsOnlyForModerator;
	public final Integer meetingCameraCap;
	public final Integer userCameraCap;
	public final Integer maxPinnedCameras;
	public final String moderatorPass;
	public final String viewerPass;
	public final String learningDashboardAccessToken;
	public final ArrayList<String> disabledFeatures;
	public final Boolean notifyRecordingIsOn;
	public final String presentationUploadExternalDescription;
	public final String presentationUploadExternalUrl;
	public final Long createTime;
	public final String createDate;
	public final Map<String, String> metadata;
	
	public CreateMeetingMessage(String id, String externalId, String name, Boolean record, 
						String voiceBridge, Long duration, 
						Boolean autoStartRecording, Boolean allowStartStopRecording,
						Boolean webcamsOnlyForModerator, Integer meetingCameraCap, Integer userCameraCap, Integer maxPinnedCameras, String moderatorPass,
						String viewerPass, String learningDashboardAccessToken,
						ArrayList<String> disabledFeatures,
						Boolean notifyRecordingIsOn,
						String presentationUploadExternalDescription,
						String presentationUploadExternalUrl,
						Long createTime, String createDate, Map<String, String> metadata) {
		this.id = id;
		this.externalId = externalId;
		this.name = name;
		this.record = record;
		this.voiceBridge = voiceBridge;
		this.duration = duration;
		this.autoStartRecording = autoStartRecording;
		this.allowStartStopRecording = allowStartStopRecording;
		this.webcamsOnlyForModerator = webcamsOnlyForModerator;
		this.meetingCameraCap = meetingCameraCap;
		this.userCameraCap = userCameraCap;
		this.maxPinnedCameras = maxPinnedCameras;
		this.moderatorPass = moderatorPass;
		this.viewerPass = viewerPass;
		this.learningDashboardAccessToken = learningDashboardAccessToken;
		this.disabledFeatures = disabledFeatures;
		this.notifyRecordingIsOn = notifyRecordingIsOn;
		this.presentationUploadExternalDescription = presentationUploadExternalDescription;
		this.presentationUploadExternalUrl = presentationUploadExternalUrl;
		this.createTime = createTime;
		this.createDate = createDate;
		this.metadata = metadata;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/converters/messages/DeletedRecordingMessage.java,"package org.bigbluebutton.api.messaging.converters.messages;

public class DeletedRecordingMessage {
	public static final String DELETED_RECORDING_EVENT = ""deleted_recording_event"";
	public static final String VERSION = ""0.0.1"";

	public final String recordId;

	public DeletedRecordingMessage(String recordId) {
		this.recordId = recordId;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/converters/messages/UnpublishedRecordingMessage.java,"package org.bigbluebutton.api.messaging.converters.messages;

public class UnpublishedRecordingMessage {
	public static final String UNPUBLISHED_RECORDING_EVENT = ""unpublished_recording_event"";
	public static final String VERSION = ""0.0.1"";

	public final String recordId;

	public UnpublishedRecordingMessage(String recordId) {
		this.recordId = recordId;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/ReceivedMessage.java,"package org.bigbluebutton.api.messaging;

import org.bigbluebutton.api.messaging.messages.IMessage;

public class ReceivedMessage {
  private final IMessage message;

  public ReceivedMessage(IMessage message) {

    this.message = message;
  }

  public IMessage getMessage() {
    return message;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/MessagingService.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */

package org.bigbluebutton.api.messaging;

import java.util.Map;

public interface MessagingService {
  void recordMeetingInfo(String meetingId, Map<String, String> info);

  void recordBreakoutInfo(String meetingId, Map<String, String> breakoutInfo);

  void addBreakoutRoom(String parentId, String breakoutId);
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/MessageListener.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */

package org.bigbluebutton.api.messaging;

import org.bigbluebutton.api.messaging.messages.IMessage;

public interface MessageListener {
  void handle(IMessage message);
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/ReceivedMessageHandler.java,"package org.bigbluebutton.api.messaging;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

import org.bigbluebutton.api.IReceivedOldMessageHandler;
import org.bigbluebutton.api.messaging.messages.IMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ReceivedMessageHandler implements IReceivedOldMessageHandler {
    private static Logger log = LoggerFactory.getLogger(ReceivedMessageHandler.class);

    private BlockingQueue<ReceivedMessage> receivedMessages = new LinkedBlockingQueue<>();

    private volatile boolean processMessage = false;

    private final Executor msgProcessorExec = Executors.newSingleThreadExecutor();
    private final Executor runExec = Executors.newSingleThreadExecutor();

    private MessageDistributor outGW;

    public void stop() {
        processMessage = false;
    }

    public void start() {
        log.info(""Ready to handle messages from Redis pubsub!"");

        try {
            processMessage = true;

            Runnable messageProcessor = new Runnable() {
                public void run() {
                    while (processMessage) {
                        try {
                            ReceivedMessage msg = receivedMessages.take();
                            processMessage(msg);
                        } catch (InterruptedException e) {
                            log.warn(""Error while taking received message from queue."");
                        }
                    }
                }
            };
            msgProcessorExec.execute(messageProcessor);
        } catch (Exception e) {
            log.error(""Error subscribing to channels: {}"", e);
        }
    }

    private void notifyListeners(IMessage message) {
        outGW.notifyListeners(message);
    }

    private void processMessage(final ReceivedMessage msg) {
        Runnable task = new Runnable() {
            public void run() {
                notifyListeners(msg.getMessage());
            }
        };

        runExec.execute(task);
    }

    public void handleMessage(IMessage message) {
        ReceivedMessage rm = new ReceivedMessage(message);
        receivedMessages.add(rm);
    }

    public void setMessageDistributor(MessageDistributor outGW) {
        this.outGW = outGW;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/UserSharedWebcam.java,"package org.bigbluebutton.api.messaging.messages;

public class UserSharedWebcam implements IMessage {
  public final String userId;
  public final String meetingId;
  public final String stream;
  
  public UserSharedWebcam(String meetingId, String userId, String stream) {
  	this.meetingId = meetingId;
  	this.userId = userId;
  	this.stream = stream;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/UserJoined.java,"package org.bigbluebutton.api.messaging.messages;

public class UserJoined implements IMessage {
  public final String meetingId;
  public final String userId;
  public final String externalUserId;
  public final String name;
  public final String role;
  public final Boolean locked;
  public final String avatarURL;
  public final Boolean guest;
  public final String guestStatus;
	public final String clientType;
  

  public UserJoined(String meetingId,
										String userId,
										String externalUserId,
										String name,
										String role,
										Boolean locked,
										String avatarURL,
										Boolean guest,
										String guestStatus,
										String clientType) {
  	this.meetingId = meetingId;
  	this.userId = userId;
  	this.externalUserId = externalUserId;
  	this.name = name;
  	this.role = role;
  	this.locked = locked;
  	this.avatarURL = avatarURL;
  	this.guest = guest;
  	this.guestStatus = guestStatus;
  	this.clientType = clientType;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/MeetingStarted.java,"package org.bigbluebutton.api.messaging.messages;

public class MeetingStarted implements IMessage {
  public final String meetingId;
  
  public MeetingStarted(String meetingId) {
  	this.meetingId = meetingId;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/IMessage.java,"package org.bigbluebutton.api.messaging.messages;

public interface IMessage {

}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/MeetingEnded.java,"package org.bigbluebutton.api.messaging.messages;

public class MeetingEnded implements IMessage {
  public final String meetingId;
  
  public MeetingEnded(String meetingId) {
  	this.meetingId = meetingId;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/RegisterUser.java,"package org.bigbluebutton.api.messaging.messages;


public class RegisterUser implements IMessage {

	public final String meetingID;
	public final String internalUserId;
	public final String fullname;
	public final String role;
	public final String externUserID;
	public final String authToken;
	public final String sessionToken;
	public final String avatarURL;
	public final Boolean guest;
	public final Boolean authed;
	public final String guestStatus;
	public final Boolean excludeFromDashboard;
	public final Boolean leftGuestLobby;

	public RegisterUser(String meetingID, String internalUserId, String fullname, String role, String externUserID,
						String authToken, String sessionToken, String avatarURL, Boolean guest,
						Boolean authed, String guestStatus, Boolean excludeFromDashboard, Boolean leftGuestLobby) {
		this.meetingID = meetingID;
		this.internalUserId = internalUserId;
		this.fullname = fullname;
		this.role = role;
		this.externUserID = externUserID;
		this.authToken = authToken;
		this.sessionToken = sessionToken;
		this.avatarURL = avatarURL;
		this.guest = guest;
		this.authed = authed;
		this.guestStatus = guestStatus;
		this.excludeFromDashboard = excludeFromDashboard;
		this.leftGuestLobby = leftGuestLobby;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/EndMeeting.java,"package org.bigbluebutton.api.messaging.messages;

public class EndMeeting implements IMessage {

	public final String meetingId;
	
	public EndMeeting(String meetingId) {
		this.meetingId = meetingId;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/UserListeningOnly.java,"package org.bigbluebutton.api.messaging.messages;

public class UserListeningOnly implements IMessage {
  public final String userId;
  public final String meetingId;
  public final Boolean listenOnly;
  
  public UserListeningOnly(String meetingId, String userId, Boolean listenOnly) {
  	this.meetingId = meetingId;
  	this.userId = userId;
  	this.listenOnly = listenOnly;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/EndBreakoutRoom.java,"package org.bigbluebutton.api.messaging.messages;

public class EndBreakoutRoom implements IMessage {
  public final String breakoutMeetingId;

  public EndBreakoutRoom(String breakoutMeetingId) {
    this.breakoutMeetingId = breakoutMeetingId;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/UserJoinedVoice.java,"package org.bigbluebutton.api.messaging.messages;

public class UserJoinedVoice implements IMessage {
  public final String userId;
  public final String meetingId;
  public final String name;
  
  public UserJoinedVoice(String meetingId, String userId, String name) {
  	this.meetingId = meetingId;
  	this.userId = userId;
  	this.name = name;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/MakePresentationDownloadableMsg.java,"package org.bigbluebutton.api.messaging.messages;

public class MakePresentationDownloadableMsg implements IMessage {
	public final String meetingId;
	public final String presId;
	public final String presFilename;
	public final Boolean downloadable;

	public MakePresentationDownloadableMsg(String meetingId, String presId, String presFilename, Boolean downloadable) {
		this.meetingId = meetingId;
		this.presId = presId;
		this.presFilename = presFilename;
		this.downloadable = downloadable;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/PresentationUploadToken.java,"package org.bigbluebutton.api.messaging.messages;

public class PresentationUploadToken implements IMessage  {
    public final String podId;
    public final String authzToken;
    public final String filename;
    public final String meetingId;

    public PresentationUploadToken(String podId, String authzToken, String filename, String meetingId) {
        this.podId = podId;
        this.authzToken = authzToken;
        this.filename = filename;
        this.meetingId = meetingId;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/GuestsStatus.java,"package org.bigbluebutton.api.messaging.messages;

public class GuestsStatus {

    public final String userId;
    public final String status;

    public GuestsStatus(String userId, String status) {
      this.userId = userId;
      this.status = status;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/KeepAliveReply.java,"package org.bigbluebutton.api.messaging.messages;

public class KeepAliveReply implements IMessage {
	
  public final String system;
  public final Long bbbWebTimestamp;
  public final Long akkaAppsTimestamp;

  public KeepAliveReply(String system, Long bbbWebTimestamp, Long akkaAppsTimestamp) {
  	this.system = system;
  	this.bbbWebTimestamp = bbbWebTimestamp;
  	this.akkaAppsTimestamp = akkaAppsTimestamp;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/StunTurnInfoRequested.java,"package org.bigbluebutton.api.messaging.messages;

public class StunTurnInfoRequested implements IMessage {
	public final String meetingId;
	public final String internalUserId;

	public StunTurnInfoRequested (String meetingId, String internalUserId) {
		this.meetingId = meetingId;
		this.internalUserId = internalUserId;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/UserLeft.java,"package org.bigbluebutton.api.messaging.messages;

public class UserLeft implements IMessage {
  public final String userId;
  public final String meetingId;
  
  public UserLeft(String meetingId, String userId) {
  	this.meetingId = meetingId;
  	this.userId = userId;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/UserRoleChanged.java,"package org.bigbluebutton.api.messaging.messages;

public class UserRoleChanged implements IMessage {
	public final String meetingId;
	public final String userId;
	public final String role;

	public UserRoleChanged(String meetingId, String userId, String role) {
		this.meetingId = meetingId;
		this.userId = userId;
		this.role = role;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/UserUnsharedWebcam.java,"package org.bigbluebutton.api.messaging.messages;

public class UserUnsharedWebcam implements IMessage {
  public final String userId;
  public final String meetingId;
  public final String stream;
  
  public UserUnsharedWebcam(String meetingId, String userId, String stream) {
  	this.meetingId = meetingId;
  	this.userId = userId;
  	this.stream = stream;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/UserLockedInMeeting.java,"package org.bigbluebutton.api.messaging.messages;

public class UserLockedInMeeting implements IMessage {
	public final String meetingId;
	public final String userId;
	public final Boolean locked;

	public UserLockedInMeeting(String meetingId, String userId, Boolean locked) {
		this.meetingId = meetingId;
		this.userId = userId;
		this.locked = locked;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/MeetingDestroyed.java,"package org.bigbluebutton.api.messaging.messages;

public class MeetingDestroyed implements IMessage {
  public final String meetingId;
  
  public MeetingDestroyed(String meetingId) {
  	this.meetingId = meetingId;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/CreateMeeting.java,"package org.bigbluebutton.api.messaging.messages;

import org.bigbluebutton.api.domain.Meeting;

public class CreateMeeting implements IMessage {

	public final Meeting meeting;
	
	public CreateMeeting(Meeting meeting) {
		this.meeting = meeting;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/LearningDashboard.java,"package org.bigbluebutton.api.messaging.messages;

public class LearningDashboard implements IMessage {
    public final String meetingId;
    public final String activityJson;
    public final String learningDashboardAccessToken;

    public LearningDashboard(String meetingId, String learningDashboardAccessToken, String activityJson) {
        this.meetingId = meetingId;
        this.activityJson = activityJson;
        this.learningDashboardAccessToken = learningDashboardAccessToken;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/UserStatusChanged.java,"package org.bigbluebutton.api.messaging.messages;

public class UserStatusChanged implements IMessage {
  public final String meetingId;
  public final String userId;
  public final String status;
  public final String value;
  
  public UserStatusChanged(String meetingId, String userId, String status, String value) {
  	this.meetingId = meetingId;
  	this.userId = userId;
  	this.status = status;
  	this.value = value;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/PrivateGuestLobbyMessageChanged.java,"package org.bigbluebutton.api.messaging.messages;

public class PrivateGuestLobbyMessageChanged implements IMessage {
    public final String meetingId;
    public final String message;
    public final String guestId;

    public PrivateGuestLobbyMessageChanged(String meetingId, String guestId, String message) {
        this.meetingId = meetingId;
        this.guestId = guestId;
        this.message = message;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/RecordChapterBreak.java,"package org.bigbluebutton.api.messaging.messages;

public class RecordChapterBreak implements IMessage {
    public final String meetingId;
    public final Long timestamp;

    public RecordChapterBreak(String meetingId, Long timestamp) {
        this.meetingId = meetingId;
        this.timestamp = timestamp;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/UserLeftVoice.java,"package org.bigbluebutton.api.messaging.messages;

public class UserLeftVoice implements IMessage {
  public final String userId;
  public final String meetingId;
  
  public UserLeftVoice(String meetingId, String userId) {
  	this.meetingId = meetingId;
  	this.userId = userId;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/CreateBreakoutRoom.java,"package org.bigbluebutton.api.messaging.messages;

public class CreateBreakoutRoom implements IMessage {

    public final String meetingId;
    public final String parentMeetingId; // The main meeting internal id
    public final String name; // The name of the breakout room
    public final Integer sequence; // The sequence number of the breakout room
    public final String shortName; // Name used in breakout rooms list
    public final Boolean isDefaultName; // Inform if using default name or changed by moderator
    public final Boolean freeJoin; // Allow users to freely join the conference
                                   // in the client
    public final String dialNumber;
    public final String voiceConfId; // The voice conference id
    public final String viewerPassword;
    public final String moderatorPassword;
    public final Integer durationInMinutes; // The duration of the breakout room
    public final String sourcePresentationId;
    public final Integer sourcePresentationSlide;
    public final Boolean record;
    public final Boolean privateChatEnabled;
    public final Boolean captureNotes; // Upload shared notes to main room after breakout room end
    public final Boolean captureSlides; // Upload annotated breakout slides to main room after breakout room end
    public final String captureNotesFilename;
    public final String captureSlidesFilename;

    public CreateBreakoutRoom(String meetingId,
															String parentMeetingId,
															String name,
															Integer sequence,
															String shortName,
															Boolean isDefaultName,
															Boolean freeJoin,
															String dialNumber,
															String voiceConfId,
															String viewerPassword,
															String moderatorPassword,
															Integer duration,
															String sourcePresentationId,
															Integer sourcePresentationSlide,
															Boolean record,
															Boolean privateChatEnabled,
                                                            Boolean captureNotes,
                                                            Boolean captureSlides,
                                                            String captureNotesFilename,
                                                            String captureSlidesFilename) {
        this.meetingId = meetingId;
        this.parentMeetingId = parentMeetingId;
        this.name = name;
        this.sequence = sequence;
        this.shortName = shortName;
        this.isDefaultName = isDefaultName;
        this.freeJoin = freeJoin;
        this.dialNumber = dialNumber;
        this.voiceConfId = voiceConfId;
        this.viewerPassword = viewerPassword;
        this.moderatorPassword = moderatorPassword;
        this.durationInMinutes = duration;
        this.sourcePresentationId = sourcePresentationId;
        this.sourcePresentationSlide = sourcePresentationSlide;
        this.record = record;
        this.privateChatEnabled = privateChatEnabled;
        this.captureNotes = captureNotes;
        this.captureSlides = captureSlides;
        this.captureNotesFilename = captureNotesFilename;
        this.captureSlidesFilename = captureSlidesFilename;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/UpdateRecordingStatus.java,"package org.bigbluebutton.api.messaging.messages;

public class UpdateRecordingStatus implements IMessage {
    public final String meetingId;
    public final Boolean recording;

    public UpdateRecordingStatus(String meetingId, Boolean recording) {
        this.meetingId = meetingId;
        this.recording = recording;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/GuestLobbyMessageChanged.java,"package org.bigbluebutton.api.messaging.messages;

public class GuestLobbyMessageChanged implements IMessage {
    public final String meetingId;
    public final String message;

    public GuestLobbyMessageChanged(String meetingId, String message) {
        this.meetingId = meetingId;
        this.message = message;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/PositionInWaitingQueueUpdated.java,"package org.bigbluebutton.api.messaging.messages;

import java.util.HashMap;

public class PositionInWaitingQueueUpdated implements IMessage {
    public final String meetingId;
    public final HashMap guests;

    public PositionInWaitingQueueUpdated(String meetingId, HashMap<String,String> guests) {
        this.meetingId = meetingId;
        this.guests = guests;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/GuestStatusChangedEventMsg.java,"package org.bigbluebutton.api.messaging.messages;

import java.util.ArrayList;

public class GuestStatusChangedEventMsg implements IMessage {

  public final String meetingId;
  public final ArrayList<GuestsStatus> guests;

  public GuestStatusChangedEventMsg(String meetingId, ArrayList<GuestsStatus> guests) {
    this.meetingId = meetingId;
    this.guests = guests;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/messaging/messages/GuestPolicyChanged.java,"package org.bigbluebutton.api.messaging.messages;

public class GuestPolicyChanged implements IMessage {
    public final String meetingId;
    public final String policy;

    public GuestPolicyChanged(String meetingId, String policy) {
        this.meetingId = meetingId;
        this.policy = policy;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/MeetingLayout.java,"package org.bigbluebutton.api.domain;

public class MeetingLayout {
    public static final String FOCUS_ON_PRESENTATION = ""FOCUS_ON_PRESENTATION"";
    public static final String FOCUS_ON_WEBCAMS = ""FOCUS_ON_WEBCAMS"";
    public static final String SMART_LAYOUT = ""SMART_LAYOUT"";
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Image.java,"package org.bigbluebutton.api.domain;

import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText;

public class Image {

  /**
   * <image width=""176"" height=""136"" alt=""Welcome to"">
   *   http://192.168.23.22/presentation/32ee8bcccfad34f85c58a12f87fc4268130a4fd3-1489173065780/presentation/743dd59a958334b4cdcdaa302846d0c0eadcf9ff-1489173070800/thumbnails/thumb-1.png
   *  </image>
   */

  @JacksonXmlProperty(isAttribute = true)
  private String width;

  @JacksonXmlProperty(isAttribute = true)
  private String height;

  @JacksonXmlProperty(isAttribute = true)
  private String alt;

  @JacksonXmlText
  private String value;


  public void setWidth(String width) {
    this.width = width;
  }

  public String getWidth() {
    return width;
  }

  public void setHeight(String height) {
    this.height = height;
  }

  public String getHeight() {
    return height;
  }

  public void setAlt(String alt) {
    this.alt = alt;
  }

  public String getAlt() {
    return alt;
  }

  public String getValue() {
    return value;
  }

  public void setValue(String value) {
    this.value = value;
  }

}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/RecordingMetadataPlayback.java,"package org.bigbluebutton.api.domain;

import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;

@JacksonXmlRootElement(localName = ""playback"")
public class RecordingMetadataPlayback {
  private String format;
  private String link;

  @JacksonXmlProperty(localName = ""processing_time"")
  private Long processingTime = 0L;

  private Long duration = 0L;

  private Extensions extensions;

  private String size;

  public void setFormat(String format) {
    this.format = format;
  }

  public String getFormat() {
    return format;
  }

  public void setLink(String link) {
    this.link = link;
  }

  public String getLink() {
    return link;
  }

  public void setProcessingTime(Long processingTime) {
    this.processingTime = processingTime;
  }

  public Long getProcessingTime() {
    return processingTime;
  }

  public void setDuration(Long duration) {
    this.duration = duration;
  }

  public Long getDuration() {
    return duration;
  }

  public Long calculateDuration() {
    if (duration > 0) {
      // convert to minutes
      return duration / 60000;
    } else {
      return 0L;
    }
  }

  public void setExtensions(Extensions extensions) {
    this.extensions = extensions;
  }

  public Extensions getExtensions() {
    return extensions;
  }

  public void setSize(String size) {
    this.size = size;
  }

  public String getSize() {
    return size;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/RegisteredUser.java,"package org.bigbluebutton.api.domain;

public class RegisteredUser {
    public final String authToken;
    public final String userId;
    public final Long registeredOn;

    private String guestStatus;
    private Boolean excludeFromDashboard;
    private Long guestWaitedOn;
    private Boolean leftGuestLobby;

    public RegisteredUser(String authToken, String userId, String guestStatus, Boolean excludeFromDashboard, Boolean leftGuestLobby) {
        this.authToken = authToken;
        this.userId = userId;
        this.guestStatus = guestStatus;
        this.excludeFromDashboard = excludeFromDashboard;
        this.leftGuestLobby = leftGuestLobby;

        Long currentTimeMillis = System.currentTimeMillis();
        this.registeredOn = currentTimeMillis;
        this.guestWaitedOn = currentTimeMillis;
    }

    public void setGuestStatus(String status) {
        this.guestStatus = status;
    }

    public String getGuestStatus() {
        return guestStatus;
    }

    public Boolean getLeftGuestLobby() {
        return leftGuestLobby;
    }

    public void setExcludeFromDashboard(Boolean excludeFromDashboard) {
        this.excludeFromDashboard = excludeFromDashboard;
    }

    public Boolean getExcludeFromDashboard() {
        return excludeFromDashboard;
    }

    public void updateGuestWaitedOn() {
        this.guestWaitedOn = System.currentTimeMillis();
    }

    public void setLeftGuestLobby(boolean bool) {
        this.leftGuestLobby = bool;
    }
    public Long getGuestWaitedOn() {
        return this.guestWaitedOn;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Recordings.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.api.domain;

import java.io.File;
import java.io.FileFilter;

public class Recordings {

    public String[] getRecordings(String recordingDir) {
        File dir = new File(recordingDir);

        FileFilter fileFilter = File::isDirectory;

        File[] dirs = dir.listFiles(fileFilter);
        String[] meetings = new String[dirs.length];

        for (int i = 0; i < dirs.length; i++) {
            meetings[i] = dirs[i].getName();
        }
        return meetings;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Preview.java,"package org.bigbluebutton.api.domain;

import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;

public class Preview {
  @JacksonXmlElementWrapper(localName = ""images"")
  @JacksonXmlProperty(localName = ""image"")
  private Image[] images;

  public void setImages(Image[] images) {
    this.images = images;
  }

  public Image[] getImages() {
    return images;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Breakout.java,"package org.bigbluebutton.api.domain;

import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;

public class Breakout {
  /**
   * <breakout parentMeetingId=""f3ffe06acedf425565cc024c8ebe89a6552e8782-1489172964374"" sequence=""2"" meetingId=""f2041d123b6a4b994e7ad87ee9d348496a73472c-1489173065780""/>
   */

  @JacksonXmlProperty(isAttribute = true)
  private String parentMeetingId = """";

  @JacksonXmlProperty(isAttribute = true)
  private int sequence = 0;

  @JacksonXmlProperty(isAttribute = true)
  private String meetingId = """";

  public void setParentMeetingId(String parentMeetingId) {
    this.parentMeetingId = parentMeetingId;
  }

  public String getParentMeetingId() {
    return parentMeetingId;
  }

  public void setSequence(int sequence) {
    this.sequence = sequence;
  }

  public int getSequence() {
    return sequence;
  }

  public void setMeetingId(String meetingId) {
    this.meetingId = meetingId;
  }

  public String getMeetingId() {
    return meetingId;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/GuestPolicy.java,"package org.bigbluebutton.api.domain;

public class GuestPolicy {
    public static final String ALWAYS_ACCEPT = ""ALWAYS_ACCEPT"";
    public static final String ALWAYS_DENY = ""ALWAYS_DENY"";
    public static final String ASK_MODERATOR = ""ASK_MODERATOR"";
    public static final String ALWAYS_ACCEPT_AUTH = ""ALWAYS_ACCEPT_AUTH"";

    public static final String ALLOW = ""ALLOW"";
    public static final String DENY = ""DENY"";
    public static final String WAIT = ""WAIT"";

}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/MeetingInfo.java,"package org.bigbluebutton.api.domain;

import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;

public class MeetingInfo {
  /**
   * <meeting id=""random-2810069"" name=""random-2810069"" breakout=""false""/>
   */
  @JacksonXmlProperty(isAttribute = true)
  private String id;

  @JacksonXmlProperty(isAttribute = true)
  private String externalId;

  @JacksonXmlProperty(isAttribute = true)
  private String name;

  @JacksonXmlProperty(isAttribute = true)
  private boolean breakout;


  public void setId(String id) {
    this.id = id;
  }

  public String getId() {
    return id;
  }

  public void setExternalId(String externalId) {
    this.externalId = externalId;
  }

  public String getExternalId() {
    return externalId;
  }

  public void setName(String name) {
    this.name = name;
  }

  public String getName() {
    return name;
  }

  public void setBreakout(boolean breakout) {
    this.breakout = breakout;
  }

  public boolean isBreakout() {
    return breakout;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Metadata.java,"package org.bigbluebutton.api.domain;

import java.util.Map;
import java.util.TreeMap;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;

@JacksonXmlRootElement(localName = ""meta"")
public class Metadata {
  private Map<String,String> map = new TreeMap<>();

  @JsonAnyGetter
  public Map<String, String> get() {
    return map;
  }

  @JsonAnySetter
  public void set(String name, String value) {
    map.put(name, value);
  }

  public void remove(String key) {
    map.remove(key);
  }

  public boolean containsKey(String key) {
    return map.containsKey(key);
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Group.java,"package org.bigbluebutton.api.domain;

import java.util.Vector;

public class Group {

    private String groupId = """";
    private String name = """";
    private Vector<String> usersExtId;

    public Group(String groupId,
                 String name,
                 Vector<String> usersExtId) {
        this.groupId = groupId;
        this.name = name;
        this.usersExtId = usersExtId;
    }

    public String getGroupId() {
        return groupId;
    }

    public void setGroupId(String groupId) {
        this.groupId = groupId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Vector<String> getUsersExtId() {
        return usersExtId;
    }

    public void setUsersExtId(Vector<String> usersExtId) {
        this.usersExtId = usersExtId;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/CaptionTrack.java,"package org.bigbluebutton.api.domain;

public class CaptionTrack {
	public final String kind;
	public final String lang;
	public final String source;
	public final String href;

	public CaptionTrack(String kind, String lang, String source, String href) {
		this.kind = kind;
		this.lang = lang;
		this.source = source;
		this.href = href;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Meeting.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
*
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.api.domain;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class Meeting {

	public static final String ROLE_MODERATOR = ""MODERATOR"";
	public static final String ROLE_ATTENDEE = ""VIEWER"";

	private String name;
	private String extMeetingId;
	private String intMeetingId;
	private String parentMeetingId = ""bbb-none""; // Initialize so we don't send null in the json message.
	private Integer sequence = 0;
	private Boolean freeJoin = false;
	private Boolean captureSlides = false;
	private Boolean captureNotes = false;
	private String captureSlidesFilename = ""bbb-none"";
	private String captureNotesFilename = ""bbb-none"";
  	private Integer duration = 0;
	private long createdTime = 0;
	private long startTime = 0;
	private long endTime = 0;
	private boolean forciblyEnded = false;
	private String telVoice;
	private String webVoice;
	private String moderatorPass = """";
	private String viewerPass = """";
	private int learningDashboardCleanupDelayInMinutes;
	private String learningDashboardAccessToken;
	private ArrayList<String> disabledFeatures;
	private Boolean notifyRecordingIsOn;
	private String welcomeMsgTemplate;
	private String welcomeMsg;
	private String modOnlyMessage = """";
	private String logoutUrl;
	private int logoutTimer = 0;
	private int maxUsers;
	private String bannerColor = ""#FFFFFF"";
	private String bannerText = """";
	private boolean record;
	private boolean autoStartRecording = false;
	private boolean allowStartStopRecording = false;
	private boolean haveRecordingMarks = false;
	private boolean webcamsOnlyForModerator = false;
	private Integer meetingCameraCap = 0;
	private Integer userCameraCap = 0;
	private Integer maxPinnedCameras = 0;
	private String dialNumber;
	private String defaultAvatarURL;
	private String guestPolicy = GuestPolicy.ASK_MODERATOR;
	private String guestLobbyMessage = """";
	private Map<String,String> usersWithGuestLobbyMessages;
	private Boolean authenticatedGuest = false;
	private String meetingLayout = MeetingLayout.SMART_LAYOUT;
	private boolean userHasJoined = false;
	private Map<String, String> guestUsersWithPositionInWaitingLine;
	private Map<String, String> metadata;
	private Map<String, Object> userCustomData;
	private final ConcurrentMap<String, User> users;
	private final ConcurrentMap<String, RegisteredUser> registeredUsers;
	private final ConcurrentMap<String, Long> enteredUsers;
	private final Boolean isBreakout;
	private final List<String> breakoutRooms = new ArrayList<>();
	private ArrayList<Group> groups = new ArrayList<Group>();
	private String customLogoURL = """";
	private String customCopyright = """";
	private Boolean muteOnStart = false;
	private Boolean allowModsToUnmuteUsers = false;
	private Boolean allowRequestsWithoutSession = false;
	private Boolean allowModsToEjectCameras = false;
	private Boolean meetingKeepEvents;
	private String presentationUploadExternalDescription;
	private String presentationUploadExternalUrl;

	private Integer meetingExpireIfNoUserJoinedInMinutes = 5;
	private Integer meetingExpireWhenLastUserLeftInMinutes = 1;
	private Integer userInactivityInspectTimerInMinutes = 120;
	private Integer userInactivityThresholdInMinutes = 30;
    private Integer userActivitySignResponseDelayInMinutes = 5;
    private Boolean endWhenNoModerator = false;
    private Integer endWhenNoModeratorDelayInMinutes = 1;

	public final BreakoutRoomsParams breakoutRoomsParams;
	public final LockSettingsParams lockSettingsParams;

	public final Integer maxUserConcurrentAccesses;

	private String meetingEndedCallbackURL = """";

	private Integer html5InstanceId;

    public Meeting(Meeting.Builder builder) {
        name = builder.name;
        extMeetingId = builder.externalId;
        intMeetingId = builder.internalId;
		disabledFeatures = builder.disabledFeatures;
		notifyRecordingIsOn = builder.notifyRecordingIsOn;
		presentationUploadExternalDescription = builder.presentationUploadExternalDescription;
		presentationUploadExternalUrl = builder.presentationUploadExternalUrl;
		if (builder.viewerPass == null){
			viewerPass = """";
		} else {
			viewerPass = builder.viewerPass;
		}
		if (builder.moderatorPass == null){
			moderatorPass = """";
		} else {
			moderatorPass = builder.moderatorPass;
		}
		learningDashboardCleanupDelayInMinutes = builder.learningDashboardCleanupDelayInMinutes;
		learningDashboardAccessToken = builder.learningDashboardAccessToken;
        maxUsers = builder.maxUsers;
        bannerColor = builder.bannerColor;
        bannerText = builder.bannerText;
        logoutUrl = builder.logoutUrl;
        logoutTimer = builder.logoutTimer;
        defaultAvatarURL = builder.defaultAvatarURL;
        record = builder.record;
        autoStartRecording = builder.autoStartRecording;
        allowStartStopRecording = builder.allowStartStopRecording;
        webcamsOnlyForModerator = builder.webcamsOnlyForModerator;
        meetingCameraCap = builder.meetingCameraCap;
        userCameraCap = builder.userCameraCap;
        maxPinnedCameras = builder.maxPinnedCameras;
        duration = builder.duration;
        webVoice = builder.webVoice;
        telVoice = builder.telVoice;
        welcomeMsgTemplate = builder.welcomeMsgTemplate;
        welcomeMsg = builder.welcomeMsg;
        dialNumber = builder.dialNumber;
        metadata = builder.metadata;
        createdTime = builder.createdTime;
        isBreakout = builder.isBreakout;
        guestPolicy = builder.guestPolicy;
        authenticatedGuest = builder.authenticatedGuest;
		meetingLayout = builder.meetingLayout;
        allowRequestsWithoutSession = builder.allowRequestsWithoutSession;
        breakoutRoomsParams = builder.breakoutRoomsParams;
        lockSettingsParams = builder.lockSettingsParams;
		maxUserConcurrentAccesses = builder.maxUserConcurrentAccesses;
        endWhenNoModerator = builder.endWhenNoModerator;
        endWhenNoModeratorDelayInMinutes = builder.endWhenNoModeratorDelayInMinutes;
        html5InstanceId = builder.html5InstanceId;
		groups = builder.groups;
		guestUsersWithPositionInWaitingLine = new HashMap<>();
        userCustomData = new HashMap<>();
		usersWithGuestLobbyMessages = new HashMap<>();

        users = new ConcurrentHashMap<>();
        registeredUsers = new ConcurrentHashMap<>();
        enteredUsers = new  ConcurrentHashMap<>();
    }

	public void addBreakoutRoom(String meetingId) {
		breakoutRooms.add(meetingId);
	}

	public List<String> getBreakoutRooms() {
		return breakoutRooms;
	}

	public Map<String, String> getMetadata() {
		return metadata;
	}

	public Collection<User> getUsers() {
		return users.isEmpty() ? Collections.<User>emptySet() : Collections.unmodifiableCollection(users.values());
	}

	public ConcurrentMap<String, User> getUsersMap() {
	    return users;
	}

	public Integer countUniqueExtIds() {
		List<String> uniqueExtIds = new ArrayList<String>();
		for (User user : users.values()) {
			if(!uniqueExtIds.contains(user.getExternalUserId())) {
				uniqueExtIds.add(user.getExternalUserId());
			}
		}

		return uniqueExtIds.size();
	}

	public List<String> getUsersWithExtId(String externalUserId) {
		List<String> usersWithExtId = new ArrayList<String>();
		for (User user : users.values()) {
			if(user.getExternalUserId().equals(externalUserId)) {
				usersWithExtId.add(user.getInternalUserId());
			}
		}

		return usersWithExtId;
	}

	public void guestIsWaiting(String userId) {
		RegisteredUser ruser = registeredUsers.get(userId);
		if (ruser != null) {
			ruser.updateGuestWaitedOn();
		}
	}

	public void setLeftGuestLobby(String userId, Boolean bool) {
		RegisteredUser ruser = registeredUsers.get(userId);
		if (ruser != null) {
			ruser.setLeftGuestLobby(bool);
		}
	}

	public Boolean didGuestUserLeaveGuestLobby(String userId) {
		RegisteredUser ruser = registeredUsers.get(userId);

		if (ruser != null) {
			return ruser.getLeftGuestLobby();
		}
		return true;
	}

	public void setGuestStatusWithId(String userId, String guestStatus) {
    	User user = getUserById(userId);
    	if (user != null) {
    		user.setGuestStatus(guestStatus);
		}

		RegisteredUser ruser = registeredUsers.get(userId);
		if (ruser != null) {
			ruser.setGuestStatus(guestStatus);
		}

	}

	public RegisteredUser getRegisteredUserWithAuthToken(String authToken) {
		for (RegisteredUser ruser : registeredUsers.values()) {
			if (ruser.authToken.equals(authToken)) {
				return ruser;
			}
		}

		return null;
	}

	public String getGuestStatusWithAuthToken(String authToken) {
		RegisteredUser rUser = getRegisteredUserWithAuthToken(authToken);
		if (rUser != null) {
			return rUser.getGuestStatus();
		}

		return GuestPolicy.DENY;
	}

	public int getHtml5InstanceId() { return html5InstanceId; }

    public void setHtml5InstanceId(int instanceId) { html5InstanceId = instanceId; }

	public ArrayList<Group> getGroups() { return groups; }

	public void setGroups(ArrayList<Group> groups) { this.groups = groups; }

    public long getStartTime() {
		return startTime;
	}

	public void setStartTime(long t) {
		startTime = t;
	}

	public long getCreateTime() {
		return createdTime;
	}

	public void setSequence(Integer s) {
        sequence = s;
    }

	public Integer getSequence() {
        return sequence;
    }

    public Boolean isFreeJoin() {
        return freeJoin;
    }

    public void setFreeJoin(Boolean freeJoin) {
        this.freeJoin = freeJoin;
    }

	public Boolean isCaptureSlides() {
        return captureSlides;
    }

	public void setCaptureSlides(Boolean capture) {
		this.captureSlides = captureSlides;
	}
	
	public Boolean isCaptureNotes() {
        return captureNotes;
    }

	public void setCaptureNotes(Boolean capture) {
		this.captureNotes = captureNotes;
	}

	public void setCaptureNotesFilename(String filename) {
		this.captureNotesFilename = filename;
	}

	public void setCaptureSlidesFilename(String filename) {
		this.captureSlidesFilename = filename;
	}

	public Integer getDuration() {
		return duration;
	}

	public long getEndTime() {
		return endTime;
	}

	public void setModeratorOnlyMessage(String msg) {
		modOnlyMessage = msg;
	}

	public String getModeratorOnlyMessage() {
		return modOnlyMessage;
	}

	public void setEndTime(long t) {
		endTime = t;
	}

	public boolean isRunning() {
		return ! users.isEmpty();
	}

	public Boolean isBreakout() {
	  return isBreakout;
	}

    public void setHaveRecordingMarks(boolean marks) {
        haveRecordingMarks = marks;
    }

    public boolean haveRecordingMarks() {
        return  haveRecordingMarks;
    }

	public String getName() {
		return name;
	}

	public boolean isForciblyEnded() {
		return forciblyEnded;
	}

	public void setForciblyEnded(boolean forciblyEnded) {
		this.forciblyEnded = forciblyEnded;
	}

	public String getExternalId() {
		return extMeetingId;
	}

	public String getInternalId() {
		return intMeetingId;
	}

	public void setParentMeetingId(String p) {
        parentMeetingId = p;
    }

	public String getParentMeetingId() {
	    return parentMeetingId;
	}

	public String getWebVoice() {
		return webVoice;
	}

	public String getTelVoice() {
		return telVoice;
	}

	public String getModeratorPassword() {
		return moderatorPass;
	}

	public String getViewerPassword() {
		return viewerPass;
	}

	public int getLearningDashboardCleanupDelayInMinutes() {
		return learningDashboardCleanupDelayInMinutes;
	}

	public String getLearningDashboardAccessToken() {
		return learningDashboardAccessToken;
	}

	public ArrayList<String> getDisabledFeatures() {
		return disabledFeatures;
	}

	public Boolean getNotifyRecordingIsOn() {
		return notifyRecordingIsOn;
	}

	public String getPresentationUploadExternalDescription() {
		return presentationUploadExternalDescription;
	}
	public String getPresentationUploadExternalUrl() {
		return presentationUploadExternalUrl;
	}

  public String getWelcomeMessageTemplate() {
    return welcomeMsgTemplate;
  }

	public String getWelcomeMessage() {
		return welcomeMsg;
	}

	public String getDefaultAvatarURL() {
		return defaultAvatarURL;
	}

	public void setWaitingPositionsInWaitingQueue(HashMap<String, String> guestUsersWithPositionInWaitingLine) {
		this.guestUsersWithPositionInWaitingLine = guestUsersWithPositionInWaitingLine;
	}

	public String getWaitingPositionsInWaitingQueue(String userId) {
		return guestUsersWithPositionInWaitingLine.get(userId);
	}

	public void setGuestPolicy(String policy) {
		guestPolicy = policy;
	}

	public String getGuestPolicy() {
    	return guestPolicy;
	}

	public void setGuestLobbyMessage(String message) {
		guestLobbyMessage = message;
	}

	public String getGuestLobbyMessage(String guestId) {
		if (usersWithGuestLobbyMessages.containsKey(guestId) && usersWithGuestLobbyMessages.get(guestId) != """") {
			return usersWithGuestLobbyMessages.get(guestId);
		}
		return guestLobbyMessage;
	}

	public void setPrivateGuestLobbyMessage(String guestId, String message) {
		usersWithGuestLobbyMessages.put(guestId, message);
	}

	public void setAuthenticatedGuest(Boolean authGuest) {
		authenticatedGuest = authGuest;
	}

	public Boolean getAuthenticatedGuest() {
		return authenticatedGuest;
	}

	public void setMeetingLayout(String layout) {
		meetingLayout = layout;
	}

	public String getMeetingLayout() {
		return meetingLayout;
	}

	private String getUnauthenticatedGuestStatus(Boolean guest) {
		if (guest) {
			switch(guestPolicy) {
				case GuestPolicy.ALWAYS_ACCEPT:
				case GuestPolicy.ALWAYS_ACCEPT_AUTH:
					return GuestPolicy.ALLOW;
				case GuestPolicy.ASK_MODERATOR:
					return GuestPolicy.WAIT;
				case GuestPolicy.ALWAYS_DENY:
					return GuestPolicy.DENY;
				default:
					return GuestPolicy.DENY;
			}
		} else {
			return GuestPolicy.ALLOW;
		}
	}

	public String calcGuestStatus(String role, Boolean guest, Boolean authned) {
		if (!authenticatedGuest) return getUnauthenticatedGuestStatus(guest);

		// Allow moderators all the time.
		if (ROLE_MODERATOR.equals(role)) {
			return GuestPolicy.ALLOW;
		}

		if (GuestPolicy.ALWAYS_ACCEPT.equals(guestPolicy)) {
			return GuestPolicy.ALLOW;
		} else if (GuestPolicy.ALWAYS_DENY.equals(guestPolicy)) {
			return GuestPolicy.DENY;
		} else if (GuestPolicy.ASK_MODERATOR.equals(guestPolicy)) {
			if  (guest || (!ROLE_MODERATOR.equals(role) && authned)) {
				return GuestPolicy.WAIT ;
			}
			return GuestPolicy.ALLOW;
		} else if (GuestPolicy.ALWAYS_ACCEPT_AUTH.equals(guestPolicy)) {
			if (guest){
				// Only ask moderator for guests.
				return GuestPolicy.WAIT ;
			}
			return GuestPolicy.ALLOW;
		}
		return GuestPolicy.DENY ;
	}


	public String getLogoutUrl() {
		return logoutUrl;
	}

	public int getMaxUsers() {
		return maxUsers;
	}

	public Integer getMaxUserConcurrentAccesses() {
		return maxUserConcurrentAccesses;
	}

	public int getLogoutTimer() {
		return logoutTimer;
	}

	public String getBannerColor() {
		return bannerColor;
	}

	public String getBannerText() {
		return bannerText;
	}

	public boolean isRecord() {
		return record;
	}

	public boolean getAutoStartRecording() {
		return autoStartRecording;
	}

	public boolean getAllowStartStopRecording() {
		return allowStartStopRecording;
	}

    public boolean getWebcamsOnlyForModerator() {
        return webcamsOnlyForModerator;
    }

    public Integer getMeetingCameraCap() {
        return meetingCameraCap;
    }

    public Integer getUserCameraCap() {
        return userCameraCap;
    }

    public Integer getMaxPinnedCameras() {
        return maxPinnedCameras;
    }

	public boolean hasUserJoined() {
		return userHasJoined;
	}

	public String getCustomLogoURL() {
		return customLogoURL;
	}

	public void setCustomLogoURL(String url) {
		customLogoURL = url;
	}

	public void setCustomCopyright(String copyright) {
    	customCopyright = copyright;
	}

	public String getCustomCopyright() {
    	return customCopyright;
	}

	public void setMuteOnStart(Boolean mute) {
    	muteOnStart = mute;
	}

	public Boolean getMuteOnStart() {
    	return muteOnStart;
	}

  public void setMeetingKeepEvents(Boolean mke) {
    meetingKeepEvents = mke;
  }

  public Boolean getMeetingKeepEvents() {
    return meetingKeepEvents;
  }

	public void setAllowModsToUnmuteUsers(Boolean value) {
		allowModsToUnmuteUsers = value;
	}

	public Boolean getAllowModsToUnmuteUsers() {
		return allowModsToUnmuteUsers;
	}

	public void setAllowRequestsWithoutSession(Boolean value) {
		allowRequestsWithoutSession = value;
	}

	public Boolean getAllowRequestsWithoutSession() {
		return allowRequestsWithoutSession;
	}

  public void setAllowModsToEjectCameras(Boolean value) {
    allowModsToEjectCameras = value;
  }

  public Boolean getAllowModsToEjectCameras() {
    return allowModsToEjectCameras;
  }

	public void userJoined(User user) {
		User u = getUserById(user.getInternalUserId());
		if (u != null) {
			u.joined();
		} else {
			if (!userHasJoined) userHasJoined = true;
			this.users.put(user.getInternalUserId(), user);
			// Clean this user up from the entered user's list
			removeEnteredUser(user.getInternalUserId());
		}
	}

	public User userLeft(String userId) {
		User user = getUserById(userId);
		if (user != null) {
			user.left();
		}

		return user;
	}

	public User removeUser(String userId) {
		return this.users.remove(userId);
	}

	public User getUserById(String id){
		return this.users.get(id);
	}

	public int getNumUsers(){
		return this.users.size();
	}

	public int getNumUsersOnline(){
		int countUsersOnline = 0;
		for (User user : this.users.values()) {
			if(!user.hasLeft()) countUsersOnline++;
		}

		return countUsersOnline;
	}

    public int getNumModerators() {
        int sum = 0;
        for (Map.Entry<String, User> entry : users.entrySet()) {
            User u = entry.getValue();
            if (u.isModerator())
                sum++;
        }
        return sum;
    }

	public String getDialNumber() {
		return dialNumber;
	}

    public int getNumListenOnly() {
        int sum = 0;
        for (Map.Entry<String, User> entry : users.entrySet()) {
            User u = entry.getValue();
            if (u.isListeningOnly())
                sum++;
        }
        return sum;
    }

    public int getNumVoiceJoined() {
        int sum = 0;
        for (Map.Entry<String, User> entry : users.entrySet()) {
            User u = entry.getValue();
            if (u.isVoiceJoined())
                sum++;
        }
        return sum;
    }

    public int getNumVideos() {
        int sum = 0;
        for (Map.Entry<String, User> entry : users.entrySet()) {
            User u = entry.getValue();
            sum += u.getStreams().size();
        }
        return sum;
    }

	public void addUserCustomData(String userID, Map<String, String> data) {
		userCustomData.put(userID, data);
	}

	public void setMeetingExpireWhenLastUserLeftInMinutes(Integer value) {
		meetingExpireWhenLastUserLeftInMinutes = value;
	}

	public Integer getMeetingExpireWhenLastUserLeftInMinutes() {
		return meetingExpireWhenLastUserLeftInMinutes;
	}


	public void setMeetingExpireIfNoUserJoinedInMinutes(Integer value) {
		meetingExpireIfNoUserJoinedInMinutes = value;
	}

	public Integer getMeetingExpireIfNoUserJoinedInMinutes() {
		return meetingExpireIfNoUserJoinedInMinutes;
	}

   public Integer getUserInactivityInspectTimerInMinutes() {
        return userInactivityInspectTimerInMinutes;
    }

    public void setUserInactivityInspectTimerInMinutes(Integer userInactivityInjspectTimerInMinutes) {
        this.userInactivityInspectTimerInMinutes = userInactivityInjspectTimerInMinutes;
    }

    public Integer getUserInactivityThresholdInMinutes() {
        return userInactivityThresholdInMinutes;
    }

    public void setUserInactivityThresholdInMinutes(Integer userInactivityThresholdInMinutes) {
        this.userInactivityThresholdInMinutes = userInactivityThresholdInMinutes;
    }

    public Integer getUserActivitySignResponseDelayInMinutes() {
        return userActivitySignResponseDelayInMinutes;
    }

    public void setUserActivitySignResponseDelayInMinutes(Integer userActivitySignResponseDelayInMinutes) {
        this.userActivitySignResponseDelayInMinutes = userActivitySignResponseDelayInMinutes;
    }

	public Boolean getEndWhenNoModerator() {
		return endWhenNoModerator;
	}

	public void setEndWhenNoModerator(Boolean endWhenNoModerator) {
		this.endWhenNoModerator = endWhenNoModerator;
	}

	public Integer getEndWhenNoModeratorDelayInMinutes() {
		return endWhenNoModeratorDelayInMinutes;
	}

	public void setEndWhenNoModeratorDelayInMinutes(Integer endWhenNoModeratorDelayInMinutes) {
		this.endWhenNoModeratorDelayInMinutes = endWhenNoModeratorDelayInMinutes;
	}

    public String getMeetingEndedCallbackURL() {
    	return meetingEndedCallbackURL;
    }

    public void setMeetingEndedCallbackURL(String meetingEndedCallbackURL) {
    	this.meetingEndedCallbackURL = meetingEndedCallbackURL;
    }

	public Map<String, Object> getUserCustomData(String userID){
		return (Map<String, Object>) userCustomData.get(userID);
	}

	public void userRegistered(RegisteredUser user) {
        this.registeredUsers.put(user.userId, user);
    }

    public RegisteredUser userUnregistered(String userid) {
		return this.registeredUsers.remove(userid);
    }

    public ConcurrentMap<String, RegisteredUser> getRegisteredUsers() {
        return registeredUsers;
    }

    public ConcurrentMap<String, Long> getEnteredUsers() {
        return this.enteredUsers;
    }

    public void userEntered(String userId) {
        // Skip if user already joined
        User u = getUserById(userId);
        if (u != null) return;

        if (!enteredUsers.containsKey(userId)) {
            Long time = System.currentTimeMillis();
            this.enteredUsers.put(userId, time);
        }
    }

    public Long removeEnteredUser(String userId) {
        return this.enteredUsers.remove(userId);
    }

    public Long getEnteredUserById(String userId) {
        return this.enteredUsers.get(userId);
    }

    /***
	 * Meeting Builder
	 *
	 */
	public static class Builder {
    	private String name;
    	private String externalId;
    	private String internalId;
    	private int maxUsers;
    	private boolean record;
    	private boolean autoStartRecording;
        private boolean allowStartStopRecording;
        private boolean webcamsOnlyForModerator;
        private Integer meetingCameraCap;
        private Integer userCameraCap;
        private Integer maxPinnedCameras;
    	private String moderatorPass;
    	private String viewerPass;
    	private int learningDashboardCleanupDelayInMinutes;
    	private String learningDashboardAccessToken;
		private ArrayList<String> disabledFeatures;
		private Boolean notifyRecordingIsOn;
		private String presentationUploadExternalDescription;
		private String presentationUploadExternalUrl;
    	private int duration;
    	private String webVoice;
    	private String telVoice;
    	private String welcomeMsgTemplate;
    	private String welcomeMsg;
    	private String logoutUrl;
    	private String bannerColor;
    	private String bannerText;
    	private int logoutTimer;
    	private Map<String, String> metadata;
    	private String dialNumber;
    	private String defaultAvatarURL;
    	private long createdTime;
    	private boolean isBreakout;
    	private String guestPolicy;
    	private Boolean authenticatedGuest;
    	private Boolean allowRequestsWithoutSession;
		private String meetingLayout;
    	private BreakoutRoomsParams breakoutRoomsParams;
    	private LockSettingsParams lockSettingsParams;

		private Integer maxUserConcurrentAccesses;
		private Boolean endWhenNoModerator;
		private Integer endWhenNoModeratorDelayInMinutes;
		private int html5InstanceId;
		private ArrayList<Group> groups;

    	public Builder(String externalId, String internalId, long createTime) {
    		this.externalId = externalId;
    		this.internalId = internalId;
    		this.createdTime = createTime;
    	}

    	public Builder withName(String name) {
    		this.name = name;
    		return this;
    	}

    	public Builder withDuration(int minutes) {
    		duration = minutes;
    		return this;
    	}

    	public Builder withMaxUsers(int n) {
    		maxUsers = n;
    		return this;
    	}

    	public Builder withRecording(boolean record) {
    		this.record = record;
    		return this;
    	}

    	public Builder withAutoStartRecording(boolean start) {
    		this.autoStartRecording = start;
    		return this;
    	}

    	public Builder withAllowStartStopRecording(boolean allow) {
    		this.allowStartStopRecording = allow;
    		return this;
    	}

        public Builder withWebcamsOnlyForModerator(boolean only) {
            this.webcamsOnlyForModerator = only;
            return this;
        }

        public Builder withMeetingCameraCap(Integer cap) {
            this.meetingCameraCap = cap;
            return this;
        }

        public Builder withUserCameraCap(Integer cap) {
            this.userCameraCap = cap;
            return this;
        }

        public Builder withMaxPinnedCameras(Integer pins) {
            this.maxPinnedCameras = pins;
            return this;
        }

    	public Builder withWebVoice(String w) {
    		this.webVoice = w;
    		return this;
    	}

    	public Builder withTelVoice(String t) {
    		this.telVoice = t;
    		return this;
    	}

    	public Builder withDialNumber(String d) {
    		this.dialNumber = d;
    		return this;
    	}

    	public Builder withModeratorPass(String p) {
    		this.moderatorPass = p;
    		return this;
    	}

    	public Builder withViewerPass(String p) {
	    	this.viewerPass = p;
	    	return this;
	    }

    	public Builder withLearningDashboardCleanupDelayInMinutes(int m) {
	    	this.learningDashboardCleanupDelayInMinutes = m;
	    	return this;
	    }

    	public Builder withLearningDashboardAccessToken(String t) {
	    	this.learningDashboardAccessToken = t;
	    	return this;
	    }

		public Builder withDisabledFeatures(ArrayList<String> list) {
			this.disabledFeatures = list;
			return this;
		}

    	public Builder withNotifyRecordingIsOn(Boolean b) {
	    	this.notifyRecordingIsOn = b;
	    	return this;
	    }

    	public Builder withPresentationUploadExternalDescription(String d) {
	    	this.presentationUploadExternalDescription = d;
	    	return this;
	    }

			public Builder withPresentationUploadExternalUrl(String u) {
	    	this.presentationUploadExternalUrl = u;
	    	return this;
	    }

    	public Builder withWelcomeMessage(String w) {
    		welcomeMsg = w;
    		return this;
    	}

	    public Builder withWelcomeMessageTemplate(String w) {
            welcomeMsgTemplate = w;
            return this;
        }

    	public Builder withDefaultAvatarURL(String w) {
    		defaultAvatarURL = w;
    		return this;
    	}

    	public Builder isBreakout(Boolean b) {
    	  isBreakout = b;
    	  return this;
    	}

    	public Builder withLogoutUrl(String l) {
    		logoutUrl = l;
    		return this;
    	}

    	public Builder withLogoutTimer(int l) {
    		logoutTimer = l;
    		return this;
    	}

    	public Builder withBannerColor(String c) {
    		bannerColor = c;
    		return this;
    	}

    	public Builder withBannerText(String t) {
    		bannerText = t;
    		return this;
    	}

    	public Builder withMetadata(Map<String, String> m) {
    		metadata = m;
    		return this;
    	}

    	public Builder withGuestPolicy(String policy) {
    		guestPolicy = policy;
    		return  this;
			}

    	public Builder withAuthenticatedGuest(Boolean authGuest) {
    		authenticatedGuest = authGuest;
    		return this;
    	}

    	public Builder withAllowRequestsWithoutSession(Boolean value) {
    		allowRequestsWithoutSession = value;
    		return this;
    	}

			public Builder withMeetingLayout(String layout) {
				meetingLayout = layout;
				return this;
			}

		public Builder withBreakoutRoomsParams(BreakoutRoomsParams params) {
    		breakoutRoomsParams = params;
    		return this;
		}

		public Builder withLockSettingsParams(LockSettingsParams params) {
    		lockSettingsParams = params;
    		return  this;
		}

		public Builder withMaxUserConcurrentAccesses(Integer maxUserConcurrentAccesses) {
    		this.maxUserConcurrentAccesses = maxUserConcurrentAccesses;
    		return this;
		}

		public Builder withEndWhenNoModerator(Boolean endWhenNoModerator) {
    		this.endWhenNoModerator = endWhenNoModerator;
    		return this;
		}

		public Builder withEndWhenNoModeratorDelayInMinutes(Integer endWhenNoModeratorDelayInMinutes) {
    		this.endWhenNoModeratorDelayInMinutes = endWhenNoModeratorDelayInMinutes;
    		return this;
		}

		public Builder withHTML5InstanceId(int instanceId) {
    		html5InstanceId = instanceId;
    		return this;
		}

		public Builder withGroups(ArrayList<Group> groups) {
			this.groups = groups;
			return this;
		}

		public Meeting build() {
    		return new Meeting(this);
    	}
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/LockSettingsParams.java,"package org.bigbluebutton.api.domain;

public class LockSettingsParams {
	public final Boolean disableCam;
	public final Boolean disableMic;
	public final Boolean disablePrivateChat;
	public final Boolean disablePublicChat;
	public final Boolean disableNotes;
	public final Boolean hideUserList;
	public final Boolean lockOnJoin;
	public final Boolean lockOnJoinConfigurable;
	public final Boolean hideViewersCursor;

	public LockSettingsParams(Boolean disableCam,
					Boolean disableMic,
					Boolean disablePrivateChat,
					Boolean disablePublicChat,
					Boolean disableNotes,
					Boolean hideUserList,
					Boolean lockOnJoin,
					Boolean lockOnJoinConfigurable,
					Boolean hideViewersCursor) {
		this.disableCam = disableCam;
		this.disableMic = disableMic;
		this.disablePrivateChat = disablePrivateChat;
		this.disablePublicChat = disablePublicChat;
		this.disableNotes = disableNotes;
		this.hideUserList = hideUserList;
		this.lockOnJoin = lockOnJoin;
		this.lockOnJoinConfigurable = lockOnJoinConfigurable;
		this.hideViewersCursor = hideViewersCursor;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/BreakoutRoomsParams.java,"package org.bigbluebutton.api.domain;

public class BreakoutRoomsParams {
	public final Boolean record;
	public final Boolean privateChatEnabled;
	public final Boolean captureNotes;
	public final Boolean captureSlides;
	public final String captureNotesFilename;
	public final String captureSlidesFilename;

	public BreakoutRoomsParams(Boolean record, Boolean privateChatEnabled, Boolean captureNotes, Boolean captureSlides, String captureNotesFilename, String captureSlidesFilename) {
		this.record = record;
		this.privateChatEnabled = privateChatEnabled;
		this.captureNotes = captureNotes;
		this.captureSlides = captureSlides;
		this.captureNotesFilename = captureNotesFilename;
		this.captureSlidesFilename = captureSlidesFilename;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Recording.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.api.domain;

import java.math.BigInteger;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

public class Recording {
	private String id;
	private String meetingID;
	private String name;
	private boolean published;
	private String startTime;
	private String endTime;
	private String numParticipants;
	private String rawSize;
	private Map<String, String> metadata = new TreeMap<>();
	private List<Playback> playbacks=new ArrayList<>();
	
	//TODO: 
	private String state;
	private String playbackLink;
	private String playbackFormat;
	private String playbackDuration;
	private String playbackSize;
	private String processingTime;
	private List<Extension> playbackExtensions;

	private String downloadLink;
	private String downloadFormat;
	private String downloadMd5;
	private String downloadKey;
	private String downloadSize;

	public static final String STATE_PROCESSING = ""processing"";
	public static final String STATE_PROCESSED = ""processed"";
	public static final String STATE_PUBLISING = ""publishing"";
	public static final String STATE_PUBLISHED = ""published"";
	public static final String STATE_UNPUBLISING = ""unpublishing"";
	public static final String STATE_UNPUBLISHED = ""unpublished"";
	public static final String STATE_DELETING = ""deleting"";
	public static final String STATE_DELETED = ""deleted"";

	public String getId() {
		return id;
	}
	
	public void setId(String id) {
		this.id = id;
	}
	
	public String getState() {
	    String currentState = this.state;
	    if ( currentState == null || """".equals(currentState) || ""available"".equals(currentState) ) {
	        currentState = isPublished()? STATE_PUBLISHED: STATE_UNPUBLISHED;
	    }
		return currentState;
	}
	
	public void setState(String state) {
		this.state = state;
	}
	
	public boolean isPublished() {
		return published;
	}
	
	public void setPublished(boolean published) {
		this.published = published;
	}
	
	public String getStartTime() {
		return startTime;
	}
	
	public void setStartTime(String startTime) {
		this.startTime = convertOldDateFormat(startTime);
	}
	
	public String getEndTime() {
		return endTime;
	}
	
	public void setNumParticipants(String numParticipants) {
		this.numParticipants = numParticipants;
	}

	public String getNumParticipants() {
		return numParticipants;
	}

	public void setEndTime(String endTime) {
		this.endTime = convertOldDateFormat(endTime);
	}
	
	public String getSize() {
		BigInteger size = BigInteger.ZERO;
		for (Playback p: playbacks) {
			if (p.getSize().length() > 0) {
				size = size.add(new BigInteger(p.getSize()));
			}
		}
		return size.toString();
	}

	public String getRawSize() {
		return rawSize;
	}

	public void setRawSize(String rawSize) {
		this.rawSize = rawSize;
	}

	public String getPlaybackLink() {
		return playbackLink;
	}
	
	public void setPlaybackLink(String playbackLink) {
		this.playbackLink = playbackLink;
	}

	public String getPlaybackFormat() {
		return playbackFormat;
	}

	public void setPlaybackFormat(String playbackFormat) {
		this.playbackFormat = playbackFormat;
	}
	
	public String getPlaybackDuration() {
		return playbackDuration;
	}
	
	public void setPlaybackDuration(String playbackDuration) {
		this.playbackDuration = playbackDuration;
	}

	public String getPlaybackSize() {
		return playbackSize;
	}

	public void setPlaybackSize(String playbackSize) {
		this.playbackSize = playbackSize;
	}

	public String getProcessingTime() {
		return processingTime;
	}

	public void setProcessingTime(String processingTime) {
		this.processingTime = processingTime;
	}

	public List<Extension> getPlaybackExtensions() {
		return playbackExtensions;
	}

	public void setPlaybackExtensions(List<Extension> playbackExtensions) {
		this.playbackExtensions = playbackExtensions;
	}
	
	public Map<String, String> getMetadata() {
		return this.metadata;
	}

	public String getMetadata(String key) {
		return this.metadata.get(key);
	}

	public void setMetadata(Map<String, String> metadata) {
		this.metadata = metadata;
	}

	public void updateMetadata(String key, String value) {
		this.metadata.put(key, value);
	}

	public void deleteMetadata(String key) {
		this.metadata.remove(key);
	}

	public boolean containsMetadata(String key) {
		return this.metadata.containsKey(key);
	}

	public String getMeetingID() {
		return this.meetingID;
	}

	public void setMeetingID(String meetingID) {
		this.meetingID = meetingID;
	}

	public String getName() {
		return this.name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public List<Playback> getPlaybacks() {
		return playbacks;
	}

	public void setPlaybacks(List<Playback> playbacks) {
		this.playbacks = playbacks;
	}
	
	/* We used to have an old date format in the recordings 
	 * e.g.: Thu Mar 04 14:05:56 UTC 2010
	 * Now, we have a new one which it's a long string
	 * This method converts the old date format to the new one */
	
	private String convertOldDateFormat(String olddate){
		String newdate = olddate;

		try {
			SimpleDateFormat sdf = new SimpleDateFormat(""EEE MMM d HH:mm:ss z yyyy"");
			Calendar cal=Calendar.getInstance();
			sdf.setLenient(false);
			
			cal.setTime(sdf.parse(olddate));
			newdate = Long.toString(cal.getTimeInMillis());
		} catch (ParseException pe) {
			
		}

		return newdate;
	}
	
	public String getExternalMeetingId() {
		String externalMeetingId = null;
		if (this.metadata != null) {
			externalMeetingId = this.metadata.get(""meetingId"");
		}

		if (externalMeetingId != null) {
			return externalMeetingId;
		} else {
			return """";
		}
	}
}

/*
<recording>
	<id>Demo Meeting-3243244</id>
	<state>available</state>
	<published>true</published>
	<start_time>Thu Mar 04 14:05:56 UTC 2010</start_time>
	<end_time>Thu Mar 04 15:01:01 UTC 2010</end_time>	
	<playback>
		<format>simple</format>
		<link>http://server.com/simple/playback?recordingID=Demo Meeting-3243244</link> 	
	</playback>
	<meta>
		<title>Test Recording 2</title>
		<subject>English 232 session</subject>
		<description>Second  test recording</description>
		<creator>Omar Shammas</creator>
		<contributor>Blindside</contributor>
		<language>en_US</language>
	</meta>
</recording>
*/"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/BreakoutRoom.java,"package org.bigbluebutton.api.domain;

import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText;


public class BreakoutRoom {

  @JacksonXmlText
  private String value;

  public String getValue() {
    return value;
  }

  public void setValue(String value) {
    this.value = value;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/User.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.api.domain;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class User {
	private String internalUserId;
	private String externalUserId;
	private String fullname;
	private String role;
	private Boolean locked;
	private String avatarURL;
	private Map<String,String> status;
	private Boolean guest;
	private String  guestStatus;
	private Boolean listeningOnly = false;
	private Boolean voiceJoined = false;
	private String clientType;
	private List<String> streams;
	private Long leftOn = null;

	public User(String internalUserId,
							String externalUserId,
							String fullname,
							String role,
							Boolean locked,
							String avatarURL,
							Boolean guest,
							String  guestStatus,
							String clientType) {
		this.internalUserId = internalUserId;
		this.externalUserId = externalUserId;
		this.fullname = fullname;
		this.role = role;
		this.locked = locked;
		this.avatarURL = avatarURL;
		this.guest = guest;
		this.guestStatus = guestStatus;
		this.status = new ConcurrentHashMap<>();
		this.streams = Collections.synchronizedList(new ArrayList<String>());
		this.clientType = clientType;
	}

	public String getInternalUserId() {
		return this.internalUserId;
	}
	public void setInternalUserId(String internalUserId) {
		this.internalUserId = internalUserId;
	}
	
	public String getExternalUserId(){
		return this.externalUserId;
	}
	
	public void setExternalUserId(String externalUserId){
		this.externalUserId = externalUserId;
	}

	public void setGuest(Boolean guest) {
		this.guest = guest;
	}

	public Boolean isGuest() {
		return this.guest;
	}

	public void setGuestStatus(String guestStatus) {
		this.guestStatus = guestStatus;
	}

	public String getGuestStatus() {
		return this.guestStatus;
	}
	
	public Boolean hasLeft() {
		return leftOn != null;
	}

	public void joined() {
		this.leftOn = null;
	}

	public void left() {
		this.leftOn = System.currentTimeMillis();
	}

	public Long getLeftOn() {
		return this.leftOn;
	}

	public String getFullname() {
		return fullname;
	}
	public void setFullname(String fullname) {
		this.fullname = fullname;
	}
	public String getRole() {
		return role;
	}
	public void setRole(String role) {
		this.role = role;
	}
	public void setLocked(Boolean locked) {
		this.locked = locked;
	}

	public String getAvatarUrl() {
		return avatarURL;
	}

	public void setAvatarUrl(String avatarURL) {
		this.avatarURL = avatarURL;
	}

	public boolean isModerator() {
		return ""MODERATOR"".equalsIgnoreCase(this.role);
	}
	
	public void setStatus(String key, String value){
		this.status.put(key, value);
	}
	public void removeStatus(String key){
		this.status.remove(key);
	}
	public Map<String,String> getStatus(){
		return this.status;
	}

	public boolean isPresenter() {
		String isPresenter = this.status.get(""presenter"");
		if (isPresenter != null) {
			return ""true"".equalsIgnoreCase(isPresenter);
		}
		return false;
	}
	
	public void addStream(String stream) {
		if (!streams.contains(stream)) {
			streams.add(stream);
		}
	}
	
	public void removeStream(String stream) {
		streams.remove(stream);
	}
	
	public List<String> getStreams() {
		return streams;
	}

    public Boolean hasVideo() {
        return !this.getStreams().isEmpty();
    }

	public Boolean isListeningOnly() {
		return listeningOnly;
	}

	public void setListeningOnly(Boolean listeningOnly) {
		this.listeningOnly = listeningOnly;
	}

	public Boolean isVoiceJoined() {
		return voiceJoined;
	}

	public void setVoiceJoined(Boolean voiceJoined) {
		this.voiceJoined = voiceJoined;
	}

	public String getClientType() {
		return this.clientType;
	}

}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Extension.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.api.domain;

import java.util.Map;

public class Extension {
	private String type;
	private Map<String,Object> properties;
	
	public Extension(String type, Map<String,Object> properties) {
		this.type = type;
		this.properties = properties;
	}
	public String getType() {
		return type;
	}
	public void setType(String type) {
		this.type = type;
	}
	public Map<String,Object> getProperties() {
		return properties;
	}
	public void setProperties(Map<String,Object> properties) {
		this.properties = properties;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/RecordingMetadata.java,"package org.bigbluebutton.api.domain;

import java.util.Map;

import org.bigbluebutton.api2.domain.RecMeta;

public class RecordingMetadata {

  private RecMeta recMeta;

  public void setRecMeta(RecMeta rm) {
    recMeta = rm;
  }

  public RecMeta getRecMeta() {
    return recMeta;
  }

  public void setState(String state) {
    recMeta = recMeta.setState(state);
  }

  public void setPublished(boolean published) {
    recMeta = recMeta.setPublished(published);
  }

  public void setMeta(Map<String, String> meta) {
    recMeta = recMeta.setRecMeta(meta);
  }

  public java.util.Map<String, String> getMeta() {
    return recMeta.getRecMeta();
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Playback.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.api.domain;

import java.util.List;

public class Playback {
	private String format;
	private String url;
	private int length;
	private String size;
	private String processingTime;
	private List<Extension> extensions;
	
	public Playback(String format, String url, int length, String size, String processingTime, List<Extension> extensions) {
		this.format = format;
		this.url = url;
		this.length = length;
		this.size = size;
		this.processingTime = processingTime;
		this.extensions = extensions;
	}
	public String getFormat() {
		return format;
	}
	public void setFormat(String format) {
		this.format = format;
	}
	public String getUrl() {
		return url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public int getLength() {
		return length;
	}
	public void setLength(int length) {
		this.length = length;
	}
	public String getSize() {
		return size;
	}
	public void setSize(String size) {
		this.size = size;
	}
	public String getProcessingTime() {
		return processingTime;
	}
	public void setProcessingTime(String processingTime) {
		this.processingTime = processingTime;
	}
	public List<Extension> getExtensions() {
		return extensions;
	}
	public void setExtensions(List<Extension> extensions) {
		this.extensions = extensions;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/UserSession.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.api.domain;

import java.util.concurrent.atomic.AtomicInteger;

public class UserSession {
  public String authToken = null;
  public String internalUserId = null;
  public String conferencename = null;
  public String meetingID = null;
  public String externMeetingID = null;
  public String externUserID = null;
  public String fullname = null; 
  public String role = null;
  public String conference = null;
  public String room = null;
  public Boolean guest = false;
  public Boolean authed = false;
  public String voicebridge = null;
  public String webvoiceconf = null;
  public String mode = null;
  public String record = null;
  public String welcome = null;
  public String logoutUrl = null;
  public String defaultLayout = ""NOLAYOUT"";
  public String avatarURL;
  public String guestStatus = GuestPolicy.ALLOW;
  public String clientUrl = null;
  public Boolean excludeFromDashboard = false;
  public Boolean leftGuestLobby = false;

  private AtomicInteger connections = new AtomicInteger(0);
  
 
  public synchronized int incrementConnectionNum() {
    return connections.incrementAndGet();
  }

  public String getAuthToken() {
    return authToken;
  }

  public String getInternalUserId() {
    return internalUserId;
  }

  public String getConferencename() {
    return conferencename;
  }

  public String getMeetingID() {
    return meetingID;
  }

  public String getExternMeetingID() {
    return externMeetingID;
  }

  public String getExternUserID() {
    return externUserID;
  }

  public String getFullname() {
    return fullname;
  }

  public String getRole() {
    return role;
  }

  public String getConference() {
    return conference;
  }

  public String getRoom() {
    return room;
  }

  public Boolean getGuest() {
    return guest;
  }

  public Boolean getAuthed() {
    return authed;
  }

  public String getVoicebridge() {
    return voicebridge;
  }

  public String getWebvoiceconf() {
    return webvoiceconf;
  }

  public String getMode() {
    return mode;
  }

  public String getRecord() {
    return record;
  }

  public String getWelcome() {
    return welcome;
  }

  public String getLogoutUrl() {
    return logoutUrl;
  }

  public String getDefaultLayout() {
    return defaultLayout;
  }

  public String getAvatarURL() {
    return avatarURL;
  }

  public String getGuestStatus() {
    return guestStatus;
  }

  public String getClientUrl() {
    return clientUrl;
  }

  public String toString() {
    return fullname + "" "" + meetingID + "" "" + conferencename;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Config.java,"package org.bigbluebutton.api.domain;

public class Config {
	
	public final String token;
	public final long createdOn;
	public final String config;
	
	public Config(String token, long timestamp, String config) {
		this.token = token;
		this.createdOn = timestamp;
		this.config = config;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Poll.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.api.domain;

import java.util.HashMap;

public class Poll{

	private String meetingID;
	private String pollID;
	private String title;
	private String question;
	private String datetime;
	private HashMap<String,String> answers;

	public Poll(String meetingID, String title, String question){
		this.pollID = generatePollID(meetingID);
		this.meetingID = meetingID;
		this.title = title;
		this.question = question;
		this.datetime = Long.toString(System.currentTimeMillis()); 
		this.answers = new HashMap<>();
	}

	public void addAnswer(String answer){
		String answerID = generateAnswerID(this.meetingID);
		this.answers.put(answerID,answer);
	}

	public void removeAnswer(String answerID){
		this.answers.remove(answerID);
	}

	public String generatePollID(String meetingID){
		return null;
	}

	public String generateAnswerID(String meetingID){
		return null;
	}

	public void store() throws Exception{

	}

	public String getMeetingID(){
		return this.meetingID;
	}

	public String getPollID(){
		return this.pollID;
	}

	public HashMap<String,String> toMap(){
		HashMap<String,String> map = new HashMap<>();
		map.put(""pollID"",pollID);
		map.put(""meetingID"",meetingID);
		map.put(""title"", title);
		map.put(""question"",question);
		map.put(""datetime"",datetime);
		return map;
	}

}"
bbb-common-web/src/main/java/org/bigbluebutton/api/domain/Extensions.java,"package org.bigbluebutton.api.domain;

import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;

/**
 * Created by ritz on 2017-03-11.
 */
public class Extensions {
  @JacksonXmlProperty(localName = ""preview"")
  @JacksonXmlElementWrapper(useWrapping = false)
  private Preview preview;

  public void setPreview(Preview preview) {
    this.preview = preview;
  }

  public Preview getPreview() {
    return preview;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/service/ValidationService.java,"package org.bigbluebutton.api.service;

import org.bigbluebutton.api.model.request.*;
import org.bigbluebutton.api.model.shared.Checksum;
import org.bigbluebutton.api.model.shared.ChecksumValidationGroup;
import org.bigbluebutton.api.model.shared.GetChecksum;
import org.bigbluebutton.api.model.shared.PostChecksum;
import org.bigbluebutton.api.util.ParamsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class ValidationService {

    private static Logger log = LoggerFactory.getLogger(ValidationService.class);

    public enum RequestType {
        GET,
        POST
    }

    public enum ApiCall {
        CREATE(""create"", RequestType.GET),
        JOIN(""join"", RequestType.GET),
        MEETING_RUNNING(""isMeetingRunning"", RequestType.GET),
        END(""end"", RequestType.GET),
        GET_MEETING_INFO(""getMeetingInfo"", RequestType.GET),
        GET_MEETINGS(""getMeetings"", RequestType.GET),
        GET_SESSIONS(""getSessions"", RequestType.GET),
        GUEST_WAIT(""guestWait"", RequestType.GET),
        ENTER(""enter"", RequestType.GET),
        STUNS(""stuns"", RequestType.GET),
        SIGN_OUT(""signOut"", RequestType.GET),
        LEARNING_DASHBOARD(""learningDashboard"", RequestType.GET),
        GET_JOIN_URL(""getJoinUrl"", RequestType.GET),
        INSERT_DOCUMENT(""insertDocument"", RequestType.GET);

        private final String name;
        private final RequestType requestType;

        ApiCall(String name, RequestType requestType) {
            this.name = name;
            this.requestType = requestType;
        }

        public String getName() { return this.name; }
        public RequestType getRequestType() { return this.requestType; }
    }

    private String securitySalt;
    private String supportedChecksumAlgorithms;
    private Boolean allowRequestsWithoutSession;

    private ValidatorFactory validatorFactory;
    private Validator validator;

    public ValidationService() {
        validatorFactory = Validation.buildDefaultValidatorFactory();
        validator = validatorFactory.getValidator();
    }

    public Map<String, String> validate(ApiCall apiCall, Map<String, String[]> params, String queryString) {
        log.info(""Validating {} request with query string {}"", apiCall.getName(), queryString);
        params = sanitizeParams(params);

        Request request = initializeRequest(apiCall, params, queryString);
        Map<String,String> violations = new HashMap<>();

        if(request == null) {
            violations.put(""validationError"", ""Request not recognized"");
        } else {
            request.populateFromParamsMap(params);
            violations = performValidation(request);
        }

        return violations;
    }

    private Request initializeRequest(ApiCall apiCall, Map<String, String[]> params, String queryString) {
        Request request = null;
        Checksum checksum;

        String checksumValue = """";
        if(params.containsKey(""checksum"")) {
            checksumValue = params.get(""checksum"")[0];
        }

        if(queryString == null || queryString.isEmpty()) {
            queryString = buildQueryStringFromParamsMap(params);
        }

        switch(apiCall.requestType) {
            case GET:
                checksum = new GetChecksum(apiCall.getName(), checksumValue, queryString);
                switch(apiCall) {
                    case CREATE:
                        request = new CreateMeeting(checksum);
                        break;
                    case JOIN:
                        request = new JoinMeeting(checksum);
                        break;
                    case MEETING_RUNNING:
                        request = new MeetingRunning(checksum);
                        break;
                    case END:
                        request = new EndMeeting(checksum);
                        break;
                    case GET_MEETING_INFO:
                        request = new MeetingInfo(checksum);
                        break;
                    case GET_MEETINGS:
                    case GET_SESSIONS:
                        request = new SimpleRequest(checksum);
                        break;
                    case INSERT_DOCUMENT:
                        request = new InsertDocument(checksum);
                        break;
                    case GUEST_WAIT:
                        request = new GuestWait();
                        break;
                    case ENTER:
                        request = new Enter();
                        break;
                    case STUNS:
                        request = new Stuns();
                        break;
                    case SIGN_OUT:
                        request = new SignOut();
                        break;
                    case LEARNING_DASHBOARD:
                        request = new LearningDashboard();
                        break;
                    case GET_JOIN_URL:
                        request = new GetJoinUrl();
                        break;
                }
        }

        return request;
    }

    private <R extends Request> Map<String, String> performValidation(R classToValidate) {
        Set<ConstraintViolation<R>> violations = validator.validate(classToValidate, ChecksumValidationGroup.class);

        if(violations.isEmpty()) {
            violations = validator.validate(classToValidate);
        }

        return buildViolationsMap(classToValidate, violations);
    }

    private <R extends Request> Map<String, String> buildViolationsMap(R classToValidate, Set<ConstraintViolation<R>> violations) {
        Map<String, String> violationMap = new HashMap<>();

        for(ConstraintViolation<R> violation: violations) {
            Map<String, Object> attributes = violation.getConstraintDescriptor().getAttributes();
            String key;
            String message;

            if(attributes.containsKey(""key"")) {
                key = (String) attributes.get(""key"");
            } else {
                key = ""validationError"";
            }

            if(attributes.containsKey(""message"")) {
                message = (String) attributes.get(""message"");
            } else {
                message = ""An unknown validation error occurred"";
            }

            violationMap.put(key, message);
        }

        if(violationMap.isEmpty()) {
            classToValidate.convertParamsFromString();
        }

        return violationMap;
    }

    private Map<String, String[]> sanitizeParams(Map<String, String[]> params) {
        Map<String, String[]> sanitizedParams = new LinkedHashMap<>();

        for(Map.Entry<String, String[]> param: params.entrySet()) {
            String paramName = ParamsUtil.sanitizeString(param.getKey());
            String[] sanitizedValues = new String[param.getValue().length];

            for(int i = 0; i < sanitizedValues.length; i++) {
                String sanitizedValue = ParamsUtil.sanitizeString(param.getValue()[i]);
                sanitizedValues[i] = sanitizedValue;
            }

            sanitizedParams.put(paramName, sanitizedValues);
        }

        return sanitizedParams;
    }

    private String mapToString(Map<String, String[]> map) {
        StringBuilder mapString = new StringBuilder();

        for(Map.Entry<String, String[]> entry: map.entrySet()) {
            StringBuilder entryString = new StringBuilder();
            entryString.append(entry.getKey() + "": ["");

            for(int i = 0; i < entry.getValue().length; i++) {
                if(i == entry.getValue().length - 1) {
                    entryString.append(entry.getValue()[i]);
                } else {
                    entryString.append(entry.getValue()[i] + "", "");
                }
            }

            entryString.append(""], "");
            mapString.append(entryString);
        }

        return mapString.toString();
    }

    public static String buildQueryStringFromParamsMap(Map<String, String[]> params) {
        StringBuilder queryString = new StringBuilder();
        SortedSet<String> keys = new TreeSet<>(params.keySet());

        boolean firstParam = true;
        for(String key: keys) {

            if(key.equals(""checksum"")) {
                continue;
            }

            for(String value: params.get(key)) {
                if(firstParam) {
                    firstParam = false;
                } else {
                    queryString.append(""&"");
                }

                queryString.append(key);
                queryString.append(""="");

                String encodedValue = encodeString(value);
                queryString.append(encodedValue);
            }
        }

        return queryString.toString();
    }

    private static String encodeString(String stringToEncode) {
        String encodedResult;

        try {
            encodedResult = URLEncoder.encode(stringToEncode, StandardCharsets.UTF_8.name());
        } catch(UnsupportedEncodingException ex) {
            encodedResult = stringToEncode;
        }

        return encodedResult;
    }

    public void setSecuritySalt(String securitySalt) { this.securitySalt = securitySalt; }
    public String getSecuritySalt() { return securitySalt; }

    public void setSupportedChecksumAlgorithms(String supportedChecksumAlgorithms) { this.supportedChecksumAlgorithms = supportedChecksumAlgorithms; }
    public String getSupportedChecksumAlgorithms() { return supportedChecksumAlgorithms; }

    public void setAllowRequestsWithoutSession(Boolean allowRequestsWithoutSession) {
        this.allowRequestsWithoutSession = allowRequestsWithoutSession;
    }
    public Boolean getAllowRequestsWithoutSession() { return allowRequestsWithoutSession; }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/service/XmlService.java,"package org.bigbluebutton.api.service;

import org.bigbluebutton.api.model.entity.*;

import java.util.Collection;
import org.springframework.data.domain.*;

public interface XmlService {

    String recordingsToXml(Collection<Recording> recordings);
    String recordingToXml(Recording recording);
    String metadataToXml(Metadata metadata);
    String playbackFormatToXml(PlaybackFormat playbackFormat);
    String thumbnailToXml(Thumbnail thumbnail);
    String callbackDataToXml(CallbackData callbackData);
    String constructResponseFromRecordingsXml(String xml);
    String constructPaginatedResponse(Page<?> page, int offset, String response);
    Recording xmlToRecording(String recordId, String xml);
    String noRecordings();
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/service/impl/XmlServiceImpl.java,"package org.bigbluebutton.api.service.impl;

import org.bigbluebutton.api.model.entity.*;
import org.bigbluebutton.api.service.XmlService;
import org.w3c.dom.CharacterData;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.ByteArrayInputStream;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.util.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Node;

import org.springframework.data.domain.*;
import org.w3c.dom.NodeList;

public class XmlServiceImpl implements XmlService {

    private static Logger logger = LoggerFactory.getLogger(XmlServiceImpl.class);

    private DocumentBuilderFactory factory;
    private DocumentBuilder builder;

    @Override
    public String recordingsToXml(Collection<Recording> recordings) {
        logger.info(""Converting {} recordings to xml"", recordings.size());
        try {
            setup();
            Document document = builder.newDocument();

            Element rootElement = createElement(document, ""recordings"", null);
            document.appendChild(rootElement);

            String xml;
            Document secondDoc;
            Node node;

            for(Recording recording: recordings) {
                xml = recordingToXml(recording);
                secondDoc = builder.parse(new ByteArrayInputStream(xml.getBytes()));
                node = document.importNode(secondDoc.getDocumentElement(), true);
                rootElement.appendChild(node);
            }

            String result = documentToString(document);
//            logger.info(""========== Result =========="");
//            logger.info(""{}"", result);
//            logger.info(""============================"");
            return result;
        } catch(Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public String recordingToXml(Recording recording) {
//        logger.info(""Converting {} to xml"", recording);
        try {
            setup();
            Document document = builder.newDocument();

            Element rootElement = createElement(document,""recording"", null);
            document.appendChild(rootElement);
            appendFields(document, rootElement, recording, new String[] {""id"", ""metadata"", ""format"", ""callbackData""}, Type.CHILD);

            Element meta = createElement(document, ""meta"", null);
            rootElement.appendChild(meta);

            String xml;
            Document secondDoc;
            Node node;

            if(recording.getMetadata() != null) {
                for(Metadata metadata: recording.getMetadata()) {
                    xml = metadataToXml(metadata);
                    secondDoc = builder.parse(new ByteArrayInputStream(xml.getBytes()));
                    node = document.importNode(secondDoc.getDocumentElement(), true);
                    meta.appendChild(node);
                }
            }

            if(recording.getFormat() != null) {
                xml = playbackFormatToXml(recording.getFormat());
                secondDoc = builder.parse(new ByteArrayInputStream(xml.getBytes()));
                node = document.importNode(secondDoc.getDocumentElement(), true);
                rootElement.appendChild(node);
            }

            if(recording.getCallbackData() != null) {
                xml = callbackDataToXml(recording.getCallbackData());
                secondDoc = builder.parse(new ByteArrayInputStream(xml.getBytes()));
                node = document.importNode(secondDoc.getDocumentElement(), true);
                rootElement.appendChild(node);
            }

            String result = documentToString(document);
//            logger.info(""========== Result =========="");
//            logger.info(""{}"", result);
//            logger.info(""============================"");
            return result;
        } catch(Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public String metadataToXml(Metadata metadata) {
//        logger.info(""Converting {} to xml"", metadata);

        try {
            setup();
            Document document = builder.newDocument();

            Element rootElement = createElement(document, metadata.getKey(), metadata.getValue());
            document.appendChild(rootElement);

            String result = documentToString(document);
//            logger.info(""========== Result =========="");
//            logger.info(""{}"", result);
//            logger.info(""============================"");
            return result;
        } catch(Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public String playbackFormatToXml(PlaybackFormat playbackFormat) {
//        logger.info(""Converting {} to xml"", playbackFormat);

        try {
            setup();
            Document document = builder.newDocument();

            Element rootElement = createElement(document, ""playback"", null);
            document.appendChild(rootElement);
            appendFields(document, rootElement, playbackFormat, new String[] {""id"", ""recording"", ""thumbnails""}, Type.CHILD);

            if(playbackFormat.getThumbnails() != null && !playbackFormat.getThumbnails().isEmpty()) {
                Element images = createElement(document, ""images"", null);
                rootElement.appendChild(images);

                List<Thumbnail> thumbnails = new ArrayList<>(playbackFormat.getThumbnails());
                Collections.sort(thumbnails);

                for(Thumbnail thumbnail: thumbnails) {
                    String xml = thumbnailToXml(thumbnail);
                    Document thumbnailDoc = builder.parse(new ByteArrayInputStream(xml.getBytes()));
                    Node node = document.importNode(thumbnailDoc.getDocumentElement(), true);
                    images.appendChild(node);
                }
            }

            String result = documentToString(document);
//            logger.info(""========== Result =========="");
//            logger.info(""{}"", result);
//            logger.info(""============================"");
            return result;
        } catch(Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public String thumbnailToXml(Thumbnail thumbnail) {
//        logger.info(""Converting {} to xml"", thumbnail);

        try {
            setup();
            Document document = builder.newDocument();

            Element rootElement = createElement(document, ""image"", thumbnail.getUrl());
            document.appendChild(rootElement);
            appendFields(document, rootElement, thumbnail, new String[] {""id"", ""url"", ""playbackFormat""}, Type.ATTRIBUTE);

            String result = documentToString(document);
//            logger.info(""========== Result =========="");
//            logger.info(""{}"", result);
//            logger.info(""============================"");
            return result;
        } catch(Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public String callbackDataToXml(CallbackData callbackData) {
//        logger.info(""Converting {} to xml"", callbackData);

        try {
            setup();
            Document document = builder.newDocument();

            Element rootElement = createElement(document, ""callback"", null);
            document.appendChild(rootElement);
            appendFields(document, rootElement, callbackData, new String[] {""id"", ""recording""}, Type.CHILD);

            String result = documentToString(document);
//            logger.info(""========== Result =========="");
//            logger.info(""{}"", result);
//            logger.info(""============================"");
            return result;
        } catch(Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public String constructResponseFromRecordingsXml(String xml) {
        logger.info(""Constructing response from recordings xml"");

        try {
            setup();
            Document document = builder.newDocument();

            Element rootElement = createElement(document, ""response"", null);
            document.appendChild(rootElement);

            Element returnCode = createElement(document, ""returncode"", ""SUCCESS"");
            rootElement.appendChild(returnCode);

            Document recordingsDoc = builder.parse(new ByteArrayInputStream(xml.getBytes()));
            Node recordingsNode = document.importNode(recordingsDoc.getDocumentElement(), true);
            rootElement.appendChild(recordingsNode);

            String result = documentToString(document);
//            logger.info(""========== Result =========="");
//            logger.info(""{}"", result);
//            logger.info(""============================"");
            return result;
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public String noRecordings() {
        logger.info(""Constructing no recordings response"");

        try {
            setup();
            Document document = builder.newDocument();

            Element rootElement = createElement(document, ""response"", null);
            document.appendChild(rootElement);

            Element returnCode = createElement(document, ""returncode"", ""SUCCESS"");
            rootElement.appendChild(returnCode);

            Element messageKey = createElement(document, ""messageKey"", ""noRecordings"");
            rootElement.appendChild(messageKey);

            Element message = createElement(document, ""message"", ""No recordings found. This may occur if you attempt to retrieve all recordings."");
            rootElement.appendChild(message);

            String result = documentToString(document);
//            logger.info(""========== Result =========="");
//            logger.info(""{}"", result);
//            logger.info(""============================"");
            return result;
        } catch(Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public String constructPaginatedResponse(Page<?> page, int offset, String response) {
        logger.info(""Constructing paginated response"");

        try {
            setup();

            if(response == null || response.equals("""")) {
                return null;
            }

            Document document = builder.parse(new ByteArrayInputStream(response.getBytes()));
            Element rootElement = document.getDocumentElement();

            Element pagination = createElement(document, ""pagination"", null);

            String xml;
            Document secondDoc;
            Node node;

            xml = pageableToXml(page.getPageable(), offset);
            secondDoc = builder.parse(new ByteArrayInputStream(xml.getBytes()));
            node = document.importNode(secondDoc.getDocumentElement(), true);
            pagination.appendChild(node);

            Element totalElements = createElement(document, ""totalElements"", String.valueOf(page.getTotalElements()));
            pagination.appendChild(totalElements);

//            Element last = createElement(document, ""last"", String.valueOf(page.isLast()));
//            pagination.appendChild(last);

//            Element totalPages = createElement(document, ""totalPages"", String.valueOf(page.getTotalPages()));
//            pagination.appendChild(totalPages);

//            Element first = createElement(document, ""first"", String.valueOf(page.isFirst()));
//            pagination.appendChild(first);

            Element empty = createElement(document, ""empty"", String.valueOf(!page.hasContent()));
            pagination.appendChild(empty);

            rootElement.appendChild(pagination);

            String result = documentToString(document);
//            logger.info(""========== Result =========="");
//            logger.info(""{}"", result);
//            logger.info(""============================"");
            return result;
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    private String pageableToXml(Pageable pageable, int o) {
        logger.info(""Converting {} to xml"", pageable);

        try {
            setup();
            Document document = builder.newDocument();

            Element rootElement = createElement(document, ""pageable"", null);
            document.appendChild(rootElement);

//            Sort sort = pageable.getSort();
//            Element sortElement = createElement(document, ""sort"", null);
//
//            Element unsorted = createElement(document, ""unsorted"", String.valueOf(sort.isUnsorted()));
//            sortElement.appendChild(unsorted);
//
//            Element sorted = createElement(document, ""sorted"", String.valueOf(sort.isSorted()));
//            sortElement.appendChild(sorted);
//
//            Element empty = createElement(document, ""empty"", String.valueOf(sort.isEmpty()));
//            sortElement.appendChild(empty);
//
//            rootElement.appendChild(sortElement);

            Element offset = createElement(document, ""offset"", String.valueOf(o));
            rootElement.appendChild(offset);

            Element limit = createElement(document, ""limit"", String.valueOf(pageable.getPageSize()));
            rootElement.appendChild(limit);

//            Element pageNumber = createElement(document, ""pageNumber"", String.valueOf(pageable.getPageNumber()));
//            rootElement.appendChild(pageNumber);

            Element paged = createElement(document, ""paged"", String.valueOf(pageable.isPaged()));
            rootElement.appendChild(paged);

            Element unpaged = createElement(document, ""unpaged"", String.valueOf(pageable.isUnpaged()));
            rootElement.appendChild(unpaged);

            String result = documentToString(document);
//            logger.info(""========== Result =========="");
//            logger.info(""{}"", result);
//            logger.info(""============================"");
            return result;
        } catch(Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    public Recording xmlToRecording(String recordId, String xml) {
        try {
            setup();
            Document document = builder.parse(new ByteArrayInputStream(xml.getBytes()));
            Recording recording = parseRecordingDocument(document);

            if (recording.getRecordId() == null || recording.getRecordId().equals(""""))
                recording.setRecordId(recordId);

            return recording;
        } catch(Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    private Recording parseRecordingDocument(Document recordingDocument) {
        String id = getNodeData(recordingDocument, ""id"");
        String state = getNodeData(recordingDocument, ""state"");
        String published = getNodeData(recordingDocument, ""published"");
        String startTime = getNodeData(recordingDocument, ""start_time"");
        String endTime = getNodeData(recordingDocument, ""end_time"");
        String participants = getNodeData(recordingDocument, ""participants"");
        String externalId = getNodeData(recordingDocument, ""externalId"");
        String name = getNodeData(recordingDocument, ""name"");

        if (tagExists(recordingDocument, ""meeting"")) {
            Element meeting = (Element) recordingDocument.getElementsByTagName(""meeting"").item(0);
            externalId = meeting.getAttribute(""externalId"");
            name = meeting.getAttribute(""name"");
            if (id == null || id.equals(""""))
                id = meeting.getAttribute(""id"");
        }

        Recording recording = new Recording();
        recording.setRecordId(id);
        recording.setMeetingId(externalId);
        recording.setName(name);
        recording.setPublished(Boolean.parseBoolean(published));
        recording.setState(state);

        try {
            recording.setStartTime(
                    LocalDateTime.ofInstant(Instant.ofEpochMilli(Long.parseLong(startTime)), ZoneOffset.UTC));
            recording
                    .setEndTime(LocalDateTime.ofInstant(Instant.ofEpochMilli(Long.parseLong(endTime)), ZoneOffset.UTC));
            recording.setParticipants(Integer.parseInt(participants));
        } catch (NumberFormatException e) {
        }

        parseMetadata(recordingDocument, recording);
        PlaybackFormat playback = parsePlaybackFormat(recordingDocument);
        recording.setFormat(playback);
        playback.setRecording(recording);

        logger.info(""Finished constructing recording: {}"", recording);

        return recording;
    }

    private void parseMetadata(Document recordingDocument, Recording recording) {
        Node meta = recordingDocument.getElementsByTagName(""meta"").item(0);
        NodeList children = meta.getChildNodes();

        for (int i = 0; i < children.getLength(); i++) {
            Node node = children.item(i);

            if (!(node instanceof Element))
                continue;

            String key = node.getNodeName();
            String value = node.getTextContent();

            Metadata metadata = new Metadata();
            metadata.setKey(key);
            metadata.setValue(value);

            logger.info(""Finished constructing metadata: {}"", metadata);

            recording.addMetadata(metadata);
        }
    }

    private PlaybackFormat parsePlaybackFormat(Document recordingDocument) {
        PlaybackFormat playback = new PlaybackFormat();

        String format = getNodeData(recordingDocument, ""format"");
        playback.setFormat(format);

        String url = getNodeData(recordingDocument, ""link"");
        playback.setUrl(url);

        String length = getNodeData(recordingDocument, ""duration"");
        String processingTime = getNodeData(recordingDocument, ""processingTime"");

        try {
            playback.setLength(Integer.parseInt(length));
            playback.setProcessingTime(Integer.parseInt(processingTime));
        } catch (NumberFormatException e) {

        }

        NodeList images = recordingDocument.getElementsByTagName(""image"");

        for (int i = 0; i < images.getLength(); i++) {
            Element image = (Element) images.item(i);

            String height = image.getAttribute(""height"");
            String width = image.getAttribute(""width"");
            String alt = image.getAttribute(""alt"");
            String src = image.getTextContent();

            Thumbnail thumbnail = new Thumbnail();

            try {
                thumbnail.setHeight(Integer.parseInt(height));
                thumbnail.setWidth(Integer.parseInt(width));
            } catch (NumberFormatException e) {
            }

            thumbnail.setAlt(alt);
            thumbnail.setUrl(src);
            thumbnail.setSequence(i);

            logger.info(""Finished constructing image: {}"", image);

            playback.addThumbnail(thumbnail);
        }

        logger.info(""Finished constructing playback format: {}"", playback);

        return playback;
    }

    private void setup() throws ParserConfigurationException {
        if(factory == null) factory = DocumentBuilderFactory.newInstance();
        if(builder == null) builder = factory.newDocumentBuilder();
    }

    private Element createElement(Document document, String name, String value) {
        Element element = document.createElement(name);
        if(value != null) element.setTextContent(value);
        return element;
    }

    public String documentToString(Document document) {
        String output = null;

        try {
            TransformerFactory factory = TransformerFactory.newInstance();
            Transformer transformer = factory.newTransformer();
            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""yes"");
            transformer.setOutputProperty(OutputKeys.INDENT, ""no"");
            StringWriter writer = new StringWriter();
            transformer.transform(new DOMSource(document), new StreamResult(writer));
            output = writer.toString();
        } catch(Exception e) {
            e.printStackTrace();
        }

        return output;
    }

    private void appendFields(Document document, Element parent, Object object, String[] ignoredFields, Type type) throws IllegalAccessException {
        Field[] fields = object.getClass().getDeclaredFields();

        for(Field field: fields) {
            if(Arrays.stream(ignoredFields).anyMatch(field.getName()::equals)) continue;
            field.setAccessible(true);
            Object fieldValue = field.get(object);
            if(fieldValue != null) {
                if(fieldValue instanceof LocalDateTime) {
                    fieldValue = localDateTimeToEpoch((LocalDateTime) fieldValue);
                }

                switch(type) {
                    case CHILD:
                        Element child = createElement(document, field.getName(), fieldValue.toString());
                        parent.appendChild(child);
                        break;
                    case ATTRIBUTE:
                        parent.setAttribute(field.getName(), fieldValue.toString());
                        break;
                }
            }
        }

    }

    private String localDateTimeToEpoch(LocalDateTime localDateTime) {
        Instant instant = localDateTime.atZone(ZoneId.systemDefault()).toInstant();
        return String.valueOf(instant.toEpochMilli());
    }

    private boolean tagExists(Document document, String tag) {
        NodeList node = document.getElementsByTagName(tag);
        if (node == null || node.getLength() == 0)
            return false;
        return true;
    }

    private String getNodeData(Document document, String tag) {
        String data = null;
        if (!tagExists(document, tag))
            return data;

        NodeList node = document.getElementsByTagName(tag);
        Element element = (Element) node.item(0);
        Node child = element.getFirstChild();

        if (child instanceof CharacterData) {
            CharacterData characterData = (CharacterData) child;
            data = characterData.getData();
        }

        return data;
    }

    private enum Type {
        CHILD,
        ATTRIBUTE
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/service/impl/RecordingServiceFileImpl.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 *
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 *
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.bigbluebutton.api.service.impl;

import java.io.File;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.bigbluebutton.api.Util;
import org.bigbluebutton.api.RecordingService;
import org.bigbluebutton.api.domain.Recording;
import org.bigbluebutton.api.domain.RecordingMetadata;
import org.bigbluebutton.api.messaging.messages.MakePresentationDownloadableMsg;
import org.bigbluebutton.api.service.XmlService;
import org.bigbluebutton.api.util.RecordingMetadataReaderHelper;
import org.bigbluebutton.api2.domain.UploadedTrack;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.data.domain.*;

public class RecordingServiceFileImpl implements RecordingService {
    private static Logger log = LoggerFactory.getLogger(RecordingServiceFileImpl.class);

    private static final Pattern PRESENTATION_ID_PATTERN = Pattern.compile(""^[a-z0-9]{40}-[0-9]{13}\\.[0-9a-zA-Z]{3,4}$"");

    private static String processDir = ""/var/bigbluebutton/recording/process"";
    private static String publishedDir = ""/var/bigbluebutton/published"";
    private static String unpublishedDir = ""/var/bigbluebutton/unpublished"";
    private static String deletedDir = ""/var/bigbluebutton/deleted"";
    private RecordingMetadataReaderHelper recordingServiceHelper;
    private XmlService xmlService;
    private String recordStatusDir;
    private String captionsDir;
    private Boolean allowFetchAllRecordings;
    private String presentationBaseDir;
    private String defaultServerUrl;
    private String defaultTextTrackUrl;

    private void copyPresentationFile(File presFile, File dlownloadableFile) {
        try {
            FileUtils.copyFile(presFile, dlownloadableFile);
        } catch (IOException ex) {
            log.error(""Failed to copy file: {}"", ex);
        }
    }

    public void processMakePresentationDownloadableMsg(MakePresentationDownloadableMsg msg) {
        try {
            File presDir = Util.getPresentationDir(presentationBaseDir, msg.meetingId, msg.presId);
            Util.makePresentationDownloadable(presDir, msg.presId, msg.downloadable);
        } catch (IOException e) {
            log.error(""Failed to make presentation downloadable: {}"", e);
        }
    }

    public File getDownloadablePresentationFile(String meetingId, String presId, String presFilename) {
        log.info(""Find downloadable presentation for meetingId={} presId={} filename={}"", meetingId, presId,
                presFilename);

        if (! Util.isPresFileIdValidFormat(presFilename)) {
            log.error(""Invalid presentation filename for meetingId={} presId={} filename={}"", meetingId, presId,
                    presFilename);
            return null;
        }

        String presFilenameExt = FilenameUtils.getExtension(presFilename);
        File presDir = Util.getPresentationDir(presentationBaseDir, meetingId, presId);
        File downloadMarker = Util.getPresFileDownloadMarker(presDir, presId);
        if (presDir != null && downloadMarker != null && downloadMarker.exists()) {
            String safePresFilename = presId.concat(""."").concat(presFilenameExt);
            File presFile = new File(presDir.getAbsolutePath() + File.separatorChar + safePresFilename);
            if (presFile.exists()) {
                return presFile;
            }

            log.error(""Presentation file missing for meetingId={} presId={} filename={}"", meetingId, presId,
                    presFilename);
            return null;
        }

        log.error(""Invalid presentation directory for meetingId={} presId={} filename={}"", meetingId, presId,
                presFilename);
        return null;
    }

    public void kickOffRecordingChapterBreak(String meetingId, Long timestamp) {
        String done = recordStatusDir + File.separatorChar + meetingId + ""-"" + timestamp + "".done"";

        File doneFile = new File(done);
        if (!doneFile.exists()) {
            try {
                doneFile.createNewFile();
                if (!doneFile.exists())
                    log.error(""Failed to create {} file."", done);
            } catch (IOException e) {
                log.error(""Exception occured when trying to create {} file"", done);
            }
        } else {
            log.error(""{} file already exists."", done);
        }
    }

    public void startIngestAndProcessing(String meetingId) {
        String done = recordStatusDir + File.separatorChar + meetingId + "".done"";

        File doneFile = new File(done);
        if (!doneFile.exists()) {
            try {
                doneFile.createNewFile();
                if (!doneFile.exists())
                    log.error(""Failed to create {} file."", done);
            } catch (IOException e) {
                log.error(""Exception occured when trying to create {} file."", done);
            }
        } else {
            log.error(""{} file already exists."", done);
        }
    }

    public void markAsEnded(String meetingId) {
        String done = recordStatusDir + ""/../ended/"" + meetingId + "".done"";

        File doneFile = new File(done);
        if (!doneFile.exists()) {
            try {
                doneFile.createNewFile();
                if (!doneFile.exists())
                    log.error(""Failed to create "" + done + "" file."");
            } catch (IOException e) {
                log.error(""Exception occured when trying to create {} file."", done);
            }
        } else {
            log.error(done + "" file already exists."");
        }
    }

    public List<RecordingMetadata> getRecordingsMetadata(List<String> recordIDs, List<String> states) {
        List<RecordingMetadata> recs = new ArrayList<>();

        Map<String, List<File>> allDirectories = getAllDirectories(states);
        if (recordIDs.isEmpty()) {
            for (Map.Entry<String, List<File>> entry : allDirectories.entrySet()) {
                recordIDs.addAll(getAllRecordingIds(entry.getValue()));
            }
        }

        for (String recordID : recordIDs) {
            for (Map.Entry<String, List<File>> entry : allDirectories.entrySet()) {
                List<File> _recs = getRecordingsForPath(recordID, entry.getValue());
                for (File _rec : _recs) {
                    RecordingMetadata r = getRecordingMetadata(_rec);
                    if (r != null) {
                        recs.add(r);
                    }
                }
            }
        }

        return recs;
    }

    public Boolean validateTextTrackSingleUseToken(String recordId, String caption, String token) {
        return recordingServiceHelper.validateTextTrackSingleUseToken(recordId, caption, token);
    }

    public String getRecordingTextTracks(String recordId) {
        return recordingServiceHelper.getRecordingTextTracks(recordId, captionsDir, getCaptionFileUrlDirectory());
    }

    public String putRecordingTextTrack(UploadedTrack track) {
        return recordingServiceHelper.putRecordingTextTrack(track);
    }

    public String getRecordings2x(List<String> idList, List<String> states, Map<String, String> metadataFilters, int offset, Pageable pageable) {
        // If no IDs or limit were provided return no recordings instead of every recording
        if(idList.isEmpty() && pageable == null && !allowFetchAllRecordings) return xmlService.noRecordings();

        List<RecordingMetadata> recsList = getRecordingsMetadata(idList, states);
        ArrayList<RecordingMetadata> recs = filterRecordingsByMetadata(recsList, metadataFilters);

        // If no/invalid pagination parameters were given do not paginate the response
        if(pageable == null) return recordingServiceHelper.getRecordings2x(recs);

        Page<RecordingMetadata> recordingsPage = listToPage(recs, offset, pageable);
        String response = recordingServiceHelper.getRecordings2x(new ArrayList<RecordingMetadata>(recordingsPage.getContent()));
        return xmlService.constructPaginatedResponse(recordingsPage, offset, response);
    }

    private RecordingMetadata getRecordingMetadata(File dir) {
        File file = new File(dir.getPath() + File.separatorChar + ""metadata.xml"");
        return recordingServiceHelper.getRecordingMetadata(file);
    }

    public boolean recordingMatchesMetadata(RecordingMetadata recording, Map<String, String> metadataFilters) {
        boolean matchesMetadata = true;
        Map<String, String> recMeta = recording.getMeta();
        for (Map.Entry<String, String> filter : metadataFilters.entrySet()) {
            String metadataValue = recMeta.get(filter.getKey());
            if ( metadataValue == null ) {
                // The recording doesn't have metadata specified
                matchesMetadata = false;
            } else {
                String filterValue = filter.getValue();
                if( filterValue.charAt(0) == '%' && filterValue.charAt(filterValue.length()-1) == '%' && metadataValue.contains(filterValue.substring(1, filterValue.length()-1)) ){
                    // Filter value embraced by two wild cards
                    // AND the filter value is part of the metadata value
                } else if( filterValue.charAt(0) == '%' && metadataValue.endsWith(filterValue.substring(1, filterValue.length())) ) {
                    // Filter value starts with a wild cards
                    // AND the filter value ends with the metadata value
                } else if( filterValue.charAt(filterValue.length()-1) == '%' && metadataValue.startsWith(filterValue.substring(0, filterValue.length()-1)) ) {
                    // Filter value ends with a wild cards
                    // AND the filter value starts with the metadata value
                } else if( metadataValue.equals(filterValue) ) {
                    // Filter value doesnt have wildcards
                    // AND the filter value is the same as metadata value
                } else {
                    matchesMetadata = false;
                }
            }
        }
        return matchesMetadata;
    }


    public ArrayList<RecordingMetadata> filterRecordingsByMetadata(List<RecordingMetadata> recordings, Map<String, String> metadataFilters) {
        ArrayList<RecordingMetadata> resultRecordings = new ArrayList<>();
        for (RecordingMetadata entry : recordings) {
            if (recordingMatchesMetadata(entry, metadataFilters))
                resultRecordings.add(entry);
        }
        return resultRecordings;
    }

    private ArrayList<File> getAllRecordingsFor(String recordId) {
        String[] format = getPlaybackFormats(publishedDir);
        ArrayList<File> ids = new ArrayList<File>();

        for (int i = 0; i < format.length; i++) {
            List<File> recordings = getDirectories(publishedDir + File.separatorChar + format[i]);
            for (int f = 0; f < recordings.size(); f++) {
                if (recordId.equals(recordings.get(f).getName()))
                    ids.add(recordings.get(f));
            }
        }

        return ids;
    }

    public boolean isRecordingExist(String recordId) {
        List<String> publishList = getAllRecordingIds(publishedDir);
        List<String> unpublishList = getAllRecordingIds(unpublishedDir);
        if (publishList.contains(recordId) || unpublishList.contains(recordId)) {
            return true;
        }

        return false;
    }

    public boolean existAnyRecording(List<String> idList) {
        List<String> publishList = getAllRecordingIds(publishedDir);
        List<String> unpublishList = getAllRecordingIds(unpublishedDir);

        for (String id : idList) {
            if (publishList.contains(id) || unpublishList.contains(id)) {
                return true;
            }
        }
        return false;
    }

    private List<String> getAllRecordingIds(String path) {
        String[] format = getPlaybackFormats(path);

        return getAllRecordingIds(path, format);
    }

    private List<String> getAllRecordingIds(String path, String[] format) {
        List<String> ids = new ArrayList<>();

        for (String aFormat : format) {
            List<File> recordings = getDirectories(path + File.separatorChar + aFormat);
            for (File recording : recordings) {
                if (!ids.contains(recording.getName())) {
                    ids.add(recording.getName());
                }
            }
        }

        return ids;
    }

    private Set<String> getAllRecordingIds(List<File> recs) {
        Set<String> ids = new HashSet<>();

        Iterator<File> iterator = recs.iterator();
        while (iterator.hasNext()) {
            ids.add(iterator.next().getName());
        }

        return ids;
    }

    private List<File> getRecordingsForPath(String id, List<File> recordings) {
        List<File> recs = new ArrayList<>();

        Iterator<File> iterator = recordings.iterator();
        while (iterator.hasNext()) {
            File rec = iterator.next();
            if (rec.getName().startsWith(id)) {
                recs.add(rec);
            }
        }
        return recs;
    }

    private static void deleteRecording(String id, String path) {
        String[] format = getPlaybackFormats(path);
        for (String aFormat : format) {
            List<File> recordings = getDirectories(path + File.separatorChar + aFormat);
            for (File recording : recordings) {
                if (recording.getName().equals(id)) {
                    deleteDirectory(recording);
                    createDirectory(recording);
                }
            }
        }
    }

    private static void createDirectory(File directory) {
        if (!directory.exists())
            directory.mkdirs();
    }

    private static void deleteDirectory(File directory) {
        /**
         * Go through each directory and check if it's not empty. We need to
         * delete files inside a directory before a directory can be deleted.
         **/
        File[] files = directory.listFiles();
        for (File file : files) {
            if (file.isDirectory()) {
                deleteDirectory(file);
            } else {
                file.delete();
            }
        }
        // Now that the directory is empty. Delete it.
        directory.delete();
    }

    private static List<File> getDirectories(String path) {
        List<File> files = new ArrayList<>();
        try {
            DirectoryStream<Path> stream = Files.newDirectoryStream(FileSystems.getDefault().getPath(path));
            Iterator<Path> iter = stream.iterator();
            while (iter.hasNext()) {
                Path next = iter.next();
                files.add(next.toFile());
            }
            stream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return files;
    }

    private static String[] getPlaybackFormats(String path) {
        System.out.println(""Getting playback formats at "" + path);
        List<File> dirs = getDirectories(path);
        String[] formats = new String[dirs.size()];

        for (int i = 0; i < dirs.size(); i++) {
            System.out.println(""Playback format = "" + dirs.get(i).getName());
            formats[i] = dirs.get(i).getName();
        }
        return formats;
    }

    public void setRecordingStatusDir(String dir) {
        recordStatusDir = dir;
    }

    public void setUnpublishedDir(String dir) {
        unpublishedDir = dir;
    }

    public void setPresentationBaseDir(String dir) {
        presentationBaseDir = dir;
    }

    public void setDefaultServerUrl(String url) {
        defaultServerUrl = url;
    }

    public void setDefaultTextTrackUrl(String url) {
        defaultTextTrackUrl = url;
    }

    public void setPublishedDir(String dir) {
        publishedDir = dir;
    }

    public void setCaptionsDir(String dir) {
        captionsDir = dir;
    }

    public void setAllowFetchAllRecordings(Boolean allowFetchAllRecordings) { this.allowFetchAllRecordings = allowFetchAllRecordings; }

    public void setRecordingServiceHelper(RecordingMetadataReaderHelper r) {
        recordingServiceHelper = r;
    }

    public void setXmlService(XmlService xmlService) { this.xmlService = xmlService; }

    private boolean shouldIncludeState(List<String> states, String type) {
        boolean r = false;

        if (!states.isEmpty()) {
            if (states.contains(""any"")) {
                r = true;
            } else {
                if (type.equals(Recording.STATE_PUBLISHED) && states.contains(Recording.STATE_PUBLISHED)) {
                    r = true;
                } else if (type.equals(Recording.STATE_UNPUBLISHED) && states.contains(Recording.STATE_UNPUBLISHED)) {
                    r = true;
                } else if (type.equals(Recording.STATE_DELETED) && states.contains(Recording.STATE_DELETED)) {
                    r = true;
                } else if (type.equals(Recording.STATE_PROCESSING) && states.contains(Recording.STATE_PROCESSING)) {
                    r = true;
                } else if (type.equals(Recording.STATE_PROCESSED) && states.contains(Recording.STATE_PROCESSED)) {
                    r = true;
                }
            }

        } else {
            if (type.equals(Recording.STATE_PUBLISHED) || type.equals(Recording.STATE_UNPUBLISHED)) {
                r = true;
            }
        }

        return r;
    }

    public boolean changeState(String recordingId, String state) {
        boolean succeeded = false;
        if (state.equals(Recording.STATE_PUBLISHED)) {
            // It can only be published if it is unpublished
            succeeded |= changeState(unpublishedDir, recordingId, state);
        } else if (state.equals(Recording.STATE_UNPUBLISHED)) {
            // It can only be unpublished if it is published
            succeeded |= changeState(publishedDir, recordingId, state);
        } else if (state.equals(Recording.STATE_DELETED)) {
            // It can be deleted from any state
            succeeded |= changeState(publishedDir, recordingId, state);
            succeeded |= changeState(unpublishedDir, recordingId, state);
        }
        return succeeded;
    }

    private boolean changeState(String path, String recordingId, String state) {
        boolean exists = false;
        boolean succeeded = true;
        String[] format = getPlaybackFormats(path);
        for (String aFormat : format) {
            List<File> recordings = getDirectories(path + File.separatorChar + aFormat);
            for (File recording : recordings) {
                if (recording.getName().equalsIgnoreCase(recordingId)) {
                    exists = true;
                    File dest;
                    if (state.equals(Recording.STATE_PUBLISHED)) {
                        dest = new File(publishedDir + File.separatorChar + aFormat);
                        succeeded &= publishRecording(dest, recordingId, recording, aFormat);
                    } else if (state.equals(Recording.STATE_UNPUBLISHED)) {
                        dest = new File(unpublishedDir + File.separatorChar + aFormat);
                        succeeded &= unpublishRecording(dest, recordingId, recording, aFormat);
                    } else if (state.equals(Recording.STATE_DELETED)) {
                        dest = new File(deletedDir + File.separatorChar + aFormat);
                        succeeded &= deleteRecording(dest, recordingId, recording, aFormat);
                    } else {
                        log.debug(String.format(""State: %s, is not supported"", state));
                        return false;
                    }
                }
            }
        }
        return exists && succeeded;
    }

    public boolean publishRecording(File destDir, String recordingId, File recordingDir, String format) {
        File metadataXml = recordingServiceHelper.getMetadataXmlLocation(recordingDir.getPath());
        RecordingMetadata r = recordingServiceHelper.getRecordingMetadata(metadataXml);
        if (r != null) {
            if (!destDir.exists()) destDir.mkdirs();

            try {
                FileUtils.moveDirectory(recordingDir, new File(destDir.getPath() + File.separatorChar + recordingId));

                r.setState(Recording.STATE_PUBLISHED);
                r.setPublished(true);

                File medataXmlFile = recordingServiceHelper.getMetadataXmlLocation(
                        destDir.getAbsolutePath() + File.separatorChar + recordingId);

                // Process the changes by saving the recording into metadata.xml
                return recordingServiceHelper.saveRecordingMetadata(medataXmlFile, r);
            } catch (IOException e) {
                log.error(""Failed to publish recording : "" + recordingId, e);
            }
        }
        return false;
    }

    public boolean unpublishRecording(File destDir, String recordingId, File recordingDir, String format) {
        File metadataXml = recordingServiceHelper.getMetadataXmlLocation(recordingDir.getPath());

        RecordingMetadata r = recordingServiceHelper.getRecordingMetadata(metadataXml);
        if (r != null) {
            if (!destDir.exists()) destDir.mkdirs();

            try {
                FileUtils.moveDirectory(recordingDir, new File(destDir.getPath() + File.separatorChar + recordingId));
                r.setState(Recording.STATE_UNPUBLISHED);
                r.setPublished(false);

                File medataXmlFile = recordingServiceHelper.getMetadataXmlLocation(
                        destDir.getAbsolutePath() + File.separatorChar + recordingId);

                // Process the changes by saving the recording into metadata.xml
                return recordingServiceHelper.saveRecordingMetadata(medataXmlFile, r);
            } catch (IOException e) {
                log.error(""Failed to unpublish recording : "" + recordingId, e);
            }
        }
        return false;
    }

    public boolean deleteRecording(File destDir, String recordingId, File recordingDir, String format) {
        File metadataXml = recordingServiceHelper.getMetadataXmlLocation(recordingDir.getPath());

        RecordingMetadata r = recordingServiceHelper.getRecordingMetadata(metadataXml);
        if (r != null) {
            if (!destDir.exists()) destDir.mkdirs();

            try {
                FileUtils.moveDirectory(recordingDir, new File(destDir.getPath() + File.separatorChar + recordingId));
                r.setState(Recording.STATE_DELETED);
                r.setPublished(false);

                File medataXmlFile = recordingServiceHelper.getMetadataXmlLocation(
                        destDir.getAbsolutePath() + File.separatorChar + recordingId);

                // Process the changes by saving the recording into metadata.xml
                return recordingServiceHelper.saveRecordingMetadata(medataXmlFile, r);
            } catch (IOException e) {
                log.error(""Failed to delete recording : "" + recordingId, e);
            }
        }
        return false;
    }


    private List<File> getAllDirectories(String state) {
        List<File> allDirectories = new ArrayList<>();

        String dir = getDestinationBaseDirectoryName(state);

        if ( dir != null ) {
            String[] formats = getPlaybackFormats(dir);
            for (String format : formats) {
                allDirectories.addAll(getDirectories(dir + File.separatorChar + format));
            }
        }

        return allDirectories;
    }

    private Map<String, List<File>> getAllDirectories(List<String> states) {
        Map<String, List<File>> allDirectories = new HashMap<>();

        if ( shouldIncludeState(states, Recording.STATE_PUBLISHED) ) {
            List<File> listedDirectories = getAllDirectories(Recording.STATE_PUBLISHED);
            allDirectories.put(Recording.STATE_PUBLISHED, listedDirectories);
        }

        if ( shouldIncludeState(states, Recording.STATE_UNPUBLISHED) ) {
            List<File> listedDirectories = getAllDirectories(Recording.STATE_UNPUBLISHED);
            allDirectories.put(Recording.STATE_UNPUBLISHED, listedDirectories);
        }

        if ( shouldIncludeState(states, Recording.STATE_DELETED) ) {
            List<File> listedDirectories = getAllDirectories(Recording.STATE_DELETED);
            allDirectories.put(Recording.STATE_DELETED, listedDirectories);
        }

        if ( shouldIncludeState(states, Recording.STATE_PROCESSING) ) {
            List<File> listedDirectories = getAllDirectories(Recording.STATE_PROCESSING);
            allDirectories.put(Recording.STATE_PROCESSING, listedDirectories);
        }

        if ( shouldIncludeState(states, Recording.STATE_PROCESSED) ) {
            List<File> listedDirectories = getAllDirectories(Recording.STATE_PROCESSED);
            allDirectories.put(Recording.STATE_PROCESSED, listedDirectories);
        }

        return allDirectories;
    }

    public void updateMetaParams(List<String> recordIDs, Map<String,String> metaParams) {
        // Define the directories used to lookup the recording
        List<String> states = new ArrayList<>();
        states.add(Recording.STATE_PUBLISHED);
        states.add(Recording.STATE_UNPUBLISHED);
        states.add(Recording.STATE_DELETED);

        // Gather all the existent directories based on the states defined for the lookup
        Map<String, List<File>> allDirectories = getAllDirectories(states);

        // Retrieve the actual recording from the directories gathered for the lookup
        for (String recordID : recordIDs) {
            for (Map.Entry<String, List<File>> entry : allDirectories.entrySet()) {
                List<File> recs = getRecordingsForPath(recordID, entry.getValue());

                // Go through all recordings of all formats
                for (File rec : recs) {
                    File metadataXml = recordingServiceHelper.getMetadataXmlLocation(rec.getPath());
                    updateRecordingMetadata(metadataXml, metaParams, metadataXml);
                }
            }
        }
    }

    public void updateRecordingMetadata(File srxMetadataXml, Map<String,String> metaParams, File destMetadataXml) {
        RecordingMetadata rec = recordingServiceHelper.getRecordingMetadata(srxMetadataXml);

        Map<String, String> recMeta = rec.getMeta();

        if (rec != null && !recMeta.isEmpty()) {
            for (Map.Entry<String,String> meta : metaParams.entrySet()) {
                if ( !"""".equals(meta.getValue()) ) {
                    // As it has a value, if the meta parameter exists update it, otherwise add it
                    recMeta.put(meta.getKey(), meta.getValue());
                } else {
                    // As it doesn't have a value, if it exists delete it
                    if ( recMeta.containsKey(meta.getKey()) ) {
                        recMeta.remove(meta.getKey());
                    }
                }
            }

            rec.setMeta(recMeta);

            // Process the changes by saving the recording into metadata.xml
            recordingServiceHelper.saveRecordingMetadata(destMetadataXml, rec);
        }
    }


    private Map<String,File> indexRecordings(List<File> recs) {
        Map<String,File> indexedRecs = new HashMap<>();

        Iterator<File> iterator = recs.iterator();
        while (iterator.hasNext()) {
            File rec = iterator.next();
            indexedRecs.put(rec.getName(), rec);
        }

        return indexedRecs;
    }

    private String getDestinationBaseDirectoryName(String state) {
        return getDestinationBaseDirectoryName(state, false);
    }

    private String getDestinationBaseDirectoryName(String state, boolean forceDefault) {
        String baseDir = null;

        if ( state.equals(Recording.STATE_PROCESSING) || state.equals(Recording.STATE_PROCESSED) )
            baseDir = processDir;
        else if ( state.equals(Recording.STATE_PUBLISHED) )
            baseDir = publishedDir;
        else if ( state.equals(Recording.STATE_UNPUBLISHED) )
            baseDir = unpublishedDir;
        else if ( state.equals(Recording.STATE_DELETED) )
            baseDir = deletedDir;
        else if ( forceDefault )
            baseDir = publishedDir;

        return baseDir;
    }

    public String getCaptionTrackInboxDir() {
        return captionsDir + File.separatorChar + ""inbox"";
    }

    public String getCaptionsDir() {
        return captionsDir;
    }

    public String getCaptionFileUrlDirectory() {
        return defaultTextTrackUrl + ""/textTrack/"";
    }

}
"
bbb-common-web/src/main/java/org/bigbluebutton/api/service/impl/RecordingServiceDbImpl.java,"package org.bigbluebutton.api.service.impl;

import org.bigbluebutton.api.RecordingService;
import org.bigbluebutton.api.messaging.messages.MakePresentationDownloadableMsg;
import org.bigbluebutton.api.model.entity.Metadata;
import org.bigbluebutton.api.model.entity.Recording;
import org.bigbluebutton.api.service.XmlService;
import org.bigbluebutton.api.util.DataStore;
import org.bigbluebutton.api.util.RecordingMetadataReaderHelper;
import org.bigbluebutton.api2.domain.UploadedTrack;

import java.io.File;
import java.util.*;
import java.util.stream.Stream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.data.domain.*;

public class RecordingServiceDbImpl implements RecordingService {

    private static final Logger logger = LoggerFactory.getLogger(RecordingServiceDbImpl.class);

    private String processDir = ""/var/bigbluebutton/recording/process"";
    private String publishedDir = ""/var/bigbluebutton/published"";
    private String unpublishedDir = ""/var/bigbluebutton/unpublished"";
    private String deletedDir = ""/var/bigbluebutton/deleted"";

    private RecordingMetadataReaderHelper recordingServiceHelper;
    private String recordStatusDir;
    private String captionsDir;
    private Boolean allowFetchAllRecordings;
    private String presentationBaseDir;
    private String defaultServerUrl;
    private String defaultTextTrackUrl;

    private DataStore dataStore;
    private XmlService xmlService;

    public RecordingServiceDbImpl() {
        dataStore = DataStore.getInstance();
    }

    @Override
    public Boolean validateTextTrackSingleUseToken(String recordId, String caption, String token) {
        return null;
    }

    @Override
    public String getRecordingTextTracks(String recordId) {
        return null;
    }

    @Override
    public String putRecordingTextTrack(UploadedTrack track) {
        return null;
    }

    @Override
    public String getCaptionTrackInboxDir() {
        return null;
    }

    @Override
    public String getCaptionsDir() {
        return null;
    }

    @Override
    public boolean isRecordingExist(String recordId) {
        return dataStore.findRecordingByRecordId(recordId) != null;
    }

    @Override
    public String getRecordings2x(List<String> idList, List<String> states, Map<String, String> metadataFilters, int offset, Pageable pageable) {
        // If no IDs or limit were provided return no recordings instead of every recording
        if((idList == null || idList.isEmpty()) && pageable == null && !allowFetchAllRecordings) return xmlService.noRecordings();

        logger.info(""Retrieving all recordings"");
        Set<Recording> recordings = new HashSet<>(dataStore.findAll(Recording.class));
        logger.info(""{} recordings found"", recordings.size());

        if(idList != null && !idList.isEmpty()) {
            Set<Recording> recordingsById = new HashSet<>();

            for(String id: idList) {
                logger.info(""Finding recordings using meeting ID with value {}"", id);
                List<Recording> recordingsByMeetingId = dataStore.findRecordingsByMeetingId(id);

                if(recordingsByMeetingId == null || recordingsByMeetingId.isEmpty()) {
                    logger.info(""Finding recordings using recording ID with value {}"", id);
                    Recording recording = dataStore.findRecordingByRecordId(id);
                    if(recording != null) {
                        logger.info(""Recording found"");
                        recordingsById.add(recording);
                    }
                } else {
                    logger.info(""{} recordings found"", recordingsByMeetingId.size());
                    recordingsById.addAll(recordingsByMeetingId);
                }
            }

            logger.info(""Filtering recordings by ID"");
            recordings.retainAll(recordingsById);
            logger.info(""{} recordings remain"", recordings.size());
        }

        if(states != null && !states.isEmpty()) {
            Set<Recording> recordingsByState = new HashSet<>();

            for(String state: states) {
                logger.info(""Finding recordings by state {}"", state);
                List<Recording> r = dataStore.findRecordingsByState(state);
                if(state != null && !state.isEmpty()) {
                    logger.info(""{} recordings found"", r.size());
                    recordingsByState.addAll(r);
                }
            }

            logger.info(""Filtering recordings by state"");
            recordings.retainAll(recordingsByState);
            logger.info(""{} recordings remain"", recordings.size());
        }

        if(metadataFilters != null && !metadataFilters.isEmpty()) {
            List<Metadata> metadata = new ArrayList<>();

            for(Map.Entry<String, String> filter: metadataFilters.entrySet()) {
                logger.info(""Finding metadata using filter {} {}"", filter.getKey(), filter.getValue());
                List<Metadata> metadataByFilter = dataStore.findMetadataByFilter(filter.getKey(), filter.getValue());
                if(metadataByFilter != null) {
                    logger.info(""{} metadata found"", metadataByFilter.size());
                    metadata.addAll(metadataByFilter);
                }
            }

            Set<Recording> recordingsByMetadata = new HashSet<>();
            for(Metadata m: metadata) recordingsByMetadata.add(m.getRecording());

            logger.info(""Filtering recordings by metadata"");
            recordings.retainAll(recordingsByMetadata);
            logger.info(""{} recordings remain"", recordings.size());
        }

        // If no/invalid pagination parameters were given do not paginate the response
        if(pageable == null) {
            String recordingsXml = xmlService.recordingsToXml(recordings);
            return xmlService.constructResponseFromRecordingsXml(recordingsXml);
        }

        Page<Recording> recordingsPage = listToPage(new ArrayList<>(recordings), offset, pageable);
        String recordingsXml = xmlService.recordingsToXml(recordingsPage.getContent());
        String response = xmlService.constructResponseFromRecordingsXml(recordingsXml);

        return xmlService.constructPaginatedResponse(recordingsPage, offset, response);
    }

    @Override
    public boolean existAnyRecording(List<String> idList) {
        for(String id: idList) {
            if(dataStore.findRecordingByRecordId(id) != null) return true;
        }
        return false;
    }

    @Override
    public boolean changeState(String recordingId, String state) {
        if(Stream.of(Recording.State.values()).anyMatch(x -> x.getValue().equals(state))) {
            Recording recording = dataStore.findRecordingByRecordId(recordingId);
            if(recording != null) {
                recording.setState(state);
                dataStore.save(recording);
                return true;
            } else {
                logger.error(""A recording with ID {} does not exist"", recordingId);
            }
        } else {
            logger.error(""State [{}] is not a valid state"", state);
        }
        return false;
    }

    @Override
    public void updateMetaParams(List<String> recordIDs, Map<String, String> metaParams) {
        Set<Recording> recordings = new HashSet<>();
        for(String id: recordIDs) {
            Recording recording = dataStore.findRecordingByRecordId(id);
            if(recording != null) recordings.add(recording);
        }

        for(Recording recording: recordings) {
            Set<Metadata> metadata = recording.getMetadata();

            for(Map.Entry<String, String> entry: metaParams.entrySet()) {
                for(Metadata m: metadata) {
                    if(m.getKey().equals(entry.getKey())) {
                        m.setValue(entry.getValue());
                    } else {
                        Metadata newParam = new Metadata();
                        newParam.setKey(entry.getKey());
                        newParam.setValue(entry.getValue());
                        newParam.setRecording(recording);
                        recording.addMetadata(newParam);
                    }
                }
            }

            dataStore.save(recording);
        }
    }

    @Override
    public void startIngestAndProcessing(String meetingId) {

    }

    @Override
    public void markAsEnded(String meetingId) {

    }

    @Override
    public void kickOffRecordingChapterBreak(String meetingId, Long timestamp) {

    }

    @Override
    public void processMakePresentationDownloadableMsg(MakePresentationDownloadableMsg msg) {

    }

    @Override
    public File getDownloadablePresentationFile(String meetingId, String presId, String presFilename) {
        return null;
    }

    public void setRecordingStatusDir(String dir) {
        recordStatusDir = dir;
    }

    public void setUnpublishedDir(String dir) {
        unpublishedDir = dir;
    }

    public void setPresentationBaseDir(String dir) {
        presentationBaseDir = dir;
    }

    public void setDefaultServerUrl(String url) {
        defaultServerUrl = url;
    }

    public void setDefaultTextTrackUrl(String url) {
        defaultTextTrackUrl = url;
    }

    public void setPublishedDir(String dir) {
        publishedDir = dir;
    }

    public void setCaptionsDir(String dir) {
        captionsDir = dir;
    }

    public void setAllowFetchAllRecordings(Boolean allowFetchAllRecordings) {
        this.allowFetchAllRecordings = allowFetchAllRecordings;
    }

    public void setRecordingServiceHelper(RecordingMetadataReaderHelper r) {
        recordingServiceHelper = r;
    }

    public void setXmlService(XmlService xmlService) { this.xmlService = xmlService; }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/service/SessionService.java,"package org.bigbluebutton.api.service;

import org.bigbluebutton.api.MeetingService;
import org.bigbluebutton.api.domain.UserSession;

public class SessionService {

    private String sessionToken;
    private UserSession userSession;
    private MeetingService meetingService;

    public SessionService() {
        meetingService = ServiceUtils.getMeetingService();
    }

    public void setSessionToken(String sessionToken) {
        this.sessionToken = sessionToken;
        getUserSessionWithToken();
    }

    public String getSessionToken() { return sessionToken; }

    private void getUserSessionWithToken() {
        if(sessionToken != null) {
            userSession = meetingService.getUserSessionWithAuthToken(sessionToken);
        }
    }

    public String getMeetingID() {
        if(userSession != null) {
            return userSession.meetingID;
        }
        return """";
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api/service/ServiceUtils.java,"package org.bigbluebutton.api.service;

import org.bigbluebutton.api.MeetingService;
import org.bigbluebutton.api.ParamsProcessorUtil;
import org.bigbluebutton.api.domain.Meeting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ServiceUtils {

    private static Logger log = LoggerFactory.getLogger(ServiceUtils.class);

    private static MeetingService meetingService;
    private static ValidationService validationService;

    public void setMeetingService(MeetingService meetingService) { this.meetingService = meetingService; }
    public static MeetingService getMeetingService() { return meetingService; }

    public void setValidationService(ValidationService validationService) { this.validationService = validationService; }
    public static ValidationService getValidationService() { return validationService; }

    public static Meeting findMeetingFromMeetingID(String meetingID) {
        log.info(""Attempting to find meeting with ID {}"", meetingID);
        Meeting meeting = meetingService.getMeeting(meetingID);

        if(meeting == null) {
            log.info(""Meeting with ID {} could not be found"", meetingID);
            log.info(""Provided ID {} may be an external ID converting to an internal ID"", meetingID);

            ParamsProcessorUtil paramsProcessorUtil = new ParamsProcessorUtil();
            String internalMeetingID = paramsProcessorUtil.convertToInternalMeetingId(meetingID);
            log.info(""Provided ID {} converted to internal ID {}"", meetingID, internalMeetingID);

            meeting = meetingService.getMeeting(internalMeetingID);
        }

        return meeting;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/common/messages/BbbAppsIsAliveMessage.java,"package org.bigbluebutton.common.messages;

import java.util.HashMap;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

public class BbbAppsIsAliveMessage {
	public static final String BBB_APPS_IS_ALIVE = ""bbb_apps_is_alive_message"";
	public static final String VERSION = ""0.0.1"";

	public static final String TIMESTAMP = ""timestamp"";	
	public static final String STARTED_ON = ""started_on"";
	
	public final Long timestamp;
	public final Long startedOn;

	public BbbAppsIsAliveMessage(Long startedOn, Long timestamp) {
		this.startedOn = startedOn;
		this.timestamp = timestamp;
	}

	public String toJson() {
		HashMap<String, Object> payload = new HashMap<>();
		payload.put(TIMESTAMP, timestamp);
		payload.put(STARTED_ON, timestamp);
		
		java.util.HashMap<String, Object> header = MessageBuilder.buildHeader(BBB_APPS_IS_ALIVE, VERSION, null);
		return MessageBuilder.buildJson(header, payload);
	}

	public static BbbAppsIsAliveMessage fromJson(String message) {
		JsonParser parser = new JsonParser();
		JsonObject obj = (JsonObject) parser.parse(message);
		if (obj.has(""header"") && obj.has(""payload"")) {
			JsonObject header = (JsonObject) obj.get(""header"");
			JsonObject payload = (JsonObject) obj.get(""payload"");

			if (header.has(""name"")) {
				String messageName = header.get(""name"").getAsString();
				if (BBB_APPS_IS_ALIVE.equals(messageName)) {

					if (payload.has(TIMESTAMP) && payload.has(STARTED_ON)) {
						Long timestamp = payload.get(TIMESTAMP).getAsLong();
						Long startedOn = payload.get(STARTED_ON).getAsLong();
						return new BbbAppsIsAliveMessage(startedOn, timestamp);
					}
				}
			}
		}
		return null;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/common/messages/MessageBuilder.java,"package org.bigbluebutton.common.messages;

import java.util.concurrent.TimeUnit;

import org.apache.commons.lang3.StringUtils;

import com.google.gson.Gson;

public class MessageBuilder {
  public final static String VERSION = ""version"";
  public static final String NAME                            = ""name"";
  public static final String HEADER                          = ""header"";
  public static final String PAYLOAD                         = ""payload"";
  public static final String TIMESTAMP                       = ""timestamp"";
  public static final String REPLY_TO                        = ""reply_to"";
  
  public static long generateTimestamp() {
    return TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
  }
  
  public static java.util.HashMap<String, Object> buildHeader(String name, String version, String replyTo) {
  	java.util.HashMap<String, Object> header = new java.util.HashMap<String, Object>();
    header.put(NAME, name);
    header.put(VERSION, version);
    header.put(TIMESTAMP, generateTimestamp());
    if (!StringUtils.isEmpty(replyTo))
      header.put(REPLY_TO, replyTo);
    
    return header;
  }
  
  
  public static String buildJson(java.util.HashMap<String, Object> header, 
  		java.util.HashMap<String, Object> payload) {
    
  	java.util.HashMap<String, java.util.HashMap<String, Object>> message = new java.util.HashMap<String, java.util.HashMap<String, Object>>();
    message.put(HEADER, header);
    message.put(PAYLOAD, payload);
    
    Gson gson = new Gson();
    return gson.toJson(message);
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api2/IMeetingService.java,"package org.bigbluebutton.api2;

import java.util.Collection;
import java.util.Map;

import org.bigbluebutton.api.domain.Meeting;
import org.bigbluebutton.api.domain.UserSession;
import org.bigbluebutton.api.messaging.messages.UserJoinedVoice;
import org.bigbluebutton.api.messaging.messages.UserLeftVoice;
import org.bigbluebutton.api.messaging.messages.UserListeningOnly;
import org.bigbluebutton.api.messaging.messages.UserSharedWebcam;
import org.bigbluebutton.api.messaging.messages.UserUnsharedWebcam;

public interface IMeetingService {
  void addUserSession(String token, UserSession user);
  void registerUser(String meetingID, String internalUserId,
                    String fullname, String role, String externUserID,
                    String authToken, String avatarURL, Boolean guest, Boolean authed);
  UserSession getUserSession(String token);
  UserSession removeUserSession(String token);
  void purgeRegisteredUsers();
  Collection<Meeting> getMeetings();
  Collection<UserSession> getSessions();
  boolean createMeeting(Meeting m);
  Meeting getMeeting(String meetingId);
  Collection<Meeting> getMeetingsWithId(String meetingId);
  Meeting getNotEndedMeetingWithId(String meetingId);



  boolean isMeetingWithVoiceBridgeExist(String voiceBridge);
  void send(String channel, String message);
  void endMeeting(String meetingId);
  void addUserCustomData(String meetingId, String userID,
                         Map<String, String> userCustomData);
  void userJoinedVoice(UserJoinedVoice message);
  void userLeftVoice(UserLeftVoice message);
  void userListeningOnly(UserListeningOnly message);
  void userSharedWebcam(UserSharedWebcam message);
  void userUnsharedWebcam(UserUnsharedWebcam message);


}"
bbb-common-web/src/main/java/org/bigbluebutton/api2/IRecordingService.java,"package org.bigbluebutton.api2;

import java.util.List;
import java.util.Map;

import org.bigbluebutton.api.domain.Recording;
import org.bigbluebutton.api.domain.RecordingMetadata;

public interface IRecordingService {
  List<RecordingMetadata> getRecordingsMetadata(List<String> idList, List<String> states);
  Map<String, Recording> getRecordings(List<String> idList, List<String> states);
  List<RecordingMetadata> filterRecordingsByMetadata(List<RecordingMetadata> recsList,
                                                     Map<String, String> metadataFilters);
  Map<String, Recording> filterRecordingsByMetadata(Map<String, Recording> recordings,
                                                    Map<String, String> metadataFilters);
  Map<String, Recording> reorderRecordings(List<Recording> olds);
  boolean existsAnyRecording(List<String> idList);
  void setPublishRecording(List<String> idList, boolean publish);
  void deleteRecordings(List<String> idList);

  void updateRecordings(List<String> idList, Map<String, String> metaParams);
  void processRecording(String meetingId);
}"
bbb-common-web/src/main/java/org/bigbluebutton/api2/RecordingServiceGW.java,"package org.bigbluebutton.api2;

import java.io.File;
import java.util.ArrayList;

import org.bigbluebutton.api.domain.RecordingMetadata;
import org.bigbluebutton.api2.domain.UploadedTrack;

import scala.Option;

public interface RecordingServiceGW {

  String getRecordings2x(ArrayList<RecordingMetadata> recs);
  Option<RecordingMetadata> getRecordingMetadata(File xml);
  boolean saveRecordingMetadata(File xml, RecordingMetadata metadata);
  boolean validateTextTrackSingleUseToken(String recordId, String caption, String token);
  String getRecordingTextTracks(String recordId, String captionsDir, String captionBasUrl);
  String putRecordingTextTrack(UploadedTrack track);
}"
bbb-common-web/src/main/java/org/bigbluebutton/api2/IBbbWebApiGWApp.java,"package org.bigbluebutton.api2;

import java.util.ArrayList;
import java.util.Map;

import org.bigbluebutton.api.domain.BreakoutRoomsParams;
import org.bigbluebutton.api.domain.LockSettingsParams;
import org.bigbluebutton.api.domain.Group;
import org.bigbluebutton.api.messaging.converters.messages.DestroyMeetingMessage;
import org.bigbluebutton.api.messaging.converters.messages.EndMeetingMessage;
import org.bigbluebutton.api.messaging.converters.messages.PublishedRecordingMessage;
import org.bigbluebutton.api.messaging.converters.messages.UnpublishedRecordingMessage;
import org.bigbluebutton.api.messaging.converters.messages.DeletedRecordingMessage;
import org.bigbluebutton.presentation.messages.IDocConversionMsg;

public interface IBbbWebApiGWApp {
  void send(String channel, String message);
  void createMeeting(String meetingID, String externalMeetingID,
                     String parentMeetingID, String meetingName, Boolean recorded,
                     String voiceBridge, Integer duration, Boolean autoStartRecording,
                     Boolean allowStartStopRecording, Boolean webcamsOnlyForModerator,
                     Integer meetingCameraCap,
                     Integer userCameraCap,
                     Integer maxPinnedCameras,
                     String moderatorPass, String viewerPass, String learningDashboardAccessToken, Long createTime,
                     String createDate, Boolean isBreakout, Integer sequence, Boolean freejoin, Map<String, String> metadata,
                     String guestPolicy, Boolean authenticatedGuest, String meetingLayout, String welcomeMsgTemplate, String welcomeMsg, String modOnlyMessage,
                     String dialNumber, Integer maxUsers, Integer maxUserConcurrentAccesses,
                     Integer meetingExpireIfNoUserJoinedInMinutes,
                     Integer meetingExpireWhenLastUserLeftInMinutes,
                     Integer userInactivityInspectTimerInMinutes,
                     Integer userInactivityThresholdInMinutes,
                     Integer userActivitySignResponseDelayInMinutes,
                     Boolean endWhenNoModerator,
                     Integer endWhenNoModeratorDelayInMinutes,
                     Boolean muteOnStart,
                     Boolean allowModsToUnmuteUsers,
                     Boolean allowModsToEjectCameras,
                     Boolean keepEvents,
                     BreakoutRoomsParams breakoutParams,
                     LockSettingsParams lockSettingsParams,
                     Integer html5InstanceId,
                     ArrayList<Group> groups,
                     ArrayList<String> disabledFeatures,
                     Boolean notifyRecordingIsOn,
                     String presentationUploadExternalDescription,
                     String presentationUploadExternalUrl);

  void registerUser(String meetingID, String internalUserId, String fullname, String role,
                    String externUserID, String authToken, String sessionToken, String avatarURL,
                    Boolean guest, Boolean authed, String guestStatus, Boolean excludeFromDashboard);
  void guestWaitingLeft(String meetingID, String internalUserId);

  void destroyMeeting(DestroyMeetingMessage msg);
  void endMeeting(EndMeetingMessage msg);
  void sendKeepAlive(String system, Long bbbWebTimestamp, Long akkaAppsTimestamp);
  void publishedRecording(PublishedRecordingMessage msg);
  void unpublishedRecording(UnpublishedRecordingMessage msg);
  void deletedRecording(DeletedRecordingMessage msg);
  void sendDocConversionMsg(IDocConversionMsg msg);
}"
bbb-common-web/src/main/java/org/bigbluebutton/api2/domain/VoiceProp2.java,"package org.bigbluebutton.api2.domain;


public class VoiceProp2 {
    public final String telVoice;
    public final String webVoice;
    public final String dialNumber;

    public VoiceProp2(String telVoice,
                      String webVoice,
                      String dialNumber) {
        this.telVoice = telVoice;
        this.webVoice = webVoice;
        this.dialNumber = dialNumber;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api2/domain/MeetingProp2.java,"package org.bigbluebutton.api2.domain;


public class MeetingProp2 {
    public final String name;
    public final String extId;
    public final String intId;
    public final int meetingCameraCap;
    public final int maxPinnedCameras;
    public final String parentId;
    public final Integer sequence;
    public final Boolean isBreakout;

    public MeetingProp2(String name,
                        String extId,
                        String intId,
                        int meetingCameraCap,
                        int maxPinnedCameras,
                        String parentId,
                        Integer sequence,
                        Boolean isBreakout) {
        this.name = name;
        this.extId = extId;
        this.intId = intId;
        this.meetingCameraCap = meetingCameraCap;
        this.maxPinnedCameras = maxPinnedCameras;
        this.parentId = parentId;
        this.sequence = sequence;
        this.isBreakout = isBreakout;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api2/domain/WelcomeProp2.java,"package org.bigbluebutton.api2.domain;

public class WelcomeProp2 {
    public final String welcomeMsgTemplate;
    public final String welcomeMsg;
    public final String modOnlyMessage;

    public WelcomeProp2(String welcomeMsgTemplate,
                        String welcomeMsg,
                        String modOnlyMessage) {
        this.welcomeMsgTemplate = welcomeMsgTemplate;
        this.welcomeMsg = welcomeMsg;
        this.modOnlyMessage = modOnlyMessage;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api2/domain/DurationProp2.java,"package org.bigbluebutton.api2.domain;


public class DurationProp2 {
    public final Integer duration;
    public final long createdTime;
    public final long startTime;
    public final long endTime;

    public DurationProp2(Integer duration,
                         long createdTime,
                         long startTime,
                         long endTime) {
        this.duration = duration;
        this.startTime = startTime;
        this.createdTime = createdTime;
        this.endTime = endTime;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api2/domain/Meeting2.java,"package org.bigbluebutton.api2.domain;


import java.util.List;
import java.util.Map;


public class Meeting2 {

    public final MeetingProp2 props;
    public final DurationProp2 durationProp;
    public final RecordProp2 recordProp;
    public final WelcomeProp2 welcomeProp;
    public final VoiceProp2 voiceProp;
    public final PasswordProp2 passwordProp;
    public final UsersProp2 usersProp;
    public final boolean forciblyEnded;
    public final String logoutUrl;
    public final String defaultAvatarURL;
    public final Map<String, String> metadata;
    public final List<String> breakoutRooms;

    public Meeting2(MeetingProp2 props,
            DurationProp2 durationProp,
            RecordProp2 recordProp,
            WelcomeProp2 welcomeProp,
            VoiceProp2 voiceProp,
            PasswordProp2 passwordProp,
            UsersProp2 usersProp,
            boolean forciblyEnded,
            String logoutUrl,
            String defaultAvatarURL,
            Map<String, String> metadata,
            List<String> breakoutRooms) {
        this.props = props;
        this.durationProp = durationProp;
        this.recordProp = recordProp;
        this.welcomeProp = welcomeProp;
        this.voiceProp = voiceProp;
        this.passwordProp = passwordProp;
        this.usersProp = usersProp;
        this.forciblyEnded = forciblyEnded;
        this.logoutUrl = logoutUrl;
        this.defaultAvatarURL = defaultAvatarURL;
        this.metadata = metadata;
        this.breakoutRooms = breakoutRooms;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api2/domain/UsersProp2.java,"package org.bigbluebutton.api2.domain;


import java.util.Map;

public class UsersProp2 {
    public final String guestPolicy;
    public final String meetingLayout;
    public final boolean authenticatedGuest;
    public final boolean userHasJoined;
    public final boolean webcamsOnlyForModerator;
    public final int userCameraCap;
    public final int maxUsers;
    public final Map<String, String> userCustomData;
    public final Map<String, User2> users;
    public final Map<String, Long> registeredUsers;

    public UsersProp2(int maxUsers,
                      boolean webcamsOnlyForModerator,
                      int userCameraCap,
                      String guestPolicy,
                      String meetingLayout,
                      boolean authenticatedGuest,
                      boolean userHasJoined,
                      Map<String, String> userCustomData,
                      Map<String, User2> users,
                      Map<String, Long> registeredUsers) {
        this.maxUsers = maxUsers;
        this.webcamsOnlyForModerator = webcamsOnlyForModerator;
        this.userCameraCap = userCameraCap;
        this.guestPolicy = guestPolicy;
        this.meetingLayout = meetingLayout;
        this.authenticatedGuest = authenticatedGuest;
        this.userHasJoined = userHasJoined;
        this.userCustomData = userCustomData;
        this.users = users;
        this.registeredUsers = registeredUsers;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api2/domain/PasswordProp2.java,"package org.bigbluebutton.api2.domain;

public class PasswordProp2 {
    public final String moderatorPass;
    public final String viewerPass;

    public PasswordProp2(String moderatorPass,
                         String viewerPass) {
        this.moderatorPass = moderatorPass;
        this.viewerPass = viewerPass;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/api2/domain/RecordProp2.java,"package org.bigbluebutton.api2.domain;


public class RecordProp2 {
    public final boolean record;
    public final boolean autoStartRecording;
    public final boolean allowStartStopRecording;

    public RecordProp2(boolean record,
                       boolean autoStartRecording,
                       boolean allowStartStopRecording) {
        this.record = record;
        this.autoStartRecording = autoStartRecording;
        this.allowStartStopRecording = allowStartStopRecording;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/SupportedDocumentFilter.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */

package org.bigbluebutton.presentation;

import java.io.File;

import org.apache.commons.io.FilenameUtils;
import org.bigbluebutton.api2.IBbbWebApiGWApp;
import org.bigbluebutton.presentation.messages.DocConversionProgress;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SupportedDocumentFilter {
  private static Logger log = LoggerFactory.getLogger(SupportedDocumentFilter.class);

  private final IBbbWebApiGWApp gw;

  public SupportedDocumentFilter(IBbbWebApiGWApp m) {
    gw = m;
  }

  public boolean isSupported(UploadedPresentation pres) {
    File presentationFile = pres.getUploadedFile();

    /* Get file extension - Perhaps try to rely on a more accurate method than an extension type ? */
    String extension = FilenameUtils.getExtension(presentationFile.getName());
    boolean supported = SupportedFileTypes.isFileSupported(extension);
    notifyProgressListener(supported, pres);
    if (supported) {
      log.info(""Received supported file {}"", pres.getUploadedFile().getAbsolutePath());
      pres.setFileType(extension);
    } else {
      log.warn(""Received not supported file {}"", pres.getUploadedFile().getAbsolutePath());
    }
    return supported;
  }

  private void notifyProgressListener(boolean supported, UploadedPresentation pres) {
    String msgKey = ConversionMessageConstants.SUPPORTED_DOCUMENT_KEY;

    if (!supported) {
        msgKey = ConversionMessageConstants.UNSUPPORTED_DOCUMENT_KEY;
    }

    if (gw != null) {
      DocConversionProgress progress = new DocConversionProgress(pres.getPodId(), pres.getMeetingId(),
        pres.getId(), pres.getId(),
        pres.getName(), ""notUsedYet"", ""notUsedYet"",
        pres.isDownloadable(), pres.isRemovable(),  msgKey, pres.getTemporaryPresentationId());

      gw.sendDocConversionMsg(progress);

    } else {
      log.warn(""MessagingService has not been set!"");
    }
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/UploadedPresentation.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

import java.io.File;
import java.util.ArrayList;

public final class UploadedPresentation {
  private final String podId;
  private final String meetingId;
  private final String id;
  private final String temporaryPresentationId;
  private final String name;
  private final boolean uploadFailed;
  private final ArrayList<String> uploadFailReason;
  private File uploadedFile;
  private String fileType = ""unknown"";
  private int numberOfPages = 0;
  private String conversionStatus;
  private final String baseUrl;
  private boolean isDownloadable = false;
  private boolean isRemovable = true;
  private boolean current = false;
  private String authzToken;
  private boolean conversionStarted = false;


  public UploadedPresentation(String podId,
                              String meetingId,
                              String id,
                              String temporaryPresentationId,
                              String name,
                              String baseUrl,
                              Boolean current,
                              String authzToken,
                              Boolean uploadFailed,
                              ArrayList<String> uploadFailReason) {
    this.podId = podId;
    this.meetingId = meetingId;
    this.id = id;
    this.temporaryPresentationId = temporaryPresentationId;
    this.name = name;
    this.baseUrl = baseUrl;
    this.isDownloadable = false;
    this.current = current;
    this.authzToken = authzToken;
    this.uploadFailed = uploadFailed;
    this.uploadFailReason = uploadFailReason;
  }

  public UploadedPresentation(String podId,
                              String meetingId,
                              String id,
                              String name,
                              String baseUrl,
                              Boolean current,
                              String authzToken,
                              Boolean uploadFailed,
                              ArrayList<String> uploadFailReason) {
    this(podId, meetingId, id, """", name, baseUrl,
            current, authzToken, uploadFailed, uploadFailReason);
  }

  public File getUploadedFile() {
    return uploadedFile;
  }

  public void setUploadedFile(File uploadedFile) {
    this.uploadedFile = uploadedFile;
  }

  public String getMeetingId() {
    return meetingId;
  }

  public String getPodId() {
    return podId;
  }

  public String getId() {
    return id;
  }

  public String getTemporaryPresentationId() {
    return temporaryPresentationId;
  }

  public String getName() {
    return name;
  }

  public String getBaseUrl() {
    return baseUrl;
  }

  public String getFileType() {
    return fileType;
  }

  public void setFileType(String fileType) {
    this.fileType = fileType;
  }

  public int getNumberOfPages() {
    return numberOfPages;
  }

  public void setNumberOfPages(int numberOfPages) {
    this.numberOfPages = numberOfPages;
  }

  public String getConversionStatus() {
    return conversionStatus;
  }

  public void setConversionStatus(String conversionStatus) {
    this.conversionStatus = conversionStatus;
  }

  public boolean isDownloadable() {
    return isDownloadable;
  }

  public void setDownloadable() {
    this.isDownloadable = true;
  }

  public boolean isRemovable() {
    return isRemovable;
  }

  public void setRemovable(boolean removable) {
    isRemovable = removable;
  }

  public boolean isCurrent() {
    return current;
  }

  public void setCurrent(Boolean value) {
    this.current = value;
  }

  public String getAuthzToken() {
    return authzToken;
  }

  public void startConversion() {
    conversionStarted = true;
  }

  public boolean isConversionStarted() {
    return conversionStarted;
  }

  public boolean isUploadFailed() {
    return uploadFailed;
  }

  public ArrayList<String> getUploadFailReason() {
    return uploadFailReason;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/GeneratedSlidesInfoHelper.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

public interface GeneratedSlidesInfoHelper {
	String generateUploadedPresentationInfo(UploadedPresentation pres);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/DocumentConversionServiceImp.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

import java.io.File;
import java.util.HashMap;
import java.util.Map;
import org.bigbluebutton.api2.IBbbWebApiGWApp;
import org.bigbluebutton.presentation.imp.*;
import org.bigbluebutton.presentation.messages.DocConversionRequestReceived;
import org.bigbluebutton.presentation.messages.DocInvalidMimeType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.google.gson.Gson;

import static org.bigbluebutton.presentation.Util.deleteDirectoryFromFileHandlingErrors;

public class DocumentConversionServiceImp implements DocumentConversionService {
  private static Logger log = LoggerFactory.getLogger(DocumentConversionServiceImp.class);

  private IBbbWebApiGWApp gw;
  private OfficeToPdfConversionService officeToPdfConversionService;
  private SlidesGenerationProgressNotifier notifier;

  private PresentationFileProcessor presentationFileProcessor;

  public void processDocument(UploadedPresentation pres) {
    if (pres.isUploadFailed()) {
      // We should send a message to the client in the future.
      // ralam may 1, 2020
      log.error(""Presentation upload failed for meetingId={} presId={}"", pres.getMeetingId(), pres.getId());
      log.error(""Presentation upload fail reasons {}"", pres.getUploadFailReason());
      return;
    }

    sendDocConversionRequestReceived(pres);

    processDocumentStart(pres);
  }

  public void processDocumentStart(UploadedPresentation pres) {
    SupportedDocumentFilter sdf = new SupportedDocumentFilter(gw);
    if (sdf.isSupported(pres)) {
      String fileType = pres.getFileType();

      if (SupportedFileTypes.isOfficeFile(fileType)) {
        pres = officeToPdfConversionService.convertOfficeToPdf(pres);
        OfficeToPdfConversionSuccessFilter ocsf = new OfficeToPdfConversionSuccessFilter(gw);
        if (ocsf.didConversionSucceed(pres)) {
          ocsf.sendProgress(pres);
          // Successfully converted to pdf. Call the process again, this time it
          // should be handled by
          // the PDF conversion service.
          processDocumentStart(pres);
        } else {
          // Send notification that office to pdf conversion failed.
          // The cause should have been set by the previous step.
          // (ralam feb 15, 2020)
          ocsf.sendProgress(pres);
        }
      } else if (SupportedFileTypes.isPdfFile(fileType)) {
        presentationFileProcessor.process(pres);
      } else if (SupportedFileTypes.isImageFile(fileType)) {
        presentationFileProcessor.process(pres);
      } else {
        Map<String, Object> logData = new HashMap<String, Object>();
        logData = new HashMap<String, Object>();
        logData.put(""podId"", pres.getPodId());
        logData.put(""meetingId"", pres.getMeetingId());
        logData.put(""presId"", pres.getId());
        logData.put(""filename"", pres.getName());
        logData.put(""current"", pres.isCurrent());
        logData.put(""logCode"", ""supported_file_not_handled"");
        logData.put(""message"", ""Supported file not handled."");
        logData.put(""removable"", pres.isRemovable());

        Gson gson = new Gson();
        String logStr = gson.toJson(logData);
        log.warn("" --analytics-- data={}"", logStr);
      }

    } else {
      File presentationFile = pres.getUploadedFile();
      deleteDirectoryFromFileHandlingErrors(presentationFile);

      Map<String, Object> logData = new HashMap<String, Object>();
      logData = new HashMap<String, Object>();
      logData.put(""podId"", pres.getPodId());
      logData.put(""meetingId"", pres.getMeetingId());
      logData.put(""presId"", pres.getId());
      logData.put(""filename"", pres.getName());
      logData.put(""current"", pres.isCurrent());
      logData.put(""logCode"", ""unsupported_file_format"");
      logData.put(""message"", ""Unsupported file format"");

      Gson gson = new Gson();
      String logStr = gson.toJson(logData);
      log.error("" --analytics-- data={}"", logStr);

      logData.clear();

      logData.put(""podId"", pres.getPodId());
      logData.put(""meetingId"", pres.getMeetingId());
      logData.put(""presId"", pres.getId());
      logData.put(""filename"", pres.getName());
      logData.put(""current"", pres.isCurrent());
      logData.put(""logCode"", ""presentation_conversion_end"");
      logData.put(""message"", ""End presentation conversion."");

      logStr = gson.toJson(logData);
      log.info("" --analytics-- data={}"", logStr);

      notifier.sendConversionCompletedMessage(pres);
    }
  }

  public void sendDocConversionFailedOnMimeType(UploadedPresentation pres, String fileMime,
                                                String fileExtension) {
    notifier.sendInvalidMimeTypeMessage(pres, fileMime, fileExtension);
  }

  private void sendDocConversionRequestReceived(UploadedPresentation pres) {
      if (! pres.isConversionStarted()) {
          Map<String, Object> logData = new HashMap<String, Object>();

          logData.put(""podId"", pres.getPodId());
          logData.put(""meetingId"", pres.getMeetingId());
          logData.put(""presId"", pres.getId());
          logData.put(""filename"", pres.getName());
          logData.put(""current"", pres.isCurrent());
          logData.put(""authzToken"", pres.getAuthzToken());
          logData.put(""logCode"", ""presentation_conversion_start"");
          logData.put(""message"", ""Start presentation conversion."");
          logData.put(""isRemovable"", pres.isRemovable());

          Gson gson = new Gson();
          String logStr = gson.toJson(logData);
          log.info("" --analytics-- data={}"", logStr);

          pres.startConversion();

          DocConversionRequestReceived progress = new DocConversionRequestReceived(
                  pres.getPodId(),
                  pres.getMeetingId(),
                  pres.getId(),
                  pres.getTemporaryPresentationId(),
                  pres.getName(),
                  pres.getAuthzToken(),
                  pres.isDownloadable(),
                  pres.isRemovable(),
                  pres.isCurrent());
          notifier.sendDocConversionProgress(progress);
      }
  }

  public void setBbbWebApiGWApp(IBbbWebApiGWApp m) {
    gw = m;
  }

  public void setOfficeToPdfConversionService(OfficeToPdfConversionService s) {
    officeToPdfConversionService = s;
  }

  public void setSlidesGenerationProgressNotifier(SlidesGenerationProgressNotifier notifier) {
      this.notifier = notifier;
  }

  public void setPresentationFileProcessor(PresentationFileProcessor presentationFileProcessor) {
      this.presentationFileProcessor = presentationFileProcessor;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/TextFileCreator.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

public interface TextFileCreator {
	public boolean createTextFile(UploadedPresentation pres, int page);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/PageAnalyser.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * 
 * Copyright (c) 2015 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.bigbluebutton.presentation;

import java.io.File;

public interface PageAnalyser {
  /**
   * 
   * @param output
   *          a File to analyse
   * @return true if the file has been parsed without any error
   */
  public boolean analyse(File output);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/PdfPageDownscaler.java,"package org.bigbluebutton.presentation.imp;

import java.io.File;

public class PdfPageDownscaler {
    private static final String SPACE = "" "";

    public boolean downscale(File source,File dest) {
        String COMMAND = ""gs -sDEVICE=pdfwrite -dNOPAUSE -dQUIET -dBATCH -dFirstPage=1 -dLastPage=1 -sOutputFile=""
                + dest.getAbsolutePath() + SPACE
                + ""/etc/bigbluebutton/nopdfmark.ps"" + SPACE
                + source.getAbsolutePath();

        //System.out.println(""DOWNSCALING "" + COMMAND);

        return new ExternalProcessExecutor().exec(COMMAND, 10000);
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/BigPdfException.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2019 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation.imp;

@SuppressWarnings(""serial"")
public class BigPdfException extends Exception {
  
  private final int bigPageNumber;
  private final long bigPageSize;
  private final ExceptionType exceptionType;

  public BigPdfException(BigPdfException.ExceptionType type, int bigPageNumber, long bigPageSize) {
      super(""Exception while converting PDF that has at least one big page."");
      this.bigPageNumber = bigPageNumber;
      this.bigPageSize = bigPageSize;
      exceptionType = type;
  }

  public int getBigPageNumber() {
      return bigPageNumber;
  }

  public BigPdfException.ExceptionType getExceptionType() {
      return exceptionType;
  }

  public long getBigPageSize() {
      return bigPageSize;
  }
  
  public enum ExceptionType {
    PDF_HAS_BIG_PAGE
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/OfficeToPdfConversionService.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * 
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */
package org.bigbluebutton.presentation.imp;

import com.google.gson.Gson;
import org.bigbluebutton.presentation.ConversionMessageConstants;
import org.bigbluebutton.presentation.SupportedFileTypes;
import org.bigbluebutton.presentation.UploadedPresentation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Semaphore;

public class OfficeToPdfConversionService {
  private static Logger log = LoggerFactory.getLogger(OfficeToPdfConversionService.class);
  private OfficeDocumentValidator2 officeDocumentValidator;
  private boolean skipOfficePrecheck = false;
  private String presOfficeConversionExec = null;
  private Semaphore presOfficeConversionSemaphore = new Semaphore(4);
  private int presOfficeConversionTimeout = 60;

  /*
   * Convert the Office document to PDF. If successful, update
   * UploadPresentation.uploadedFile with the new PDF out and
   * UploadPresentation.lastStepSuccessful to TRUE.
   */
  public UploadedPresentation convertOfficeToPdf(UploadedPresentation pres) {
    initialize(pres);
    if (SupportedFileTypes.isOfficeFile(pres.getFileType())) {
      // Check if we need to precheck office document
      if (!skipOfficePrecheck && officeDocumentValidator.isValid(pres)) {
        Map<String, Object> logData = new HashMap<>();
        logData.put(""meetingId"", pres.getMeetingId());
        logData.put(""presId"", pres.getId());
        logData.put(""filename"", pres.getName());
        logData.put(""logCode"", ""problems_office_to_pdf_validation"");
        logData.put(""message"", ""Problems detected prior to converting the file to PDF."");
        Gson gson = new Gson();
        String logStr = gson.toJson(logData);
        log.warn("" --analytics-- data={}"", logStr);
        pres.setConversionStatus(ConversionMessageConstants.OFFICE_DOC_CONVERSION_INVALID_KEY);
        return pres;
      }
      File pdfOutput = setupOutputPdfFile(pres);
      if (convertOfficeDocToPdf(pres, pdfOutput)) {
        Map<String, Object> logData = new HashMap<>();
        logData.put(""meetingId"", pres.getMeetingId());
        logData.put(""presId"", pres.getId());
        logData.put(""filename"", pres.getName());
        logData.put(""logCode"", ""office_to_pdf_success"");
        logData.put(""message"", ""Successfully converted office file to pdf."");
        Gson gson = new Gson();
        String logStr = gson.toJson(logData);
        log.info("" --analytics-- data={}"", logStr);
        makePdfTheUploadedFileAndSetStepAsSuccess(pres, pdfOutput);
      } else {
        Map<String, Object> logData = new HashMap<>();
        logData.put(""meetingId"", pres.getMeetingId());
        logData.put(""presId"", pres.getId());
        logData.put(""filename"", pres.getName());
        logData.put(""logCode"", ""office_to_pdf_failed"");
        logData.put(""message"", ""Failed to convert "" + pres.getUploadedFile().getAbsolutePath() + "" to Pdf."");
        Gson gson = new Gson();
        String logStr = gson.toJson(logData);
        log.warn("" --analytics-- data={}"", logStr);
        pres.setConversionStatus(ConversionMessageConstants.OFFICE_DOC_CONVERSION_FAILED_KEY);
        return pres;
      }
    }
    return pres;
  }
  public void initialize(UploadedPresentation pres) {
    pres.setConversionStatus(ConversionMessageConstants.OFFICE_DOC_CONVERSION_FAILED_KEY);
  }
  private File setupOutputPdfFile(UploadedPresentation pres) {
    File presentationFile = pres.getUploadedFile();
    String filenameWithoutExt = presentationFile.getAbsolutePath().substring(0,
        presentationFile.getAbsolutePath().lastIndexOf('.'));
    return new File(filenameWithoutExt + "".pdf"");
  }
  private boolean convertOfficeDocToPdf(UploadedPresentation pres, File pdfOutput) {
    boolean success = false;
    int attempts = 0;
    while(!success) {

      try {
        if(presOfficeConversionSemaphore.availablePermits() == 0) {
          log.info(""Waiting for previous conversions finish before start (meetingId: {}, presId: {}, filename: {}), current queue: {}."",
                  pres.getMeetingId(), pres.getId(), pres.getName(), presOfficeConversionSemaphore.getQueueLength());
        }
        presOfficeConversionSemaphore.acquire();

        success = Office2PdfPageConverter.convert(pres.getUploadedFile(), pdfOutput, 0, pres,
                presOfficeConversionExec, presOfficeConversionTimeout);

      } catch (Exception e) {
      } finally {
        presOfficeConversionSemaphore.release();
      }

      
      if(!success) {
        if(++attempts != 3) {
          //Try again
        } else {
          break;
        }
      }
    }

    return success;
  }

  private void makePdfTheUploadedFileAndSetStepAsSuccess(UploadedPresentation pres, File pdf) {
    pres.setUploadedFile(pdf);
    pres.setConversionStatus(ConversionMessageConstants.OFFICE_DOC_CONVERSION_SUCCESS_KEY);
  }

  public void setOfficeDocumentValidator(OfficeDocumentValidator2 v) {
    officeDocumentValidator = v;
  }

  public void setSkipOfficePrecheck(boolean skipOfficePrecheck) {
    this.skipOfficePrecheck = skipOfficePrecheck;
  }

  public void setPresOfficeConversionExec(String presOfficeConversionExec) {
    this.presOfficeConversionExec = presOfficeConversionExec;
  }

  public void setPresOfficeConversionTimeout(int presOfficeConversionTimeout) {
    this.presOfficeConversionTimeout = presOfficeConversionTimeout;
  }

  public void setPresOfficeConversionMaxConcurrents(int presOfficeConversionMaxConcurrents) {
    presOfficeConversionSemaphore = new Semaphore(presOfficeConversionMaxConcurrents);
  }

}
"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/SlidesGenerationProgressNotifier.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */

package org.bigbluebutton.presentation.imp;

import org.bigbluebutton.api.messaging.messages.PresentationUploadToken;
import org.bigbluebutton.api2.IBbbWebApiGWApp;
import org.bigbluebutton.presentation.ConversionMessageConstants;
import org.bigbluebutton.presentation.GeneratedSlidesInfoHelper;
import org.bigbluebutton.presentation.UploadedPresentation;
import org.bigbluebutton.presentation.messages.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SlidesGenerationProgressNotifier {
  private static Logger log = LoggerFactory.getLogger(SlidesGenerationProgressNotifier.class);

  private IBbbWebApiGWApp messagingService;
  private int maxNumberOfAttempts = 3;
  private GeneratedSlidesInfoHelper generatedSlidesInfoHelper;


  public void sendDocConversionProgress(IDocConversionMsg msg) {
    messagingService.sendDocConversionMsg(msg);
  }

  public void sendUploadFileTooLargeMessage(PresentationUploadToken pres, int uploadedFileSize, int maxUploadFileSize) {
    UploadFileTooLargeMessage progress = new UploadFileTooLargeMessage(
            pres.podId,
            pres.meetingId,
            pres.filename,
            pres.authzToken,
            ConversionMessageConstants.FILE_TOO_LARGE,
            uploadedFileSize,
            maxUploadFileSize);
    messagingService.sendDocConversionMsg(progress);
  }
  public void sendInvalidMimeTypeMessage(UploadedPresentation pres, String fileMime, String fileExtension) {
    DocInvalidMimeType invalidMimeType = new DocInvalidMimeType(
            pres.getPodId(),
            pres.getMeetingId(),
            pres.getId(),
            pres.getTemporaryPresentationId(),
            pres.getName(),
            pres.getAuthzToken(),
            ""IVALID_MIME_TYPE"",
            fileMime,
            fileExtension
    );
    messagingService.sendDocConversionMsg(invalidMimeType);
  }

  public void sendUploadFileTimedout(UploadedPresentation pres, int page) {
    UploadFileTimedoutMessage errorMessage = new UploadFileTimedoutMessage(
            pres.getPodId(),
            pres.getMeetingId(),
            pres.getName(),
            ConversionMessageConstants.CONVERSION_TIMEOUT_KEY,
            page, pres.getTemporaryPresentationId(), pres.getId(), maxNumberOfAttempts);
    messagingService.sendDocConversionMsg(errorMessage);
  }

  public void sendConversionUpdateMessage(int slidesCompleted, UploadedPresentation pres, int pageGenerated) {
    DocPageGeneratedProgress progress = new DocPageGeneratedProgress(pres.getPodId(),
            pres.getMeetingId(),
            pres.getId(),
            pres.getId(),
            pres.getName(),
            ""notUsedYet"",
            ""notUsedYet"",
            pres.isDownloadable(),
            pres.isRemovable(),
            ConversionMessageConstants.GENERATED_SLIDE_KEY,
            pres.getNumberOfPages(),
            slidesCompleted,
            generateBasePresUrl(pres),
            pageGenerated,
            (pageGenerated == 1));
    messagingService.sendDocConversionMsg(progress);
  }

  public void sendCreatingThumbnailsUpdateMessage(UploadedPresentation pres) {
    DocConversionProgress progress = new DocConversionProgress(pres.getPodId(), pres.getMeetingId(),
      pres.getId(), pres.getId(),
      pres.getName(), ""notUsedYet"", ""notUsedYet"",
      pres.isDownloadable(), pres.isRemovable(), ConversionMessageConstants.GENERATING_THUMBNAIL_KEY,
      pres.getTemporaryPresentationId());
    messagingService.sendDocConversionMsg(progress);
  }

  public void sendConversionCompletedMessage(UploadedPresentation pres) {
    if (generatedSlidesInfoHelper == null) {
      log.error(""GeneratedSlidesInfoHelper was not set. Could not notify interested listeners."");
      return;
    }

    DocPageCompletedProgress progress = new DocPageCompletedProgress(pres.getPodId(), pres.getMeetingId(),
      pres.getId(), pres.getTemporaryPresentationId(), pres.getId(),
      pres.getName(), ""notUsedYet"", ""notUsedYet"",
      pres.isDownloadable(), pres.isRemovable(), ConversionMessageConstants.CONVERSION_COMPLETED_KEY,
      pres.getNumberOfPages(), generateBasePresUrl(pres), pres.isCurrent());
    messagingService.sendDocConversionMsg(progress);
  }

  private String generateBasePresUrl(UploadedPresentation pres) {
    return pres.getBaseUrl() + ""/"" + pres.getMeetingId() + ""/"" + pres.getMeetingId() + ""/"" + pres.getId();
  }

  public void setMessagingService(IBbbWebApiGWApp m) {
    messagingService = m;
  }

  public void setMaxNumberOfAttempts(int maxNumberOfAttempts) {
    this.maxNumberOfAttempts = maxNumberOfAttempts;
  }

  public void setGeneratedSlidesInfoHelper(GeneratedSlidesInfoHelper helper) {
    generatedSlidesInfoHelper = helper;
  }

  public void sendCreatingTextFilesUpdateMessage(UploadedPresentation pres) {
    DocConversionProgress progress = new DocConversionProgress(pres.getPodId(), pres.getMeetingId(),
      pres.getId(), pres.getId(),
      pres.getName(), ""notUsedYet"", ""notUsedYet"",
      pres.isDownloadable(), pres.isRemovable(), ConversionMessageConstants.GENERATING_TEXTFILES_KEY,
      pres.getTemporaryPresentationId());
    messagingService.sendDocConversionMsg(progress);
  }

  public void sendCreatingSvgImagesUpdateMessage(UploadedPresentation pres) {
    DocConversionProgress progress = new DocConversionProgress(pres.getPodId(), pres.getMeetingId(),
      pres.getId(), pres.getId(),
      pres.getName(), ""notUsedYet"", ""notUsedYet"",
      pres.isDownloadable(), pres.isRemovable(), ConversionMessageConstants.GENERATING_SVGIMAGES_KEY,
      pres.getTemporaryPresentationId());
    messagingService.sendDocConversionMsg(progress);
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/PdfSlidesGenerationService.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 *
 * Copyright (c) 2015 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 *
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.bigbluebutton.presentation.imp;


import java.util.ArrayList;
import java.util.concurrent.*;
import org.bigbluebutton.presentation.messages.PageConvertProgressMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PdfSlidesGenerationService {
  private static Logger log = LoggerFactory.getLogger(PdfSlidesGenerationService.class);

  private ExecutorService executor;

  private BlockingQueue<PageToConvert> messages = new LinkedBlockingQueue<PageToConvert>();

  private PresentationConversionCompletionService presentationConversionCompletionService;

  public PdfSlidesGenerationService(int numConversionThreads) {
    executor = Executors.newFixedThreadPool(numConversionThreads);
  }

  public void process(PageToConvert pageToConvert) {
    Runnable task = new Runnable() {
      public void run() {
        pageToConvert.convert();
        PageConvertProgressMessage msg = new PageConvertProgressMessage(
                pageToConvert.getPageNumber(),
                pageToConvert.getPresId(),
                pageToConvert.getMeetingId(),
                new ArrayList<>());
        presentationConversionCompletionService.handle(msg);
        pageToConvert.getPageFile().delete();
      }
    };

    executor.execute(task);
  }

  public void setPresentationConversionCompletionService(PresentationConversionCompletionService s) {
    this.presentationConversionCompletionService = s;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/PdfPageCounter.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation.imp;

import java.io.File;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;

import org.bigbluebutton.presentation.PageCounter;
import org.bigbluebutton.presentation.handlers.PdfPageCounterHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.zaxxer.nuprocess.NuProcess;
import com.zaxxer.nuprocess.NuProcessBuilder;

public class PdfPageCounter implements PageCounter {
  private static Logger log = LoggerFactory.getLogger(PdfPageCounter.class);

  private static int waitForSec = 5;

  public int countNumberOfPages(File presentationFile) {
    int numPages = 0; // total numbers of this pdf

    NuProcessBuilder pdfInfo = new NuProcessBuilder(
        Arrays.asList(""pdfinfo"", presentationFile.getAbsolutePath()));

    PdfPageCounterHandler pHandler = new PdfPageCounterHandler();
    pdfInfo.setProcessListener(pHandler);

    NuProcess process = pdfInfo.start();
    try {
      process.waitFor(waitForSec, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
      log.error(""InterruptedException while counting PDF pages {}"", presentationFile.getName(), e);
    }

    numPages = pHandler.numberOfPages();
    return numPages;
  }

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/ThumbnailCreatorImp.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2014 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation.imp;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.io.FileUtils;
import org.bigbluebutton.presentation.SupportedFileTypes;
import org.bigbluebutton.presentation.ThumbnailCreator;
import org.bigbluebutton.presentation.UploadedPresentation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;

public class ThumbnailCreatorImp implements ThumbnailCreator {
  private static Logger log = LoggerFactory.getLogger(ThumbnailCreatorImp.class);

  private static final Pattern PAGE_NUMBER_PATTERN = Pattern.compile(""(.+-thumb)-([0-9]+)-([0-9]+)(.png)"");

  private static String TEMP_THUMB_NAME = ""temp-thumb"";

  private String IMAGEMAGICK_DIR;

  private String BLANK_THUMBNAIL;

  @Override
  public boolean createThumbnail(UploadedPresentation pres, int page, File pageFile) {
    boolean success = false;
    File thumbsDir = determineThumbnailDirectory(pres.getUploadedFile());

    if (!thumbsDir.exists())
      thumbsDir.mkdir();

    try {
      success = generateThumbnail(thumbsDir, pres, page, pageFile);
    } catch (InterruptedException e) {
      log.error(""Interrupted Exception while generating thumbnails {}"", pres.getName(), e);
      success = false;
    }

    renameThumbnails(thumbsDir, page);

    // Create blank thumbnails for pages that failed to generate a thumbnail.
    if (!success) {
      createBlankThumbnail(thumbsDir, page);
    }


    return success;
  }

  private boolean generateThumbnail(File thumbsDir, UploadedPresentation pres, int page, File pageFile)
      throws InterruptedException {
    String source = pageFile.getAbsolutePath();
    String dest;
    String COMMAND = """";

    if (SupportedFileTypes.isImageFile(pres.getFileType())) {
      dest = thumbsDir.getAbsolutePath() + File.separatorChar + ""thumb-"" + page + "".png"";
      COMMAND = IMAGEMAGICK_DIR + File.separatorChar + ""convert -thumbnail 150x150 ""  + source + "" "" + dest;
    } else {
      dest = thumbsDir.getAbsolutePath() + File.separatorChar + TEMP_THUMB_NAME + ""-"" + page; // the ""-x.png"" is appended automagically
      COMMAND = ""pdftocairo -png -scale-to 150 -cropbox "" + source + "" "" + dest;
    }

    //System.out.println(COMMAND);

    boolean done = new ExternalProcessExecutor().exec(COMMAND, 10000);

    if (done) {
      return true;
    } else {
      Map<String, Object> logData = new HashMap<String, Object>();
      logData.put(""meetingId"", pres.getMeetingId());
      logData.put(""presId"", pres.getId());
      logData.put(""filename"", pres.getName());
      logData.put(""page"", page);
      logData.put(""logCode"", ""create_thumbnails_failed"");
      logData.put(""message"", ""Failed to create thumbnails."");

      Gson gson = new Gson();
      String logStr = gson.toJson(logData);
      log.warn("" --analytics-- data={}"", logStr);
    }

    return false;
  }

  private File determineThumbnailDirectory(File presentationFile) {
    return new File(
        presentationFile.getParent() + File.separatorChar + ""thumbnails"");
  }

  private void renameThumbnails(File dir, int page) {
    /*
     * If more than 1 file, filename like 'temp-thumb-X.png' else filename is
     * 'temp-thumb.png'
     */
    Matcher matcher;
    if (dir.list().length > 1) {
      File[] files = dir.listFiles();
      for (File file : files) {
        matcher = PAGE_NUMBER_PATTERN.matcher(file.getAbsolutePath());
        if (matcher.matches()) {
          // Path should be something like
          // 'c:/temp/bigluebutton/presname/thumbnails/temp-thumb-1.png'
          // Extract the page number. There should be 4 matches.
          // 0. c:/temp/bigluebutton/presname/thumbnails/temp-thumb-1.png
          // 1. c:/temp/bigluebutton/presname/thumbnails/temp-thumb
          // 2. 1 ---> what we are interested in
          // 3. .png
          // We are interested in the second match.
          int pageNum = Integer.valueOf(matcher.group(2).trim()).intValue();
          if (pageNum == page) {
            String newFilename = ""thumb-"" + (page) + "".png"";
            File renamedFile = new File(
                    dir.getAbsolutePath() + File.separatorChar + newFilename);
            file.renameTo(renamedFile);
          }
        }
      }
    } else if (dir.list().length == 1) {
      File oldFilename = new File(
          dir.getAbsolutePath() + File.separatorChar + dir.list()[0]);
      String newFilename = ""thumb-1.png"";

      // Might be the first thumbnail of a set and it might be out of order
      // Avoid setting the second/third/... slide as thumb-1.png
      matcher = PAGE_NUMBER_PATTERN.matcher(oldFilename.getAbsolutePath());
      if (matcher.matches()) {
        int pageNum = Integer.valueOf(matcher.group(2).trim()).intValue();
        newFilename = ""thumb-"" + (pageNum) + "".png"";
      }

      File renamedFile = new File(
          oldFilename.getParent() + File.separatorChar + newFilename);
      oldFilename.renameTo(renamedFile);
    }
  }

  private void createBlankThumbnail(File thumbsDir, int page) {
    File[] thumbs = thumbsDir.listFiles();

    File thumb = new File(thumbsDir.getAbsolutePath() + File.separatorChar + ""thumb-"" + page + "".png"");
    if (!thumb.exists()) {
      log.info(""Copying blank thumbnail for slide {}"", page);
      copyBlankThumbnail(thumb);
    }
  }

  private void copyBlankThumbnail(File thumb) {
    try {
      FileUtils.copyFile(new File(BLANK_THUMBNAIL), thumb);
    } catch (IOException e) {
      log.error(""IOException while copying blank thumbnail."", e);
    }
  }

  private void cleanDirectory(File directory) {
    File[] files = directory.listFiles();
    for (File file : files) {
      file.delete();
    }
  }

  public void setImageMagickDir(String imageMagickDir) {
    IMAGEMAGICK_DIR = imageMagickDir;
  }

  public void setBlankThumbnail(String blankThumbnail) {
    BLANK_THUMBNAIL = blankThumbnail;
  }

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/PresentationFileProcessor.java,"package org.bigbluebutton.presentation.imp;

import com.google.gson.Gson;
import org.bigbluebutton.api.Util;
import org.bigbluebutton.presentation.*;
import org.bigbluebutton.presentation.messages.DocPageConversionStarted;
import org.bigbluebutton.presentation.messages.DocPageCountExceeded;
import org.bigbluebutton.presentation.messages.DocPageCountFailed;
import org.bigbluebutton.presentation.messages.PresentationConvertMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

public class PresentationFileProcessor {
    private static Logger log = LoggerFactory.getLogger(PresentationFileProcessor.class);

    private boolean svgImagesRequired=true;
    private boolean generatePngs;
    private PageExtractor pageExtractor;

    private long bigPdfSize;
    private long maxBigPdfPageSize;

    private long MAX_CONVERSION_TIME = 5 * 60 * 1000L;

    private TextFileCreator textFileCreator;
    private SvgImageCreator svgImageCreator;
    private ThumbnailCreator thumbnailCreator;
    private PngCreator pngCreator;
    private SlidesGenerationProgressNotifier notifier;
    private PageCounterService counterService;
    private PresentationConversionCompletionService presentationConversionCompletionService;
    private ImageSlidesGenerationService imageSlidesGenerationService;
    private PdfSlidesGenerationService pdfSlidesGenerationService;

    private ExecutorService executor;
    private volatile boolean processPresentation = false;

    private BlockingQueue<UploadedPresentation> presentations = new LinkedBlockingQueue<UploadedPresentation>();

    public PresentationFileProcessor(int numConversionThreads) {
        executor = Executors.newFixedThreadPool(numConversionThreads);
    }

    public synchronized void process(UploadedPresentation pres) {
        if (pres.isDownloadable()) {
            processMakePresentationDownloadableMsg(pres);
        }

        Runnable messageProcessor = new Runnable() {
            public void run() {
                processUploadedPresentation(pres);
            }
        };
        executor.submit(messageProcessor);
    }

    private void processMakePresentationDownloadableMsg(UploadedPresentation pres) {
        try {
            File presentationFileDir = pres.getUploadedFile().getParentFile();
            Util.makePresentationDownloadable(presentationFileDir, pres.getId(), pres.isDownloadable());
        } catch (IOException e) {
            log.error(""Failed to make presentation downloadable: {}"", e);
        }
    }

    private void processUploadedPresentation(UploadedPresentation pres) {
        if (SupportedFileTypes.isPdfFile(pres.getFileType())) {
            determineNumberOfPages(pres);
            sendDocPageConversionStartedProgress(pres);
            PresentationConvertMessage msg = new PresentationConvertMessage(pres);
            presentationConversionCompletionService.handle(msg);
            extractIntoPages(pres);
        } else if (SupportedFileTypes.isImageFile(pres.getFileType())) {
            pres.setNumberOfPages(1); // There should be only one image to convert.
            sendDocPageConversionStartedProgress(pres);
            imageSlidesGenerationService.generateSlides(pres);
        }
    }

    private void extractIntoPages(UploadedPresentation pres) {
        List<PageToConvert> listOfPagesConverted = new ArrayList<>();
        for (int page = 1; page <= pres.getNumberOfPages(); page++) {
            String presDir = pres.getUploadedFile().getParent();
            File pageFile = new File(presDir + ""/page"" + ""-"" + page + "".pdf"");

            File extractedPageFile = extractPage(pres, page);

            if (extractedPageFile.length() > maxBigPdfPageSize) {
                File downscaledPageFile = downscalePage(pres, extractedPageFile, page);
                downscaledPageFile.renameTo(pageFile);
                extractedPageFile.delete();
            } else {
                extractedPageFile.renameTo(pageFile);
            }

            PageToConvert pageToConvert = new PageToConvert(
                    pres,
                    page,
                    pageFile,
                    svgImagesRequired,
                    generatePngs,
                    textFileCreator,
                    svgImageCreator,
                    thumbnailCreator,
                    pngCreator,
                    notifier
            );

            pdfSlidesGenerationService.process(pageToConvert);
            listOfPagesConverted.add(pageToConvert);
            PageToConvert timeoutErrorMessage =
            listOfPagesConverted.stream().filter(item -> {
                return item.getMessageErrorInConversion() != null;
            }).findAny().orElse(null);

            if (timeoutErrorMessage != null) {
                log.error(timeoutErrorMessage.getMessageErrorInConversion());
                notifier.sendUploadFileTimedout(pres, timeoutErrorMessage.getPageNumber());
                break;
            }
        }
    }

    private File downscalePage(UploadedPresentation pres, File filePage, int pageNum) {
        String presDir = pres.getUploadedFile().getParent();
        File tempPage = new File(presDir + ""/downscaled"" + ""-"" + pageNum + "".pdf"");
        PdfPageDownscaler downscaler = new PdfPageDownscaler();
        downscaler.downscale(filePage, tempPage);
        if (tempPage.exists()) {
            return tempPage;
        }

        return filePage;
    }

    private File extractPage(UploadedPresentation pres, int page) {
        String presDir = pres.getUploadedFile().getParent();

        File tempPage = new File(presDir + ""/extracted"" + ""-"" + page + "".pdf"");
        pageExtractor.extractPage(pres.getUploadedFile(), tempPage, page);

        return tempPage;
    }

    private boolean determineNumberOfPages(UploadedPresentation pres) {
        try {
            counterService.determineNumberOfPages(pres);
            return true;
        } catch (CountingPageException e) {
            sendFailedToCountPageMessage(e, pres);
        }
        return false;
    }

    private void sendDocPageConversionStartedProgress(UploadedPresentation pres) {
        Map<String, Object> logData = new HashMap<String, Object>();

        logData.put(""podId"", pres.getPodId());
        logData.put(""meetingId"", pres.getMeetingId());
        logData.put(""presId"", pres.getId());
        logData.put(""filename"", pres.getName());
        logData.put(""num_pages"", pres.getNumberOfPages());
        logData.put(""authzToken"", pres.getAuthzToken());
        logData.put(""logCode"", ""presentation_conversion_num_pages"");
        logData.put(""message"", ""Presentation conversion number of pages."");

        Gson gson = new Gson();
        String logStr = gson.toJson(logData);
        log.info("" --analytics-- data={}"", logStr);

        DocPageConversionStarted progress = new DocPageConversionStarted(
                pres.getPodId(),
                pres.getMeetingId(),
                pres.getId(),
                pres.getName(),
                pres.getAuthzToken(),
                pres.isDownloadable(),
                pres.isRemovable(),
                pres.isCurrent(),
                pres.getNumberOfPages());
        notifier.sendDocConversionProgress(progress);
    }

    private void sendFailedToCountPageMessage(CountingPageException e, UploadedPresentation pres) {
        ConversionUpdateMessage.MessageBuilder builder = new ConversionUpdateMessage.MessageBuilder(pres);

        if (e.getExceptionType() == CountingPageException.ExceptionType.PAGE_COUNT_EXCEPTION) {
            builder.messageKey(ConversionMessageConstants.PAGE_COUNT_FAILED_KEY);

            Map<String, Object> logData = new HashMap<>();
            logData.put(""podId"", pres.getPodId());
            logData.put(""meetingId"", pres.getMeetingId());
            logData.put(""presId"", pres.getId());
            logData.put(""filename"", pres.getName());
            logData.put(""logCode"", ""determine_num_pages_failed"");
            logData.put(""message"", ""Failed to determine number of pages."");
            Gson gson = new Gson();
            String logStr = gson.toJson(logData);
            log.error("" --analytics-- data={}"", logStr, e);

            DocPageCountFailed progress = new DocPageCountFailed(pres.getPodId(), pres.getMeetingId(),
                    pres.getId(), pres.getId(),
                    pres.getName(), ""notUsedYet"", ""notUsedYet"",
                    pres.isDownloadable(), pres.isRemovable(), ConversionMessageConstants.PAGE_COUNT_FAILED_KEY,
                    pres.getTemporaryPresentationId());

            notifier.sendDocConversionProgress(progress);

        } else if (e.getExceptionType() == CountingPageException.ExceptionType.PAGE_EXCEEDED_EXCEPTION) {
            builder.numberOfPages(e.getPageCount());
            builder.maxNumberPages(e.getMaxNumberOfPages());
            builder.messageKey(ConversionMessageConstants.PAGE_COUNT_EXCEEDED_KEY);

            Map<String, Object> logData = new HashMap<String, Object>();
            logData.put(""podId"", pres.getPodId());
            logData.put(""meetingId"", pres.getMeetingId());
            logData.put(""presId"", pres.getId());
            logData.put(""filename"", pres.getName());
            logData.put(""pageCount"", e.getPageCount());
            logData.put(""maxNumPages"", e.getMaxNumberOfPages());
            logData.put(""logCode"", ""num_pages_exceeded"");
            logData.put(""message"", ""Number of pages exceeded."");
            Gson gson = new Gson();
            String logStr = gson.toJson(logData);
            log.warn("" --analytics-- data={}"", logStr);

            DocPageCountExceeded progress = new DocPageCountExceeded(pres.getPodId(), pres.getMeetingId(),
                    pres.getId(), pres.getId(),
                    pres.getName(), ""notUsedYet"", ""notUsedYet"",
                    pres.isDownloadable(), pres.isRemovable(), ConversionMessageConstants.PAGE_COUNT_EXCEEDED_KEY,
                    e.getPageCount(), e.getMaxNumberOfPages(), pres.getTemporaryPresentationId());

            notifier.sendDocConversionProgress(progress);
        }
    }

    public void start() {
        log.info(""Ready to process presentation files!"");

        try {
            processPresentation = true;

            Runnable messageProcessor = new Runnable() {
                public void run() {
                    while (processPresentation) {
                        try {
                            UploadedPresentation pres = presentations.take();
                            processUploadedPresentation(pres);
                        } catch (InterruptedException e) {
                            log.warn(""Error while taking presentation file from queue."");
                        }
                    }
                }
            };
            executor.submit(messageProcessor);
        } catch (Exception e) {
            log.error(""Error processing presentation file: {}"", e);
        }
    }

    public void stop() {
        processPresentation = false;
    }

    public void setSlidesGenerationProgressNotifier(SlidesGenerationProgressNotifier notifier) {
        this.notifier = notifier;
    }

    public void setCounterService(PageCounterService counterService) {
        this.counterService = counterService;
    }

    public void setPageExtractor(PageExtractor extractor) {
        this.pageExtractor = extractor;
    }

    public void setGeneratePngs(boolean generatePngs) {
        this.generatePngs = generatePngs;
    }

    public void setBigPdfSize(long bigPdfSize) {
        this.bigPdfSize = bigPdfSize;
    }

    public void setMaxBigPdfPageSize(long maxBigPdfPageSize) {
        this.maxBigPdfPageSize = maxBigPdfPageSize;
    }

    public void setSvgImagesRequired(boolean svgImagesRequired) {
        this.svgImagesRequired = svgImagesRequired;
    }

    public void setThumbnailCreator(ThumbnailCreator thumbnailCreator) {
        this.thumbnailCreator = thumbnailCreator;
    }

    public void setPngCreator(PngCreator pngCreator) {
        this.pngCreator = pngCreator;
    }

    public void setTextFileCreator(TextFileCreator textFileCreator) {
        this.textFileCreator = textFileCreator;
    }

    public void setSvgImageCreator(SvgImageCreator svgImageCreator) {
        this.svgImageCreator = svgImageCreator;
    }

    public void setMaxConversionTime(int minutes) {
        MAX_CONVERSION_TIME = minutes * 60 * 1000L * 1000L * 1000L;
    }

    public void setImageSlidesGenerationService(ImageSlidesGenerationService s) {
        imageSlidesGenerationService = s;
    }

    public void setPresentationConversionCompletionService(PresentationConversionCompletionService s) {
        this.presentationConversionCompletionService = s;
    }

    public void setPdfSlidesGenerationService(PdfSlidesGenerationService s) {
        this.pdfSlidesGenerationService = s;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/Office2PdfPageConverter.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * 
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.bigbluebutton.presentation.imp;


import java.io.File;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import com.zaxxer.nuprocess.NuProcess;
import com.zaxxer.nuprocess.NuProcessBuilder;
import org.bigbluebutton.presentation.UploadedPresentation;
import org.bigbluebutton.presentation.handlers.Office2PdfConverterHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;

import static org.bigbluebutton.presentation.Util.deleteDirectoryFromFileHandlingErrors;

public abstract class Office2PdfPageConverter {
  private static Logger log = LoggerFactory.getLogger(Office2PdfPageConverter.class);

  public static boolean convert(File presentationFile, File output, int page, UploadedPresentation pres,
                         String presOfficeConversionExec, int conversionTimeout) {

    try {
      Map<String, Object> logData = new HashMap<>();
      logData.put(""meetingId"", pres.getMeetingId());
      logData.put(""presId"", pres.getId());
      logData.put(""filename"", pres.getName());
      logData.put(""logCode"", ""office_doc_to_pdf"");
      logData.put(""message"", ""Converting Office doc to PDF."");
      Gson gson = new Gson();
      String logStr = gson.toJson(logData);
      log.info("" --analytics-- data={}"", logStr);

      if(presOfficeConversionExec == null) throw new Exception(""Cannot find the conversion script path."");

      File conversionScript = new File(presOfficeConversionExec);
      if(!conversionScript.exists()) throw new Exception(String.format(""File not found: %s."",presOfficeConversionExec));

      log.info(String.format(""Calling conversion script %s."", presOfficeConversionExec));

      NuProcessBuilder officeConverterExec = new NuProcessBuilder(Arrays.asList(""timeout"", conversionTimeout + ""s"", ""/bin/sh"", ""-c"",
              ""\""""+presOfficeConversionExec + ""\"" \"""" + presentationFile.getAbsolutePath() + ""\"" \"""" + output.getAbsolutePath()+""\"" pdf "" + conversionTimeout));
      Office2PdfConverterHandler office2PdfConverterHandler  = new Office2PdfConverterHandler();
      officeConverterExec.setProcessListener(office2PdfConverterHandler);

      NuProcess process = officeConverterExec.start();
      try {
        process.waitFor(conversionTimeout + 1, TimeUnit.SECONDS);
      } catch (InterruptedException e) {
        log.error(""InterruptedException while counting PDF pages {}"", presentationFile.getName(), e);
      }

      if(office2PdfConverterHandler.isCommandTimeout()) {
        log.error(""Command execution ({}) exceeded the {} secs timeout for {}."",presOfficeConversionExec, conversionTimeout, presentationFile.getName());
      }

      if(!office2PdfConverterHandler.isCommandSuccessful()) {
        throw new Exception(String.format(""Error while executing conversion script %s."", presOfficeConversionExec));
      }

      if (output.exists()) {
        return true;
      } else {
        logData = new HashMap<>();
        logData.put(""meetingId"", pres.getMeetingId());
        logData.put(""presId"", pres.getId());
        logData.put(""filename"", pres.getName());
        logData.put(""logCode"", ""office_doc_to_pdf_failed"");
        logData.put(""message"", ""Failed to convert Office doc to PDF."");
        gson = new Gson();
        logStr = gson.toJson(logData);
        log.warn("" --analytics-- data={}"", logStr);

        return false;
      }
    } catch (Exception e) {
      deleteDirectoryFromFileHandlingErrors(presentationFile);
      Map<String, Object> logData = new HashMap<>();
      logData.put(""meetingId"", pres.getMeetingId());
      logData.put(""presId"", pres.getId());
      logData.put(""filename"", pres.getName());
      logData.put(""logCode"", ""office_doc_to_pdf_failed_with_exception"");
      logData.put(""message"", ""Failed to convert Office doc to PDF."");
      logData.put(""exception"", e);
      Gson gson = new Gson();
      String logStr = gson.toJson(logData);
      log.error("" --analytics-- data={}"", logStr, e);
      return false;
    }
  }



}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/PageToConvert.java,"package org.bigbluebutton.presentation.imp;


import org.bigbluebutton.presentation.*;
import java.io.File;
import java.util.concurrent.TimeoutException;

public class PageToConvert {

  private UploadedPresentation pres;
  private int page;

  private boolean svgImagesRequired=true;
  private boolean generatePngs;
  private PageExtractor pageExtractor;


  private TextFileCreator textFileCreator;
  private SvgImageCreator svgImageCreator;
  private ThumbnailCreator thumbnailCreator;
  private PngCreator pngCreator;
  private SlidesGenerationProgressNotifier notifier;
  private File pageFile;
  private String messageErrorInConversion;

  public PageToConvert(UploadedPresentation pres,
                       int page,
                       File pageFile,
                       boolean svgImagesRequired,
                       boolean generatePngs,
                       TextFileCreator textFileCreator,
                       SvgImageCreator svgImageCreator,
                       ThumbnailCreator thumbnailCreator,
                       PngCreator pngCreator,
                       SlidesGenerationProgressNotifier notifier) {
    this.pres = pres;
    this.page = page;
    this.pageFile = pageFile;
    this.svgImagesRequired = svgImagesRequired;
    this.generatePngs = generatePngs;
    this.textFileCreator = textFileCreator;
    this.svgImageCreator = svgImageCreator;
    this.thumbnailCreator = thumbnailCreator;
    this.pngCreator = pngCreator;
    this.notifier = notifier;
  }

  public File getPageFile() {
    return pageFile;
  }

  public int getPageNumber() {
    return page;
  }

  public String getPresId() {
    return pres.getId();
  }

  public String getMeetingId() {
    return pres.getMeetingId();
  }

  public String getMessageErrorInConversion() {
    return messageErrorInConversion;
  }

  public void setMessageErrorInConversion(String messageErrorInConversion) {
    this.messageErrorInConversion = messageErrorInConversion;
  }

  public PageToConvert convert() {

    /* adding accessibility */
    createThumbnails(pres, page, pageFile);

    createTextFiles(pres, page);

    // only create SVG images if the configuration requires it
    if (svgImagesRequired) {
      try{
        createSvgImages(pres, page);
      } catch (TimeoutException e) {
        messageErrorInConversion = e.getMessage();
      }
    }

    // only create PNG images if the configuration requires it
    if (generatePngs) {
      createPngImages(pres, page, pageFile);
    }

    return this;
  }

  private void createThumbnails(UploadedPresentation pres, int page, File pageFile) {
    //notifier.sendCreatingThumbnailsUpdateMessage(pres);
    thumbnailCreator.createThumbnail(pres, page, pageFile);
  }

  private void createTextFiles(UploadedPresentation pres, int page) {
    //notifier.sendCreatingTextFilesUpdateMessage(pres);
    textFileCreator.createTextFile(pres, page);
  }

  private void createSvgImages(UploadedPresentation pres, int page) throws TimeoutException {
    //notifier.sendCreatingSvgImagesUpdateMessage(pres);
    svgImageCreator.createSvgImage(pres, page);
  }

  private void createPngImages(UploadedPresentation pres, int page, File pageFile) {
    pngCreator.createPng(pres, page, pageFile);
  }

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/PresentationConversionCompletionService.java,"package org.bigbluebutton.presentation.imp;

import com.google.gson.Gson;
import org.bigbluebutton.presentation.messages.IPresentationCompletionMessage;
import org.bigbluebutton.presentation.messages.PageConvertProgressMessage;
import org.bigbluebutton.presentation.messages.PresentationConvertMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.*;

public class PresentationConversionCompletionService {
    private static Logger log = LoggerFactory.getLogger(PresentationConversionCompletionService.class);

    private SlidesGenerationProgressNotifier notifier;

    private ExecutorService executor;
    private volatile boolean processProgress = false;

    private final ConcurrentMap<String, PresentationToConvert> presentationsToConvert
            = new ConcurrentHashMap<String, PresentationToConvert>();

    private BlockingQueue<IPresentationCompletionMessage> messages = new LinkedBlockingQueue<IPresentationCompletionMessage>();

    public PresentationConversionCompletionService() {
        executor = Executors.newSingleThreadExecutor();
    }

    public void handle(IPresentationCompletionMessage msg) {
        messages.offer(msg);
    }

    private void processMessage(IPresentationCompletionMessage msg) {
        if (msg instanceof PresentationConvertMessage) {
            PresentationConvertMessage m = (PresentationConvertMessage) msg;
            PresentationToConvert p = new PresentationToConvert(m.pres);

            String presentationToConvertKey = p.getKey() + ""_"" + m.pres.getMeetingId();

            presentationsToConvert.put(presentationToConvertKey, p);
        } else if (msg instanceof PageConvertProgressMessage) {
            PageConvertProgressMessage m = (PageConvertProgressMessage) msg;

            String presentationToConvertKey = m.presId + ""_"" + m.meetingId;

            PresentationToConvert p = presentationsToConvert.get(presentationToConvertKey);
            if (p != null) {
                p.incrementPagesCompleted();
                notifier.sendConversionUpdateMessage(p.getPagesCompleted(), p.pres, m.page);
                if (p.getPagesCompleted() == p.pres.getNumberOfPages()) {
                    handleEndProcessing(p);
                }
            }
        }
    }

    private void handleEndProcessing(PresentationToConvert p) {
        String presentationToConvertKey = p.getKey() + ""_"" + p.pres.getMeetingId();

        presentationsToConvert.remove(presentationToConvertKey);

        Map<String, Object> logData = new HashMap<String, Object>();
        logData = new HashMap<String, Object>();
        logData.put(""podId"", p.pres.getPodId());
        logData.put(""meetingId"", p.pres.getMeetingId());
        logData.put(""presId"", p.pres.getId());
        logData.put(""filename"", p.pres.getName());
        logData.put(""current"", p.pres.isCurrent());
        logData.put(""logCode"", ""presentation_conversion_end"");
        logData.put(""message"", ""End presentation conversion."");

        Gson gson = new Gson();
        String logStr = gson.toJson(logData);
        log.info("" --analytics-- data={}"", logStr);

        notifier.sendConversionCompletedMessage(p.pres);
    }
    public void start() {
        log.info(""Ready to process presentation files!"");

        try {
            processProgress = true;

            Runnable messageProcessor = new Runnable() {
                public void run() {
                    while (processProgress) {
                        try {
                            IPresentationCompletionMessage msg = messages.take();
                            processMessage(msg);
                        } catch (InterruptedException e) {
                            log.warn(""Error while taking presentation file from queue."");
                        }
                    }
                }
            };
            executor.submit(messageProcessor);
        } catch (Exception e) {
            log.error(""Error processing presentation file: {}"", e);
        }
    }

    public void stop() {
        processProgress = false;
    }

    public void setSlidesGenerationProgressNotifier(SlidesGenerationProgressNotifier notifier) {
        this.notifier = notifier;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/SvgImageCreatorImp.java,"package org.bigbluebutton.presentation.imp;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.apache.commons.io.FileUtils;
import org.bigbluebutton.presentation.SupportedFileTypes;
import org.bigbluebutton.presentation.SvgImageCreator;
import org.bigbluebutton.presentation.UploadedPresentation;
import org.bigbluebutton.presentation.handlers.AddNamespaceToSvgHandler;
import org.bigbluebutton.presentation.handlers.Pdf2PngPageConverterHandler;
import org.bigbluebutton.presentation.handlers.Png2SvgConversionHandler;
import org.bigbluebutton.presentation.handlers.SvgConversionHandler;
import org.bigbluebutton.presentation.handlers.PdfFontType3DetectorHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;
import com.zaxxer.nuprocess.NuProcess;
import com.zaxxer.nuprocess.NuProcessBuilder;

public class SvgImageCreatorImp implements SvgImageCreator {
    private static Logger log = LoggerFactory.getLogger(SvgImageCreatorImp.class);

    private SlidesGenerationProgressNotifier notifier;
    private long imageTagThreshold;
    private long pathsThreshold;
    private int convPdfToSvgTimeout = 60;
    private int pdfFontsTimeout = 3;
    private int svgResolutionPpi = 300;
    private boolean forceRasterizeSlides = false;
    private int pngWidthRasterizedSlides = 2048;
	private String BLANK_SVG;
    private int maxNumberOfAttempts = 3;

    @Override
    public boolean createSvgImage(UploadedPresentation pres, int page) throws TimeoutException{
        boolean success = false;
        File svgImagesPresentationDir = determineSvgImagesDirectory(pres.getUploadedFile());
        if (!svgImagesPresentationDir.exists())
            svgImagesPresentationDir.mkdir();

        try {
            success = generateSvgImage(svgImagesPresentationDir, pres, page);
        } catch (InterruptedException e) {
            log.error(""Interrupted Exception while generating images {}"", pres.getName(), e);
            success = false;
        }

        return success;
    }

    private PdfFontType3DetectorHandler createDetectFontType3tHandler(boolean done, int page, String source, UploadedPresentation pres) {
        //Detect if PDF contains text with font Type 3
        //Pdftocairo has problem to convert Pdf to Svg when text contains font Type 3
        //Case detects type 3, rasterize will be forced to avoid the problem
        NuProcessBuilder detectFontType3Process = this.createDetectFontType3Process(source, page);
        PdfFontType3DetectorHandler detectFontType3tHandler = new PdfFontType3DetectorHandler();
        detectFontType3Process.setProcessListener(detectFontType3tHandler);

        NuProcess processDetectFontType3 = detectFontType3Process.start();
        try {
            processDetectFontType3.waitFor(pdfFontsTimeout + 1, TimeUnit.SECONDS);
            done = true;
        } catch (InterruptedException e) {
            done = false;
            log.error(""InterruptedException while verifing font type 3 on {} page {}: {}"", pres.getName(), page, e);
        }
        return detectFontType3tHandler;
    }

    private boolean generateSvgImage(File imagePresentationDir, UploadedPresentation pres, int page)
            throws InterruptedException, TimeoutException {
        String source = pres.getUploadedFile().getAbsolutePath();
        String dest;
        int countOfTimeOut = 0;

        int numSlides = 1;
        boolean done = false;
        Boolean rasterizeCurrSlide = this.forceRasterizeSlides;

        // Convert single image file
        if (SupportedFileTypes.isImageFile(pres.getFileType())) {

            dest = imagePresentationDir.getAbsolutePath() + File.separator + ""slide-1.pdf"";

            NuProcessBuilder convertImgToSvg = new NuProcessBuilder(
                    Arrays.asList(""timeout"", convPdfToSvgTimeout + ""s"", ""convert"", source, ""-auto-orient"", dest));

            Png2SvgConversionHandler pHandler = new Png2SvgConversionHandler();
            convertImgToSvg.setProcessListener(pHandler);

            NuProcess process = convertImgToSvg.start();
            try {
                process.waitFor(convPdfToSvgTimeout + 1, TimeUnit.SECONDS);
                done = true;
            } catch (InterruptedException e) {
                done = false;
                log.error(""InterruptedException while converting to SVG {}"", dest, e);
            }

            if(pHandler.isCommandTimeout()) {
                log.error(""Command execution (convertImgToSvg) exceeded the {} secs timeout for {} page {}."", convPdfToSvgTimeout, pres.getName(), page);
            }

            // Use the intermediate PDF file as source
            source = dest;
        }

        //System.out.println(""******** CREATING SVG page "");

        // Continue image processing
        long startConv = System.currentTimeMillis();

        PdfFontType3DetectorHandler detectFontType3tHandler = this.createDetectFontType3tHandler(done, page, source, pres);

        while (detectFontType3tHandler.isCommandTimeout()) {
            // Took the first process of the function out of the count because it already happened above
            if (countOfTimeOut >= maxNumberOfAttempts - 1) {
                log.error(""Command execution (detectFontType3) exceeded the {} secs timeout within {} attempts for {} page {}."", pdfFontsTimeout, maxNumberOfAttempts, pres.getName(), page);
                throw new TimeoutException(""(Timeout error) The slide "" + page +
                        "" could not be processed within ""
                        + convPdfToSvgTimeout +
                        "" seconds."");
            }
            detectFontType3tHandler = this.createDetectFontType3tHandler(done, page, source, pres);
            countOfTimeOut += 1;
        }

        if(detectFontType3tHandler.hasFontType3()) {
            log.info(""Font Type 3 identified on {} page {}, slide will be rasterized."", pres.getName(), page);
            rasterizeCurrSlide = true;
        }


        File destsvg = new File(imagePresentationDir.getAbsolutePath() + File.separatorChar + ""slide"" + page + "".svg"");

        SvgConversionHandler pHandler = new SvgConversionHandler();

        if(rasterizeCurrSlide == false) {
            NuProcessBuilder convertPdfToSvg = createConversionProcess(""-svg"", page, source, destsvg.getAbsolutePath(),
                    true);

            convertPdfToSvg.setProcessListener(pHandler);

            NuProcess process = convertPdfToSvg.start();
            try {
                process.waitFor(convPdfToSvgTimeout + 1, TimeUnit.SECONDS);
                done = true;
            } catch (InterruptedException e) {
                log.error(""Interrupted Exception while generating SVG slides {}"", pres.getName(), e);
            }

            if(pHandler.isCommandTimeout()) {
                log.error(""Command execution (convertPdfToSvg) exceeded the {} secs timeout for {} page {}."", convPdfToSvgTimeout, pres.getName(), page);
            }

            if (!done) {
                return done;
            }
        }


        if (destsvg.length() == 0 ||
                pHandler.numberOfImageTags() > imageTagThreshold ||
                pHandler.numberOfPaths() > pathsThreshold ||
                rasterizeCurrSlide) {

            // We need t delete the destination file as we are starting a
            // new conversion process
            if (destsvg.exists()) {
                destsvg.delete();
            }

            done = false;

            if(!rasterizeCurrSlide) {
                Map<String, Object> logData = new HashMap<String, Object>();
                logData.put(""meetingId"", pres.getMeetingId());
                logData.put(""presId"", pres.getId());
                logData.put(""filename"", pres.getName());
                logData.put(""page"", page);
                logData.put(""convertSuccess"", pHandler.isCommandSuccessful());
                logData.put(""fileExists"", destsvg.exists());
                logData.put(""numberOfImages"", pHandler.numberOfImageTags());
                logData.put(""numberOfPaths"", pHandler.numberOfPaths());
                logData.put(""logCode"", ""potential_problem_with_svg"");
                logData.put(""message"", ""Potential problem with generated SVG"");
                Gson gson = new Gson();
                String logStr = gson.toJson(logData);

                log.warn("" --analytics-- data={}"", logStr);
            }


            File tempPng = null;
            String basePresentationame = UUID.randomUUID().toString();
            try {
                tempPng = File.createTempFile(basePresentationame + ""-"" + page, "".png"");
            } catch (IOException ioException) {
                // We should never fall into this if the server is correctly
                // configured
                Map<String, Object> logData = new HashMap<String, Object>();
                logData = new HashMap<String, Object>();
                logData.put(""meetingId"", pres.getMeetingId());
                logData.put(""presId"", pres.getId());
                logData.put(""filename"", pres.getName());
                logData.put(""logCode"", ""problem_with_creating_svg"");
                logData.put(""message"", ""Unable to create temporary files"");
                Gson gson = new Gson();
                String logStr = gson.toJson(logData);
                log.error("" --analytics-- data={}"", logStr, ioException);
            }

            // Step 1: Convert a PDF page to PNG using a raw pdftocairo
            NuProcessBuilder convertPdfToPng = createConversionProcess(""-png"", page, source,
                        tempPng.getAbsolutePath().substring(0, tempPng.getAbsolutePath().lastIndexOf('.')), false);

            Pdf2PngPageConverterHandler pngHandler = new Pdf2PngPageConverterHandler();
            convertPdfToPng.setProcessListener(pngHandler);
            NuProcess pngProcess = convertPdfToPng.start();
            try {
                pngProcess.waitFor(convPdfToSvgTimeout + 1, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                log.error(""Interrupted Exception while generating PNG image {}"", pres.getName(), e);
            }

            if(pngHandler.isCommandTimeout()) {
                log.error(""Command execution (convertPdfToPng) exceeded the {} secs timeout for {} page {}."", convPdfToSvgTimeout, pres.getName(), page);
            }

            if(tempPng.length() > 0) {
                // Step 2: Convert a PNG image to SVG
                NuProcessBuilder convertPngToSvg = new NuProcessBuilder(Arrays.asList(""timeout"", convPdfToSvgTimeout + ""s"", ""convert"",
                            tempPng.getAbsolutePath(), destsvg.getAbsolutePath()));

                Png2SvgConversionHandler svgHandler = new Png2SvgConversionHandler();
                convertPngToSvg.setProcessListener(svgHandler);
                NuProcess svgProcess = convertPngToSvg.start();
                try {
                    svgProcess.waitFor(convPdfToSvgTimeout + 1, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    log.error(""Interrupted Exception while generating SVG image {}"", pres.getName(), e);
                }

                if(svgHandler.isCommandTimeout()) {
                    log.error(""Command execution (convertPngToSvg) exceeded the {} secs timeout for {} page {}."", convPdfToSvgTimeout, pres.getName(), page);
                }

                done = svgHandler.isCommandSuccessful();

                if(destsvg.length() > 0) {
                    // Step 3: Add SVG namespace to the destionation file
                    // Check : https://phabricator.wikimedia.org/T43174
                    NuProcessBuilder addNameSpaceToSVG = new NuProcessBuilder(Arrays.asList(""timeout"", convPdfToSvgTimeout + ""s"",
                            ""/bin/sh"", ""-c"",
                            ""sed -i ""
                                    + ""'4s|>| xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" version=\""1.2\"">|' ""
                                    + destsvg.getAbsolutePath()));

                    AddNamespaceToSvgHandler namespaceHandler = new AddNamespaceToSvgHandler();
                    addNameSpaceToSVG.setProcessListener(namespaceHandler);
                    NuProcess namespaceProcess = addNameSpaceToSVG.start();
                    try {
                        namespaceProcess.waitFor(convPdfToSvgTimeout + 1, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        log.error(""Interrupted Exception while adding SVG namespace {}"", pres.getName(), e);
                    }

                    if (namespaceHandler.isCommandTimeout()) {
                        log.error(""Command execution (addNameSpaceToSVG) exceeded the {} secs timeout for {} page {}."", convPdfToSvgTimeout, pres.getName(), page);
                    }
                }
            }

            // Delete the temporary PNG after finishing the image conversion
            if(tempPng.exists()) {
                tempPng.delete();
            }
        }


        long endConv = System.currentTimeMillis();

        //System.out.println(""******** CREATING SVG page "" + page + "" "" + (endConv - startConv));

        if (done) {
            return true;
        }

        copyBlankSvgs(imagePresentationDir, pres.getNumberOfPages());

        Map<String, Object> logData = new HashMap<String, Object>();
        logData.put(""meetingId"", pres.getMeetingId());
        logData.put(""presId"", pres.getId());
        logData.put(""filename"", pres.getName());
        logData.put(""logCode"", ""create_svg_images_failed"");
        logData.put(""message"", ""Failed to create svg images."");

        Gson gson = new Gson();
        String logStr = gson.toJson(logData);
        log.warn("" --analytics-- data={}"", logStr);

        return false;
    }

    private NuProcessBuilder createConversionProcess(String format, int page, String source, String destFile,
            boolean analyze) {
        String rawCommand = ""pdftocairo -r "" + this.svgResolutionPpi + "" "" + format + (analyze ? """" : "" -singlefile"");

        //Resize png resolution to avoid too large files
        if(format.equals(""-png"") && this.pngWidthRasterizedSlides != 0) {
            rawCommand += "" -scale-to-x "" + this.pngWidthRasterizedSlides + "" -scale-to-y -1 "";
        }

        rawCommand  += "" -q -f "" + String.valueOf(page) + "" -l "" + String.valueOf(page) + "" "" + source + "" "" + destFile;
        if (analyze) {
            rawCommand += "" && cat "" + destFile;
            rawCommand += "" | egrep 'data:image/png;base64|<path' | sed 's/  / /g' | cut -d' ' -f 1 | sort | uniq -cw 2"";
        }

        return new NuProcessBuilder(Arrays.asList(""timeout"", convPdfToSvgTimeout + ""s"", ""/bin/sh"", ""-c"", rawCommand));
    }

    private NuProcessBuilder createDetectFontType3Process(String source, int page) {
        String rawCommand  = ""pdffonts -f "" + String.valueOf(page) + "" -l "" + String.valueOf(page) + "" "" + source;
        rawCommand += "" | grep -m 1 'Type 3'"";
        rawCommand += "" | wc -l"";

        return new NuProcessBuilder(Arrays.asList(""timeout"", pdfFontsTimeout + ""s"", ""/bin/sh"", ""-c"", rawCommand));
    }

    private File determineSvgImagesDirectory(File presentationFile) {
        return new File(presentationFile.getParent() + File.separatorChar + ""svgs"");
    }

    private void copyBlankSvgs(File svgssDir, int pageCount) {
    	File[] svgs = svgssDir.listFiles();

		if (svgs.length != pageCount) {
			for (int i = 1; i <= pageCount; i++) {
				File svg = new File(svgssDir.getAbsolutePath() + File.separator + ""slide"" + i + "".svg"");
				if (!svg.exists()) {
					log.info(""Copying blank svg for slide {}"", i);
					copyBlankSvg(svg);
				}
			}
		}
    }

	private void copyBlankSvg(File svg) {
		try {
			FileUtils.copyFile(new File(BLANK_SVG), svg);
		} catch (IOException e) {
			log.error(""IOException while copying blank SVG."");
		}
	}


	public void setBlankSvg(String blankSvg) {
		BLANK_SVG = blankSvg;
	}
    public void setMaxNumberOfAttempts(int maxNumberOfAttempts) {
        this.maxNumberOfAttempts = maxNumberOfAttempts;
    }
    public void setPdfFontsTimeout(int pdfFontsTimeout) {
        this.pdfFontsTimeout = pdfFontsTimeout;
    }

    public void setImageTagThreshold(long threshold) {
        imageTagThreshold = threshold;
    }

    public void setPathsThreshold(long threshold) {
        pathsThreshold = threshold;
    }
    
    public void setSlidesGenerationProgressNotifier(
        SlidesGenerationProgressNotifier notifier) {
      this.notifier = notifier;
    }

    public void setConvPdfToSvgTimeout(int convPdfToSvgTimeout) {
        this.convPdfToSvgTimeout = convPdfToSvgTimeout;
    }

    public void setSvgResolutionPpi(int svgResolutionPpi) {
        this.svgResolutionPpi = svgResolutionPpi;
    }

    public void setForceRasterizeSlides(boolean forceRasterizeSlides) {
        this.forceRasterizeSlides = forceRasterizeSlides;
    }

    public void setPngWidthRasterizedSlides(int pngWidthRasterizedSlides) {
        this.pngWidthRasterizedSlides = pngWidthRasterizedSlides;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/PresentationToConvert.java,"package org.bigbluebutton.presentation.imp;

import org.bigbluebutton.presentation.UploadedPresentation;

public class PresentationToConvert {
    public final UploadedPresentation pres;
    private int pagesCompleted = 0;

    public PresentationToConvert(UploadedPresentation pres) {
        this.pres = pres;
    }

    public String getKey() {
        return pres.getId();
    }

    public int getPagesCompleted() {
        return pagesCompleted;
    }

    public void incrementPagesCompleted() {
        pagesCompleted++;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/PageCounterService.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation.imp;

import org.bigbluebutton.presentation.PageCounter;
import org.bigbluebutton.presentation.SupportedFileTypes;
import org.bigbluebutton.presentation.UploadedPresentation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PageCounterService {	
	private static Logger log = LoggerFactory.getLogger(PageCounterService.class);
	
	private int maxNumPages = 100;
	private PageCounter pageCounter;
	
	public void determineNumberOfPages(UploadedPresentation pres) throws CountingPageException {
		int numberOfPages = 0;
		if (SupportedFileTypes.isPdfFile(pres.getFileType())) {
			numberOfPages = countPages(pres);			
		} else if (SupportedFileTypes.isImageFile(pres.getFileType())) {
			numberOfPages = 1;
		}
		
		if (isNumberOfPagesValid(numberOfPages)) {
			pres.setNumberOfPages(numberOfPages);
		}		
	}

	private boolean isNumberOfPagesValid(int numberOfPages) throws CountingPageException {
		if (numberOfPages <= 0) {
			throw new CountingPageException(CountingPageException.ExceptionType.PAGE_COUNT_EXCEPTION, 0, maxNumPages);
		} 
		
		if (checkIfNumberOfPagesExceedsLimit(numberOfPages)) {
			throw new CountingPageException(CountingPageException.ExceptionType.PAGE_EXCEEDED_EXCEPTION, numberOfPages, maxNumPages);
		}
		
		return true;
	}
	
	private boolean checkIfNumberOfPagesExceedsLimit(int numberOfPages) {
		if (numberOfPages > maxNumPages) {
			return true;
		}
		return false;
	}
	
	private int countPages(UploadedPresentation pres) {
		int numPages = 0;
		
		if (pageCounter == null) {
			log.warn(""No page counter!"");
			return 0;
		}
		
		numPages = pageCounter.countNumberOfPages(pres.getUploadedFile());
		return numPages;
	}
			
	public void setMaxNumPages(int maxPages) {
		maxNumPages = maxPages;
	}
		
	public void setPageCounter(PageCounter pageCounter) {
		this.pageCounter = pageCounter;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/PngCreatorImp.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2014 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */

package org.bigbluebutton.presentation.imp;

import com.google.gson.Gson;
import com.zaxxer.nuprocess.NuProcess;
import com.zaxxer.nuprocess.NuProcessBuilder;
import org.apache.commons.io.FileUtils;
import org.bigbluebutton.presentation.PngCreator;
import org.bigbluebutton.presentation.SupportedFileTypes;
import org.bigbluebutton.presentation.UploadedPresentation;
import org.bigbluebutton.presentation.handlers.Png2SvgConversionHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class PngCreatorImp implements PngCreator {
	private static Logger log = LoggerFactory.getLogger(PngCreatorImp.class);

	private static final Pattern PAGE_NUMBER_PATTERN = Pattern.compile(""(.+-png)-([0-9]+)-([0-9]+)(.png)"");

	private String BLANK_PNG;
	private int slideWidth = 800;
	private String convTimeout = ""7s"";
	private int WAIT_FOR_SEC = 7;

	private static final String TEMP_PNG_NAME = ""temp-png"";

	public boolean createPng(UploadedPresentation pres, int page, File pageFile) {
		boolean success = false;
		File pngDir = determinePngDirectory(pres.getUploadedFile());

		if (!pngDir.exists())
			pngDir.mkdir();

		try {
			long start = System.currentTimeMillis();
			success = generatePng(pngDir, pres, page, pageFile);
			long end = System.currentTimeMillis();
			//System.out.println(""*** GENERATE PNG "" + (end - start));
		} catch (InterruptedException e) {
			log.warn(""Interrupted Exception while generating png."");
			success = false;
		}

		long start = System.currentTimeMillis();
		renamePng(pngDir, page);
		// Create blank thumbnails for pages that failed to generate a thumbnail.
		createBlankPng(pngDir, page);
		long end = System.currentTimeMillis();
		//System.out.println(""*** GENERATE BLANK PNG "" + (end - start));

		//start = System.currentTimeMillis();
		//renamePng(pngDir);
		//end = System.currentTimeMillis();
		//System.out.println(""*** RENAME PNG "" + (end - start));

		return success;
	}

	private boolean generatePng(File pngsDir, UploadedPresentation pres, int page, File pageFile)
					throws InterruptedException {
		String source = pageFile.getAbsolutePath();
		String dest;

		if (SupportedFileTypes.isImageFile(pres.getFileType())) {
			// Need to create a PDF as intermediate step.
			// Convert single image file
			dest = pngsDir.getAbsolutePath() + File.separator + ""slide-1.pdf"";

			NuProcessBuilder convertImgToSvg = new NuProcessBuilder(
					Arrays.asList(""timeout"", convTimeout, ""convert"", source, ""-auto-orient"", dest));

			Png2SvgConversionHandler pHandler = new Png2SvgConversionHandler();
			convertImgToSvg.setProcessListener(pHandler);

			NuProcess process = convertImgToSvg.start();
			try {
				process.waitFor(WAIT_FOR_SEC, TimeUnit.SECONDS);
			} catch (InterruptedException e) {
				log.error(""InterruptedException while converting to PDF {}"", dest, e);
				return false;
			}

			// Use the intermediate PDF file as source
			source = dest;
		}

		String COMMAND = """";
		dest = pngsDir.getAbsolutePath() + File.separator + TEMP_PNG_NAME + ""-"" + page; // the ""-x.png"" is appended automagically
		COMMAND = ""pdftocairo -png -scale-to "" + slideWidth + "" "" + source + "" "" + dest;

		//System.out.println(""********* CREATING PNGs "" + COMMAND);

		boolean done = new ExternalProcessExecutor().exec(COMMAND, 10000);

		if (done) {
			return true;
		} else {
			Map<String, Object> logData = new HashMap<String, Object>();
			logData.put(""meetingId"", pres.getMeetingId());
			logData.put(""presId"", pres.getId());
			logData.put(""filename"", pres.getName());
			logData.put(""logCode"", ""png_create_failed"");
			logData.put(""message"", ""Failed to create png."");

			Gson gson = new Gson();
			String logStr = gson.toJson(logData);
			log.warn("" --analytics-- data={}"",  logStr);
		}

		return false;
	}

	private File determinePngDirectory(File presentationFile) {
		return new File(presentationFile.getParent() + File.separatorChar + ""pngs"");
	}

	private void renamePng(File dir, int page) {
		/*
		 * If more than 1 file, filename like 'temp-png-X.png' else filename is
		 * 'temp-png.png'
		 */
		if (dir.list().length > 1) {
			File[] files = dir.listFiles();
			Matcher matcher;
			for (int i = 0; i < files.length; i++) {

				//System.out.println(""*** PPNG file "" + files[i].getAbsolutePath());

				matcher = PAGE_NUMBER_PATTERN.matcher(files[i].getAbsolutePath());
				if (matcher.matches()) {
					// Path should be something like
					// 'c:/temp/bigluebutton/presname/pngs/temp-png-1.png'
					// Extract the page number. There should be 4 matches.
					// 0. c:/temp/bigluebutton/presname/pngs/temp-png-1.png
					// 1. c:/temp/bigluebutton/presname/pngs/temp-png
					// 2. 1 ---> what we are interested in
					// 3. .png
					// We are interested in the second match.
					int pageNum = Integer.parseInt(matcher.group(2).trim());
					if (pageNum == page) {
						String newFilename = ""slide-"" + (page) + "".png"";
						File renamedFile = new File(
								dir.getAbsolutePath() + File.separator + newFilename);
						files[i].renameTo(renamedFile);
					}

				}
			}
		} else if (dir.list().length == 1) {
			File oldFilename = new File(
							dir.getAbsolutePath() + File.separator + dir.list()[0]);
			//System.out.println(""*** PPNG file "" + oldFilename.getAbsolutePath());
			String newFilename = ""slide-1.png"";
			File renamedFile = new File(
							oldFilename.getParent() + File.separator + newFilename);
			oldFilename.renameTo(renamedFile);
		}
	}

	private void createBlankPng(File pngsDir, int page) {
		File png = new File(pngsDir.getAbsolutePath() + File.separator + ""slide-"" + page + "".png"");
		if (!png.exists()) {
			log.info(""Copying blank png for slide {}"", page);
			copyBlankPng(png);
		}
	}

	private void copyBlankPng(File png) {
		try {
			FileUtils.copyFile(new File(BLANK_PNG), png);
		} catch (IOException e) {
			log.error(""IOException while copying blank PNG."");
		}
	}

	private void cleanDirectory(File directory) {
		File[] files = directory.listFiles();
		for (int i = 0; i < files.length; i++) {
			files[i].delete();
		}
	}

	public void setBlankPng(String blankPng) {
		BLANK_PNG = blankPng;
	}

	public void setSlideWidth(int width) {
		slideWidth = width;
	}

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/TextFileCreatorImp.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation.imp;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.HashMap;
import java.util.Map;

import org.bigbluebutton.presentation.SupportedFileTypes;
import org.bigbluebutton.presentation.TextFileCreator;
import org.bigbluebutton.presentation.UploadedPresentation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;

public class TextFileCreatorImp implements TextFileCreator {
  private static Logger log = LoggerFactory.getLogger(TextFileCreatorImp.class);

  @Override
  public boolean createTextFile(UploadedPresentation pres, int page) {
    boolean success = false;
    File textfilesDir = determineTextfilesDirectory(pres.getUploadedFile());
    if (!textfilesDir.exists())
      textfilesDir.mkdir();


    try {
      success = generateTextFile(textfilesDir, pres, page);
    } catch (InterruptedException e) {
      log.error(""Interrupted Exception while generating thumbnails {}"", pres.getName(), e);
      success = false;
    }

    // TODO: in case that it doesn't generated the textfile, we should create a
    // textfile with some message
    // createUnavailableTextFile

    return success;
  }

  private boolean generateTextFile(File textfilesDir,
      UploadedPresentation pres, int page) throws InterruptedException {
    boolean success = true;
    String source = pres.getUploadedFile().getAbsolutePath();
    String dest;
    String COMMAND = """";

    if (SupportedFileTypes.isImageFile(pres.getFileType())) {
      dest = textfilesDir.getAbsolutePath() + File.separatorChar + ""slide-1.txt"";
      String text = ""No text could be retrieved for the slide"";

      File file = new File(dest);
      Writer writer = null;
      try {
        writer = new BufferedWriter(new FileWriter(file));
        writer.write(text);
      } catch (IOException e) {
        log.error(""Error: "", e);
        success = false;
      } finally {
        try {
          writer.close();
        } catch (IOException e) {
          log.error(""Error: "", e);
          success = false;
        }
      }

    } else {
      dest = textfilesDir.getAbsolutePath() + File.separatorChar + ""slide-"" + page + "".txt"";
      // sudo apt-get install xpdf-utils

        COMMAND = ""pdftotext -raw -nopgbrk -enc UTF-8 -f "" + page + "" -l "" + page
            + "" "" + source + "" "" + dest;

        //System.out.println(COMMAND);

        boolean done = new ExternalProcessExecutor().exec(COMMAND, 60000);
        if (!done) {
          success = false;

          Map<String, Object> logData = new HashMap<String, Object>();
          logData.put(""meetingId"", pres.getMeetingId());
          logData.put(""presId"", pres.getId());
          logData.put(""filename"", pres.getName());
          logData.put(""logCode"", ""create_txt_files_failed"");
          logData.put(""message"", ""Failed to create text files."");

          Gson gson = new Gson();
          String logStr = gson.toJson(logData);
          log.warn("" --analytics-- data={}"", logStr);

        }
    }

    return success;
  }

  private File determineTextfilesDirectory(File presentationFile) {
    return new File(
        presentationFile.getParent() + File.separatorChar + ""textfiles"");
  }

  private void cleanDirectory(File directory) {
    File[] files = directory.listFiles();
    for (File file : files) {
      file.delete();
    }
  }

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/PageExtractorImp.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * 
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.bigbluebutton.presentation.imp;

import java.io.File;

import org.bigbluebutton.presentation.PageExtractor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PageExtractorImp implements PageExtractor {
  private static Logger log = LoggerFactory.getLogger(PageExtractorImp.class);

  private static final String SPACE = "" "";
  private static final long extractTimeout = 10000; // 10sec

  public boolean extractPage(File presentationFile, File output, int page) {
    String COMMAND = ""pdfseparate -f "" + page + "" -l "" + page + SPACE
        + presentationFile.getAbsolutePath() + SPACE + output.getAbsolutePath();
    return new ExternalProcessExecutor().exec(COMMAND, extractTimeout);
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/ImageSlidesGenerationService.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation.imp;

import java.awt.image.BufferedImage;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeoutException;

import org.bigbluebutton.presentation.ImageResizer;
import org.bigbluebutton.presentation.PngCreator;
import org.bigbluebutton.presentation.SvgImageCreator;
import org.bigbluebutton.presentation.TextFileCreator;
import org.bigbluebutton.presentation.ThumbnailCreator;
import org.bigbluebutton.presentation.UploadedPresentation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.imageio.ImageIO;

public class ImageSlidesGenerationService {
	private static Logger log = LoggerFactory.getLogger(ImageSlidesGenerationService.class);
	
	private ExecutorService executor;
	private SlidesGenerationProgressNotifier notifier;
	private SvgImageCreator svgImageCreator;
	private ThumbnailCreator thumbnailCreator;
	private TextFileCreator textFileCreator;
	private PngCreator pngCreator;
	private ImageResizer imageResizer;
	private long maxImageWidth = 2048;
	private long maxImageHeight = 1536;
	private long MAX_CONVERSION_TIME = 5*60*1000L;
	private boolean svgImagesRequired=true;
	private boolean generatePngs;
	
	public ImageSlidesGenerationService() {
		int numThreads = Runtime.getRuntime().availableProcessors();
		executor = Executors.newFixedThreadPool(numThreads);
	}

	public void generateSlides(UploadedPresentation pres) {

		for (int page = 1; page <= pres.getNumberOfPages(); page++) {
			/* adding accessibility */
			createTextFiles(pres, page);
			createThumbnails(pres, page);

			if (svgImagesRequired) {
				try {
					createSvgImages(pres, page);
				} catch (TimeoutException e) {
					log.error(""Slide {} was not converted due to TimeoutException, ending process."", page, e);
					notifier.sendUploadFileTimedout(pres, page);
					break;
				}
			}

			if (generatePngs) {
				createPngImages(pres, page);
			}

			notifier.sendConversionUpdateMessage(page, pres, page);
		}

		System.out.println(""****** Conversion complete for "" + pres.getName());
		notifier.sendConversionCompletedMessage(pres);

	}

	private void createTextFiles(UploadedPresentation pres, int page) {
		log.debug(""Creating textfiles for accessibility."");
		notifier.sendCreatingTextFilesUpdateMessage(pres);
		textFileCreator.createTextFile(pres, page);
	}
	
	private void createThumbnails(UploadedPresentation pres, int page) {
		log.debug(""Creating thumbnails."");
		notifier.sendCreatingThumbnailsUpdateMessage(pres);
		thumbnailCreator.createThumbnail(pres, page, pres.getUploadedFile());
	}
	
	private void createSvgImages(UploadedPresentation pres, int page) throws TimeoutException{
		log.debug(""Creating SVG images."");

		try {
			BufferedImage bimg = ImageIO.read(pres.getUploadedFile());
			if(bimg.getWidth() > maxImageWidth || bimg.getHeight() > maxImageHeight) {
				log.info(""The image exceeds max dimension allowed, it will be resized."");
				resizeImage(pres, maxImageWidth + ""x"" + maxImageHeight);
			}
		} catch (Exception e) {
			log.error(""Exception while resizing image {}"", pres.getName(), e);
		}

		notifier.sendCreatingSvgImagesUpdateMessage(pres);
		svgImageCreator.createSvgImage(pres, page);
	}
	
   private void createPngImages(UploadedPresentation pres, int page) {
        pngCreator.createPng(pres, page, pres.getUploadedFile());
   }

	private void resizeImage(UploadedPresentation pres, String ratio) {
	    imageResizer.resize(pres, ratio);
	}

	public void setThumbnailCreator(ThumbnailCreator thumbnailCreator) {
		this.thumbnailCreator = thumbnailCreator;
	}

	public void setTextFileCreator(TextFileCreator textFileCreator) {
		this.textFileCreator = textFileCreator;
	}

	public void setPngCreator(PngCreator pngCreator) {
	  this.pngCreator = pngCreator;
	}
	
	public void setSvgImageCreator(SvgImageCreator svgImageCreator) {
		this.svgImageCreator = svgImageCreator;
	}
	
	public void setGeneratePngs(boolean generatePngs) {
	  this.generatePngs = generatePngs;
	}

	public void setSvgImagesRequired(boolean svg) {
	  this.svgImagesRequired = svg;
	}
	
	public void setMaxConversionTime(int minutes) {
		MAX_CONVERSION_TIME = minutes * 60 * 1000L;
	}

	public void setSlidesGenerationProgressNotifier(SlidesGenerationProgressNotifier notifier) {
		this.notifier = notifier;
	}
	
	public void setImageResizer(ImageResizer imageResizer) {
	    this.imageResizer = imageResizer;
	}
	
	public void setMaxImageWidth(long maxImageWidth) {
	    this.maxImageWidth = maxImageWidth;
	}
	public void setMaxImageHeight(long maxImageHeight) {
		this.maxImageHeight = maxImageHeight;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/OfficeDocumentValidator2.java,"package org.bigbluebutton.presentation.imp;

import java.util.HashMap;
import java.util.Map;

import org.apache.commons.io.FilenameUtils;
import org.bigbluebutton.presentation.FileTypeConstants;
import org.bigbluebutton.presentation.UploadedPresentation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;

public class OfficeDocumentValidator2 {
  private static Logger log = LoggerFactory.getLogger(OfficeDocumentValidator2.class);

  private String presCheckExec;

  public boolean isValid(UploadedPresentation pres) {
    boolean valid = true;

    if (FilenameUtils.isExtension(pres.getUploadedFile().getName(), FileTypeConstants.PPTX)) {
      String COMMAND = ""timeout 20 "" + presCheckExec + "" "" + pres.getUploadedFile().getAbsolutePath();

      log.info(""Running pres check "" + COMMAND);

      boolean done = new ExternalProcessExecutor().exec(COMMAND, 25000);

      if (done) {
        return true;
      } else {
        Map<String, Object> logData = new HashMap<>();
        logData.put(""meetingId"", pres.getMeetingId());
        logData.put(""presId"", pres.getId());
        logData.put(""filename"", pres.getName());
        logData.put(""logCode"", ""pptx_validation_failed"");
        logData.put(""message"", ""PPTX failed validation."");
        Gson gson = new Gson();
        String logStr = gson.toJson(logData);
        log.error("" --analytics-- data={}"", logStr);

        return false;
      }
    }
    return valid;
  }

  public void setPresCheckExec(String path) {
    this.presCheckExec = path;
  }

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/OfficeDocumentValidator.java,"package org.bigbluebutton.presentation.imp;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.Predicate;
import org.apache.commons.io.FilenameUtils;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.xslf.usermodel.XMLSlideShow;
import org.apache.poi.xslf.usermodel.XSLFPictureData;
import org.bigbluebutton.presentation.FileTypeConstants;
import org.bigbluebutton.presentation.UploadedPresentation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;

public class OfficeDocumentValidator {
  private static Logger log = LoggerFactory.getLogger(OfficeDocumentValidator.class);

  public boolean isValid(UploadedPresentation pres) {
    boolean valid = true;
    if (FilenameUtils.isExtension(pres.getUploadedFile().getName(),
        FileTypeConstants.PPTX)) {
      XMLSlideShow xmlSlideShow;
      try {
        xmlSlideShow = new XMLSlideShow(
            new FileInputStream(pres.getUploadedFile()));
        valid &= !embedsEmf(xmlSlideShow, pres);
        valid &= !containsTinyTileBackground(xmlSlideShow, pres);
        // Close the resource once we finished reading it
        xmlSlideShow.close();
      } catch (IOException e) {
        Map<String, Object> logData = new HashMap<>();
        logData.put(""meetingId"", pres.getMeetingId());
        logData.put(""presId"", pres.getId());
        logData.put(""filename"", pres.getName());
        logData.put(""logCode"", ""open_pptx_failed"");
        logData.put(""message"", ""Cannot open PPTX file "" + pres.getName());
        Gson gson = new Gson();
        String logStr = gson.toJson(logData);
        log.error("" --analytics-- data={}"", logStr, e);

        valid = false;
      }
    }
    return valid;
  }

  /**
   * Checks if the slide-show file embeds any EMF document
   * 
   * @param xmlSlideShow
   * @return
   */
  private boolean embedsEmf(XMLSlideShow xmlSlideShow, UploadedPresentation pres) {
    EmfPredicate emfPredicate = new EmfPredicate();
    ArrayList<XSLFPictureData> embeddedEmfFiles = (ArrayList<XSLFPictureData>) CollectionUtils
        .select(xmlSlideShow.getPictureData(), emfPredicate);
    if (!embeddedEmfFiles.isEmpty()) {

      Map<String, Object> logData = new HashMap<>();
      logData.put(""meetingId"", pres.getMeetingId());
      logData.put(""presId"", pres.getId());
      logData.put(""filename"", pres.getName());
      logData.put(""logCode"", ""presentation_contains_embedded_emfs"");
      logData.put(""message"", ""Found "" + embeddedEmfFiles.size() + "" EMF files in presentation."");
      Gson gson = new Gson();
      String logStr = gson.toJson(logData);
      log.warn("" --analytics-- data={}"", logStr);

      return true;
    }
    return false;
  }

  /**
   * Checks if the slide-show contains a small background tile image
   * 
   * @param xmlSlideShow
   * @return
   */
  private boolean containsTinyTileBackground(XMLSlideShow xmlSlideShow, UploadedPresentation pres) {
    TinyTileBackgroundPredicate tinyTileCondition = new TinyTileBackgroundPredicate();
    ArrayList<XSLFPictureData> tileImage = (ArrayList<XSLFPictureData>) CollectionUtils
        .select(xmlSlideShow.getPictureData(), tinyTileCondition);
    if (!tileImage.isEmpty()) {

      Map<String, Object> logData = new HashMap<>();
      logData.put(""meetingId"", pres.getMeetingId());
      logData.put(""presId"", pres.getId());
      logData.put(""filename"", pres.getName());
      logData.put(""logCode"", ""presentation_contains_background_tiles"");
      logData.put(""message"", ""Found small background tile image."");
      Gson gson = new Gson();
      String logStr = gson.toJson(logData);
      log.warn("" --analytics-- data={}"", logStr);

      return true;
    }
    return false;
  }

  private final class EmfPredicate implements Predicate<XSLFPictureData> {
    @Override
    public boolean evaluate(XSLFPictureData img) {
      return ""image/x-emf"".equals(img.getContentType());
    }
  }

  private final class TinyTileBackgroundPredicate
      implements Predicate<XSLFPictureData> {
    @Override
    public boolean evaluate(XSLFPictureData img) {
      return img.getContentType() != null
          && ""image/jpeg"".equals(img.getContentType())
          && LittleEndian.getLong(img.getChecksum()) == 4114937224L;
    }
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/ExternalProcessExecutor.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation.imp;

import java.io.File;
import java.io.IOException;
import java.time.Duration;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A wrapper class the executes an external command.
 * 
 * @author Richard Alam
 * @author Marcel Hellkamp
 */
public class ExternalProcessExecutor {
	private static Logger log = LoggerFactory.getLogger(ExternalProcessExecutor.class);
	// Replace with ProcessBuilder.Redirect.DISCARD in java 9+
	private static File DISCARD = new File(
			System.getProperty(""os.name"").startsWith(""Windows"") ? ""NUL"" : ""/dev/null"");

	/**
	 * Run COMMAND for at most timeoutMillis while ignoring any output.
	 * 
	 * @deprecated The COMMAND string is split on whitespace to create an argument
	 *             list. This won't work for arguments that contain whitespace. Use
	 *             {@link #exec(List, Duration)} instead.
	 * 
	 * @param COMMAND       A single command or whitespace separated list of
	 *                      arguments.
	 * @param timeoutMillis Timeout in milliseconds.
	 * @return true if the command terminated in time with an exit value of 0.
	 */
	@Deprecated
	public boolean exec(String COMMAND, long timeoutMillis) {
		return exec(Arrays.asList(COMMAND.split(""[ \\t\\n\\r\\f]+"")), Duration.ofMillis(timeoutMillis));
	}

	/**
	 * Run a command for a limited amount of time while ignoring any output.
	 * 
	 * @param cmd     List containing the program and its arguments.
	 * @param timeout Maximum execution time.
	 * @return true if the command terminated in time with an exit value of 0.
	 */
	public boolean exec(List<String> cmd, Duration timeout) {

		ProcessBuilder pb = new ProcessBuilder(cmd);
		pb.redirectError(DISCARD);
		pb.redirectOutput(DISCARD);

		Process proc;
		try {
			proc = pb.start();
		} catch (IOException e) {
			log.error(""Failed to execute: {}"", String.join("" "", cmd), e);
			return false;
		}

		try {
			if (!proc.waitFor(timeout.toMillis(), TimeUnit.MILLISECONDS)) {
				log.warn(""TIMEDOUT excuting: {}"", String.join("" "", cmd));
				proc.destroy();
			}
			return !proc.isAlive() && proc.exitValue() == 0;
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
			proc.destroy();
			return false;
		}
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/CountingPageException.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation.imp;

@SuppressWarnings(""serial"")
public class CountingPageException extends Exception {

    private final int maxNumberOfPages;
    private final ExceptionType exceptionType;
    private final int pageCount;

    public CountingPageException(CountingPageException.ExceptionType type, int pageCount, int maxNumberOfPages) {
        super(""Exception while trying to determine number of pages."");
        this.pageCount = pageCount;
        this.maxNumberOfPages = maxNumberOfPages;
        exceptionType = type;
    }

    public int getMaxNumberOfPages() {
        return maxNumberOfPages;
    }

    public CountingPageException.ExceptionType getExceptionType() {
        return exceptionType;
    }

    public int getPageCount() {
        return pageCount;
    }

    public enum ExceptionType {
        PAGE_COUNT_EXCEPTION, PAGE_EXCEEDED_EXCEPTION
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/imp/ImageResizerImp.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2018 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */

package org.bigbluebutton.presentation.imp;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;

import org.bigbluebutton.presentation.ImageResizer;
import org.bigbluebutton.presentation.UploadedPresentation;
import org.bigbluebutton.presentation.handlers.ImageResizerHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.zaxxer.nuprocess.NuProcess;
import com.zaxxer.nuprocess.NuProcessBuilder;

public class ImageResizerImp implements ImageResizer {
    private static Logger log = LoggerFactory.getLogger(ImageResizerImp.class);

    private static int waitForSec = 7;

    public boolean resize(UploadedPresentation pres, String ratio) {
        Boolean conversionSuccess = true;

        log.debug(""Rescaling file {} with {} ratio"", pres.getUploadedFile().getAbsolutePath(), ratio);
        NuProcessBuilder imgResize = new NuProcessBuilder(Arrays.asList(""convert"", ""-resize"", ratio,
                pres.getUploadedFile().getAbsolutePath(), pres.getUploadedFile().getAbsolutePath()));

        ImageResizerHandler pHandler = new ImageResizerHandler();
        imgResize.setProcessListener(pHandler);

        NuProcess process = imgResize.start();
        try {
            process.waitFor(waitForSec, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error(e.getMessage());
            conversionSuccess = false;
        }

        return conversionSuccess;
    }

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/MimeTypeUtils.java,"package org.bigbluebutton.presentation;

import java.util.*;

import static org.bigbluebutton.presentation.FileTypeConstants.*;

public class MimeTypeUtils {
    private  static final String XLS = ""application/vnd.ms-excel"";
    private  static final String XLSX = ""application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"";
    private  static final String DOC = ""application/msword"";
    private  static final String DOCX = ""application/vnd.openxmlformats-officedocument.wordprocessingml.document"";
    private  static final String PPT = ""application/vnd.ms-powerpoint"";
    private  static final String PPTX = ""application/vnd.openxmlformats-officedocument.presentationml.presentation"";
    private  static final String ODT = ""application/vnd.oasis.opendocument.text"";
    private  static final String RTF = ""application/rtf"";
    private  static final String TXT = ""text/plain"";
    private  static final String ODS = ""application/vnd.oasis.opendocument.spreadsheet"";
    private  static final String ODP = ""application/vnd.oasis.opendocument.presentation"";
    private  static final String PDF = ""application/pdf"";
    private  static final String JPEG = ""image/jpeg"";
    private  static final String PNG = ""image/png"";
    private  static final String SVG = ""image/svg+xml"";

    private static final HashMap<String,String> EXTENSIONS_MIME = new HashMap<String,String>(16) {
        {
            // Add all the supported files
            put(FileTypeConstants.XLS, XLS);
            put(FileTypeConstants.XLSX, XLSX);
            put(FileTypeConstants.DOC, DOC);
            put(FileTypeConstants.DOCX, DOCX);
            put(FileTypeConstants.PPT, PPT);
            put(FileTypeConstants.PPTX, PPTX);
            put(FileTypeConstants.ODT, ODT);
            put(FileTypeConstants.RTF, RTF);
            put(FileTypeConstants.TXT, TXT);
            put(FileTypeConstants.ODS, ODS);
            put(FileTypeConstants.ODP, ODP);
            put(FileTypeConstants.PDF, PDF);
            put(FileTypeConstants.JPG, JPEG);
            put(FileTypeConstants.JPEG, JPEG);
            put(FileTypeConstants.PNG, PNG);
            put(FileTypeConstants.SVG, SVG);
        }
    };

    public Boolean extensionMatchMimeType(String mimeType, String finalExtension) {
        if(EXTENSIONS_MIME.containsKey(finalExtension.toLowerCase()) &&
            EXTENSIONS_MIME.get(finalExtension.toLowerCase()).equalsIgnoreCase(mimeType)) {
            return true;
        } else if(EXTENSIONS_MIME.containsKey(finalExtension.toLowerCase() + 'x') &&
                    EXTENSIONS_MIME.get(finalExtension.toLowerCase() + 'x').equalsIgnoreCase(mimeType)) {
            //Exception for MS Office files named with old extension but using internally the new mime type
            //e.g. a file named with extension `ppt` but has the content of a `pptx`
            return true;
        }

        return false;
    }

    public List<String> getValidMimeTypes() {
        List<String> validMimeTypes = Arrays.asList(XLS, XLSX,
                DOC, DOCX, PPT, PPTX, ODT, RTF, TXT, ODS, ODP,
                PDF, JPEG, PNG, SVG
        );
        return validMimeTypes;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/SupportedFileTypes.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.bigbluebutton.presentation.FileTypeConstants.*;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;

@SuppressWarnings(""serial"")
public final class SupportedFileTypes {

	private static Logger log = LoggerFactory.getLogger(SupportedFileTypes.class);
	private static MimeTypeUtils mimeTypeUtils = new MimeTypeUtils();

	private static final List<String> SUPPORTED_FILE_LIST = Collections.unmodifiableList(new ArrayList<String>(15) {		
		{				
			// Add all the supported files				
			add(XLS); add(XLSX);	add(DOC); add(DOCX); add(PPT); add(PPTX);				
			add(ODT); add(RTF); add(TXT); add(ODS); add(ODP); add(PDF);
			add(JPG); add(JPEG); add(PNG);
		}
	});
		
	private static final List<String> OFFICE_FILE_LIST = Collections.unmodifiableList(new ArrayList<String>(11) {		
		{			
			// Add all Offile file types
			add(XLS); add(XLSX);	add(DOC); add(DOCX); add(PPT); add(PPTX);				
			add(ODT); add(RTF); add(TXT); add(ODS); add(ODP); 
		}
	});
	
	private static final List<String> IMAGE_FILE_LIST = Collections.unmodifiableList(new ArrayList<String>(3) {		
		{	
			// Add all image file types
			add(JPEG); add(JPG); add(PNG);
		}
	});
	
	/*
	 * Returns if the file with extension is supported.
	 */
	public static boolean isFileSupported(String fileExtension) {
		return SUPPORTED_FILE_LIST.contains(fileExtension.toLowerCase());
	}
	
	/*
	 * Returns if the office file is supported.
	 */
	public static boolean isOfficeFile(String fileExtension) {
		return OFFICE_FILE_LIST.contains(fileExtension.toLowerCase());
	}
	
	public static boolean isPdfFile(String fileExtension) {
		return ""pdf"".equalsIgnoreCase(fileExtension);
	}
	
	/*
	 * Returns if the iamge file is supported
	 */
	public static boolean isImageFile(String fileExtension) {
		return IMAGE_FILE_LIST.contains(fileExtension.toLowerCase());
	}

	/*
	 * It was tested native java methods to detect mimetypes, such as:
	 *   - URLConnection.guessContentTypeFromStream(InputStream is);
	 *   - Files.probeContentType(Path path);
	 *   - FileNameMap fileNameMap.getContentTypeFor(String file.getName());
	 *   - MimetypesFileTypeMap fileTypeMap.getContentType(File file);
	 * But none of them was as successful as the linux based command
	 */
	public static String detectMimeType(File pres) {
		try {
			if (pres == null) throw new NullPointerException(""Presentation is null"");
			if (!pres.isFile()) throw new RuntimeException(""Presentation is not a file"");

			ProcessBuilder processBuilder = new ProcessBuilder();
			processBuilder.command(""bash"", ""-c"", ""file -b --mime-type \"""" + pres.getAbsolutePath() + ""\"""");
			Process process = processBuilder.start();
			StringBuilder output = new StringBuilder();
			BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
			String line;
			while ((line = reader.readLine()) != null) {
				output.append(line + ""\n"");
			}
			int exitVal = process.waitFor();
			if (exitVal == 0) {
				return output.toString().trim();
			} else {
				String executedCommand = processBuilder.command().toArray(new String[0])[2];

				//Read error stream
				BufferedReader stdError = new BufferedReader(new InputStreamReader(process.getErrorStream()));
				StringBuilder errorString = new StringBuilder();
				while (stdError.ready()) {
					errorString.append(stdError.readLine());
					if (stdError.ready()) {
						errorString.append(""\n"");
					}
				}

				log.error(""Error while executing command '{}': {}"", executedCommand, errorString);

				if (exitVal == 127) {
					// 127 - command not found
					// use Java method to detect in this case (based on file name)
					return URLConnection.getFileNameMap().getContentTypeFor(pres.getAbsolutePath());
				} else {
					throw new RuntimeException(errorString.toString());
				}
			}
		} catch (Exception e) {
			log.error(""Error while executing detectMimeType: {}"", e.getMessage());
		}

		return """";
	}

	public static Boolean isPresentationMimeTypeValid(File pres, String fileExtension) {
		String mimeType = detectMimeType(pres);

		if (mimeType == null || mimeType.equals("""")) {
			return false;
		}

		if (!mimeTypeUtils.getValidMimeTypes().contains(mimeType)) {
			return false;
		}

		if (!mimeTypeUtils.extensionMatchMimeType(mimeType, fileExtension)) {
			log.error(""File with extension [{}] doesn't match with mimeType [{}]."", fileExtension, mimeType);
			return false;
		}

		return true;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/PageCounter.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

import java.io.File;

public interface PageCounter {
	public int countNumberOfPages(File presentation);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/ThumbnailCreator.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

import java.io.File;

public interface ThumbnailCreator {
	public boolean createThumbnail(UploadedPresentation pres, int page, File pageFile);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/ConversionMessageConstants.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

public class ConversionMessageConstants {
    public static final String OFFICE_DOC_CONVERSION_SUCCESS_KEY = ""OFFICE_DOC_CONVERSION_SUCCESS"";
    public static final String OFFICE_DOC_CONVERSION_FAILED_KEY = ""OFFICE_DOC_CONVERSION_FAILED"";
    public static final String OFFICE_DOC_CONVERSION_INVALID_KEY = ""OFFICE_DOC_CONVERSION_INVALID"";
    public static final String FILE_TOO_LARGE = ""FILE_TOO_LARGE"";
    public static final String SUPPORTED_DOCUMENT_KEY = ""SUPPORTED_DOCUMENT"";
    public static final String UNSUPPORTED_DOCUMENT_KEY = ""UNSUPPORTED_DOCUMENT"";
    public static final String PAGE_COUNT_FAILED_KEY = ""PAGE_COUNT_FAILED"";
    public static final String PAGE_COUNT_EXCEEDED_KEY = ""PAGE_COUNT_EXCEEDED"";
    public static final String PDF_HAS_BIG_PAGE = ""PDF_HAS_BIG_PAGE"";
    public static final String GENERATED_SLIDE_KEY = ""GENERATED_SLIDE"";
    public static final String GENERATING_THUMBNAIL_KEY = ""GENERATING_THUMBNAIL"";
    public static final String GENERATED_THUMBNAIL_KEY = ""GENERATED_THUMBNAIL"";
    public static final String GENERATING_TEXTFILES_KEY = ""GENERATING_TEXTFILES"";
    public static final String GENERATED_TEXTFILES_KEY = ""GENERATED_TEXTFILES"";
    public static final String GENERATING_SVGIMAGES_KEY = ""GENERATING_SVGIMAGES"";
    public static final String GENERATED_SVGIMAGES_KEY = ""GENERATED_SVGIMAGES"";
    public static final String CONVERSION_STARTED_KEY = ""CONVERSION_STARTED_KEY"";
    public static final String CONVERSION_COMPLETED_KEY = ""CONVERSION_COMPLETED"";
    public static final String CONVERSION_TIMEOUT_KEY = ""CONVERSION_TIMEOUT"";

    private ConversionMessageConstants() {
        throw new IllegalStateException(""ConversionMessageConstants is a utility class. Instanciation is forbidden."");
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/DocumentConversionService.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

public interface DocumentConversionService {
	void processDocument(UploadedPresentation pres);
	void sendDocConversionFailedOnMimeType(UploadedPresentation pres, String fileMime, String fileExtension);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/PageConverter.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

import java.io.File;

public interface PageConverter {
	public boolean convert(File presentation, File output, int page, UploadedPresentation pres);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/SvgImageCreator.java,"/* BigBlueButton - http://www.bigbluebutton.org
 * 
 * 
 * Copyright (c) 2008-2009 by respective authors (see below). All rights reserved.
 * 
 * BigBlueButton is free software; you can redistribute it and/or modify it under the 
 * terms of the GNU Lesser General Public License as published by the Free Software 
 * Foundation; either version 3 of the License, or (at your option) any later 
 * version. 
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License along 
 * with BigBlueButton; if not, If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Richard Alam <ritzalam@gmail.com>
 * 		   DJP <DJP@architectes.org>
 * 
 * @version $Id: $
 */
package org.bigbluebutton.presentation;
import java.util.concurrent.TimeoutException;

import java.util.concurrent.TimeoutException;

public interface SvgImageCreator {
	public boolean createSvgImage(UploadedPresentation pres, int page) throws TimeoutException;
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/ImageResizer.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2018 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */

package org.bigbluebutton.presentation;

public interface ImageResizer {
    boolean resize(UploadedPresentation pres, String ratio);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/PngCreator.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */

package org.bigbluebutton.presentation;

import java.io.File;

public interface PngCreator {
	public boolean createPng(UploadedPresentation pres, int page, File pageFile);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/ConversionUpdateMessage.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

public class ConversionUpdateMessage {
	private Map<String, Object> message = new HashMap<String, Object>();
	
	private ConversionUpdateMessage(ConversionUpdateMessage.MessageBuilder builder) {
		message = builder.message;
	}
	
	public Map<String, Object> getMessage() {
		return message;
	}
	
	public static class MessageBuilder {
		private Map<String, Object> message = new HashMap<String, Object>();
		
		public MessageBuilder(UploadedPresentation pres) {
			message.put(""conference"", pres.getMeetingId());
			message.put(""room"", pres.getMeetingId());
			message.put(""returnCode"", ""CONVERT"");
			message.put(""presentationName"", pres.getId());
			message.put(""presentationId"", pres.getId());
			message.put(""filename"", pres.getName());
			message.put(""downloadable"", pres.isDownloadable());
    	}
		
		public MessageBuilder entry(String key, Object value) {
			message.put(key, value);
			return this;
		}
		
		public MessageBuilder messageKey(String messageKey) {
			message.put(""messageKey"", messageKey);
			return this;
		}
		
		public MessageBuilder pagesCompleted(int pagesCompleted) {
			message.put(""pagesCompleted"", pagesCompleted);
			return this;
		}
		
		public MessageBuilder numberOfPages(int numberOfPages) {
			message.put(""numberOfPages"", numberOfPages);
			return this;
		}
		
		public MessageBuilder maxNumberPages(int maxNumberPages) {
			message.put(""maxNumberPages"", maxNumberPages);
			return this;
		}
		
		public MessageBuilder slidesInfo(String slidesInfo) {
			message.put(""slidesInfo"", slidesInfo);
			return this;
		} 
		
		public MessageBuilder presBaseUrl(UploadedPresentation pres) {
			message.put(""presentationBaseUrl"", generateBasePresUrl(pres));
			return this;
		} 
				
		public ConversionUpdateMessage build() {
			return new ConversionUpdateMessage(this);
		}
		
		public MessageBuilder generatePages(UploadedPresentation pres) {
			String basePresUrl = generateBasePresUrl(pres);
			ArrayList<Map<String, String>> pages = new ArrayList<Map<String, String>>();
			
			for (int i = 1; i <= pres.getNumberOfPages(); i++) {
				Map<String, String> page = new HashMap<String, String>();
				page.put(""num"", Integer.toString(i));
				page.put(""thumb"", basePresUrl + ""/thumbnail/"" + i);
				page.put(""text"", basePresUrl + ""/textfiles/"" + i);
				
				pages.add(page);
			}
			
			message.put(""pages"", pages);
			
			return this;
		}
		
		private String generateBasePresUrl(UploadedPresentation pres) {
			return pres.getBaseUrl() + ""/"" + pres.getMeetingId() + ""/"" + pres.getMeetingId() + ""/"" + pres.getId();
		}
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/FileTypeConstants.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

public final class FileTypeConstants {
	/* OFFICE FILE */	
	public static final String XLS = ""xls"";
    public static final String XLSX = ""xlsx"";
    public static final String DOC = ""doc"";
    public static final String DOCX = ""docx"";
    public static final String PPT = ""ppt"";
    public static final String PPTX = ""pptx"";
    public static final String ODT = ""odt"";
    public static final String RTF = ""rtf"";
    public static final String TXT = ""txt"";
    public static final String ODS = ""ods"";
    public static final String ODP = ""odp"";
    public static final String AVI = ""avi"";
    public static final String MPG = ""mpg"";
    public static final String MP3 = ""mp3"";
    public static final String PDF = ""pdf"";
    public static final String JPG = ""jpg"";
    public static final String JPEG = ""jpeg"";
    public static final String PNG = ""png"";
    public static final String SVG = ""svg"";
    private FileTypeConstants() {} // Prevent instantiation
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/OfficeToPdfConversionSuccessFilter.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

import java.util.HashMap;
import java.util.Map;

import org.bigbluebutton.api2.IBbbWebApiGWApp;
import org.bigbluebutton.presentation.messages.DocConversionProgress;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class OfficeToPdfConversionSuccessFilter {
  private static Logger log = LoggerFactory.getLogger(OfficeToPdfConversionSuccessFilter.class);

  private final IBbbWebApiGWApp gw;

  private static Map<String, String> conversionMessagesMap = new HashMap<String, String>();

  public OfficeToPdfConversionSuccessFilter(IBbbWebApiGWApp m) {
    gw = m;
    conversionMessagesMap.put(
        ConversionMessageConstants.OFFICE_DOC_CONVERSION_SUCCESS_KEY,
        ""Office document successfully converted."");
    conversionMessagesMap.put(
        ConversionMessageConstants.OFFICE_DOC_CONVERSION_FAILED_KEY,
        ""Failed to convert Office document."");
    conversionMessagesMap.put(
        ConversionMessageConstants.OFFICE_DOC_CONVERSION_INVALID_KEY,
        ""Invalid Office document detected, it will not be converted."");
  }

  public boolean didConversionSucceed(UploadedPresentation pres) {
    return ConversionMessageConstants.OFFICE_DOC_CONVERSION_SUCCESS_KEY.equals(pres.getConversionStatus());
  }

  public void sendProgress(UploadedPresentation pres) {
    DocConversionProgress progress = new DocConversionProgress(pres.getPodId(),
      pres.getMeetingId(),
      pres.getId(),
      pres.getId(),
      pres.getName(),
      ""notUsedYet"",
      ""notUsedYet"",
      pres.isDownloadable(),
      pres.isRemovable(),
      pres.getConversionStatus(),
      pres.getTemporaryPresentationId());
    gw.sendDocConversionMsg(progress);
  }

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/handlers/Pdf2PngPageConverterHandler.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * 
 * Copyright (c) 2015 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.bigbluebutton.presentation.handlers;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Pdf2PngPageConverterHandler extends AbstractCommandHandler {
    private static Logger log = LoggerFactory.getLogger(Pdf2PngPageConverterHandler.class);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/handlers/PdfFontType3DetectorHandler.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * 
 * Copyright (c) 2015 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.bigbluebutton.presentation.handlers;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PdfFontType3DetectorHandler extends AbstractCommandHandler {

  private static Logger log = LoggerFactory
      .getLogger(PdfFontType3DetectorHandler.class);

  /**
   *
   * @return If pdf page contains one or more texts with font Type 3.
   */
  public boolean hasFontType3() {
    if (stdoutEquals(""1"")) {
      return true;
    }

    return false;
  }

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/handlers/SvgConversionHandler.java,"package org.bigbluebutton.presentation.handlers;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SvgConversionHandler extends AbstractCommandHandler {
    private static Logger log = LoggerFactory.getLogger(SvgConversionHandler.class);

    private static String PATH_OUTPUT = ""<path"";
    private static String IMAGE_TAG_OUTPUT = ""<image"";
    private static String PATH_PATTERN = ""\\d+\\s"" + PATH_OUTPUT;
    private static String IMAGE_TAG_PATTERN = ""\\d+\\s"" + IMAGE_TAG_OUTPUT;

    /**
     * 
     * @return The number of <path/> tags in the generated SVG
     */
    public int numberOfPaths() {
        if (stdoutContains(PATH_OUTPUT)) {
            try {
                String out = stdoutBuilder.toString();
                Pattern r = Pattern.compile(PATH_PATTERN);
                Matcher m = r.matcher(out);
                m.find();
                return Integer.parseInt(m.group(0).replace(PATH_OUTPUT, """").trim());
            } catch (Exception e) {
                log.error(""Exception counting the number of paths"", e);
                return 0;
            }
        }
        return 0;
    }

    /**
     * 
     * @return The number of <image/> tags in the generated SVG.
     */
    public int numberOfImageTags() {
        if (stdoutContains(IMAGE_TAG_OUTPUT)) {
            try {
                String out = stdoutBuilder.toString();
                Pattern r = Pattern.compile(IMAGE_TAG_PATTERN);
                Matcher m = r.matcher(out);
                m.find();
                return Integer.parseInt(m.group(0).replace(IMAGE_TAG_OUTPUT, """").trim());
            } catch (Exception e) {
                log.error(""Exception counting the number of image tags"", e);
                return 0;
            }
        }
        return 0;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/handlers/Png2SvgConversionHandler.java,"package org.bigbluebutton.presentation.handlers;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Png2SvgConversionHandler extends AbstractCommandHandler {
    private static Logger log = LoggerFactory.getLogger(Png2SvgConversionHandler.class);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/handlers/PdfPageCounterHandler.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * 
 * Copyright (c) 2017 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */
package org.bigbluebutton.presentation.handlers;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PdfPageCounterHandler extends AbstractCommandHandler {

  private static Logger log = LoggerFactory
      .getLogger(PdfPageCounterHandler.class);

  private static final Pattern PAGE_NUMBER_PATTERN = Pattern
      .compile(""Pages:(?:\\s*)(\\d*)"");

  /**
   * @return The number of pages inside the scanned PDF document
   */
  public int numberOfPages() {
    try {
      Matcher m = PAGE_NUMBER_PATTERN.matcher(stdoutBuilder.toString());
      m.find();
      return Integer.parseInt(m.group(1).trim());
    } catch (Exception e) {
      log.error(""Exception counting images"", e);
      return 0;
    }
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/handlers/AddNamespaceToSvgHandler.java,"package org.bigbluebutton.presentation.handlers;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class AddNamespaceToSvgHandler extends AbstractCommandHandler {
    private static Logger log = LoggerFactory.getLogger(AddNamespaceToSvgHandler.class);

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/handlers/Office2PdfConverterHandler.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * 
 * Copyright (c) 2017 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */
package org.bigbluebutton.presentation.handlers;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Office2PdfConverterHandler extends AbstractCommandHandler {
  private static Logger log = LoggerFactory.getLogger(Office2PdfConverterHandler.class);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/handlers/AbstractCommandHandler.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * 
 * Copyright (c) 2015 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */
package org.bigbluebutton.presentation.handlers;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.StandardCharsets;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.zaxxer.nuprocess.NuAbstractProcessHandler;
import com.zaxxer.nuprocess.NuProcess;

public abstract class AbstractCommandHandler extends
    NuAbstractProcessHandler {

  private static Logger log = LoggerFactory
      .getLogger(AbstractCommandHandler.class);

  protected NuProcess nuProcess;
  protected int exitCode;
  protected final StringBuilder stdoutBuilder = new StringBuilder();
  protected final StringBuilder stderrBuilder = new StringBuilder();

  @Override
  public void onPreStart(NuProcess nuProcess) {
    this.nuProcess = nuProcess;
  }

  @Override
  public void onStart(NuProcess nuProcess) {
    super.onStart(nuProcess);
  }

  @Override
  public void onStdout(ByteBuffer buffer, boolean closed) {
    if (buffer != null) {
      CharBuffer charBuffer = StandardCharsets.UTF_8.decode(buffer);
      stdoutBuilder.append(charBuffer);
    }
  }

  @Override
  public void onStderr(ByteBuffer buffer, boolean closed) {
    if (buffer != null) {
      CharBuffer charBuffer = StandardCharsets.UTF_8.decode(buffer);
      stderrBuilder.append(charBuffer);
    }
  }

  @Override
  public void onExit(int statusCode) {
    exitCode = statusCode;
  }

  /**
   * 
   * @return true if the exit code of the process is different from 0
   */
  public Boolean exitedWithError() {
    return exitCode != 0;
  }

  protected Boolean stdoutContains(String value) {
    return stdoutBuilder.indexOf(value) > -1;
  }

  protected Boolean stdoutEquals(String value) {
    return stdoutBuilder.toString().trim().equals(value);
  }

  protected Boolean stderrContains(String value) {
    return stderrBuilder.indexOf(value) > -1;
  }

  public Boolean isCommandSuccessful() {
    return !exitedWithError();
  }

  public Boolean isCommandTimeout() {
    return exitCode == 124;
  }

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/handlers/ImageResizerHandler.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * 
 * Copyright (c) 2015 BigBlueButton Inc. and by respective authors (see below).
 *
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * 
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 *
 */

package org.bigbluebutton.presentation.handlers;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ImageResizerHandler extends AbstractCommandHandler {

  private static Logger log = LoggerFactory
      .getLogger(ImageResizerHandler.class);

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/Util.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.nio.file.Path;

public final class Util {
	private static Logger log = LoggerFactory.getLogger(Util.class);

	public static void deleteDirectory(File directory) {
		/**
		 * Go through each directory and check if it's not empty.
		 * We need to delete files inside a directory before a
		 * directory can be deleted.
		**/
		File[] files = directory.listFiles();				
		for (File file : files) {
			if (file.isDirectory()) {
				deleteDirectory(file);
			} else {
				file.delete();
			}
		}
		// Now that the directory is empty. Delete it.
		directory.delete();	
	}


	public static void deleteDirectoryFromFileHandlingErrors(File presentationFile) {
		if ( presentationFile != null ){
			Path presDir = presentationFile.toPath().getParent();
			try {
				File presFileDir = new File(presDir.toString());
				if (presFileDir.exists()) {
					deleteDirectory(presFileDir);
				}
			} catch (Exception ex) {
				log.error(""Error while trying to delete directory {}"", presDir.toString(), ex);
			}
		}
	}

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/Page.java,"package org.bigbluebutton.presentation;

public class Page {

	private final int num;
	
	public Page(int num) {
	  this.num = num;	
	}
	
	public int getNum() {
		return num;
	}
	
	 
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/PresentationUrlDownloadService.java,"package org.bigbluebutton.presentation;

import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.entity.ContentType;
import org.apache.http.impl.nio.client.CloseableHttpAsyncClient;
import org.apache.http.impl.nio.client.HttpAsyncClients;
import org.apache.http.nio.client.methods.HttpAsyncMethods;
import org.apache.http.nio.client.methods.ZeroCopyConsumer;
import org.bigbluebutton.api.Util;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PresentationUrlDownloadService {
    private static Logger log = LoggerFactory
            .getLogger(PresentationUrlDownloadService.class);

    private static final int MAX_REDIRECTS = 5;
    private PageExtractor pageExtractor;
    private DocumentConversionService documentConversionService;
    private String presentationBaseURL;
    private String presentationDir;
    private String BLANK_PRESENTATION;

    private ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);

    public void stop() {
        scheduledThreadPool.shutdownNow();
    }

    public void processUploadedPresentation(final UploadedPresentation uploadedPres) {
        /**
         * We delay processing of the presentation to make sure that the meeting has already been created.
         * Otherwise, the meeting won't get the conversion events.
         */
        ScheduledFuture scheduledFuture =
                scheduledThreadPool.schedule(new Runnable() {
                    public void run() {
                        documentConversionService.processDocument(uploadedPres);
                    }
                }, 5, TimeUnit.SECONDS);

    }

    public void processUploadedFile(String podId, String meetingId, String presId,
                                    String filename, File presFile, Boolean current, String authzToken,
                                    Boolean uploadFailed, ArrayList<String> uploadFailReasons) {
        // TODO add podId
        UploadedPresentation uploadedPres = new UploadedPresentation(
          podId,
          meetingId,
          presId,
          filename,
          presentationBaseURL,
          current,
          authzToken,
          uploadFailed,
          uploadFailReasons);
        uploadedPres.setUploadedFile(presFile);
        processUploadedPresentation(uploadedPres);
    }

    public void extractPresentationPage(final String sourceMeetingId, final String presentationId,
                                        final Integer presentationSlide, final String destinationMeetingId)  {
        /**
         * We delay processing of the presentation to make sure that the meeting has already been created.
         * Otherwise, the meeting won't get the conversion events.
         */
        ScheduledFuture scheduledFuture =
                scheduledThreadPool.schedule(new Runnable() {
                    public void run() {
                        extractPage(sourceMeetingId, presentationId, presentationSlide, destinationMeetingId) ;
                    }
                }, 5, TimeUnit.SECONDS);
    }

    private void extractPage(final String sourceMeetingId, final String presentationId,
                             final Integer presentationSlide, final String destinationMeetingId) {

        Boolean uploadFailed = false;
        ArrayList<String> uploadFailedReasons = new ArrayList<String>();

        // Build the source meeting path
        File sourceMeetingPath = new File(presentationDir + File.separatorChar
                + sourceMeetingId + File.separatorChar + sourceMeetingId
                + File.separatorChar + presentationId);

        // Find the source meeting presentation file
        final String presentationFilter = presentationId;
        FilenameFilter pdfFilter = new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return name.startsWith(presentationFilter)
                        && name.toLowerCase().endsWith(""pdf"");
            }
        };

        File[] matches = sourceMeetingPath.listFiles(pdfFilter);
        if (matches != null && matches.length != 1) {
            // No PDF presentation was found, we look for an image presentation
            FilenameFilter imgFlter = new FilenameFilter() {
                public boolean accept(File dir, String name) {
                    return name.startsWith(presentationFilter);
                }
            };

            matches = sourceMeetingPath.listFiles(imgFlter);
        }
        File sourcePresentationFile;
        if (matches == null || matches.length != 1) {
            log.warn(
                    ""Not matching PDF file with prefix {} found at {}. Using the default blank PDF"",
                    sourceMeetingId, sourceMeetingPath);
            sourcePresentationFile = new File(BLANK_PRESENTATION);
        } else {
            sourcePresentationFile = matches[0];
        }

        // Build the target meeting path
        String filenameExt = FilenameUtils.getExtension(sourcePresentationFile.getName());
        String presId = Util.generatePresentationId(presentationId);
        String newFilename = Util.createNewFilename(presId, filenameExt);

        File uploadDir = Util.createPresentationDir(destinationMeetingId,
                presentationDir, presId);
        String newFilePath = uploadDir.getAbsolutePath() + File.separatorChar
                + newFilename;
        File newPresentation = new File(newFilePath);

        if (sourcePresentationFile.getName().toLowerCase().endsWith(""pdf"")) {
            pageExtractor.extractPage(sourcePresentationFile, new File(
                    newFilePath), presentationSlide);
        } else {
            try {
                FileUtils.copyFile(sourcePresentationFile, newPresentation);
            } catch (IOException e) {
                log.error(""Could not copy presentation {} to {}"", sourcePresentationFile.getAbsolutePath(),
                        newPresentation.getAbsolutePath(), e);
            }
        }

        // Hardcode pre-uploaded presentation for breakout room to the default presentation window
        processUploadedFile(""DEFAULT_PRESENTATION_POD"",
          destinationMeetingId,
          presId,
          ""default-"" + presentationSlide.toString() + ""."" + filenameExt,
          newPresentation,
          true,
          ""breakout-authz-token"",
          uploadFailed,
          uploadFailedReasons);
    }

    private String followRedirect(String meetingId, String redirectUrl,
            int redirectCount, String origUrl) {

        if (redirectCount > MAX_REDIRECTS) {
            log.error(""Max redirect reached for meeting=[{}] with url=[{}]"",
                    meetingId, origUrl);
            return null;
        }

        URL presUrl;
        try {
            presUrl = new URL(redirectUrl);
        } catch (MalformedURLException e) {
            log.error(""Malformed url=[{}] for meeting=[{}]"", redirectUrl, meetingId, e);
            return null;
        }

        HttpURLConnection conn;
        try {
            conn = (HttpURLConnection) presUrl.openConnection();
            conn.setReadTimeout(60000);
            conn.addRequestProperty(""Accept-Language"", ""en-US,en;q=0.8"");
            conn.addRequestProperty(""User-Agent"", ""Mozilla"");

            // normally, 3xx is redirect
            int status = conn.getResponseCode();
            if (status != HttpURLConnection.HTTP_OK) {
                if (status == HttpURLConnection.HTTP_MOVED_TEMP
                        || status == HttpURLConnection.HTTP_MOVED_PERM
                        || status == HttpURLConnection.HTTP_SEE_OTHER) {
                    String newUrl = conn.getHeaderField(""Location"");
                    return followRedirect(meetingId, newUrl, redirectCount + 1,
                            origUrl);
                } else {
                    log.error(
                            ""Invalid HTTP response=[{}] for url=[{}] with meeting[{}]"",
                            status, redirectUrl, meetingId);
                    return null;
                }
            } else {
                return redirectUrl;
            }
        } catch (IOException e) {
            log.error(""IOException for url=[{}] with meeting[{}]"", redirectUrl, meetingId, e);
            return null;
        }
    }

    public boolean savePresentation(final String meetingId,
            final String filename, final String urlString) {

        String finalUrl = followRedirect(meetingId, urlString, 0, urlString);

        if (finalUrl == null) return false;

        boolean success = false;

        CloseableHttpAsyncClient httpclient = HttpAsyncClients.createDefault();
        try {
            httpclient.start();
            File download = new File(filename);
            ZeroCopyConsumer<File> consumer = new ZeroCopyConsumer<File>(download) {
                @Override
                protected File process(
                        final HttpResponse response,
                        final File file,
                        final ContentType contentType) throws Exception {
                    if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {
                        throw new ClientProtocolException(""Upload failed: "" + response.getStatusLine());
                    }
                    return file;
                }

            };
            Future<File> future = httpclient.execute(HttpAsyncMethods.createGet(finalUrl), consumer, null);
            File result = future.get();
            success = result.exists();
        } catch (java.lang.InterruptedException ex) {
            log.error(""InterruptedException while saving presentation"", meetingId, ex);
        } catch (java.util.concurrent.ExecutionException ex) {
            log.error(""ExecutionException while saving presentation"", meetingId, ex);
        } catch (java.io.FileNotFoundException ex) {
            log.error(""FileNotFoundException while saving presentation"", meetingId, ex);
        } finally {
            try {
                httpclient.close();
            } catch (java.io.IOException ex) {
                log.error(""IOException while saving presentation"", meetingId, ex);
            }
        }

        return success;
    }

    public void setPageExtractor(PageExtractor extractor) {
        this.pageExtractor = extractor;
    }

    public void setPresentationDir(String presDir) {
        presentationDir = presDir;
    }

    public void setPresentationBaseURL(String presentationBaseUrl) {
        presentationBaseURL = presentationBaseUrl;
    }

    public void setDocumentConversionService(
            DocumentConversionService documentConversionService) {
        this.documentConversionService = documentConversionService;
    }

    public void setBlankPresentation(String blankPresentation) {
        this.BLANK_PRESENTATION = blankPresentation;
    }

}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/PageExtractor.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.presentation;

import java.io.File;

public interface PageExtractor {
	public boolean extractPage(File presentationFile, File output, int page);
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/PdfConversionInvalid.java,"package org.bigbluebutton.presentation.messages;

public class PdfConversionInvalid implements IDocConversionMsg {
  public final String podId;
  public final String meetingId;
  public final String presId;
  public final String presInstance;
  public final String filename;
  public final String uploaderId;
  public final String authzToken;
  public final Boolean downloadable;
  public final Boolean removable;
  public final String key;
  public final Integer bigPageNumber;
  public final Integer bigPageSize;

  public PdfConversionInvalid(String podId, String meetingId, String presId, String presInstance,
                              String filename, String uploaderId, String authzToken,
                              Boolean downloadable, Boolean removable, Integer bigPageNumber, Integer bigPageSize, String key) {
    this.podId = podId;
    this.meetingId = meetingId;
    this.presId = presId;
    this.presInstance = presInstance;
    this.filename = filename;
    this.uploaderId = uploaderId;
    this.authzToken = authzToken;
    this.downloadable = downloadable;
    this.removable = removable;
    this.bigPageNumber = bigPageNumber;
    this.bigPageSize = bigPageSize;
    this.key = key;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/DocPageCountFailed.java,"package org.bigbluebutton.presentation.messages;

public class DocPageCountFailed implements IDocConversionMsg {
  public final String podId;
  public final String meetingId;
  public final String presId;
  public final String presInstance;
  public final String filename;
  public final String uploaderId;
  public final String authzToken;
  public final Boolean downloadable;
  public final Boolean removable;
  public final String key;
  public final String temporaryPresentationId;

  public DocPageCountFailed(String podId, String meetingId, String presId, String presInstance,
                            String filename, String uploaderId, String authzToken,
                            Boolean downloadable, Boolean removable, String key, String temporaryPresentationId) {
    this.podId = podId;
    this.meetingId = meetingId;
    this.presId = presId;
    this.presInstance = presInstance;
    this.filename = filename;
    this.uploaderId = uploaderId;
    this.authzToken = authzToken;
    this.downloadable = downloadable;
    this.removable = removable;
    this.key = key;
    this.temporaryPresentationId = temporaryPresentationId;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/UploadFileTimedoutMessage.java,"package org.bigbluebutton.presentation.messages;

public class UploadFileTimedoutMessage implements IDocConversionMsg {
  public final String podId;
  public final String meetingId;
  public final String filename;
  public final int page;
  public final String messageKey;
  public final String temporaryPresentationId;
  public final String presentationId;
  public final int maxNumberOfAttempts;

  public UploadFileTimedoutMessage(String podId,
                                   String meetingId,
                                   String filename,
                                   String messageKey,
                                   int page,
                                   String temporaryPresentationId,
                                   String presentationId,
                                   int maxNumberOfAttempts) {
    this.podId = podId;
    this.meetingId = meetingId;
    this.temporaryPresentationId = temporaryPresentationId;
    this.filename = filename;
    this.messageKey = messageKey;
    this.page = page;
    this.presentationId = presentationId;
    this.maxNumberOfAttempts = maxNumberOfAttempts;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/IDocConversionMsg.java,"package org.bigbluebutton.presentation.messages;


public interface IDocConversionMsg {
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/DocConversionProgress.java,"package org.bigbluebutton.presentation.messages;

public class DocConversionProgress implements IDocConversionMsg {
  public final String podId;
  public final String meetingId;
  public final String presId;
  public final String presInstance;
  public final String filename;
  public final String uploaderId;
  public final String authzToken;
  public final Boolean downloadable;
  public final Boolean removable;
  public final String key;
  public final String temporaryPresentationId;

  public DocConversionProgress(String podId, String meetingId, String presId, String presInstance,
                               String filename, String uploaderId, String authzToken,
                               Boolean downloadable, Boolean removable, String key,
                               String temporaryPresentationId) {
    this.podId = podId;
    this.meetingId = meetingId;
    this.presId = presId;
    this.presInstance = presInstance;
    this.filename = filename;
    this.uploaderId = uploaderId;
    this.authzToken = authzToken;
    this.downloadable = downloadable;
    this.removable = removable;
    this.key = key;
    this.temporaryPresentationId = temporaryPresentationId;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/DocPageGeneratedProgress.java,"package org.bigbluebutton.presentation.messages;

public class DocPageGeneratedProgress implements IDocConversionMsg {
  public final String podId;
  public final String meetingId;
  public final String presId;
  public final String presInstance;
  public final String filename;
  public final String uploaderId;
  public final String authzToken;
  public final Boolean downloadable;
  public final Boolean removable;
  public final String key;
  public final Integer numPages;
  public final Integer pagesCompleted;
  public final String presBaseUrl;
  public final Boolean current;
  public final Integer page;

  public DocPageGeneratedProgress(String podId,
                                  String meetingId,
                                  String presId,
                                  String presInstance,
                                  String filename,
                                  String uploaderId,
                                  String authzToken,
                                  Boolean downloadable,
                                  Boolean removable,
                                  String key,
                                  Integer numPages,
                                  Integer pagesCompleted,
                                  String presBaseUrl,
                                  Integer page,
                                  Boolean current) {
    this.podId = podId;
    this.meetingId = meetingId;
    this.presId = presId;
    this.presInstance = presInstance;
    this.filename = filename;
    this.uploaderId = uploaderId;
    this.authzToken = authzToken;
    this.downloadable = downloadable;
    this.removable = removable;
    this.key = key;
    this.numPages = numPages;
    this.pagesCompleted = pagesCompleted;
    this.presBaseUrl = presBaseUrl;
    this.page = page;
    this.current = current;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/DocPageConversionStarted.java,"package org.bigbluebutton.presentation.messages;

public class DocPageConversionStarted implements IDocConversionMsg {
    public final String podId;
    public final String meetingId;
    public final String presId;
    public final String filename;
    public final String authzToken;
    public final Boolean downloadable;
    public final Boolean removable;
    public final Boolean current;
    public final Integer numPages;

    public DocPageConversionStarted(String podId,
                                    String meetingId,
                                    String presId,
                                    String filename,
                                    String authzToken,
                                    Boolean downloadable,
                                    Boolean removable,
                                    Boolean current,
                                    Integer numPages) {
        this.podId = podId;
        this.meetingId = meetingId;
        this.presId = presId;
        this.filename = filename;
        this.authzToken = authzToken;
        this.downloadable = downloadable;
        this.removable = removable;
        this.current = current;
        this.numPages = numPages;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/PageConvertProgressMessage.java,"package org.bigbluebutton.presentation.messages;

import java.util.List;

public class PageConvertProgressMessage implements IPresentationCompletionMessage {

    public final String presId;
    public final int page;
    public final List<String> errors;
    public final String meetingId;

    public PageConvertProgressMessage(int page, String presId, String meetingId, List<String> errors) {
        this.presId = presId;
        this.meetingId = meetingId;
        this.page = page;
        this.errors = errors;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/IPresentationCompletionMessage.java,"package org.bigbluebutton.presentation.messages;

public interface IPresentationCompletionMessage {
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/UploadFileTooLargeMessage.java,"package org.bigbluebutton.presentation.messages;

public class UploadFileTooLargeMessage implements IDocConversionMsg {
  public final String podId;
  public final String meetingId;
  public final String filename;
  public final String authzToken;
  public final String key;
  public final Integer uploadedFileSize;
  public final Integer maxUploadFileSize;

  public UploadFileTooLargeMessage(String podId,
                                   String meetingId,
                                   String filename,
                                   String authzToken,
                                   String key,
                                   Integer uploadedFileSize,
                                   Integer maxUploadFileSize) {
    this.podId = podId;
    this.meetingId = meetingId;
    this.filename = filename;
    this.authzToken = authzToken;
    this.key = key;
    this.uploadedFileSize = uploadedFileSize;
    this.maxUploadFileSize = maxUploadFileSize;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/DocPageCompletedProgress.java,"package org.bigbluebutton.presentation.messages;

public class DocPageCompletedProgress implements IDocConversionMsg {
  public final String podId;
  public final String meetingId;
  public final String presId;
  public final String temporaryPresentationId;
  public final String presInstance;
  public final String filename;
  public final String uploaderId;
  public final String authzToken;
  public final Boolean downloadable;
  public final Boolean removable;
  public final String key;
  public final Integer numPages;
  public final String presBaseUrl;
  public final Boolean current;

  public DocPageCompletedProgress(String podId, String meetingId, String presId, String temporaryPresentationId, String presInstance,
                                  String filename, String uploaderId, String authzToken,
                                  Boolean downloadable, Boolean removable, String key,
                                  Integer numPages, String presBaseUrl, Boolean current) {
    this.podId = podId;
    this.meetingId = meetingId;
    this.presId = presId;
    this.temporaryPresentationId = temporaryPresentationId;
    this.presInstance = presInstance;
    this.filename = filename;
    this.uploaderId = uploaderId;
    this.authzToken = authzToken;
    this.downloadable = downloadable;
    this.removable = removable;
    this.key = key;
    this.numPages = numPages;
    this.presBaseUrl = presBaseUrl;
    this.current = current;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/DocInvalidMimeType.java,"package org.bigbluebutton.presentation.messages;

public class DocInvalidMimeType implements IDocConversionMsg{

    public final String podId;
    public final String meetingId;
    public final String presId;
    public final String temporaryPresentationId;
    public final String filename;
    public final String authzToken;
    public final String messageKey;
    public final String fileMime;
    public final String fileExtension;

    public DocInvalidMimeType(  String podId,
                                String meetingId,
                                String presId,
                                String temporaryPresentationId,
                                String filename,
                                String authzToken,
                                String messageKey,
                                String fileMime,
                                String fileExtension) {
        this.podId = podId;
        this.meetingId = meetingId;
        this.presId = presId;
        this.temporaryPresentationId = temporaryPresentationId;
        this.filename = filename;
        this.authzToken = authzToken;
        this.messageKey = messageKey;
        this.fileMime = fileMime;
        this.fileExtension = fileExtension;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/DocPageCountExceeded.java,"package org.bigbluebutton.presentation.messages;

public class DocPageCountExceeded implements IDocConversionMsg {
  public final String podId;
  public final String meetingId;
  public final String presId;
  public final String presInstance;
  public final String filename;
  public final String uploaderId;
  public final String authzToken;
  public final Boolean downloadable;
  public final Boolean removable;
  public final String key;
  public final Integer numPages;
  public final Integer maxNumPages;
  public final String temporaryPresentationId;

  public DocPageCountExceeded(String podId, String meetingId, String presId, String presInstance,
                              String filename, String uploaderId, String authzToken,
                              Boolean downloadable, Boolean removable,  String key,
                              Integer numPages, Integer maxNumPages, String temporaryPresentationId) {
    this.podId = podId;
    this.meetingId = meetingId;
    this.presId = presId;
    this.presInstance = presInstance;
    this.filename = filename;
    this.uploaderId = uploaderId;
    this.authzToken = authzToken;
    this.downloadable = downloadable;
    this.removable = removable;
    this.key = key;
    this.numPages = numPages;
    this.maxNumPages = maxNumPages;
    this.temporaryPresentationId = temporaryPresentationId;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/DocConversionRequestReceived.java,"package org.bigbluebutton.presentation.messages;

public class DocConversionRequestReceived implements IDocConversionMsg {
    public final String podId;
    public final String meetingId;
    public final String presId;
    public final String temporaryPresentationId;
    public final String filename;
    public final String authzToken;
    public final Boolean downloadable;
    public final Boolean removable;
    public final Boolean current;

    public DocConversionRequestReceived(String podId,
                                        String meetingId,
                                        String presId,
                                        String temporaryPresentationId,
                                        String filename,
                                        String authzToken,
                                        Boolean downloadable,
                                        Boolean removable,
                                        Boolean current) {
        this.podId = podId;
        this.meetingId = meetingId;
        this.presId = presId;
        this.temporaryPresentationId = temporaryPresentationId;
        this.filename = filename;
        this.authzToken = authzToken;
        this.downloadable = downloadable;
        this.removable = removable;
        this.current = current;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/presentation/messages/PresentationConvertMessage.java,"package org.bigbluebutton.presentation.messages;

import org.bigbluebutton.presentation.UploadedPresentation;

public class PresentationConvertMessage implements IPresentationCompletionMessage {
    public final UploadedPresentation pres;

    public PresentationConvertMessage(UploadedPresentation pres) {
        this.pres = pres;
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/WaitingGuestCleanupTimerTask.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2020 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
*
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.web.services;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.bigbluebutton.api.MeetingService;

public class WaitingGuestCleanupTimerTask {

    private MeetingService service;
    private ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(1);
    private long runEvery = 15000;

    public void setMeetingService(MeetingService svc) {
        this.service = svc;
    }

    public void start() {
        scheduledThreadPool.scheduleWithFixedDelay(new CleanupTask(), 60000, runEvery, TimeUnit.MILLISECONDS);
    }

    public void stop() {
        scheduledThreadPool.shutdownNow();
    }

    public void setRunEvery(long v) {
        runEvery = v;
    }

    private class CleanupTask implements Runnable {
        @Override
        public void run() {
            service.purgeWaitingGuestUsers();
        }
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/EnteredUserCleanupTimerTask.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2020 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
*
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.web.services;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.bigbluebutton.api.MeetingService;

public class EnteredUserCleanupTimerTask {

    private MeetingService service;
    private ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(1);
    private long runEvery = 30000;

    public void setMeetingService(MeetingService svc) {
        this.service = svc;
    }

    public void start() {
        scheduledThreadPool.scheduleWithFixedDelay(new CleanupTask(), 60000, runEvery, TimeUnit.MILLISECONDS);
    }

    public void stop() {
        scheduledThreadPool.shutdownNow();
    }

    public void setRunEvery(long v) {
        runEvery = v;
    }

    private class CleanupTask implements Runnable {
        @Override
        public void run() {
            service.purgeEnteredUsers();
        }
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/IStorageService.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.web.services;

import java.util.Map;

import org.bigbluebutton.api.domain.Poll;

public interface IStorageService{
	public String generatePollID(String meetingID);
	public String generatePollAnswerID(String meetingID);
	public void storePoll(Poll p);
	public void storePollAnswers(String meetingID, String pollID, Map<String,String> answers);
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/callback/MeetingEndedEvent.java,"package org.bigbluebutton.web.services.callback;

public class MeetingEndedEvent implements ICallbackEvent {
	private final String callbackUrl;
	public final String meetingid;
	public final String extMeetingid;
	public final String name;

	public MeetingEndedEvent(String mid, String extMid, String name, String callbackUrl) {
		this.callbackUrl = callbackUrl;
		this.meetingid = mid;
		this.extMeetingid = extMid;
		this.name = name;
	}

	public String getCallbackUrl() {
		return callbackUrl;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/callback/ICallbackEvent.java,"package org.bigbluebutton.web.services.callback;

public interface ICallbackEvent {
	String getCallbackUrl();
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/callback/DelayCallback.java,"package org.bigbluebutton.web.services.callback;

import java.util.concurrent.Delayed;
import java.util.concurrent.TimeUnit;

public class DelayCallback implements Delayed{
  public final ICallbackEvent callbackEvent;
  public final long callTime;
  public final int numAttempts;

  public DelayCallback(ICallbackEvent event, long delayInMillis, int numAttempts) {
    this.callbackEvent = event;
    this.callTime = System.currentTimeMillis() + delayInMillis;
    this.numAttempts = numAttempts;
  }

  @Override
  public long getDelay(TimeUnit unit) {
    long diff = callTime - System.currentTimeMillis();
    return unit.convert(diff, TimeUnit.MILLISECONDS);
  }

  @Override
  public int compareTo(Delayed o) {
    return new Long(this.callTime - ((DelayCallback) o).callTime).intValue();
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/callback/CallbackUrlService.java,"package org.bigbluebutton.web.services.callback;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.*;

import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.nio.client.CloseableHttpAsyncClient;
import org.apache.http.impl.nio.client.HttpAsyncClients;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;

public class CallbackUrlService {
	private static Logger log = LoggerFactory.getLogger(CallbackUrlService.class);

	private BlockingQueue<DelayCallback> receivedMessages = new DelayQueue<DelayCallback>();

	private volatile boolean processMessage = false;
	private static final int MAX_REDIRECTS = 5;

	private final Executor msgProcessorExec = Executors.newSingleThreadExecutor();
	private final Executor runExec = Executors.newSingleThreadExecutor();

	public void stop() {
		log.info(""Stopping callback url service."");
		processMessage = false;
	}

	public void start() {
		log.info(""Starting callback url service."");

		try {
			processMessage = true;

			Runnable messageProcessor = new Runnable() {
				public void run() {
					while (processMessage) {
						try {
							DelayCallback msg = receivedMessages.take();
							processMessage(msg);
						} catch (InterruptedException e) {
							log.warn(""Error while taking received message from queue."");
						}
					}
				}
			};
			msgProcessorExec.execute(messageProcessor);
		} catch (Exception e) {
			log.error(""Error subscribing to channels: {}"", e);
		}
	}


	private void processMessage(final DelayCallback msg) {
		Runnable task = new Runnable() {
			public void run() {
				MeetingEndedEvent event = (MeetingEndedEvent) msg.callbackEvent;
				if (fetchCallbackUrl(msg.callbackEvent.getCallbackUrl())) {
					Map<String, Object> logData = new HashMap<>();
					logData.put(""meetingId"", event.meetingid);
					logData.put(""externalMeetingId"", event.extMeetingid);
					logData.put(""name"",event.name);
					logData.put(""callback"", event.getCallbackUrl());
					logData.put(""attempts"", msg.numAttempts);
					logData.put(""logCode"", ""callback_success"");
					logData.put(""description"", ""Callback successful."");

					Gson gson = new Gson();
					String logStr = gson.toJson(logData);

					log.info("" --analytics-- data={}"", logStr);
				} else {
					schedRetryCallback(msg);
				}
			}
		};

		runExec.execute(task);
	}

	private void schedCallback(final DelayCallback msg, long delayInMillis, int numAttempt) {
		MeetingEndedEvent event = (MeetingEndedEvent) msg.callbackEvent;
		Map<String, Object> logData = new HashMap<>();
		logData.put(""meetingId"", event.meetingid);
		logData.put(""externalMeetingId"", event.extMeetingid);
		logData.put(""name"",event.name);
		logData.put(""callback"", event.getCallbackUrl());
		logData.put(""attempts"", msg.numAttempts);
		logData.put(""retryInMs"", delayInMillis);
		logData.put(""logCode"", ""callback_failed_retry"");
		logData.put(""description"", ""Callback failed but retrying."");

		Gson gson = new Gson();
		String logStr = gson.toJson(logData);

		log.info("" --analytics-- data={}"", logStr);

		DelayCallback dc = new DelayCallback(event, delayInMillis, numAttempt);
		receivedMessages.add(dc);
	}

	private void giveupCallback(final DelayCallback msg) {
		MeetingEndedEvent event = (MeetingEndedEvent) msg.callbackEvent;
		Map<String, Object> logData = new HashMap<>();
		logData.put(""meetingId"", event.meetingid);
		logData.put(""externalMeetingId"", event.extMeetingid);
		logData.put(""name"",event.name);
		logData.put(""callback"", event.getCallbackUrl());
		logData.put(""attempts"", msg.numAttempts);
		logData.put(""logCode"", ""callback_failed_give_up"");
		logData.put(""description"", ""Callback failed and giving up."");

		Gson gson = new Gson();
		String logStr = gson.toJson(logData);

		log.info("" --analytics-- data={}"", logStr);
	}
	private void schedRetryCallback(final DelayCallback msg) {
		MeetingEndedEvent event = (MeetingEndedEvent) msg.callbackEvent;

		switch (msg.numAttempts) {
			case 1:
				schedCallback(msg, 30_000 /** 30sec **/, 2);
				break;
			case 2:
				schedCallback(msg, 60_000 /** 1min **/, 3);
				break;
			case 3:
				schedCallback(msg, 120_000 /** 2min **/, 4);
				break;
			case 4:
				schedCallback(msg, 300_000 /** 5min **/, 5);
				break;
			default:
				giveupCallback(msg);
			}
	}

	public void handleMessage(ICallbackEvent message) {
		long delayInMillis = -1000 /**Send right away **/;
		int numAttempt = 1;
		DelayCallback dc = new DelayCallback(message, delayInMillis, numAttempt);
		receivedMessages.add(dc);
	}

	private String followRedirect(String redirectUrl, int redirectCount, String origUrl) {

		if (redirectCount > MAX_REDIRECTS) {
			log.error(""Max redirect reached for callback url=[{}]"", origUrl);
			return null;
		}

		URL presUrl;
		try {
			presUrl = new URL(redirectUrl);
		} catch (MalformedURLException e) {
			log.error(""Malformed callback url=[{}]"", redirectUrl);
			return null;
		}

		HttpURLConnection conn;
		try {
			conn = (HttpURLConnection) presUrl.openConnection();
			conn.setReadTimeout(5000);
			conn.addRequestProperty(""Accept-Language"", ""en-US,en;q=0.8"");
			conn.addRequestProperty(""User-Agent"", ""Mozilla"");

			// normally, 3xx is redirect
			int status = conn.getResponseCode();
			if (status != HttpURLConnection.HTTP_OK) {
				if (status == HttpURLConnection.HTTP_MOVED_TEMP
								|| status == HttpURLConnection.HTTP_MOVED_PERM
								|| status == HttpURLConnection.HTTP_SEE_OTHER) {
					String newUrl = conn.getHeaderField(""Location"");
					return followRedirect(newUrl, redirectCount + 1, origUrl);
				} else {
					log.error(""Invalid HTTP response=[{}] for callback url=[{}]"", status, redirectUrl);
					return null;
				}
			} else {
				return redirectUrl;
			}
		} catch (IOException e) {
			log.error(""IOException for callback url=[{}]"", redirectUrl);
			return null;
		}
	}

	private boolean fetchCallbackUrl(final String callbackUrl) {
		// Do not handle redirects as we must expect that the passed
		// in callback url on meeting create must be working.
		//String finalUrl = followRedirect(callbackUrl, 0, callbackUrl);
		//log.info(""Calling callback url {}"", finalUrl);
		//if (finalUrl == null) return false;

		boolean success = false;

		CloseableHttpAsyncClient httpclient = HttpAsyncClients.createDefault();
		try {
			httpclient.start();

			HttpGet request = new HttpGet(callbackUrl);

			Future<HttpResponse> future = httpclient.execute(request, null);
			HttpResponse response = future.get();
			// Consider 2xx response code as success.
			success = (response.getStatusLine().getStatusCode() >= 200 && response.getStatusLine().getStatusCode() < 300);
		} catch (java.lang.InterruptedException ex) {
			log.error(""Interrupted exception while calling url {}"", callbackUrl);
		} catch (java.util.concurrent.ExecutionException ex) {
			log.error(""ExecutionException exception while calling url {}"", callbackUrl);
		} finally {
			try {
				httpclient.close();
			} catch (java.io.IOException ex) {
				log.error(""IOException exception while closing http client for url {}"", callbackUrl);
			}
		}

		return success;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/KeepAliveMessage.java,"package org.bigbluebutton.web.services;

public interface KeepAliveMessage {

}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/KeepAliveService.java,"/**
 * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
 * <p>
 * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
 * <p>
 * This program is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 3.0 of the License, or (at your option) any later
 * version.
 * <p>
 * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * <p>
 * You should have received a copy of the GNU Lesser General Public License along
 * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 */

package org.bigbluebutton.web.services;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.bigbluebutton.api.messaging.MessageListener;
import org.bigbluebutton.api.messaging.messages.IMessage;
import org.bigbluebutton.api.messaging.messages.KeepAliveReply;
import org.bigbluebutton.api2.IBbbWebApiGWApp;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class KeepAliveService implements MessageListener {
  private static Logger log = LoggerFactory.getLogger(KeepAliveService.class);
  private static final String KEEP_ALIVE_REQUEST = ""KEEP_ALIVE_REQUEST"";
  private IBbbWebApiGWApp gw;
  private long runEvery = 10000;
  private static int maxLives = 5;
  private KeepAliveTask task = new KeepAliveTask();
  private volatile boolean processMessages = false;

  volatile boolean available = true;

  private static final Executor msgSenderExec = Executors.newFixedThreadPool(1);
  private static final Executor runExec = Executors.newFixedThreadPool(1);

  private ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(1);

  private BlockingQueue<KeepAliveMessage> messages = new LinkedBlockingQueue<KeepAliveMessage>();

  private Long lastKeepAliveMessage = 0L;
  private Long lastAkkaAppsTimestamp = 0L;

  private static final String SYSTEM = ""BbbWeb"";

  public void start() {
    scheduledThreadPool.scheduleWithFixedDelay(task, 5000, runEvery, TimeUnit.MILLISECONDS);
    processKeepAliveMessage();
  }

  public void stop() {
    processMessages = false;
    scheduledThreadPool.shutdownNow();
  }

  public void setRunEvery(long v) {
    runEvery = v * 1000;
  }

  public void setGw(IBbbWebApiGWApp gw) {
    this.gw = gw;
  }

  class KeepAliveTask implements Runnable {
    public void run() {
      KeepAlivePing ping = new KeepAlivePing();
      queueMessage(ping);
    }
  }

  public boolean isDown() {
    return !available;
  }

  private void queueMessage(KeepAliveMessage msg) {
    messages.add(msg);
  }

  private void processKeepAliveMessage() {
    processMessages = true;
    Runnable sender = new Runnable() {
      public void run() {
        while (processMessages) {
          KeepAliveMessage message;
          try {
            message = messages.take();
            processMessage(message);
          } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
          } catch (Exception e) {
            log.error(""Catching exception [{}]"", e.toString());
          }
        }
      }
    };
    msgSenderExec.execute(sender);
  }

  private void processMessage(final KeepAliveMessage msg) {
    Runnable task = new Runnable() {
      public void run() {
        if (msg instanceof KeepAlivePing) {
          processPing((KeepAlivePing) msg);
        } else if (msg instanceof KeepAlivePong) {
          processPong((KeepAlivePong) msg);
        }
      }
    };

    runExec.execute(task);
  }

  private void processPing(KeepAlivePing msg) {
    gw.sendKeepAlive(SYSTEM, System.currentTimeMillis(), lastAkkaAppsTimestamp);
    Boolean akkaAppsIsAvailable = available;

    if (lastKeepAliveMessage != 0 && (System.currentTimeMillis() - lastKeepAliveMessage > 30000)) {
      if (akkaAppsIsAvailable) {
        log.error(""BBB Web pubsub error!"");
        // BBB-Apps has gone down. Mark it as unavailable. (ralam - april 29, 2014)
        available = false;
      }
    }
  }

  private void processPong(KeepAlivePong msg) {
    if (lastKeepAliveMessage != 0 && !available) {
      log.error(""BBB Web pubsub recovered!"");
    }

    lastKeepAliveMessage = System.currentTimeMillis();
    lastAkkaAppsTimestamp = msg.akkaAppsTimestamp;
    available = true;
  }

  private void handleKeepAliveReply(String system, Long bbbWebTimestamp, Long akkaAppsTimestamp) {
    if (SYSTEM.equals(system)) {
      KeepAlivePong pong = new KeepAlivePong(system, bbbWebTimestamp, akkaAppsTimestamp);
      queueMessage(pong);
    }
  }

  @Override
  public void handle(IMessage message) {
    if (message instanceof KeepAliveReply) {
      KeepAliveReply msg = (KeepAliveReply) message;
      handleKeepAliveReply(msg.system, msg.bbbWebTimestamp, msg.akkaAppsTimestamp);
    }
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/UserCleanupTimerTask.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
*
* Copyright (c) 2020 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
*
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.web.services;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.bigbluebutton.api.MeetingService;

public class UserCleanupTimerTask {

    private MeetingService service;
    private ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(1);
    private long runEvery = 15000;

    public void setMeetingService(MeetingService svc) {
        this.service = svc;
    }

    public void start() {
        scheduledThreadPool.scheduleWithFixedDelay(new CleanupTask(), 60000, runEvery, TimeUnit.MILLISECONDS);
    }

    public void stop() {
        scheduledThreadPool.shutdownNow();
    }

    public void setRunEvery(long v) {
        runEvery = v;
    }

    private class CleanupTask implements Runnable {
        @Override
        public void run() {
            service.purgeUsers();
        }
    }
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/turn/RemoteIceCandidate.java,"package org.bigbluebutton.web.services.turn;

public class RemoteIceCandidate {

  public final String ip;

  public RemoteIceCandidate(String ip) {
    this.ip = ip;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/turn/StunTurnService.java,"package org.bigbluebutton.web.services.turn;

import java.util.HashSet;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class StunTurnService {
  private static Logger log = LoggerFactory.getLogger(StunTurnService.class);

  private Set<StunServer> stunServers;
  private Set<TurnServer> turnServers;
  private Set<RemoteIceCandidate> remoteIceCandidates;

  public Set<StunServer> getStunServers() {
    log.info(""\nStunTurnService::getStunServers \n"");
    return stunServers;
  }

  public Set<TurnEntry> getStunAndTurnServersFor(String userId) {
    log.info(""\nStunTurnService::getStunAndTurnServersFor "" + userId + ""\n"");
    Set<TurnEntry> turns = new HashSet<TurnEntry>();

    for (TurnServer ts : turnServers) {
      TurnEntry entry = ts.generatePasswordFor(userId);
      if (entry != null) {
        turns.add(entry);
      }
    }
    
    return turns;
  }

  public Set<RemoteIceCandidate> getRemoteIceCandidates() {
    return remoteIceCandidates;
  }

  public void setStunServers(Set<StunServer> stuns) {
    stunServers = stuns;
  }

  public void setTurnServers(Set<TurnServer> turns) {
    turnServers = turns;
  }

  public void setRemoteIceCandidates(Set<RemoteIceCandidate> candidates) {
    remoteIceCandidates = candidates;
  }

}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/turn/StunServer.java,"package org.bigbluebutton.web.services.turn;

public class StunServer {

  public final String url;
  
  public StunServer(String url) {
    this.url = url;
  }
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/turn/TurnServer.java,"package org.bigbluebutton.web.services.turn;

import java.security.SignatureException;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;

public class TurnServer {

  private static final String HMAC_SHA1_ALGORITHM = ""HmacSHA1"";
  private static final String COLON = "":"";
  
  private final String secretKey;
  private final String url;
  private final int ttl;

  public TurnServer(String secretKey, String url, int ttl) {
    this.secretKey = secretKey;
    this.url = url;
    this.ttl = ttl;
  }

  public TurnEntry generatePasswordFor(String userId) {
    TurnEntry turn = null;
    
    try {
      long expiryTime = System.currentTimeMillis() / 1000 + ttl;
      String username = expiryTime + COLON + userId;
      String password = calculateRFC2104HMAC(username, secretKey);
      turn = new TurnEntry(username, password, ttl, url);
    } catch (SignatureException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }

    return turn;
  }




  /**
   * Computes RFC 2104-compliant HMAC signature.
   * * @param data
   * The data to be signed.
   * @param key
   * The signing key.
   * @return
   * The Base64-encoded RFC 2104-compliant HMAC signature.
   * @throws
   * java.security.SignatureException when signature generation fails
   */
  private String calculateRFC2104HMAC(String data, String key)
      throws java.security.SignatureException
      {
    String result;
    try {

      // get an hmac_sha1 key from the raw key bytes
      SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM);

      // get an hmac_sha1 Mac instance and initialize with the signing key
      Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);
      mac.init(signingKey);

      // compute the hmac on input data bytes
      byte[] rawHmac = mac.doFinal(data.getBytes());

      // base64-encode the hmac
      result = new String(Base64.encodeBase64(rawHmac));

    } catch (Exception e) {
      throw new SignatureException(""Failed to generate HMAC : "" + e.getMessage());
    }
    return result;
      }
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/turn/TurnEntry.java,"package org.bigbluebutton.web.services.turn;

public class TurnEntry {

  public final String username;
  public final String url;
  public final String password;
  public final int ttl;
  
  public TurnEntry(String username, String password, int ttl, String url) {
    this.username = username;
    this.url = url;
    this.password = password;
    this.ttl = ttl;
  }
/*  
  public String getUsername() {
    return username;
  }
  
  public String getUrl() {
    return url;
  }
  
  public String getPassord() {
    return password;
  }
  
  public int getTtl() {
    return ttl;
  }
  */
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/KeepAlivePong.java,"package org.bigbluebutton.web.services;

public class KeepAlivePong implements KeepAliveMessage {

	public final String system;
	public final Long bbbWebTimestamp;
	public final Long akkaAppsTimestamp;

	public KeepAlivePong(String system, Long bbbWebTimestamp, Long akkaAppsTimestamp) {
		this.system = system;
		this.bbbWebTimestamp = bbbWebTimestamp;
		this.akkaAppsTimestamp = akkaAppsTimestamp;
	}
}"
bbb-common-web/src/main/java/org/bigbluebutton/web/services/KeepAlivePing.java,"package org.bigbluebutton.web.services;

public class KeepAlivePing implements KeepAliveMessage {

	public KeepAlivePing() {
	}
}"
bbb-common-web/deploy.sh,"#!/bin/bash

#Publish new bbb-common-web .jar
sbt clean 
# rm -r target/ project/target/ project/project/ lib_managed/
sbt update publish publishLocal"
bbb-common-web/psql.sh,"#!/bin/bash
. .env
echo ""==================     Help for psql   =========================""
echo ""\\dt		: Describe the current database""
echo ""\\d [table]	: Describe a table""
echo ""\\c		: Connect to a database""
echo ""\\h		: help with SQL commands""
echo ""\\?		: help with psql commands""
echo ""\\q		: quit""
echo ""Reset the database using the truncate_tables('$POSTGRES_USER') function""
echo ""==================================================================""
docker exec -it postgres psql -U $POSTGRES_USER -d bbb"
bbb-common-web/docker-clean.sh,"#!/bin/bash
docker rm -f $(docker ps -aq)"
bbb-common-web/hibernate-cfg.sh,"#!/bin/bash
. .env
mkdir -p ./src/main/resources
echo '<!DOCTYPE hibernate-configuration PUBLIC
        ""-//Hibernate/Hibernate Configuration DTD 3.0//EN""
        ""http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"">
      <hibernate-configuration>
        <session-factory>
          <!-- JDBC Database connection settings -->
	  <property name=""connection.driver_class"">org.postgresql.Driver</property>
          <property name=""connection.url"">jdbc:postgresql://localhost:'""$HOST_PORT""'/'""$POSTGRES_USER""'</property>
          <property name=""connection.username"">'""$POSTGRES_USER""'</property>
          <property name=""connection.password"">'""$POSTGRES_PASSWORD""'</property>
          <!-- JDBC connection pool settings -->
          <property name=""hibernate.connection.provider_class"">com.zaxxer.hikari.hibernate.HikariConnectionProvider</property>
          <property name=""hibernate.hikari.minimumIdle"">5</property>
          <property name=""hibernate.hikari.maximumPoolSize"">10</property>
          <property name=""hibernate.hikari.idleTimeout"">30000</property>
          <!-- Select our SQL dialect -->
          <property name=""dialect"">org.hibernate.dialect.PostgreSQL10Dialect</property>
          <!-- Echo the SQL to stdout -->
          <property name=""show_sql"">true</property>
          <!-- Set the current session context -->
          <property name=""current_session_context_class"">thread</property>
          <property name=""hibernate.show_sql"">false</property>
          <!-- format the sql nice -->
          <property name=""hibernate.format_sql"">false</property>
          <!-- show the hql as comment -->
          <property name=""use_sql_comments"">false</property>
        </session-factory>
      </hibernate-configuration>' > ./src/main/resources/hibernate.cfg.xml"
akka-bbb-apps/src/test/java/org/bigbluebutton/xml/Simple.java,"package org.bigbluebutton.xml;

public class Simple {
  public int x = 1;
  public int y = 2;
}"
akka-bbb-apps/src/main/scala/org/bigbluebutton/core/util/jhotdraw/BezierWrapper.java,"package org.bigbluebutton.core.util.jhotdraw;

import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.List;

public class BezierWrapper {
  
  private BezierWrapper() {}
  
  public static PathData lineSimplifyAndCurve(List<Float> points, int oWidth, int oHeight) {
    ArrayList<Point2D.Double> startingLine = new ArrayList<Point2D.Double>();
    //denormalize and turn into point2d
    for (int i=0; i<points.size(); i+=2) {
      startingLine.add(new Point2D.Double(denormalize(points.get(i), oWidth),denormalize(points.get(i+1), oHeight)));
    }
    
    //fit it
    BezierPath endPath = Bezier.fitBezierPath(startingLine, 1d);
    
    //get raw path
    PathData rawPath = endPath.toRawPath();
    
    // normalize
    ArrayList<Float> rtnPoints  = new ArrayList<Float>();
    ArrayList<Double> coords = rawPath.coords;
    for (int i=0; i<coords.size(); i+=2) {
      rtnPoints.add(normalize(coords.get(i), oWidth));
      rtnPoints.add(normalize(coords.get(i+1), oHeight));
    }
    
    // return
    rawPath.points = rtnPoints;
    return rawPath;
  }
  
  private static Double denormalize(Float val, int max) {
    return ((double) val)/100d*max;
  }
  
  private static Float normalize(Double val, int max) {
    return ((Double)(val/max*100)).floatValue();
  }
  
}"
akka-bbb-apps/src/main/scala/org/bigbluebutton/core/util/jhotdraw/Geom.java,"/*
 * @(#)Geom.java
 *
 * Full JHotDraw project information can be found here https://sourceforge.net/projects/jhotdraw/
 * 
 * Copyright (c) 1996-2010 The authors and contributors of JHotDraw.
 * You may not use, copy or modify this file, except in compliance with the 
 * accompanying license terms.
 *
 * These release is distributed under LGPL.
 
 * The original version of JHotDraw is copyright 1996, 1997 by IFA Informatik 
 * and Erich Gamma.
 *
 * It is hereby granted that this software can be used, copied, modified, and 
 * distributed without fee provided that this copyright noticeappears in all copies.
 */

package org.bigbluebutton.core.util.jhotdraw;

import java.awt.*;
import java.awt.geom.*;
import static java.lang.Math.*;

/**
 * Some geometric utilities.
 *
 * @version $Id$
 */
public class Geom {

    private Geom() {
    } // never instantiated

    /**
     * Tests if a point is on a line.
     */
    public static boolean lineContainsPoint(int x1, int y1,
            int x2, int y2,
            int px, int py) {
        return lineContainsPoint(x1, y1, x2, y2, px, py, 3d);
    }

    /**
     * Tests if a point is on a line.
     * <p>changed Werner Randelshofer 2003-11-26
     */
    public static boolean lineContainsPoint(int x1, int y1,
            int x2, int y2,
            int px, int py, double tolerance) {

        Rectangle r = new Rectangle(new Point(x1, y1));
        r.add(x2, y2);
        r.grow(max(2, (int) ceil(tolerance)), max(2, (int) ceil(tolerance)));
        if (!r.contains(px, py)) {
            return false;
        }

        double a, b, x, y;

        if (x1 == x2) {
            return (abs(px - x1) <= tolerance);
        }
        if (y1 == y2) {
            return (abs(py - y1) <= tolerance);
        }

        a = (double) (y1 - y2) / (double) (x1 - x2);
        b = (double) y1 - a * (double) x1;
        x = (py - b) / a;
        y = a * px + b;

        return (min(abs(x - px), abs(y - py)) <= tolerance);
    }

    /**
     * Tests if a point is on a line.
     * <p>changed Werner Randelshofer 2003-11-26
     */
    public static boolean lineContainsPoint(double x1, double y1,
            double x2, double y2,
            double px, double py, double tolerance) {

        Rectangle2D.Double r = new Rectangle2D.Double(x1, y1, 0, 0);
        r.add(x2, y2);
        double grow = max(2, (int) ceil(tolerance));
        r.x -= grow;
        r.y -= grow;
        r.width += grow * 2;
        r.height += grow * 2;
        if (!r.contains(px, py)) {
            return false;
        }

        double a, b, x, y;

        if (x1 == x2) {
            return (abs(px - x1) <= tolerance);
        }
        if (y1 == y2) {
            return (abs(py - y1) <= tolerance);
        }

        a = (y1 - y2) / (x1 - x2);
        b = y1 - a * x1;
        x = (py - b) / a;
        y = a * px + b;

        return (min(abs(x - px), abs(y - py)) <= tolerance);
    }
    /** The bitmask that indicates that a point lies above the rectangle. */
    public static final int OUT_TOP = Rectangle2D.OUT_TOP;
    /** The bitmask that indicates that a point lies below the rectangle. */
    public static final int OUT_BOTTOM = Rectangle2D.OUT_BOTTOM;
    /** The bitmask that indicates that a point lies to the left of the rectangle. */
    public static final int OUT_LEFT = Rectangle2D.OUT_LEFT;
    /** The bitmask that indicates that a point lies to the right of the rectangle. */
    public static final int OUT_RIGHT = Rectangle2D.OUT_RIGHT;

    /**
     * Returns the direction OUT_TOP, OUT_BOTTOM, OUT_LEFT, OUT_RIGHT from
     * one point to another one.
     */
    public static int direction(int x1, int y1, int x2, int y2) {
        int direction = 0;
        int vx = x2 - x1;
        int vy = y2 - y1;

        if (vy < vx && vx > -vy) {
            direction = OUT_RIGHT;
        } else if (vy > vx && vy > -vx) {
            direction = OUT_TOP;
        } else if (vx < vy && vx < -vy) {
            direction = OUT_LEFT;
        } else {
            direction = OUT_BOTTOM;
        }
        return direction;
    }

    /**
     * Returns the direction OUT_TOP, OUT_BOTTOM, OUT_LEFT, OUT_RIGHT from
     * one point to another one.
     */
    public static int direction(double x1, double y1, double x2, double y2) {
        int direction = 0;
        double vx = x2 - x1;
        double vy = y2 - y1;

        if (vy < vx && vx > -vy) {
            direction = OUT_RIGHT;
        } else if (vy > vx && vy > -vx) {
            direction = OUT_TOP;
        } else if (vx < vy && vx < -vy) {
            direction = OUT_LEFT;
        } else {
            direction = OUT_BOTTOM;
        }
        return direction;
    }

    /**
     * This method computes a binary OR of the appropriate mask values
     * indicating, for each side of Rectangle r1, whether or not the
     * Rectangle r2 is on the same side of the edge as the rest
     * of this Rectangle.
     *
     *
     *
     *
     *
     *
     *
     *
     * @return the logical OR of all appropriate out codes OUT_RIGHT, OUT_LEFT, OUT_BOTTOM,
     * OUT_TOP.
     */
    public static int outcode(Rectangle r1, Rectangle r2) {
        int outcode = 0;

        if (r2.x > r1.x + r1.width) {
            outcode = OUT_RIGHT;
        } else if (r2.x + r2.width < r1.x) {
            outcode = OUT_LEFT;
        }

        if (r2.y > r1.y + r1.height) {
            outcode |= OUT_BOTTOM;
        } else if (r2.y + r2.height < r1.y) {
            outcode |= OUT_TOP;
        }

        return outcode;
    }

    /**
     * This method computes a binary OR of the appropriate mask values
     * indicating, for each side of Rectangle r1, whether or not the
     * Rectangle r2 is on the same side of the edge as the rest
     * of this Rectangle.
     *
     *
     *
     *
     *
     *
     *
     *
     * @return the logical OR of all appropriate out codes OUT_RIGHT, OUT_LEFT, OUT_BOTTOM,
     * OUT_TOP.
     */
    public static int outcode(Rectangle2D.Double r1, Rectangle2D.Double r2) {
        int outcode = 0;

        if (r2.x > r1.x + r1.width) {
            outcode = OUT_RIGHT;
        } else if (r2.x + r2.width < r1.x) {
            outcode = OUT_LEFT;
        }

        if (r2.y > r1.y + r1.height) {
            outcode |= OUT_BOTTOM;
        } else if (r2.y + r2.height < r1.y) {
            outcode |= OUT_TOP;
        }

        return outcode;
    }

    public static Point south(Rectangle r) {
        return new Point(r.x + r.width / 2, r.y + r.height);
    }

    public static Point2D.Double south(Rectangle2D.Double r) {
        return new Point2D.Double(r.x + r.width / 2, r.y + r.height);
    }

    public static Point center(Rectangle r) {
        return new Point(r.x + r.width / 2, r.y + r.height / 2);
    }

    public static Point2D.Double center(Rectangle2D.Double r) {
        return new Point2D.Double(r.x + r.width / 2, r.y + r.height / 2);
    }

    /**
     * Returns a point on the edge of the shape which crosses the line
     * from the center of the shape to the specified point.
     * If no edge crosses of the shape crosses the line, the nearest control
     * point of the shape is returned.
     */
    public static Point2D.Double chop(Shape shape, Point2D.Double p) {
        Rectangle2D bounds = shape.getBounds2D();
        Point2D.Double ctr = new Point2D.Double(bounds.getCenterX(), bounds.getCenterY());

        // Chopped point
        double cx = -1;
        double cy = -1;
        double len = Double.MAX_VALUE;

        // Try for points along edge
        PathIterator i = shape.getPathIterator(new AffineTransform(), 1);
        double[] coords = new double[6];
        double prevX = coords[0];
        double prevY = coords[1];
        double moveToX = prevX;
        double moveToY = prevY;
        i.next();
        for (; !i.isDone(); i.next()) {
            switch (i.currentSegment(coords)) {
                case PathIterator.SEG_MOVETO:
                    moveToX = coords[0];
                    moveToY = coords[1];
                    break;
                case PathIterator.SEG_CLOSE:
                    coords[0] = moveToX;
                    coords[1] = moveToY;
                    break;
            }
            Point2D.Double chop = Geom.intersect(
                    prevX, prevY,
                    coords[0], coords[1],
                    p.x, p.y,
                    ctr.x, ctr.y);

            if (chop != null) {
                double cl = Geom.length2(chop.x, chop.y, p.x, p.y);
                if (cl < len) {
                    len = cl;
                    cx = chop.x;
                    cy = chop.y;
                }
            }

            prevX = coords[0];
            prevY = coords[1];
        }

        /*
        if (isClosed() && size() > 1) {
        Node first = get(0);
        Node last = get(size() - 1);
        Point2D.Double chop = Geom.intersect(
        first.x[0], first.y[0],
        last.x[0], last.y[0],
        p.x, p.y,
        ctr.x, ctr.y
        );
        if (chop != null) {
        double cl = Geom.length2(chop.x, chop.y, p.x, p.y);
        if (cl < len) {
        len = cl;
        cx = chop.x;
        cy = chop.y;
        }
        }
        }*/


        // if none found, pick closest vertex
        if (len == Double.MAX_VALUE) {
            i = shape.getPathIterator(new AffineTransform(), 1);
            for (; !i.isDone(); i.next()) {
                i.currentSegment(coords);

                double l = Geom.length2(ctr.x, ctr.y, coords[0], coords[1]);
                if (l < len) {
                    len = l;
                    cx = coords[0];
                    cy = coords[1];
                }
            }
        }
        return new Point2D.Double(cx, cy);
    }

    public static Point west(Rectangle r) {
        return new Point(r.x, r.y + r.height / 2);
    }

    public static Point2D.Double west(Rectangle2D.Double r) {
        return new Point2D.Double(r.x, r.y + r.height / 2);
    }

    public static Point east(Rectangle r) {
        return new Point(r.x + r.width, r.y + r.height / 2);
    }

    public static Point2D.Double east(Rectangle2D.Double r) {
        return new Point2D.Double(r.x + r.width, r.y + r.height / 2);
    }

    public static Point north(Rectangle r) {
        return new Point(r.x + r.width / 2, r.y);
    }

    public static Point2D.Double north(Rectangle2D.Double r) {
        return new Point2D.Double(r.x + r.width / 2, r.y);
    }

    /**
     * Constains a value to the given range.
     * @return the constrained value
     */
    public static int range(int min, int max, int value) {
        if (value < min) {
            value = min;
        }
        if (value > max) {
            value = max;
        }
        return value;
    }

    /**
     * Constains a value to the given range.
     * @return the constrained value
     */
    public static double range(double min, double max, double value) {
        if (value < min) {
            value = min;
        }
        if (value > max) {
            value = max;
        }
        return value;
    }

    /**
     * Gets the square distance between two points.
     */
    public static long length2(int x1, int y1, int x2, int y2) {
        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    }

    /**
     * Gets the distance between to points
     */
    public static long length(int x1, int y1, int x2, int y2) {
        return (long) sqrt(length2(x1, y1, x2, y2));
    }

    /**
     * Gets the square distance between two points.
     */
    public static double length2(double x1, double y1, double x2, double y2) {
        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    }

    /**
     * Gets the distance between to points
     */
    public static double length(double x1, double y1, double x2, double y2) {
        return sqrt(length2(x1, y1, x2, y2));
    }

    /**
     * Gets the distance between to points
     */
    public static double length(Point2D.Double p1, Point2D.Double p2) {
        return sqrt(length2(p1.x, p1.y, p2.x, p2.y));
    }

    /**
     * Caps the line defined by p1 and p2 by the number of units
     * specified by radius.
     * @return A new end point for the line.
     */
    public static Point2D.Double cap(Point2D.Double p1, Point2D.Double p2, double radius) {
        double angle = PI / 2 - atan2(p2.x - p1.x, p2.y - p1.y);
        Point2D.Double p3 = new Point2D.Double(
                p2.x + radius * cos(angle),
                p2.y + radius * sin(angle));
        return p3;
    }

    /**
     * Gets the angle of a point relative to a rectangle.
     */
    public static double pointToAngle(Rectangle r, Point p) {
        int px = p.x - (r.x + r.width / 2);
        int py = p.y - (r.y + r.height / 2);
        return atan2(py * r.width, px * r.height);
    }

    /**
     * Gets the angle of a point relative to a rectangle.
     */
    public static double pointToAngle(Rectangle2D.Double r, Point2D.Double p) {
        double px = p.x - (r.x + r.width / 2);
        double py = p.y - (r.y + r.height / 2);
        return atan2(py * r.width, px * r.height);
    }

    /**
     * Gets the angle of the specified line.
     */
    public static double angle(double x1, double y1, double x2, double y2) {
        return atan2(y2 - y1, x2 - x1);
    }

    /**
     * Gets the point on a rectangle that corresponds to the given angle.
     */
    public static Point angleToPoint(Rectangle r, double angle) {
        double si = sin(angle);
        double co = cos(angle);
        double e = 0.0001;

        int x = 0, y = 0;
        if (abs(si) > e) {
            x = (int) ((1.0 + co / abs(si)) / 2.0 * r.width);
            x = range(0, r.width, x);
        } else if (co >= 0.0) {
            x = r.width;
        }
        if (abs(co) > e) {
            y = (int) ((1.0 + si / abs(co)) / 2.0 * r.height);
            y = range(0, r.height, y);
        } else if (si >= 0.0) {
            y = r.height;
        }
        return new Point(r.x + x, r.y + y);
    }

    /**
     * Gets the point on a rectangle that corresponds to the given angle.
     */
    public static Point2D.Double angleToPoint(Rectangle2D.Double r, double angle) {
        double si = sin(angle);
        double co = cos(angle);
        double e = 0.0001;

        double x = 0, y = 0;
        if (abs(si) > e) {
            x = (1.0 + co / abs(si)) / 2.0 * r.width;
            x = range(0, r.width, x);
        } else if (co >= 0.0) {
            x = r.width;
        }
        if (abs(co) > e) {
            y = (1.0 + si / abs(co)) / 2.0 * r.height;
            y = range(0, r.height, y);
        } else if (si >= 0.0) {
            y = r.height;
        }
        return new Point2D.Double(r.x + x, r.y + y);
    }

    /**
     * Converts a polar to a point
     */
    public static Point polarToPoint(double angle, double fx, double fy) {
        double si = sin(angle);
        double co = cos(angle);
        return new Point((int) (fx * co + 0.5), (int) (fy * si + 0.5));
    }

    /**
     * Converts a polar to a point
     */
    public static Point2D.Double polarToPoint2D(double angle, double fx, double fy) {
        double si = sin(angle);
        double co = cos(angle);
        return new Point2D.Double(fx * co + 0.5, fy * si + 0.5);
    }

    /**
     * Gets the point on an oval that corresponds to the given angle.
     */
    public static Point ovalAngleToPoint(Rectangle r, double angle) {
        Point center = Geom.center(r);
        Point p = Geom.polarToPoint(angle, r.width / 2, r.height / 2);
        return new Point(center.x + p.x, center.y + p.y);
    }

    /**
     * Gets the point on an oval that corresponds to the given angle.
     */
    public static Point2D.Double ovalAngleToPoint(Rectangle2D.Double r, double angle) {
        Point2D.Double center = Geom.center(r);
        Point2D.Double p = Geom.polarToPoint2D(angle, r.width / 2, r.height / 2);
        return new Point2D.Double(center.x + p.x, center.y + p.y);
    }

    /**
     * Standard line intersection algorithm
     * Return the point of intersection if it exists, else null.
     **/
    public static Point intersect(int xa, // line 1 point 1 x
            // from Doug Lea's PolygonFigure
            int ya, // line 1 point 1 y
            int xb, // line 1 point 2 x
            int yb, // line 1 point 2 y
            int xc, // line 2 point 1 x
            int yc, // line 2 point 1 y
            int xd, // line 2 point 2 x
            int yd) { // line 2 point 2 y

        // source: http://vision.dai.ed.ac.uk/andrewfg/c-g-a-faq.html
        // eq: for lines AB and CD
        //     (YA-YC)(XD-XC)-(XA-XC)(YD-YC)
        // r = -----------------------------  (eqn 1)
        //     (XB-XA)(YD-YC)-(YB-YA)(XD-XC)
        //
        //     (YA-YC)(XB-XA)-(XA-XC)(YB-YA)
        // s = -----------------------------  (eqn 2)
        //     (XB-XA)(YD-YC)-(YB-YA)(XD-XC)
        //  XI = XA + r(XB-XA)
        //  YI = YA + r(YB-YA)

        double denom = ((xb - xa) * (yd - yc) - (yb - ya) * (xd - xc));

        double rnum = ((ya - yc) * (xd - xc) - (xa - xc) * (yd - yc));

        if (denom == 0.0) { // parallel
            if (rnum == 0.0) { // coincident; pick one end of first line
                if ((xa < xb && (xb < xc || xb < xd))
                        || (xa > xb && (xb > xc || xb > xd))) {
                    return new Point(xb, yb);
                } else {
                    return new Point(xa, ya);
                }
            } else {
                return null;
            }
        }

        double r = rnum / denom;
        double snum = ((ya - yc) * (xb - xa) - (xa - xc) * (yb - ya));
        double s = snum / denom;

        if (0.0 <= r && r <= 1.0 && 0.0 <= s && s <= 1.0) {
            int px = (int) (xa + (xb - xa) * r);
            int py = (int) (ya + (yb - ya) * r);
            return new Point(px, py);
        } else {
            return null;
        }
    }

    /**
     * Standard line intersection algorithm
     * Return the point of intersection if it exists, else null
     **/
    // from Doug Lea's PolygonFigure
    public static Point2D.Double intersect(double xa, // line 1 point 1 x
            double ya, // line 1 point 1 y
            double xb, // line 1 point 2 x
            double yb, // line 1 point 2 y
            double xc, // line 2 point 1 x
            double yc, // line 2 point 1 y
            double xd, // line 2 point 2 x
            double yd) { // line 2 point 2 y

        // source: http://vision.dai.ed.ac.uk/andrewfg/c-g-a-faq.html
        // eq: for lines AB and CD
        //     (YA-YC)(XD-XC)-(XA-XC)(YD-YC)
        // r = -----------------------------  (eqn 1)
        //     (XB-XA)(YD-YC)-(YB-YA)(XD-XC)
        //
        //     (YA-YC)(XB-XA)-(XA-XC)(YB-YA)
        // s = -----------------------------  (eqn 2)
        //     (XB-XA)(YD-YC)-(YB-YA)(XD-XC)
        //  XI = XA + r(XB-XA)
        //  YI = YA + r(YB-YA)

        double denom = ((xb - xa) * (yd - yc) - (yb - ya) * (xd - xc));

        double rnum = ((ya - yc) * (xd - xc) - (xa - xc) * (yd - yc));

        if (denom == 0.0) { // parallel
            if (rnum == 0.0) { // coincident; pick one end of first line
                if ((xa < xb && (xb < xc || xb < xd))
                        || (xa > xb && (xb > xc || xb > xd))) {
                    return new Point2D.Double(xb, yb);
                } else {
                    return new Point2D.Double(xa, ya);
                }
            } else {
                return null;
            }
        }

        double r = rnum / denom;
        double snum = ((ya - yc) * (xb - xa) - (xa - xc) * (yb - ya));
        double s = snum / denom;

        if (0.0 <= r && r <= 1.0 && 0.0 <= s && s <= 1.0) {
            double px = xa + (xb - xa) * r;
            double py = ya + (yb - ya) * r;
            return new Point2D.Double(px, py);
        } else {
            return null;
        }
    }

    public static Point2D.Double intersect(
            double xa, // line 1 point 1 x
            double ya, // line 1 point 1 y
            double xb, // line 1 point 2 x
            double yb, // line 1 point 2 y
            double xc, // line 2 point 1 x
            double yc, // line 2 point 1 y
            double xd, // line 2 point 2 x
            double yd,
            double limit) { // line 2 point 2 y

        // source: http://vision.dai.ed.ac.uk/andrewfg/c-g-a-faq.html
        // eq: for lines AB and CD
        //     (YA-YC)(XD-XC)-(XA-XC)(YD-YC)
        // r = -----------------------------  (eqn 1)
        //     (XB-XA)(YD-YC)-(YB-YA)(XD-XC)
        //
        //     (YA-YC)(XB-XA)-(XA-XC)(YB-YA)
        // s = -----------------------------  (eqn 2)
        //     (XB-XA)(YD-YC)-(YB-YA)(XD-XC)
        //  XI = XA + r(XB-XA)
        //  YI = YA + r(YB-YA)

        double denom = ((xb - xa) * (yd - yc) - (yb - ya) * (xd - xc));

        double rnum = ((ya - yc) * (xd - xc) - (xa - xc) * (yd - yc));

        if (denom == 0.0) { // parallel
            if (rnum == 0.0) { // coincident; pick one end of first line
                if ((xa < xb && (xb < xc || xb < xd))
                        || (xa > xb && (xb > xc || xb > xd))) {
                    return new Point2D.Double(xb, yb);
                } else {
                    return new Point2D.Double(xa, ya);
                }
            } else {
                return null;
            }
        }

        double r = rnum / denom;
        double snum = ((ya - yc) * (xb - xa) - (xa - xc) * (yb - ya));
        double s = snum / denom;

        if (0.0 <= r && r <= 1.0 && 0.0 <= s && s <= 1.0) {
            double px = xa + (xb - xa) * r;
            double py = ya + (yb - ya) * r;
            return new Point2D.Double(px, py);
        } else {
            double px = xa + (xb - xa) * r;
            double py = ya + (yb - ya) * r;

            if (length(xa, ya, px, py) <= limit
                    || length(xb, yb, px, py) <= limit
                    || length(xc, yc, px, py) <= limit
                    || length(xd, yd, px, py) <= limit) {
                return new Point2D.Double(px, py);
            }

            return null;
        }
    }

    /**
     * compute distance of point from line segment, or
     * Double.MAX_VALUE if perpendicular projection is outside segment; or
     * If pts on line are same, return distance from point
     **/
    // from Doug Lea's PolygonFigure
    public static double distanceFromLine(int xa, int ya,
            int xb, int yb,
            int xc, int yc) {


        // source:http://vision.dai.ed.ac.uk/andrewfg/c-g-a-faq.html#q7
        //Let the point be C (XC,YC) and the line be AB (XA,YA) to (XB,YB).
        //The length of the
        //      line segment AB is L:
        //
        //                    ___________________
        //                   |        2         2
        //              L = \| (XB-XA) + (YB-YA)
        //and
        //
        //                  (YA-YC)(YA-YB)-(XA-XC)(XB-XA)
        //              r = -----------------------------
        //                              L**2
        //
        //                  (YA-YC)(XB-XA)-(XA-XC)(YB-YA)
        //              s = -----------------------------
        //                              L**2
        //
        //      Let I be the point of perpendicular projection of C onto AB, the
        //
        //              XI=XA+r(XB-XA)
        //              YI=YA+r(YB-YA)
        //
        //      Distance from A to I = r*L
        //      Distance from C to I = s*L
        //
        //      If r < 0 I is on backward extension of AB
        //      If r>1 I is on ahead extension of AB
        //      If 0<=r<=1 I is on AB
        //
        //      If s < 0 C is left of AB (you can just check the numerator)
        //      If s>0 C is right of AB
        //      If s=0 C is on AB

        int xdiff = xb - xa;
        int ydiff = yb - ya;
        long l2 = xdiff * xdiff + ydiff * ydiff;

        if (l2 == 0) {
            return Geom.length(xa, ya, xc, yc);
        }

        double rnum = (ya - yc) * (ya - yb) - (xa - xc) * (xb - xa);
        double r = rnum / l2;

        if (r < 0.0 || r > 1.0) {
            return Double.MAX_VALUE;
        }

        double xi = xa + r * xdiff;
        double yi = ya + r * ydiff;
        double xd = xc - xi;
        double yd = yc - yi;
        return sqrt(xd * xd + yd * yd);

        /*
        for directional version, instead use
        double snum =  (ya-yc) * (xb-xa) - (xa-xc) * (yb-ya);
        double s = snum / l2;

        double l = sqrt((double)l2);
        return = s * l;
         */
    }

    /**
     * Resizes the <code>Rectangle2D.Double</code> both horizontally and vertically.
     * <p>
     * This method modifies the <code>Rectangle2D.Double</code> so that it is
     * <code>h</code> units larger on both the left and right side,
     * and <code>v</code> units larger at both the top and bottom.
     * <p>
     * The new <code>Rectangle2D.Double</code> has (<code>x&nbsp;-&nbsp;h</code>,
     * <code>y&nbsp;-&nbsp;v</code>) as its top-left corner, a
     * width of
     * <code>width</code>&nbsp;<code>+</code>&nbsp;<code>2h</code>,
     * and a height of
     * <code>height</code>&nbsp;<code>+</code>&nbsp;<code>2v</code>.
     * <p>
     * If negative values are supplied for <code>h</code> and
     * <code>v</code>, the size of the <code>Rectangle2D.Double</code>
     * decreases accordingly.
     * The <code>grow</code> method does not check whether the resulting
     * values of <code>width</code> and <code>height</code> are
     * non-negative.
     * @param h the horizontal expansion
     * @param v the vertical expansion
     */
    public static void grow(Rectangle2D.Double r, double h, double v) {
        r.x -= h;
        r.y -= v;
        r.width += h * 2d;
        r.height += v * 2d;
    }

    /**
     * Returns true, if rectangle 1 contains rectangle 2.
     * <p>
     * This method is similar to Rectangle2D.contains, but also returns true,
     * when rectangle1 contains rectangle2 and either or both of them
     * are empty.
     *
     * @param r1 Rectangle 1.
     * @param r2 Rectangle 2.
     * @return true if r1 contains r2.
     */
    public static boolean contains(Rectangle2D.Double r1, Rectangle2D.Double r2) {
        return (r2.x >= r1.x
                && r2.y >= r1.y
                && (r2.x + max(0, r2.width)) <= r1.x + max(0, r1.width)
                && (r2.y + max(0, r2.height)) <= r1.y + max(0, r1.height));
    }

    /**
     * Returns true, if rectangle 1 contains rectangle 2.
     * <p>
     * This method is similar to Rectangle2D.contains, but also returns true,
     * when rectangle1 contains rectangle2 and either or both of them
     * are empty.
     *
     * @param r1 Rectangle 1.
     * @param r2 Rectangle 2.
     * @return true if r1 contains r2.
     */
    public static boolean contains(Rectangle2D r1, Rectangle2D r2) {
        return (r2.getX()) >= r1.getX()
                && r2.getY() >= r1.getY()
                && (r2.getX() + max(0, r2.getWidth())) <= r1.getX() + max(0, r1.getWidth())
                && (r2.getY() + max(0, r2.getHeight())) <= r1.getY() + max(0, r1.getHeight());
    }
}
"
akka-bbb-apps/src/main/scala/org/bigbluebutton/core/util/jhotdraw/Bezier.java,"/*
 * @(#)Bezier.java
 *
 * Full JHotDraw project information can be found here https://sourceforge.net/projects/jhotdraw/
 * 
 * Copyright (c) 1996-2010 The authors and contributors of JHotDraw.
 * You may not use, copy or modify this file, except in compliance with the 
 * accompanying license terms.
 *
 * These release is distributed under LGPL.
 
 * The original version of JHotDraw is copyright 1996, 1997 by IFA Informatik 
 * and Erich Gamma.
 *
 * It is hereby granted that this software can be used, copied, modified, and 
 * distributed without fee provided that this copyright noticeappears in all copies.
 */

package org.bigbluebutton.core.util.jhotdraw;

import java.awt.geom.*;
import java.util.*;

/**
 * Provides algorithms for fitting Bezier curves to a set of digitized points.
 * <p>
 * Source:<br>
 * Phoenix: An Interactive Curve Design System Based on the Automatic Fitting
 * of Hand-Sketched Curves.<br>
 * Copyright (c) by Philip J. Schneider 1988.<br>
 * A thesis submitted in partial fulfillment of the requirements for the degree
 * of Master of Science, University of Washington.
 * <p>
 * http://autotrace.sourceforge.net/Interactive_Curve_Design.ps.gz
 *
 * @author Werner Randelshofer
 * @version $Id$
 */
public class Bezier {

    /** Prevent instance creation. */
    private Bezier() {
    }

    /*
    public static void main(String[] args) {
        ArrayList<Point2D.Double> d = new ArrayList<Point2D.Double>();
        d.add(new Point2D.Double(0, 0));
        d.add(new Point2D.Double(5, 1));
        d.add(new Point2D.Double(10, 0));
        d.add(new Point2D.Double(10, 10));
        d.add(new Point2D.Double(0, 10));
        d.add(new Point2D.Double(0, 0));
        ArrayList<ArrayList<Point2D.Double>> segments = (splitAtCorners(d, 45 / 180d * Math.PI, 2d));
        for (ArrayList<Point2D.Double> seg : segments) {
            for (int i = 0; i < 2; i++) {
                seg = reduceNoise(seg, 0.8);
            }
        }
    }
    */

    /**
     * Fits a bezier path to the specified list of digitized points.
     * <p>
     * This is a convenience method for calling {@link #fitBezierPath}
     * 
     * @param digitizedPoints digited points.
     * @param error the maximal allowed error between the bezier path and the
     * digitized points. 
     */
    public static BezierPath fitBezierPath(Point2D.Double[] digitizedPoints, double error) {
        return fitBezierPath(Arrays.asList(digitizedPoints), error);
    }

    /**
     * Fits a bezier path to the specified list of digitized points.
     * 
     * @param digitizedPoints digited points.
     * @param error the maximal allowed error between the bezier path and the
     * digitized points. 
     */
    public static BezierPath fitBezierPath(java.util.List<Point2D.Double> digitizedPoints, double error) {
        // Split into segments at corners
        ArrayList<ArrayList<Point2D.Double>> segments;
        segments = splitAtCorners(digitizedPoints, 77 / 180d * Math.PI, error * error);
        
        // Clean up the data in the segments
        for (int i = 0, n = segments.size(); i < n; i++) {
            ArrayList<Point2D.Double> seg = segments.get(i);
            seg = removeClosePoints(seg, error * 2);
            seg = reduceNoise(seg, 0.5);

            segments.set(i, seg);
        }


        // Create fitted bezier path
        BezierPath fittedPath = new BezierPath();


        // Quickly deal with empty dataset
        boolean isEmpty = false;
        for (ArrayList<Point2D.Double> seg : segments) {
            if (seg.isEmpty()) {
                isEmpty = false;
                break;
            }
        }
        if (!isEmpty) {
            // Process each segment of digitized points
            double errorSquared = error * error;
            for (ArrayList<Point2D.Double> seg : segments) {
                switch (seg.size()) {
                    case 0:
                        break;
                    case 1:
                        fittedPath.add(new BezierPath.Node(seg.get(0)));
                        break;
                    case 2:
                        if (fittedPath.isEmpty()) {
                            fittedPath.add(new BezierPath.Node(seg.get(0)));
                        }
                        fittedPath.lineTo(seg.get(1).x, seg.get(1).y);
                        break;
                    default:
                        if (fittedPath.isEmpty()) {
                            fittedPath.add(new BezierPath.Node(seg.get(0)));
                        }
                        /*  Unit tangent vectors at endpoints */
                        Point2D.Double tHat1;
                        Point2D.Double tHat2;
                        tHat1 = computeLeftTangent(seg, 0);
                        tHat2 = computeRightTangent(seg, seg.size() - 1);

                        fitCubic(seg, 0, seg.size() - 1, tHat1, tHat2, errorSquared, fittedPath);
                        break;
                }
            }
        }
        return fittedPath;
    }

    /**
     * Fits a bezier path to the specified list of digitized points.
     * <p>
     * This is a convenience method for calling {@link #fitBezierPath}.
     * 
     * @param digitizedPoints digited points.
     * @param error the maximal allowed error between the bezier path and the
     * digitized points. 
     */
    public static BezierPath fitBezierPath(BezierPath digitizedPoints, double error) {
        ArrayList<Point2D.Double> d = new ArrayList<Point2D.Double>(digitizedPoints.size());
        for (BezierPath.Node n : digitizedPoints) {
            d.add(new Point2D.Double(n.x[0], n.y[0]));
        }
        return fitBezierPath(d, error);
    }

    /**
     * Removes points which are closer together than the specified minimal 
     * distance.
     * <p>
     * The minimal distance should be chosen dependent on the size and resolution of the
     * display device, and on the sampling rate. A good value for mouse input
     * on a display with 100% Zoom factor is 2.
     * <p>
     * The purpose of this method, is to remove points, which add no additional
     * information about the shape of the curve from the list of digitized points.
     * <p>
     * The cleaned up set of digitized points gives better results, when used
     * as input for method {@link #splitAtCorners}.
     * 
     * @param digitizedPoints Digitized points
     * @param minDistance minimal distance between two points. If minDistance is
     * 0, this method only removes sequences of coincident points. 
     * @return Digitized points with a minimal distance.
     */
    public static ArrayList<Point2D.Double> removeClosePoints(java.util.List<Point2D.Double> digitizedPoints, double minDistance) {
        if (minDistance == 0) {
            return removeCoincidentPoints(digitizedPoints);
        } else {

            double squaredDistance = minDistance * minDistance;
            java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();
            if (digitizedPoints.size() > 0) {
                Point2D.Double prev = digitizedPoints.get(0);
                cleaned.add(prev);
                for (Point2D.Double p : digitizedPoints) {
                    if (v2SquaredDistanceBetween2Points(prev, p) > squaredDistance) {
                        cleaned.add(p);
                        prev = p;
                    }
                }
                if (!prev.equals(digitizedPoints.get(digitizedPoints.size() - 1))) {
                    cleaned.set(cleaned.size() - 1, digitizedPoints.get(digitizedPoints.size() - 1));
                }
            }
            return cleaned;
        }
    }

    /**
     * Removes sequences of coincident points.
     * <p>
     * The purpose of this method, is to clean up a list of digitized points
     * for later processing using method {@link #splitAtCorners}.
     * <p>
     * Use this method only, if you know that the digitized points contain no
     * quantization errors - which is never the case, unless you want to debug
     * the curve fitting algorithm of this class.
     * 
     * @param digitizedPoints Digitized points
     * @return Digitized points without subsequent duplicates.
     */
    private static ArrayList<Point2D.Double> removeCoincidentPoints(java.util.List<Point2D.Double> digitizedPoints) {
        java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();
        if (digitizedPoints.size() > 0) {
            Point2D.Double prev = digitizedPoints.get(0);
            cleaned.add(prev);
            for (Point2D.Double p : digitizedPoints) {
                if (!prev.equals(p)) {
                    cleaned.add(p);
                    prev = p;
                }
            }
        }
        return cleaned;
    }

    /**
     * Splits the digitized points into multiple segments at each corner point.
     * <p>
     * Corner points are both contained as the last point of a segment and
     * the first point of a subsequent segment.
     * 
     * @param digitizedPoints Digitized points 
     * @param maxAngle maximal angle in radians between the current point and its
     * predecessor and successor up to which the point does not break the
     * digitized list into segments. Recommended value 44 deg = 44 * 180d / Math.PI
     * @return Segments of digitized points, each segment having less than maximal
     * angle between points.
     */
    public static ArrayList<ArrayList<Point2D.Double>> splitAtCorners(java.util.List<Point2D.Double> digitizedPoints, double maxAngle, double minDistance) {
        ArrayList<Integer> cornerIndices = findCorners(digitizedPoints, maxAngle, minDistance);
        ArrayList<ArrayList<Point2D.Double>> segments = new ArrayList<ArrayList<Point2D.Double>>(cornerIndices.size() + 1);

        if (cornerIndices.size() == 0) {
            segments.add(new ArrayList<Point2D.Double>(digitizedPoints));
        } else {
            segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(0, cornerIndices.get(0) + 1)));
            for (int i = 1; i < cornerIndices.size(); i++) {
                segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(cornerIndices.get(i - 1), cornerIndices.get(i) + 1)));
            }
            segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(cornerIndices.get(cornerIndices.size() - 1), digitizedPoints.size())));
        }

        return segments;
    }

    /**
     * Finds corners in the provided point list, and returns their indices.
     * 
     * @param digitizedPoints List of digitized points.
     * @param minAngle Minimal angle for corner points
     * @param minDistance Minimal distance between a point and adjacent points
     * for corner detection
     * @return list of corner indices.
     */
    public static ArrayList<Integer> findCorners(java.util.List<Point2D.Double> digitizedPoints, double minAngle, double minDistance) {
        ArrayList<Integer> cornerIndices = new ArrayList<Integer>();

        double squaredDistance = minDistance * minDistance;

        int previousCorner = -1;
        double previousCornerAngle = 0;

        for (int i = 1, n = digitizedPoints.size(); i < n - 1; i++) {
            Point2D.Double p = digitizedPoints.get(i);

            // search for a preceding point for corner detection
            Point2D.Double prev = null;
            boolean intersectsPreviousCorner = false;
            for (int j = i - 1; j >= 0; j--) {
                if (j == previousCorner || v2SquaredDistanceBetween2Points(digitizedPoints.get(j), p) >= squaredDistance) {
                    prev = digitizedPoints.get(j);
                    intersectsPreviousCorner = j < previousCorner;
                    break;
                }
            }
            if (prev == null) {
                continue;
            }

            // search for a succeeding point for corner detection
            Point2D.Double next = null;
            for (int j = i + 1; j < n; j++) {
                if (v2SquaredDistanceBetween2Points(digitizedPoints.get(j), p) >= squaredDistance) {
                    next = digitizedPoints.get(j);
                    break;
                }
            }
            if (next == null) {
                continue;
            }

            double aPrev = Math.atan2(prev.y - p.y, prev.x - p.x);
            double aNext = Math.atan2(next.y - p.y, next.x - p.x);
            double angle = Math.abs(aPrev - aNext);
            if (angle < Math.PI - minAngle || angle > Math.PI + minAngle) {
                if (intersectsPreviousCorner) {
                    cornerIndices.set(cornerIndices.size() - 1, i);
                } else {
                    cornerIndices.add(i);
                }
                previousCorner = i;
                previousCornerAngle = angle;
            }
        }
        return cornerIndices;
    }

    /**
     * Reduces noise from the digitized points, by applying an approximation
     * of a gaussian filter to the data.
     * <p>
     * The filter does the following for each point P, with weight 0.5:
     * <p>
     * x[i] = 0.5*x[i] + 0.25*x[i-1] + 0.25*x[i+1];
     * y[i] = 0.5*y[i] + 0.25*y[i-1] + 0.25*y[i+1];
     * 
     * 
     * 
     * @param digitizedPoints Digitized points
     * @param weight Weight of the current point
     * @return Digitized points with reduced noise.
     */
    public static ArrayList<Point2D.Double> reduceNoise(java.util.List<Point2D.Double> digitizedPoints, double weight) {
        java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();
        if (digitizedPoints.size() > 0) {
            Point2D.Double prev = digitizedPoints.get(0);
            cleaned.add(prev);
            double pnWeight = (1d - weight) / 2d; // weight of previous and next
            for (int i = 1, n = digitizedPoints.size() - 1; i < n; i++) {
                Point2D.Double cur = digitizedPoints.get(i);
                Point2D.Double next = digitizedPoints.get(i + 1);
                cleaned.add(new Point2D.Double(
                        cur.x * weight + pnWeight * prev.x + pnWeight * next.x,
                        cur.y * weight + pnWeight * prev.y + pnWeight * next.y));
                prev = cur;
            }
            if (digitizedPoints.size() > 1) {
                cleaned.add(digitizedPoints.get(digitizedPoints.size() - 1));
            }
        }
        return cleaned;
    }

    /**
     * Fit one or multiple subsequent cubic bezier curves to a (sub)set of 
     * digitized points. The digitized points represent a smooth curve without
     * corners.
     *
     * @param d  Array of digitized points. Must not contain subsequent 
     * coincident points.
     * @param first Indice of first point in d.
     * @param last Indice of last point in d.
     * @param tHat1 Unit tangent vectors at start point.
     * @param tHat2 Unit tanget vector at end point.
     * @param errorSquared User-defined errorSquared squared.
     * @param bezierPath Path to which the bezier curve segments are added.
     */
    private static void fitCubic(ArrayList<Point2D.Double> d, int first, int last,
            Point2D.Double tHat1, Point2D.Double tHat2,
            double errorSquared, BezierPath bezierPath) {

        Point2D.Double[] bezCurve; /*Control points of fitted Bezier curve*/
        double[] u;		/*  Parameter values for point  */
        double maxError;	/*  Maximum fitting errorSquared	 */
        int[] splitPoint = new int[1]; /*  Point to split point set at.
        This is an array of size one, because we need it as an input/output parameter.
         */
        int nPts;		/*  Number of points in subset  */
        double iterationError; /* Error below which you try iterating  */
        int maxIterations = 4; /*  Max times to try iterating  */
        Point2D.Double tHatCenter; /* Unit tangent vector at splitPoint */
        int i;

        // clone unit tangent vectors, so that we can alter their coordinates
        // without affecting the input values.
        tHat1 = (Point2D.Double) tHat1.clone();
        tHat2 = (Point2D.Double) tHat2.clone();

        iterationError = errorSquared * errorSquared;
        nPts = last - first + 1;

        /*  Use heuristic if region only has two points in it */
        if (nPts == 2) {
            double dist = v2DistanceBetween2Points(d.get(last), d.get(first)) / 3.0;

            bezCurve = new Point2D.Double[4];
            for (i = 0; i < bezCurve.length; i++) {
                bezCurve[i] = new Point2D.Double();
            }
            bezCurve[0] = d.get(first);
            bezCurve[3] = d.get(last);
            v2Add(bezCurve[0], v2Scale(tHat1, dist), bezCurve[1]);
            v2Add(bezCurve[3], v2Scale(tHat2, dist), bezCurve[2]);

            bezierPath.curveTo(
                    bezCurve[1].x, bezCurve[1].y,
                    bezCurve[2].x, bezCurve[2].y,
                    bezCurve[3].x, bezCurve[3].y);
            return;
        }

        /*  Parameterize points, and attempt to fit curve */
        u = chordLengthParameterize(d, first, last);
        bezCurve = generateBezier(d, first, last, u, tHat1, tHat2);

        /*  Find max deviation of points to fitted curve */
        maxError = computeMaxError(d, first, last, bezCurve, u, splitPoint);
        if (maxError < errorSquared) {
            addCurveTo(bezCurve, bezierPath, errorSquared, first == 0 && last == d.size() - 1);
            return;
        }


        /*  If errorSquared not too large, try some reparameterization  */
        /*  and iteration */
        if (maxError < iterationError) {
            double[] uPrime;	/*  Improved parameter values */
            for (i = 0; i < maxIterations; i++) {
                uPrime = reparameterize(d, first, last, u, bezCurve);
                bezCurve = generateBezier(d, first, last, uPrime, tHat1, tHat2);
                maxError = computeMaxError(d, first, last, bezCurve, uPrime, splitPoint);
                if (maxError < errorSquared) {
                    addCurveTo(bezCurve, bezierPath, errorSquared, first == 0 && last == d.size() - 1);
                    return;
                }
                u = uPrime;
            }
        }

        /* Fitting failed -- split at max errorSquared point and fit recursively */
        tHatCenter = computeCenterTangent(d, splitPoint[0]);
        if (first < splitPoint[0]) {
            fitCubic(d, first, splitPoint[0], tHat1, tHatCenter, errorSquared, bezierPath);
        } else {
            bezierPath.lineTo(d.get(splitPoint[0]).x, d.get(splitPoint[0]).y);
         //   System.err.println(""Can't split any further "" + first + "".."" + splitPoint[0]);
        }
        v2Negate(tHatCenter);
        if (splitPoint[0] < last) {
            fitCubic(d, splitPoint[0], last, tHatCenter, tHat2, errorSquared, bezierPath);
        } else {
            bezierPath.lineTo(d.get(last).x, d.get(last).y);
          //  System.err.println(""Can't split any further "" + splitPoint[0] + "".."" + last);
        }
    }

    /**
     * Adds the curve to the bezier path.
     * 
     * @param bezCurve
     * @param bezierPath
     */
    private static void addCurveTo(Point2D.Double[] bezCurve, BezierPath bezierPath, double errorSquared, boolean connectsCorners) {
        BezierPath.Node lastNode = bezierPath.get(bezierPath.size() - 1);
        double error = Math.sqrt(errorSquared);
        if (connectsCorners && Geom.lineContainsPoint(lastNode.x[0], lastNode.y[0], bezCurve[3].x, bezCurve[3].y, bezCurve[1].x, bezCurve[1].y, error) &&
                Geom.lineContainsPoint(lastNode.x[0], lastNode.y[0], bezCurve[3].x, bezCurve[3].y, bezCurve[2].x, bezCurve[2].y, error)) {
            bezierPath.lineTo(
                    bezCurve[3].x, bezCurve[3].y);

        } else {
            bezierPath.curveTo(
                    bezCurve[1].x, bezCurve[1].y,
                    bezCurve[2].x, bezCurve[2].y,
                    bezCurve[3].x, bezCurve[3].y);
        }
    }

    /**
     * Approximate unit tangents at ""left"" endpoint of digitized curve.
     *
     * @param d Digitized points.
     * @param end Index to ""left"" end of region.
     */
    private static Point2D.Double computeLeftTangent(ArrayList<Point2D.Double> d, int end) {
        Point2D.Double tHat1;
        tHat1 = v2SubII(d.get(end + 1), d.get(end));
        tHat1 = v2Normalize(tHat1);
        return tHat1;
    }

    /**
     * Approximate unit tangents at ""right"" endpoint of digitized curve.
     *
     * @param d Digitized points.
     * @param end Index to ""right"" end of region.
     */
    private static Point2D.Double computeRightTangent(ArrayList<Point2D.Double> d, int end) {
        Point2D.Double tHat2;
        tHat2 = v2SubII(d.get(end - 1), d.get(end));
        tHat2 = v2Normalize(tHat2);
        return tHat2;
    }

    /**
     * Approximate unit tangents at ""center"" of digitized curve.
     *
     * @param d Digitized points.
     * @param center Index to ""center"" end of region.
     */
    private static Point2D.Double computeCenterTangent(ArrayList<Point2D.Double> d, int center) {
        Point2D.Double V1, V2,
                tHatCenter = new Point2D.Double();

        V1 = v2SubII(d.get(center - 1), d.get(center));
        V2 = v2SubII(d.get(center), d.get(center + 1));
        tHatCenter.x = (V1.x + V2.x) / 2.0;
        tHatCenter.y = (V1.y + V2.y) / 2.0;
        tHatCenter = v2Normalize(tHatCenter);
        return tHatCenter;
    }

    /**
     * Assign parameter values to digitized points
     * using relative distances between points.
     *
     * @param d Digitized points.
     * @param first Indice of first point of region in d.
     * @param last Indice of last point of region in d.
     */
    private static double[] chordLengthParameterize(ArrayList<Point2D.Double> d, int first, int last) {
        int i;
        double[] u;	/*  Parameterization		*/

        u = new double[last - first + 1];

        u[0] = 0.0;
        for (i = first + 1; i <= last; i++) {
            u[i - first] = u[i - first - 1] +
                    v2DistanceBetween2Points(d.get(i), d.get(i - 1));
        }

        for (i = first + 1; i <= last; i++) {
            u[i - first] = u[i - first] / u[last - first];
        }

        return (u);
    }

    /**
     * Given set of points and their parameterization, try to find
     * a better parameterization.
     *
     * @param d  Array of digitized points.
     * @param first Indice of first point of region in d.
     * @param last Indice of last point of region in d.
     * @param u Current parameter values.
     * @param bezCurve Current fitted curve.
     */
    private static double[] reparameterize(ArrayList<Point2D.Double> d, int first, int last, double[] u, Point2D.Double[] bezCurve) {
        int nPts = last - first + 1;
        int i;
        double[] uPrime; /*  New parameter values	*/

        uPrime = new double[nPts];
        for (i = first; i <= last; i++) {
            uPrime[i - first] = newtonRaphsonRootFind(bezCurve, d.get(i), u[i - first]);
        }
        return (uPrime);
    }

    /**
     * Use Newton-Raphson iteration to find better root.
     *
     * @param Q  Current fitted bezier curve.
     * @param P  Digitized point.
     * @param u  Parameter value vor P.
     */
    private static double newtonRaphsonRootFind(Point2D.Double[] Q, Point2D.Double P, double u) {
        double numerator, denominator;
        Point2D.Double[] Q1 = new Point2D.Double[3], Q2 = new Point2D.Double[2];	/*  Q' and Q''			*/
        Point2D.Double Q_u, Q1_u, Q2_u; /*u evaluated at Q, Q', & Q''	*/
        double uPrime;		/*  Improved u	*/
        int i;

        /* Compute Q(u)	*/
        Q_u = bezierII(3, Q, u);

        /* Generate control vertices for Q'	*/
        for (i = 0; i <= 2; i++) {
            Q1[i] = new Point2D.Double(
                    (Q[i + 1].x - Q[i].x) * 3.0,
                    (Q[i + 1].y - Q[i].y) * 3.0);
        }

        /* Generate control vertices for Q'' */
        for (i = 0; i <= 1; i++) {
            Q2[i] = new Point2D.Double(
                    (Q1[i + 1].x - Q1[i].x) * 2.0,
                    (Q1[i + 1].y - Q1[i].y) * 2.0);
        }

        /* Compute Q'(u) and Q''(u)	*/
        Q1_u = bezierII(2, Q1, u);
        Q2_u = bezierII(1, Q2, u);

        /* Compute f(u)/f'(u) */
        numerator = (Q_u.x - P.x) * (Q1_u.x) + (Q_u.y - P.y) * (Q1_u.y);
        denominator = (Q1_u.x) * (Q1_u.x) + (Q1_u.y) * (Q1_u.y) +
                (Q_u.x - P.x) * (Q2_u.x) + (Q_u.y - P.y) * (Q2_u.y);

        /* u = u - f(u)/f'(u) */
        uPrime = u - (numerator / denominator);
        return (uPrime);
    }

    /**
     * Find the maximum squared distance of digitized points
     * to fitted curve.
     *
     * @param d Digitized points.
     * @param first Indice of first point of region in d.
     * @param last Indice of last point of region in d.
     * @param bezCurve Fitted Bezier curve
     * @param u Parameterization of points*
     * @param splitPoint Point of maximum error (input/output parameter, must be
     * an array of 1)
     */
    private static double computeMaxError(ArrayList<Point2D.Double> d, int first, int last, Point2D.Double[] bezCurve, double[] u, int[] splitPoint) {
        int i;
        double maxDist;		/*  Maximum error */
        double dist;		/*  Current error */
        Point2D.Double P; /*  Point on curve */
        Point2D.Double v; /*  Vector from point to curve */

        splitPoint[0] = (last - first + 1) / 2;
        maxDist = 0.0;
        for (i = first + 1; i < last; i++) {
            P = bezierII(3, bezCurve, u[i - first]);
            v = v2SubII(P, d.get(i));
            dist = v2SquaredLength(v);
            if (dist >= maxDist) {
                maxDist = dist;
                splitPoint[0] = i;
            }
        }
        return (maxDist);
    }

    /**
     * Use least-squares method to find Bezier control points for region.
     *
     * @param d  Array of digitized points.
     * @param first Indice of first point in d.
     * @param last Indice of last point in d.
     * @param uPrime Parameter values for region .
     * @param tHat1 Unit tangent vectors at start point.
     * @param tHat2 Unit tanget vector at end point.
     * @return A cubic bezier curve consisting of 4 control points.
     */
    private static Point2D.Double[] generateBezier(ArrayList<Point2D.Double> d, int first, int last, double[] uPrime, Point2D.Double tHat1, Point2D.Double tHat2) {
        Point2D.Double[] bezCurve;

        bezCurve = new Point2D.Double[4];
        for (int i = 0; i < bezCurve.length; i++) {
            bezCurve[i] = new Point2D.Double();
        }


        /*  Use the Wu/Barsky heuristic*/
        double dist = v2DistanceBetween2Points(d.get(last), d.get(first)) / 3.0;

        bezCurve[0] = d.get(first);
        bezCurve[3] = d.get(last);
        v2Add(bezCurve[0], v2Scale(tHat1, dist), bezCurve[1]);
        v2Add(bezCurve[3], v2Scale(tHat2, dist), bezCurve[2]);
        return (bezCurve);
    }

    /**
     * Evaluate a Bezier curve at a particular parameter value.
     *
     * @param degree  The degree of the bezier curve.
     * @param V  Array of control points.
     * @param t  Parametric value to find point for.
     */
    private static Point2D.Double bezierII(int degree, Point2D.Double[] V, double t) {
        int i, j;
        Point2D.Double q; /* Point on curve at parameter t	*/
        Point2D.Double[] vTemp; /* Local copy of control points		*/

        /* Copy array	*/
        vTemp = new Point2D.Double[degree + 1];
        for (i = 0; i <= degree; i++) {
            vTemp[i] = (Point2D.Double) V[i].clone();
        }

        /* Triangle computation	*/
        for (i = 1; i <= degree; i++) {
            for (j = 0; j <= degree - i; j++) {
                vTemp[j].x = (1.0 - t) * vTemp[j].x + t * vTemp[j + 1].x;
                vTemp[j].y = (1.0 - t) * vTemp[j].y + t * vTemp[j + 1].y;
            }
        }

        q = vTemp[0];
        return q;
    }

    /* -------------------------------------------------------------------------
     * GraphicsGems.c
     * 2d and 3d Vector C Library
     * by Andrew Glassner
     * from ""Graphics Gems"", Academic Press, 1990
     * -------------------------------------------------------------------------
     */
    /**
     * Return the distance between two points
     */
    private static double v2DistanceBetween2Points(Point2D.Double a, Point2D.Double b) {
        return Math.sqrt(v2SquaredDistanceBetween2Points(a, b));
    }

    /**
     * Return the distance between two points
     */
    private static double v2SquaredDistanceBetween2Points(Point2D.Double a, Point2D.Double b) {
        double dx = a.x - b.x;
        double dy = a.y - b.y;
        return (dx * dx) + (dy * dy);
    }

    /**
     * Scales the input vector to the new length and returns it.
     * <p>
     * This method alters the value of the input point!
     */
    private static Point2D.Double v2Scale(Point2D.Double v, double newlen) {
        double len = v2Length(v);
        if (len != 0.0) {
            v.x *= newlen / len;
            v.y *= newlen / len;
        }

        return v;
    }

    /**
     * Scales the input vector by the specified factor and returns it.
     * <p>
     * This method alters the value of the input point!
     */
    private static Point2D.Double v2ScaleIII(Point2D.Double v, double s) {
        Point2D.Double result = new Point2D.Double();
        result.x = v.x * s;
        result.y = v.y * s;
        return result;
    }

    /**
     * Returns length of input vector.
     */
    private static double v2Length(Point2D.Double a) {
        return Math.sqrt(v2SquaredLength(a));
    }

    /**
     * Returns squared length of input vector.
     */
    private static double v2SquaredLength(Point2D.Double a) {
        return (a.x * a.x) + (a.y * a.y);
    }

    /**
     * Return vector sum c = a+b.
     * <p>
     * This method alters the value of c.
     */
    private static Point2D.Double v2Add(Point2D.Double a, Point2D.Double b, Point2D.Double c) {
        c.x = a.x + b.x;
        c.y = a.y + b.y;
        return c;
    }

    /**
     * Return vector sum = a+b.
     */
    private static Point2D.Double v2AddII(Point2D.Double a, Point2D.Double b) {
        Point2D.Double c = new Point2D.Double();
        c.x = a.x + b.x;
        c.y = a.y + b.y;
        return c;
    }

    /**
     * Negates the input vector and returns it.
     */
    private static Point2D.Double v2Negate(Point2D.Double v) {
        v.x = -v.x;
        v.y = -v.y;
        return v;
    }

    /**
     * Return the dot product of vectors a and b.
     */
    private static double v2Dot(Point2D.Double a, Point2D.Double b) {
        return (a.x * b.x) + (a.y * b.y);
    }

    /**
     * Normalizes the input vector and returns it.
     */
    private static Point2D.Double v2Normalize(Point2D.Double v) {
        double len = v2Length(v);
        if (len != 0.0) {
            v.x /= len;
            v.y /= len;
        }

        return v;
    }

    /**
     * Subtract Vector a from Vector b.
     * 
     * @param a Vector a - the value is not changed by this method
     * @param b Vector b - the value is not changed by this method
     * @return Vector a subtracted by Vector v.
     */
    private static Point2D.Double v2SubII(Point2D.Double a, Point2D.Double b) {
        Point2D.Double c = new Point2D.Double();
        c.x = a.x - b.x;
        c.y = a.y - b.y;
        return (c);
    }

    /**
     *  B0, B1, B2, B3 :
     *	Bezier multipliers
     */
    private static double b0(double u) {
        double tmp = 1.0 - u;
        return (tmp * tmp * tmp);
    }

    private static double b1(double u) {
        double tmp = 1.0 - u;
        return (3 * u * (tmp * tmp));
    }

    private static double b2(double u) {
        double tmp = 1.0 - u;
        return (3 * u * u * tmp);
    }

    private static double b3(double u) {
        return (u * u * u);
    }
}"
akka-bbb-apps/src/main/scala/org/bigbluebutton/core/util/jhotdraw/PathData.java,"package org.bigbluebutton.core.util.jhotdraw;

import java.util.ArrayList;

public class PathData {
  public ArrayList<Integer> commands;
  public ArrayList<Double> coords;
  public ArrayList<Float> points;
  
  public PathData(ArrayList<Integer> commands, ArrayList<Double> coords) {
    this.commands = commands;
    this.coords = coords;
  }
}"
akka-bbb-apps/src/main/scala/org/bigbluebutton/core/util/jhotdraw/BezierPath.java,"/*
 * @(#)BezierPath.java
 *
 * Full JHotDraw project information can be found here https://sourceforge.net/projects/jhotdraw/
 * 
 * Copyright (c) 1996-2010 The authors and contributors of JHotDraw.
 * You may not use, copy or modify this file, except in compliance with the 
 * accompanying license terms.
 *
 * These release is distributed under LGPL.
 
 * The original version of JHotDraw is copyright 1996, 1997 by IFA Informatik 
 * and Erich Gamma.
 *
 * It is hereby granted that this software can be used, copied, modified, and 
 * distributed without fee provided that this copyright noticeappears in all copies.
 */

package org.bigbluebutton.core.util.jhotdraw;

import java.awt.*;
import java.awt.geom.*;
import java.io.Serializable;
import java.util.*;

/**
 * BezierPath allows the construction of paths consisting of straight lines,
 * quadratic curves and cubic curves.
 * <p>
 * A BezierPath is defined by its nodes. Each node has three control points:
 * C0, C1, C2. A mask defines which control points are in use. At a node, 
 * the path passes through C0. C1 controls the curve going towards C0. C2
 * controls the curve going away from C0.
 *
 * @author Werner Randelshofer
 * @version $Id$
 */
public class BezierPath extends ArrayList<BezierPath.Node>
        implements Shape, Serializable, Cloneable {
    private static final long serialVersionUID=1L;

    /** Constant for having only control point C0 in effect. C0 is the point
     * through whitch the curve passes. */
    public static final int C0_MASK = 0;
    /** Constant for having control point C1 in effect (in addition
     * to C0). C1 controls the curve going towards C0.
     * */
    public static final int C1_MASK = 1;
    /** Constant for having control point C2 in effect (in addition to C0).
     * C2 controls the curve going away from C0.
     */
    public static final int C2_MASK = 2;
    /** Constant for having control points C1 and C2 in effect (in addition to C0). */
    public static final int C1C2_MASK = C1_MASK | C2_MASK;
    /**
     * We cache a Path2D.Double instance to speed up Shape operations.
     */
    private transient Path2D.Double generalPath;
    /**
     * We cache a Rectangle2D.Double instance to speed up getBounds operations.
     */
    private transient Rectangle2D.Double bounds;
    /**
     * We cache the index of the outermost node to speed up method indexOfOutermostNode();
     */
    private int outer = -1;
    /**
     * If this value is set to true, closes the bezier path.
     */
    private boolean isClosed;
    /**
     * The winding rule for filling the bezier path.
     */
    private int windingRule = Path2D.Double.WIND_EVEN_ODD;

    /**
     * Defines a vertex (node) of the bezier path.
     * <p>
     * A vertex consists of three control points: C0, C1 and C2.
     * <ul>
     * <li>The bezier path always passes through C0.</li>
     * <li>C1 is used to control the curve towards C0.
     * </li>
     * <li>C2 is used to control the curve going away from C0.</li>
     * </ul>
     */
    public static class Node implements Cloneable, Serializable {
    private static final long serialVersionUID=1L;

        /**
         * This mask is used to describe which control points in addition to
         * C0 are in effect.
         */
        public int mask = 0;
        /** Control point x coordinates. */
        public double[] x = new double[3];
        /** Control point y coordinates. */
        public double[] y = new double[3];
        /** This is a hint for editing tools. If this is set to true,
         * the editing tools shall keep all control points on the same
         * line.
         */
        public boolean keepColinear = true;

        public Node() {
        }

        public Node(Node that) {
            setTo(that);
        }

        public void setTo(Node that) {
            this.mask = that.mask;
            this.keepColinear = that.keepColinear;
            System.arraycopy(that.x, 0, this.x, 0, 3);
            System.arraycopy(that.y, 0, this.y, 0, 3);
        }

        public Node(Point2D.Double c0) {
            this.mask = 0;
            x[0] = c0.x;
            y[0] = c0.y;
            x[1] = c0.x;
            y[1] = c0.y;
            x[2] = c0.x;
            y[2] = c0.y;
        }

        public Node(int mask, Point2D.Double c0, Point2D.Double c1, Point2D.Double c2) {
            this.mask = mask;
            x[0] = c0.x;
            y[0] = c0.y;
            x[1] = c1.x;
            y[1] = c1.y;
            x[2] = c2.x;
            y[2] = c2.y;
        }

        public Node(double x0, double y0) {
            this.mask = 0;
            x[0] = x0;
            y[0] = y0;
            x[1] = x0;
            y[1] = y0;
            x[2] = x0;
            y[2] = y0;
        }

        public Node(int mask, double x0, double y0, double x1, double y1, double x2, double y2) {
            this.mask = mask;
            x[0] = x0;
            y[0] = y0;
            x[1] = x1;
            y[1] = y1;
            x[2] = x2;
            y[2] = y2;
        }

        public int getMask() {
            return mask;
        }

        public void setMask(int newValue) {
            mask = newValue;
        }

        public void setControlPoint(int index, Point2D.Double p) {
            x[index] = p.x;
            y[index] = p.y;
        }

        public Point2D.Double getControlPoint(int index) {
            return new Point2D.Double(x[index], y[index]);
        }

        public void moveTo(Point2D.Double p) {
            moveBy(p.x - x[0], p.y - y[0]);
        }

        public void moveTo(double x, double y) {
            moveBy(x - this.x[0], y - this.y[0]);
        }

        public void moveBy(double dx, double dy) {
            for (int i = 0; i < 3; i++) {
                x[i] += dx;
                y[i] += dy;
            }
        }

    @Override
        public Object clone() {
            try {
                Node that = (Node) super.clone();
                that.x = this.x.clone();
                that.y = this.y.clone();
                return that;
            } catch (CloneNotSupportedException e) {
                InternalError error = new InternalError();
                error.initCause(e);
                throw error;
            }
        }

    @Override
        public String toString() {
            StringBuilder buf = new StringBuilder();
            buf.append(super.toString());
            buf.append('[');
            for (int i = 0; i < 3; i++) {
                if (i != 0) {
                    if ((mask & i) == i) {
                        buf.append(',');
                    } else {
                        continue;
                    }
                }

                buf.append('x');
                buf.append(i);
                buf.append('=');
                buf.append(x[i]);
                buf.append("",y"");
                buf.append(i);
                buf.append('=');
                buf.append(y[i]);
            }
            buf.append(']');
            return buf.toString();
        }

    @Override
        public int hashCode() {
            return (mask & 0x3) << 29
                    | (Arrays.hashCode(x) & 0x3fff0000)
                    | (Arrays.hashCode(y) & 0xffff);
        }

    @Override
        public boolean equals(Object o) {
            if (o instanceof BezierPath.Node) {
                BezierPath.Node that = (BezierPath.Node) o;
                return that.mask == this.mask
                        && Arrays.equals(that.x, this.x)
                        && Arrays.equals(that.y, this.y);
            }
            return false;
        }
    }

    /** Creates a new instance. */
    public BezierPath() {
    }

    /**
     * Adds a node to the path.
     * <p>
     * This is a convenience method for adding a node with a single control
     * point C0 to the path.
     */
    public void add(Point2D.Double c0) {
        add(new Node(0, c0, c0, c0));
    }

    /**
     * Adds a node to the path.
     * <p>
     * This is a convenience method for adding a node with a single control
     * point C0 to the path.
     */
    public void add(double x, double y) {
        add(new Node(0, x, y, x, y, x, y));
    }

    /**
     * Adds a node to the path.
     * <p>
     * This is a convenience method for adding a node with three control points
     * C0, C1 and C2, and a mask.
     *
     * @param ctrlMask An or-combination of C0_MASK,C1_MASK and C2_MASK.
     * @param c0 The coordinates of the C0 control point.
     * @param c1 The coordinates of the C1 control point.
     * @param c2 The coordinates of the C2 control point.
     */
    public void add(int ctrlMask, Point2D.Double c0, Point2D.Double c1, Point2D.Double c2) {
        add(new Node(ctrlMask, c0, c1, c2));
    }

    /**
     * Adds a set of nodes to the path.
     * <p>
     * Convenience method for adding multiple nodes with a single control point
     * C0.
     */
    public void addPolyline(Collection<Point2D.Double> points) {
        for (Point2D.Double c0 : points) {
            add(new Node(0, c0, c0, c0));
        }
    }

    /**
     * Convenience method for changing a single control point of a node.
     *
     * @param nodeIndex The index of the node.
     * @param ctrlIndex Either C0_MASK, C1_MASK or C2_MASK.
     * @param p The control point. The coordinates will be cloned.
     */
    public void set(int nodeIndex, int ctrlIndex, Point2D.Double p) {
        Node c = get(nodeIndex);
        c.x[ctrlIndex] = p.x;
        c.y[ctrlIndex] = p.y;
    }

    /**
     * Convenience method for getting a single control point of a node.
     *
     * @param nodeIndex The index of the node.
     * @param ctrlIndex Either C0_MASK, C1_MASK or C2_MASK.
     * @return Returns a clone of the control point.
     */
    public Point2D.Double get(int nodeIndex, int ctrlIndex) {
        Node c = get(nodeIndex);
        return new Point2D.Double(
                c.x[ctrlIndex],
                c.y[ctrlIndex]);
    }

    /**
     * This must be called after the BezierPath has been changed.
     */
    public void invalidatePath() {
        generalPath = null;
        bounds = null;
        outer = -1;
    }

    /**
     * Recomputes the BezierPath, if it is invalid.
     */
    public void validatePath() {
        if (generalPath == null) {
            generalPath = toGeneralPath();
        }
    }

    /** Converts the BezierPath into a Path2D.Double. */
    public Path2D.Double toGeneralPath() {
        Path2D.Double gp = new Path2D.Double();
        gp.setWindingRule(windingRule);
        if (size() == 0) {
            gp.moveTo(0, 0);
            gp.lineTo(0, 0 + 1);
        } else if (size() == 1) {
            Node current = get(0);
            gp.moveTo(current.x[0], current.y[0]);
            gp.lineTo(current.x[0], current.y[0] + 1);
        } else {
            Node previous;
            Node current;

            previous = current = get(0);
            gp.moveTo(current.x[0], current.y[0]);
            for (int i = 1, n = size(); i < n; i++) {
                previous = current;
                current = get(i);

                if ((previous.mask & C2_MASK) == 0) {
                    if ((current.mask & C1_MASK) == 0) {
                        gp.lineTo(
                                current.x[0], current.y[0]);
                    } else {
                        gp.quadTo(
                                current.x[1], current.y[1],
                                current.x[0], current.y[0]);
                    }
                } else {
                    if ((current.mask & C1_MASK) == 0) {
                        gp.quadTo(
                                previous.x[2], previous.y[2],
                                current.x[0], current.y[0]);
                    } else {
                        gp.curveTo(
                                previous.x[2], previous.y[2],
                                current.x[1], current.y[1],
                                current.x[0], current.y[0]);
                    }
                }
            }
            if (isClosed) {
                if (size() > 1) {
                    previous = get(size() - 1);
                    current = get(0);

                    if ((previous.mask & C2_MASK) == 0) {
                        if ((current.mask & C1_MASK) == 0) {
                            gp.lineTo(
                                    current.x[0], current.y[0]);
                        } else {
                            gp.quadTo(
                                    current.x[1], current.y[1],
                                    current.x[0], current.y[0]);
                        }
                    } else {
                        if ((current.mask & C1_MASK) == 0) {
                            gp.quadTo(
                                    previous.x[2], previous.y[2],
                                    current.x[0], current.y[0]);
                        } else {
                            gp.curveTo(
                                    previous.x[2], previous.y[2],
                                    current.x[1], current.y[1],
                                    current.x[0], current.y[0]);
                        }
                    }
                }
                gp.closePath();
            }
        }
        return gp;
    }

        /** Converts the BezierPath into a raw set of coordinates to draw anywhere */
    public PathData toRawPath() {
        ArrayList<Integer> commands = new ArrayList<Integer>();
        ArrayList<Double> coords = new ArrayList<Double>();
        if (size() > 0) {
            Node previous;
            Node current;

            previous = current = get(0);
            commands.add(PathCommands.MOVE_TO);
            coords.add(current.x[0]);
            coords.add(current.y[0]);
            for (int i = 1, n = size(); i < n; i++) {
                previous = current;
                current = get(i);

                if ((previous.mask & C2_MASK) == 0) {
                    if ((current.mask & C1_MASK) == 0) {
                        commands.add(PathCommands.LINE_TO);
                        coords.add(current.x[0]);
                        coords.add(current.y[0]);
                    } else {
                        commands.add(PathCommands.Q_CURVE_TO);
                        coords.add(current.x[1]);
                        coords.add(current.y[1]);
                        coords.add(current.x[0]);
                        coords.add(current.y[0]);
                    }
                } else {
                    if ((current.mask & C1_MASK) == 0) {
                        commands.add(PathCommands.Q_CURVE_TO);
                        coords.add(previous.x[2]);
                        coords.add(previous.y[2]);
                        coords.add(current.x[0]);
                        coords.add(current.y[0]);
                    } else {
                        commands.add(PathCommands.C_CURVE_TO);
                        coords.add(previous.x[2]);
                        coords.add(previous.y[2]);
                        coords.add(current.x[1]);
                        coords.add(current.y[1]);
                        coords.add(current.x[0]);
                        coords.add(current.y[0]);
                    }
                }
            }
            if (isClosed) {
                if (size() > 1) {
                    previous = get(size() - 1);
                    current = get(0);

                    if ((previous.mask & C2_MASK) == 0) {
                        if ((current.mask & C1_MASK) == 0) {
                            commands.add(PathCommands.LINE_TO);
                            coords.add(current.x[0]);
                            coords.add(current.y[0]);
                        } else {
                            commands.add(PathCommands.Q_CURVE_TO);
                            coords.add(current.x[1]);
                            coords.add(current.y[1]);
                            coords.add(current.x[0]);
                            coords.add(current.y[0]);
                        }
                    } else {
                        if ((current.mask & C1_MASK) == 0) {
                            commands.add(PathCommands.Q_CURVE_TO);
                            coords.add(previous.x[2]);
                            coords.add(previous.y[2]);
                            coords.add(current.x[0]);
                            coords.add(current.y[0]);
                        } else {
                            commands.add(PathCommands.C_CURVE_TO);
                            coords.add(previous.x[2]);
                            coords.add(previous.y[2]);
                            coords.add(current.x[1]);
                            coords.add(current.y[1]);
                            coords.add(current.x[0]);
                            coords.add(current.y[0]);
                        }
                    }
                }
            }
        }
        
        PathData pd = new PathData(commands, coords); 
        return pd;
    }
    
    @Override
    public boolean contains(Point2D p) {
        validatePath();
        return generalPath.contains(p);
    }

    ;

    /**
     * Returns true, if the outline of this bezier path contains the specified
     * point.
     *
     * @param p The point to be tested.
     * @param tolerance The tolerance for the test.
     */
    public boolean outlineContains(Point2D.Double p, double tolerance) {
        return Shapes.outlineContains(this, p, tolerance);
    }

    @Override
    public boolean intersects(Rectangle2D r) {
        validatePath();
        return generalPath.intersects(r);
    }

    @Override
    public PathIterator getPathIterator(AffineTransform at) {
        return new BezierPathIterator(this, at);
    }

    @Override
    public PathIterator getPathIterator(AffineTransform at, double flatness) {
        return new FlatteningPathIterator(new BezierPathIterator(this, at), flatness);
    }

    @Override
    public boolean contains(Rectangle2D r) {
        validatePath();
        return generalPath.contains(r);
    }

    @Override
    public boolean intersects(double x, double y, double w, double h) {
        validatePath();
        return generalPath.intersects(x, y, w, h);
    }

    @Override
    public Rectangle2D.Double getBounds2D() {
        if (bounds == null) {
            double x1, y1, x2, y2;
            int size = size();
            if (size == 0) {
                x1 = y1 = x2 = y2 = 0.0f;
            } else {
                double x, y;

                // handle first node
                Node node = get(0);
                y1 = y2 = node.y[0];
                x1 = x2 = node.x[0];
                if (isClosed && (node.mask & C1_MASK) != 0) {
                    y = node.y[1];
                    x = node.x[1];
                    if (x < x1) {
                        x1 = x;
                    }
                    if (y < y1) {
                        y1 = y;
                    }
                    if (x > x2) {
                        x2 = x;
                    }
                    if (y > y2) {
                        y2 = y;
                    }
                }
                if ((node.mask & C2_MASK) != 0) {
                    y = node.y[2];
                    x = node.x[2];
                    if (x < x1) {
                        x1 = x;
                    }
                    if (y < y1) {
                        y1 = y;
                    }
                    if (x > x2) {
                        x2 = x;
                    }
                    if (y > y2) {
                        y2 = y;
                    }
                }
                // handle last node
                node = get(size - 1);
                y = node.y[0];
                x = node.x[0];
                if (x < x1) {
                    x1 = x;
                }
                if (y < y1) {
                    y1 = y;
                }
                if (x > x2) {
                    x2 = x;
                }
                if (y > y2) {
                    y2 = y;
                }
                if ((node.mask & C1_MASK) != 0) {
                    y = node.y[1];
                    x = node.x[1];
                    if (x < x1) {
                        x1 = x;
                    }
                    if (y < y1) {
                        y1 = y;
                    }
                    if (x > x2) {
                        x2 = x;
                    }
                    if (y > y2) {
                        y2 = y;
                    }
                }
                if (isClosed && (node.mask & C2_MASK) != 0) {
                    y = node.y[2];
                    x = node.x[2];
                    if (x < x1) {
                        x1 = x;
                    }
                    if (y < y1) {
                        y1 = y;
                    }
                    if (x > x2) {
                        x2 = x;
                    }
                    if (y > y2) {
                        y2 = y;
                    }
                }

                // handle all other nodes
                for (int i = 1, n = size - 1; i < n; i++) {
                    node = get(i);
                    y = node.y[0];
                    x = node.x[0];
                    if (x < x1) {
                        x1 = x;
                    }
                    if (y < y1) {
                        y1 = y;
                    }
                    if (x > x2) {
                        x2 = x;
                    }
                    if (y > y2) {
                        y2 = y;
                    }
                    if ((node.mask & C1_MASK) != 0) {
                        y = node.y[1];
                        x = node.x[1];
                        if (x < x1) {
                            x1 = x;
                        }
                        if (y < y1) {
                            y1 = y;
                        }
                        if (x > x2) {
                            x2 = x;
                        }
                        if (y > y2) {
                            y2 = y;
                        }
                    }
                    if ((node.mask & C2_MASK) != 0) {
                        y = node.y[2];
                        x = node.x[2];
                        if (x < x1) {
                            x1 = x;
                        }
                        if (y < y1) {
                            y1 = y;
                        }
                        if (x > x2) {
                            x2 = x;
                        }
                        if (y > y2) {
                            y2 = y;
                        }
                    }
                }
            }
            bounds = new Rectangle2D.Double(x1, y1, x2 - x1, y2 - y1);
        }
        return (Rectangle2D.Double) bounds.clone();
    }

    @Override
    public Rectangle getBounds() {
        return getBounds2D().getBounds();
    }

    @Override
    public boolean contains(double x, double y, double w, double h) {
        validatePath();
        return generalPath.contains(x, y, w, h);
    }

    @Override
    public boolean contains(double x, double y) {
        validatePath();
        return generalPath.contains(x, y);
    }

    public void setClosed(boolean newValue) {
        if (isClosed != newValue) {
            isClosed = newValue;
            invalidatePath();
        }
    }

    public boolean isClosed() {
        return isClosed;
    }

    /** Creates a deep copy of the BezierPath. */
    @Override
    public BezierPath clone() {
        BezierPath that = (BezierPath) super.clone();
        for (int i = 0, n = this.size(); i < n; i++) {
            that.set(i, (Node) this.get(i).clone());
        }
        return that;
    }

    /**
     * Transforms the BezierPath.
     * @param tx the transformation.
     */
    public void transform(AffineTransform tx) {
        Point2D.Double p = new Point2D.Double();
        for (Node cp : this) {
            for (int i = 0; i < 3; i++) {
                p.x = cp.x[i];
                p.y = cp.y[i];
                tx.transform(p, p);
                cp.x[i] = p.x;
                cp.y[i] = p.y;
            }
        }
        invalidatePath();
    }

    /**
     * Sets all values of this bezier path to that bezier path, so that this
     * path becomes identical to that path.
     */
    public void setTo(BezierPath that) {
        while (that.size() < size()) {
            remove(size() - 1);
        }
        for (int i = 0, n = size(); i < n; i++) {
            get(i).setTo(that.get(i));
        }
        while (size() < that.size()) {
            add((Node) that.get(size()).clone());
        }
    }

    /**
     * Returns the point at the center of the bezier path.
     */
    public Point2D.Double getCenter() {
        double sx = 0;
        double sy = 0;
        for (Node p : this) {
            sx += p.x[0];
            sy += p.y[0];
        }

        int n = size();
        return new Point2D.Double(sx / n, sy / n);
    }

    /**
     * Returns a point on the edge of the bezier path which crosses the line
     * from the center of the bezier path to the specified point.
     * If no edge crosses the line, the nearest C0 control point is returned.
     */
    public Point2D.Double chop(Point2D.Double p) {
        return Geom.chop(this, p);
    }

    /**
     * Return the index of the node that is the furthest away from the center
     **/
    public int indexOfOutermostNode() {
        if (outer == -1) {
            Point2D.Double ctr = getCenter();
            outer = 0;
            double dist = 0;

            for (int i = 0, n = size(); i < n; i++) {
                Node cp = get(i);
                double d = Geom.length2(ctr.x, ctr.y,
                        cp.x[0],
                        cp.y[0]);
                if (d > dist) {
                    dist = d;
                    outer = i;
                }
            }
        }
        return outer;
    }

    /**
     * Returns a relative point on the path.
     * Where 0 is the start point of the path and 1 is the end point of the
     * path.
     *
     * @param relative a value between 0 and 1.
     */
    public Point2D.Double getPointOnPath(double relative, double flatness) {
        // This method works only for straight lines
        if (size() == 0) {
            return null;
        } else if (size() == 1) {
            return get(0).getControlPoint(0);
        }
        if (relative <= 0) {
            return get(0).getControlPoint(0);
        } else if (relative >= 1) {
            return get(size() - 1).getControlPoint(0);
        }
        validatePath();

        // Compute the relative point on the path
        double len = getLengthOfPath(flatness);
        double relativeLen = len * relative;
        double pos = 0;
        double[] coords = new double[6];
        PathIterator i = generalPath.getPathIterator(new AffineTransform(), flatness);
        double prevX = coords[0];
        double prevY = coords[1];
        i.next();
        for (; !i.isDone(); i.next()) {
            i.currentSegment(coords);
            double segLen = Geom.length(prevX, prevY, coords[0], coords[1]);
            if (pos + segLen >= relativeLen) {
                //if (true) return new Point2D.Double(coords[0], coords[1]);
                // Compute the relative Point2D.Double on the line
                /*
                return new Point2D.Double(
                prevX * pos / len + coords[0] * (pos + segLen) / len,
                prevY * pos / len + coords[1] * (pos + segLen) / len
                );*/
                double factor = (relativeLen - pos) / segLen;

                return new Point2D.Double(
                        prevX * (1 - factor) + coords[0] * factor,
                        prevY * (1 - factor) + coords[1] * factor);
            }
            pos += segLen;
            prevX = coords[0];
            prevY = coords[1];
        }
        throw new InternalError(""We should never get here"");
    }

    /**
     * Returns the length of the path.
     *
     * @param flatness the flatness used to approximate the length.
     */
    public double getLengthOfPath(double flatness) {
        double len = 0;
        PathIterator i = generalPath.getPathIterator(new AffineTransform(), flatness);
        double[] coords = new double[6];
        double prevX = coords[0];
        double prevY = coords[1];
        i.next();
        for (; !i.isDone(); i.next()) {
            i.currentSegment(coords);
            len += Geom.length(prevX, prevY, coords[0], coords[1]);
            prevX = coords[0];
            prevY = coords[1];
        }
        return len;
    }

    /**
     * Returns the relative position of the specified point on the path.
     *
     * @param flatness the flatness used to approximate the length.
     *
     * @return relative position on path, this is a number between 0 and 1.
     * Returns -1, if the point is not on the path.
     */
    public double getRelativePositionOnPath(Point2D.Double find, double flatness) {
        // XXX - This method works only for straight lines!
        double len = getLengthOfPath(flatness);
        double relativeLen = 0d;
        Node v1, v2;
        BezierPath tempPath = new BezierPath();
        Node t1, t2;
        tempPath.add(t1 = new Node());
        tempPath.add(t2 = new Node());

        for (int i = 0, n = size() - 1; i < n; i++) {
            v1 = get(i);
            v2 = get(i + 1);
            if (v1.mask == 0 && v2.mask == 0) {
                if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, flatness)) {
                    relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);
                    return relativeLen / len;
                } else {
                    relativeLen += Geom.length(v1.x[0], v1.y[0], v2.x[0], v2.y[0]);
                }
            } else {
                t1.setTo(v1);
                t2.setTo(v2);
                tempPath.invalidatePath();
                if (tempPath.outlineContains(find, flatness)) {
                    relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);
                    return relativeLen / len;
                } else {
                    relativeLen += Geom.length(v1.x[0], v1.y[0], v2.x[0], v2.y[0]);
                }
            }
        }
        if (isClosed && size() > 1) {
            v1 = get(size() - 1);
            v2 = get(0);
            if (v1.mask == 0 && v2.mask == 0) {
                if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, flatness)) {
                    relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);
                    return relativeLen / len;
                }
            } else {
                t1.setTo(v1);
                t2.setTo(v2);
                tempPath.invalidatePath();
                if (tempPath.outlineContains(find, flatness)) {
                    relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);
                    return relativeLen / len;
                }
            }
        }
        return -1;
    }

    /**
     * Gets the segment of the polyline that is hit by
     * the given Point2D.Double.
     * @return the index of the segment or -1 if no segment was hit.
     */
    public int findSegment(Point2D.Double find, double tolerance) {
        // XXX - This works only for straight lines!
        Node v1, v2;
        BezierPath tempPath = new BezierPath();
        Node t1, t2;
        tempPath.add(t1 = new Node());
        tempPath.add(t2 = new Node());

        for (int i = 0, n = size() - 1; i < n; i++) {
            v1 = get(i);
            v2 = get(i + 1);
            if (v1.mask == 0 && v2.mask == 0) {
                if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, tolerance)) {
                    return i;
                }
            } else {
                t1.setTo(v1);
                t2.setTo(v2);
                tempPath.invalidatePath();
                if (tempPath.outlineContains(find, tolerance)) {
                    return i;
                }
            }
        }
        if (isClosed && size() > 1) {
            v1 = get(size() - 1);
            v2 = get(0);
            if (v1.mask == 0 && v2.mask == 0) {
                if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, tolerance)) {
                    return size() - 1;
                }
            } else {
                t1.setTo(v1);
                t2.setTo(v2);
                tempPath.invalidatePath();
                if (tempPath.outlineContains(find, tolerance)) {
                    return size() - 1;
                }
            }
        }
        return -1;
    }

    /**
     * Joins two segments into one if the given Point2D.Double hits a node
     * of the bezier path.
     * @return the index of the joined segment or -1 if no segment was joined.
     */
    public int joinSegments(Point2D.Double join, double tolerance) {
        for (int i = 0; i < size(); i++) {
            Node p = get(i);
            if (Geom.length(p.x[0], p.y[0], join.x, join.y) < tolerance) {
                remove(i);
                return i;
            }
        }
        return -1;
    }

    /**
     * Splits the segment at the given Point2D.Double if a segment was hit.
     * @return the index of the segment or -1 if no segment was hit.
     */
    public int splitSegment(Point2D.Double split, double tolerance) {
        int i = findSegment(split, tolerance);
        int nextI = (i + 1) % size();
        if (i != -1) {
            if ((get(i).mask & C2_MASK) == C2_MASK
                    && (get(nextI).mask & C1_MASK) == 0) {
                // quadto
                add(i + 1, new Node(C2_MASK, split, split, split));
            } else if ((get(i).mask & C2_MASK) == 0
                    && (get(nextI).mask & C1_MASK) == C1_MASK) {
                // quadto
                add(i + 1, new Node(C1_MASK, split, split, split));
            } else if ((get(i).mask & C2_MASK) == C2_MASK
                    && (get(nextI).mask & C1_MASK) == C1_MASK) {
                // cubicto
                add(i + 1, new Node(C1_MASK | C2_MASK, split, split, split));
            } else {
                // lineto
                add(i + 1, new Node(split));
            }
        }
        return i + 1;
    }

    /**
     * Adds the first node to the bezier path.
     * <p>
     * This is a convenience method for adding the first node with a single
     * control point C0 to the bezier path.
     */
    public void moveTo(double x1, double y1) {
        if (size() != 0) {
            throw new IllegalPathStateException(""moveTo only allowed when empty"");
        }
        Node node = new Node(x1, y1);
        node.keepColinear = false;
        add(node);
    }

    /**
     * Adds a (at least) linear 'curve' to the bezier path.
     * <p>
     * If the previous node has no C2 control point the line will be straight
     * (linear), otherwise the line will be quadratic.
     * <p>
     * This is a convenience method for adding a node with a single control
     * point C0.
     * <p>
     * The bezier path must already have at least one node.
     */
    public void lineTo(double x1, double y1) {
        if (size() == 0) {
            throw new IllegalPathStateException(""lineTo only allowed when not empty"");
        }
        get(size() - 1).keepColinear = false;
        add(new Node(x1, y1));
    }

    /**
     * Adds a (at least) quadratic curve to the bezier path.
     * <p>
     * If the previous node has no C2 control point the line will be quadratic
     * otherwise the line will be cubic.
     * <p>
     * This is a convenience method for adding a node with control point C0 and
     * C1 (incoming curve) to the bezier path.
     * <p>
     * The bezier path must already have at least one node.
     */
    public void quadTo(double x1, double y1,
            double x2, double y2) {
        if (size() == 0) {
            throw new IllegalPathStateException(""quadTo only allowed when not empty"");
        }

        add(new Node(C1_MASK, x2, y2, x1, y1, x2, y2));
    }

    /**
     * Adds a cubic curve to the bezier path.
     * <p>
     * This is a convenience method for adding a node with control point C0 and
     * C1 (incoming curve) to the bezier path, and also specifying the control
     * point C2 (outgoing curve) of the previous node.
     * <p>
     * The bezier path must already have at least one node.
     */
    public void curveTo(double x1, double y1,
            double x2, double y2,
            double x3, double y3) {
        if (size() == 0) {
            throw new IllegalPathStateException(""curveTo only allowed when not empty"");
        }
        Node lastPoint = get(size() - 1);

        lastPoint.mask |= C2_MASK;
        lastPoint.x[2] = x1;
        lastPoint.y[2] = y1;

        if ((lastPoint.mask & C1C2_MASK) == C1C2_MASK) {
            lastPoint.keepColinear = Math.abs(
                    Geom.angle(lastPoint.x[0], lastPoint.y[0],
                    lastPoint.x[1], lastPoint.y[1])
                    - Geom.angle(lastPoint.x[2], lastPoint.y[2],
                    lastPoint.x[0], lastPoint.y[0])) < 0.001;
        }

        add(new Node(C1_MASK, x3, y3, x2, y2, x3, y3));
    }

    /**
     * Adds an elliptical arc, defined by two radii, an angle from the
     * x-axis, a flag to choose the large arc or not, a flag to
     * indicate if we increase or decrease the angles and the final
     * point of the arc.
     * <p>
     * As specified in http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
     * <p>
     * The implementation of this method has been derived from
     * Apache Batik class org.apache.batik.ext.awt.geom.ExtendedGeneralPath#computArc
     *
     * @param rx the x radius of the ellipse
     * @param ry the y radius of the ellipse
     *
     * @param xAxisRotation the angle from the x-axis of the current
     * coordinate system to the x-axis of the ellipse in degrees.
     *
     * @param largeArcFlag the large arc flag. If true the arc
     * spanning less than or equal to 180 degrees is chosen, otherwise
     * the arc spanning greater than 180 degrees is chosen
     *
     * @param sweepFlag the sweep flag. If true the line joining
     * center to arc sweeps through decreasing angles otherwise it
     * sweeps through increasing angles
     *
     * @param x the absolute x coordinate of the final point of the arc.
     * @param y the absolute y coordinate of the final point of the arc.
     */
    public void arcTo(double rx, double ry,
            double xAxisRotation,
            boolean largeArcFlag, boolean sweepFlag,
            double x, double y) {


        // Ensure radii are valid
        if (rx == 0 || ry == 0) {
            lineTo(x, y);
            return;
        }

        // Get the current (x, y) coordinates of the path
        Node lastPoint = get(size() - 1);
        double x0 = ((lastPoint.mask & C2_MASK) == C2_MASK) ? lastPoint.x[2] : lastPoint.x[0];
        double y0 = ((lastPoint.mask & C2_MASK) == C2_MASK) ? lastPoint.y[2] : lastPoint.y[0];

        if (x0 == x && y0 == y) {
            // If the endpoints (x, y) and (x0, y0) are identical, then this
            // is equivalent to omitting the elliptical arc segment entirely.
            return;
        }

        // Compute the half distance between the current and the final point
        double dx2 = (x0 - x) / 2d;
        double dy2 = (y0 - y) / 2d;
        // Convert angle from degrees to radians
        double angle = Math.toRadians(xAxisRotation);
        double cosAngle = Math.cos(angle);
        double sinAngle = Math.sin(angle);

        //
        // Step 1 : Compute (x1, y1)
        //
        double x1 = (cosAngle * dx2 + sinAngle * dy2);
        double y1 = (-sinAngle * dx2 + cosAngle * dy2);
        // Ensure radii are large enough
        rx = Math.abs(rx);
        ry = Math.abs(ry);
        double Prx = rx * rx;
        double Pry = ry * ry;
        double Px1 = x1 * x1;
        double Py1 = y1 * y1;
        // check that radii are large enough
        double radiiCheck = Px1 / Prx + Py1 / Pry;
        if (radiiCheck > 1) {
            rx = Math.sqrt(radiiCheck) * rx;
            ry = Math.sqrt(radiiCheck) * ry;
            Prx = rx * rx;
            Pry = ry * ry;
        }

        //
        // Step 2 : Compute (cx1, cy1)
        //
        double sign = (largeArcFlag == sweepFlag) ? -1 : 1;
        double sq = ((Prx * Pry) - (Prx * Py1) - (Pry * Px1)) / ((Prx * Py1) + (Pry * Px1));
        sq = (sq < 0) ? 0 : sq;
        double coef = (sign * Math.sqrt(sq));
        double cx1 = coef * ((rx * y1) / ry);
        double cy1 = coef * -((ry * x1) / rx);

        //
        // Step 3 : Compute (cx, cy) from (cx1, cy1)
        //
        double sx2 = (x0 + x) / 2.0;
        double sy2 = (y0 + y) / 2.0;
        double cx = sx2 + (cosAngle * cx1 - sinAngle * cy1);
        double cy = sy2 + (sinAngle * cx1 + cosAngle * cy1);

        //
        // Step 4 : Compute the angleStart (angle1) and the angleExtent (dangle)
        //
        double ux = (x1 - cx1) / rx;
        double uy = (y1 - cy1) / ry;
        double vx = (-x1 - cx1) / rx;
        double vy = (-y1 - cy1) / ry;
        double p, n;

        // Compute the angle start
        n = Math.sqrt((ux * ux) + (uy * uy));
        p = ux; // (1 * ux) + (0 * uy)
        sign = (uy < 0) ? -1d : 1d;
        double angleStart = Math.toDegrees(sign * Math.acos(p / n));

        // Compute the angle extent
        n = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));
        p = ux * vx + uy * vy;
        sign = (ux * vy - uy * vx < 0) ? -1d : 1d;
        double angleExtent = Math.toDegrees(sign * Math.acos(p / n));
        if (!sweepFlag && angleExtent > 0) {
            angleExtent -= 360f;
        } else if (sweepFlag && angleExtent < 0) {
            angleExtent += 360f;
        }
        angleExtent %= 360f;
        angleStart %= 360f;

        //
        // We can now build the resulting Arc2D in double precision
        //
        Arc2D.Double arc = new Arc2D.Double(
                cx - rx, cy - ry,
                rx * 2d, ry * 2d,
                -angleStart, -angleExtent,
                Arc2D.OPEN);

        // Create a path iterator of the rotated arc
        PathIterator i = arc.getPathIterator(
                AffineTransform.getRotateInstance(
                angle, arc.getCenterX(), arc.getCenterY()));

        // Add the segments to the bezier path
        double[] coords = new double[6];
        i.next(); // skip first moveto
        while (!i.isDone()) {
            int type = i.currentSegment(coords);
            switch (type) {
                case PathIterator.SEG_CLOSE:
                    // ignore
                    break;
                case PathIterator.SEG_CUBICTO:
                    curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
                    break;
                case PathIterator.SEG_LINETO:
                    lineTo(coords[0], coords[1]);
                    break;
                case PathIterator.SEG_MOVETO:
                    // ignore
                    break;
                case PathIterator.SEG_QUADTO:
                    quadTo(coords[0], coords[1], coords[2], coords[3]);
                    break;
            }
            i.next();
        }
    }

    /**
     * Creates a polygon/polyline array of the bezier path which only includes
     * the C0 control points of the bezier nodes.
     * <p>
     * If the bezier path is closed, the array describes a polygon.
     * If the bezier path is open, the array describes a polyline.
     * <p>
     * @return Point array.
     */
    public Point2D.Double[] toPolygonArray() {
        Point2D.Double[] points = new Point2D.Double[size()];
        for (int i = 0, n = size(); i < n; i++) {
            points[i] = new Point2D.Double(get(i).x[0], get(i).y[0]);
        }
        return points;
    }

    /**
     * Sets winding rule for filling the bezier path.
     * @param newValue Must be Path2D.Double.WIND_EVEN_ODD or Path2D.Double.WIND_NON_ZERO.
     */
    public void setWindingRule(int newValue) {
        if (newValue != windingRule) {
            invalidatePath();
            this.windingRule = newValue;
        }
    }

    /**
     * Gets winding rule for filling the bezier path.
     * @return Path2D.Double.WIND_EVEN_ODD or Path2D.Double.WIND_NON_ZERO.
     */
    public int getWindingRule() {
        return windingRule;
    }
}"
akka-bbb-apps/src/main/scala/org/bigbluebutton/core/util/jhotdraw/BezierPathIterator.java,"/*
 * @(#)BezierPathIterator.java
 *
 * Full JHotDraw project information can be found here https://sourceforge.net/projects/jhotdraw/
 * 
 * Copyright (c) 1996-2010 The authors and contributors of JHotDraw.
 * You may not use, copy or modify this file, except in compliance with the 
 * accompanying license terms.
 *
 * These release is distributed under LGPL.
 
 * The original version of JHotDraw is copyright 1996, 1997 by IFA Informatik 
 * and Erich Gamma.
 *
 * It is hereby granted that this software can be used, copied, modified, and 
 * distributed without fee provided that this copyright noticeappears in all copies.
 */

package org.bigbluebutton.core.util.jhotdraw;

import java.awt.geom.*;

/**
 * This class represents the iterator for a BezierPath.
 * It can be used to retrieve all of the elements in a BezierPath.
 * The {@link BezierPath#getPathIterator}
 *  method is used to create a
 * BezierPathIterator for a particular BezierPath.
 * The iterator can be used to iterator the path only once.
 * Subsequent iterations require a new iterator.
 *
 * @author Werner Randelshofer
 * @version $Id$
 */
public class BezierPathIterator implements PathIterator {
    /**
     * Index of the next node.
     */
    private int index   = 0;
    /**
     * The bezier path.
     */
    private BezierPath path;
    /**
     * The transformation.
     */
    private AffineTransform affine;
    
    /** ?? */
    private static final int curvesize[] = {2, 2, 4, 6, 0};
    
    /**
     * Constructs an iterator given a BezierPath.
     * @see BezierPath#getPathIterator
     */
    public BezierPathIterator(BezierPath path) {
        this(path, null);
    }
    
    /**
     * Constructs an iterator given a BezierPath and an optional
     * AffineTransform.
     * @see BezierPath#getPathIterator
     */
    public BezierPathIterator(BezierPath path, AffineTransform at) {
        this.path = path;
        this.affine = at;
    }
    
    /**
     * Return the winding rule for determining the interior of the
     * path.
     * @see PathIterator#WIND_EVEN_ODD
     * @see PathIterator#WIND_NON_ZERO
     */
    @Override
    public int getWindingRule() {
        return path.getWindingRule();
    }
    
    /**
     * Tests if there are more points to read.
     * @return true if there are more points to read
     */
    @Override
    public boolean isDone() {
        return (index >= path.size() + (path.isClosed() ? 2 : 0));
    }
    
    /**
     * Moves the iterator to the next segment of the path forwards
     * along the primary direction of traversal as long as there are
     * more points in that direction.
     */
    @Override
    public void next() {
        if (! isDone()) {
            index++;
        }
    }
    
    /**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A float array of length 6 must be passed in and may be used to
     * store the coordinates of the point(s).
     * Each point is stored as a pair of float x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point,
     * SEG_QUADTO will return two points,
     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     * @see PathIterator#SEG_MOVETO
     * @see PathIterator#SEG_LINETO
     * @see PathIterator#SEG_QUADTO
     * @see PathIterator#SEG_CUBICTO
     * @see PathIterator#SEG_CLOSE
     */
    @Override
    public int currentSegment(float[] coords) {
        int numCoords = 0;
        int type = 0;
        if (index == path.size()) {
            // We only get here for closed paths
            if (path.size() > 1) {
                BezierPath.Node previous = path.get(path.size() - 1);
                BezierPath.Node current = path.get(0);
                
                if ((previous.mask & BezierPath.C2_MASK) == 0) {
                    if ((current.mask & BezierPath.C1_MASK) == 0) {
                        numCoords = 1;
                        type = SEG_LINETO;
                        coords[0] = (float) current.x[0];
                        coords[1] = (float) current.y[0];
                    } else {
                        numCoords = 2;
                        type = SEG_QUADTO;
                        coords[0] = (float) current.x[1];
                        coords[1] = (float) current.y[1];
                        coords[2] = (float) current.x[0];
                        coords[3] = (float) current.y[0];
                    }
                } else {
                    if ((current.mask & BezierPath.C1_MASK) == 0) {
                        numCoords = 2;
                        type = SEG_QUADTO;
                        coords[0] = (float) previous.x[2];
                        coords[1] = (float) previous.y[2];
                        coords[2] = (float) current.x[0];
                        coords[3] = (float) current.y[0];
                    } else {
                        numCoords = 3;
                        type = SEG_CUBICTO;
                        coords[0] = (float) previous.x[2];
                        coords[1] = (float) previous.y[2];
                        coords[2] = (float) current.x[1];
                        coords[3] = (float) current.y[1];
                        coords[4] = (float) current.x[0];
                        coords[5] = (float) current.y[0];
                    }
                }
            }
        } else if (index > path.size()) {
            // We only get here for closed paths
            return SEG_CLOSE;
        } else if (index == 0) {
            BezierPath.Node current = path.get(index);
            coords[0] = (float) current.x[0];
            coords[1] = (float) current.y[0];
            numCoords = 1;
            type = SEG_MOVETO;
            
        } else if (index < path.size()) {
            BezierPath.Node current = path.get(index);
            BezierPath.Node previous = path.get(index - 1);
            
            if ((previous.mask & BezierPath.C2_MASK) == 0) {
                if ((current.mask & BezierPath.C1_MASK) == 0) {
                    numCoords = 1;
                    type = SEG_LINETO;
                    coords[0] = (float) current.x[0];
                    coords[1] = (float) current.y[0];
                    
                } else {
                    numCoords = 2;
                    type = SEG_QUADTO;
                    coords[0] = (float) current.x[1];
                    coords[1] = (float) current.y[1];
                    coords[2] = (float) current.x[0];
                    coords[3] = (float) current.y[0];
                }
            } else {
                if ((current.mask & BezierPath.C1_MASK) == 0) {
                    numCoords = 2;
                    type = SEG_QUADTO;
                    coords[0] = (float) previous.x[2];
                    coords[1] = (float) previous.y[2];
                    coords[2] = (float) current.x[0];
                    coords[3] = (float) current.y[0];
                } else {
                    numCoords = 3;
                    type = SEG_CUBICTO;
                    coords[0] = (float) previous.x[2];
                    coords[1] = (float) previous.y[2];
                    coords[2] = (float) current.x[1];
                    coords[3] = (float) current.y[1];
                    coords[4] = (float) current.x[0];
                    coords[5] = (float) current.y[0];
                }
            }
        }
        
        
        if (affine != null) {
            affine.transform(coords, 0, coords, 0, numCoords);
        }
        return type;
    }
    
    /**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
     * A double array of length 6 must be passed in and may be used to
     * store the coordinates of the point(s).
     * Each point is stored as a pair of double x,y coordinates.
     * SEG_MOVETO and SEG_LINETO types will return one point,
     * SEG_QUADTO will return two points,
     * SEG_CUBICTO will return 3 points
     * and SEG_CLOSE will not return any points.
     * @see PathIterator#SEG_MOVETO
     * @see PathIterator#SEG_LINETO
     * @see PathIterator#SEG_QUADTO
     * @see PathIterator#SEG_CUBICTO
     * @see PathIterator#SEG_CLOSE
     */
    @Override
    public int currentSegment(double[] coords) {
        int numCoords = 0;
        int type = 0;
        if (index == path.size()) {
            // We only get here for closed paths
            if (path.size() > 1) {
                BezierPath.Node previous = path.get(path.size() - 1);
                BezierPath.Node current = path.get(0);
                
                if ((previous.mask & BezierPath.C2_MASK) == 0) {
                    if ((current.mask & BezierPath.C1_MASK) == 0) {
                        numCoords = 1;
                        type = SEG_LINETO;
                        coords[0] = current.x[0];
                        coords[1] = current.y[0];
                    } else {
                        numCoords = 2;
                        type = SEG_QUADTO;
                        coords[0] = current.x[1];
                        coords[1] = current.y[1];
                        coords[2] = current.x[0];
                        coords[3] = current.y[0];
                    }
                } else {
                    if ((current.mask & BezierPath.C1_MASK) == 0) {
                        numCoords = 2;
                        type = SEG_QUADTO;
                        coords[0] = previous.x[2];
                        coords[1] = previous.y[2];
                        coords[2] = current.x[0];
                        coords[3] = current.y[0];
                    } else {
                        numCoords = 3;
                        type = SEG_CUBICTO;
                        coords[0] = previous.x[2];
                        coords[1] = previous.y[2];
                        coords[2] = current.x[1];
                        coords[3] = current.y[1];
                        coords[4] = current.x[0];
                        coords[5] = current.y[0];
                    }
                }
            }
        } else if (index > path.size()) {
            // We only get here for closed paths
            return SEG_CLOSE;
        } else if (index == 0) {
            BezierPath.Node current = path.get(index);
            coords[0] = current.x[0];
            coords[1] = current.y[0];
            numCoords = 1;
            type = SEG_MOVETO;
            
        } else if (index < path.size()) {
            BezierPath.Node current = path.get(index);
            BezierPath.Node previous = path.get(index - 1);
            
            if ((previous.mask & BezierPath.C2_MASK) == 0) {
                if ((current.mask & BezierPath.C1_MASK) == 0) {
                    numCoords = 1;
                    type = SEG_LINETO;
                    coords[0] = current.x[0];
                    coords[1] = current.y[0];
                    
                } else {
                    numCoords = 2;
                    type = SEG_QUADTO;
                    coords[0] = current.x[1];
                    coords[1] = current.y[1];
                    coords[2] = current.x[0];
                    coords[3] = current.y[0];
                }
            } else {
                if ((current.mask & BezierPath.C1_MASK) == 0) {
                    numCoords = 2;
                    type = SEG_QUADTO;
                    coords[0] = previous.x[2];
                    coords[1] = previous.y[2];
                    coords[2] = current.x[0];
                    coords[3] = current.y[0];
                } else {
                    numCoords = 3;
                    type = SEG_CUBICTO;
                    coords[0] = previous.x[2];
                    coords[1] = previous.y[2];
                    coords[2] = current.x[1];
                    coords[3] = current.y[1];
                    coords[4] = current.x[0];
                    coords[5] = current.y[0];
                }
            }
        }
        
        
        if (affine != null) {
            affine.transform(coords, 0, coords, 0, numCoords);
        } else {
            System.arraycopy(coords, 0, coords, 0, numCoords);
        }
        return type;
    }
}"
akka-bbb-apps/src/main/scala/org/bigbluebutton/core/util/jhotdraw/Shapes.java,"/*
 * @(#)Shapes.java
 *
 * Full JHotDraw project information can be found here https://sourceforge.net/projects/jhotdraw/
 * 
 * Copyright (c) 1996-2010 The authors and contributors of JHotDraw.
 * You may not use, copy or modify this file, except in compliance with the 
 * accompanying license terms.
 *
 * These release is distributed under LGPL.
 
 * The original version of JHotDraw is copyright 1996, 1997 by IFA Informatik 
 * and Erich Gamma.
 *
 * It is hereby granted that this software can be used, copied, modified, and 
 * distributed without fee provided that this copyright noticeappears in all copies.
 */

package org.bigbluebutton.core.util.jhotdraw;

import java.awt.*;
import java.awt.geom.*;

/**
 * Shapes.
 *
 * @author Werner Randelshofer
 * @version $Id$
 */
public class Shapes {

    /** Creates a new instance. */
    private Shapes() {
    }

    /**
     * Returns true, if the outline of this bezier path contains the specified
     * point.
     *
     * @param p The point to be tested.
     * @param tolerance The tolerance for the test.
     */
    public static boolean outlineContains(Shape shape, Point2D.Double p, double tolerance) {
        double[] coords = new double[6];
        double prevX = 0, prevY = 0;
        double moveX = 0, moveY = 0;
        for (PathIterator i = new FlatteningPathIterator(shape.getPathIterator(new AffineTransform(), tolerance), tolerance); !i.isDone(); i.next()) {
            switch (i.currentSegment(coords)) {
                case PathIterator.SEG_CLOSE:
                    if (Geom.lineContainsPoint(
                            prevX, prevY, moveX, moveY,
                            p.x, p.y, tolerance)) {
                        return true;
                    }
                    break;
                case PathIterator.SEG_CUBICTO:
                    break;
                case PathIterator.SEG_LINETO:
                    if (Geom.lineContainsPoint(
                            prevX, prevY, coords[0], coords[1],
                            p.x, p.y, tolerance)) {
                        return true;
                    }
                    break;
                case PathIterator.SEG_MOVETO:
                    moveX = coords[0];
                    moveY = coords[1];
                    break;
                case PathIterator.SEG_QUADTO:
                    break;
                default:
                    break;
            }
            prevX = coords[0];
            prevY = coords[1];
        }
        return false;
    }
}"
akka-bbb-apps/src/main/scala/org/bigbluebutton/core/util/jhotdraw/PathCommands.java,"package org.bigbluebutton.core.util.jhotdraw;

public class PathCommands {
	public static final int MOVE_TO = 1;
	public static final int LINE_TO = 2;
	public static final int Q_CURVE_TO = 3;
	public static final int C_CURVE_TO = 4;
	
	
    private PathCommands() {
    } // never instantiated
    
}"
akka-bbb-apps/deploy.sh,"#!/usr/bin/env bash
cd ""$(dirname ""$0"")""

sudo service bbb-apps-akka stop
sbt debian:packageBin
sudo dpkg -i target/bbb-apps-akka_*.deb
echo ''
echo ''
echo '----------------'
echo 'bbb-apps-akka updated'

sudo service bbb-apps-akka start
echo 'starting service bbb-apps-akka'"
akka-bbb-apps/run-dev.sh,"#!/usr/bin/env bash

sudo service bbb-apps-akka stop

rm -rf src/main/resources
cp -R src/universal/conf src/main/resources

#Set correct sharedSecret and bbbWebAPI
sudo sed -i ""s/sharedSecret = \""changeme\""/sharedSecret = \""$(sudo bbb-conf --salt | grep Secret: | cut -d ' ' -f 6)\""/g"" src/main/resources/application.conf
sudo sed -i ""s/bbbWebAPI = \""https:\/\/192.168.23.33\/bigbluebutton\/api\""/bbbWebAPI = \""https:\/\/$(hostname -f)\/bigbluebutton\/api\""/g"" src/main/resources/application.conf

#sbt update - Resolves and retrieves external dependencies, more details in https://www.scala-sbt.org/1.x/docs/Command-Line-Reference.html
#sbt ~reStart (instead of run) - run with ""triggered restart"" mode, more details in #https://github.com/spray/sbt-revolver
exec sbt update ~reStart"
akka-bbb-apps/run.sh,"#!/usr/bin/env bash

sbt clean stage
sudo service bbb-apps-akka stop
cd target/universal/stage
exec ./bin/bbb-apps-akka"
bigbluebutton-web/deploy_to_usr_share.sh,"#!/usr/bin/env bash
cd ""$(dirname ""$0"")""
sudo service bbb-web stop
./build.sh

grails assemble
mkdir -p exploded && cd exploded
jar -xvf ../build/libs/bigbluebutton-0.10.0.war

if [ ! -d /usr/share/bbb-web-old ] ; then
	sudo cp -R /usr/share/bbb-web /usr/share/bbb-web-old
	echo ""A backup was saved in /usr/share/bbb-web-old""
else
	echo ""A backup in /usr/share/bbb-web-old already exists. Skipping..""
fi
sudo rm -rf /usr/share/bbb-web/assets/ /usr/share/bbb-web/META-INF/ /usr/share/bbb-web/org/ /usr/share/bbb-web/WEB-INF/
sudo cp -R . /usr/share/bbb-web/
sudo chown bigbluebutton:bigbluebutton /usr/share/bbb-web
sudo chown -R bigbluebutton:bigbluebutton /usr/share/bbb-web/assets/ /usr/share/bbb-web/META-INF/ /usr/share/bbb-web/org/ /usr/share/bbb-web/WEB-INF/
echo ''
echo ''
echo '----------------'
echo 'bbb-web updated'

cd ..
sudo rm -r exploded
sudo service bbb-web start

echo 'starting service bbb-web'
"
bigbluebutton-web/test/groovy/org/bigbluebutton/api/ParamsProcessorUtilTest.java,"package org.bigbluebutton.api;

import java.util.HashMap;
import java.util.Map;

import org.testng.Assert;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

public class ParamsProcessorUtilTest {
	@BeforeMethod 
	public void setUp() {
		
	}
	
	@Test
	public void testMetaParameter() {
    boolean passed = ParamsProcessorUtil.isMetaValid(""meta_foo"");
		Assert.assertTrue(passed, ""The meta check should pass."");
	}
	
	@Test
	public void testInvalidMetaParameterUndescore() {
    boolean failed = ParamsProcessorUtil.isMetaValid(""meta_foo-bar_"");
		Assert.assertFalse(failed, ""The meta check should fail due to underscore (_)."");
	}

	@Test
	public void testInvalidMetaParameterWrongStartsWith() {
    boolean failed = ParamsProcessorUtil.isMetaValid(""notmeta_foo"");
		Assert.assertFalse(failed, ""The meta check should fail due to not starting with 'meta'."");
	}
	
	@Test
	public void testInvalidMetaParameterNonAlphaNumChar() {
    boolean failed = ParamsProcessorUtil.isMetaValid(""meta_foo-bar_&"");
		Assert.assertFalse(failed, ""The meta check should fail due to & char."");
	}
	
	@Test
	public void testInvalidMetaParameterNonAlphaAfterMeta() {
    boolean failed = ParamsProcessorUtil.isMetaValid(""meta_1"");
		Assert.assertFalse(failed, ""The meta check should fail due to 1 char."");
	}
	
	@Test
	public void testStringMetaFromParameter() {
    String result = ParamsProcessorUtil.removeMetaString(""meta_foo"");
		Assert.assertEquals(result, ""foo"");
	}
	
	@Test
	public void testStringMetaFromParameterWithDash() {
    String result = ParamsProcessorUtil.removeMetaString(""meta_foo-bar"");
		Assert.assertEquals(result, ""foo-bar"");
	}
	
	@Test
	public void testProcessMetaParameters() {
		Map<String, String> params = new HashMap<String, String>();
		params.put(""meta_foo"", ""foo"");
		params.put(""meta_bar"", ""bar"");
    Map<String, String> metas = ParamsProcessorUtil.processMetaParam(params);
		Assert.assertEquals(metas.size(), 2);
	}	
	
	@Test
	public void testProcessMetaParametersSkippingInvalid() {
		Map<String, String> params = new HashMap<String, String>();
		params.put(""meta_foo"", ""foo"");
		params.put(""meta_bar"", ""bar"");
		params.put(""invalid_meta"", ""discarded"");
    Map<String, String> metas = ParamsProcessorUtil.processMetaParam(params);
		Assert.assertEquals(metas.size(), 2);
	}	
}"
bigbluebutton-web/test/groovy/org/bigbluebutton/api/messaging/NullMessagingService.java,"package org.bigbluebutton.api.messaging;

import java.util.List;
import java.util.Map;

public class NullMessagingService implements MessagingService {

    public void start() {
        // TODO Auto-generated method stub

    }

    public void stop() {
        // TODO Auto-generated method stub

    }

    @Override
    public void recordMeetingInfo(String meetingId, Map<String, String> info) {
        // TODO Auto-generated method stub

    }

    /*
     * @Override public void recordMeetingMetadata(String meetingId, Map<String,
     * String> metadata) { // TODO Auto-generated method stub
     * 
     * }
     */

    public void addListener(MessageListener listener) {
        // TODO Auto-generated method stub

    }

    public void removeListener(MessageListener listener) {
        // TODO Auto-generated method stub

    }

    public void destroyMeeting(String meetingID) {
        // TODO Auto-generated method stub

    }

    public void createMeeting(String meetingID, String externalMeetingID, String meetingName, Boolean recorded,
            String voiceBridge, Long duration) {
        // TODO Auto-generated method stub

    }

    public void sendPolls(String meetingId, String title, String question, String questionType, List<String> answers) {
        // TODO Auto-generated method stub

    }

    @Override
    public void recordBreakoutInfo(String meetingId, Map<String, String> breakoutInfo) {
        // TODO Auto-generated method stub

    }

    @Override
    public void addBreakoutRoom(String parentId, String breakoutId) {
        // TODO Auto-generated method stub

    }

}"
bigbluebutton-web/run-dev.sh,"#!/usr/bin/env bash

echo ""!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!""
echo ""  **** This is for development only *****""
echo "" ""
echo "" Make sure you change permissions to /var/bigbluebutton/""
echo "" to allow bbb-web to write to the directory. ""
echo "" ""
echo "" chmod -R 777 /var/bigbluebutton/""
echo "" ""
echo ""!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!""

sudo service bbb-web stop

exec grails prod run-app --port 8090 -reloading"
bigbluebutton-web/build.sh,"#!/usr/bin/env bash
gradle clean
gradle resolveDeps
grails clean
"
bigbluebutton-web/run.sh,"#!/usr/bin/env bash
IS_BBB_WEB_RUNNING=`ss -an | grep LISTEN | grep 8090 > /dev/null && echo 1 || echo 0`

if [ ""$IS_BBB_WEB_RUNNING"" = ""1"" ]; then
	echo ""bbb-web is running, exiting""
	exit 1
fi

if [ ""`whoami`"" != ""bigbluebutton"" ]; then
	echo ""ERROR:  bbb-web must run as bigbluebutton user ( because of the uploaded files permissions )""
	exit 1
fi

exec grails prod run-app --port 8090"
bigbluebutton-web/pres-checker/src/main/java/org/bigbluebutton/prescheck/Main.java,"package org.bigbluebutton.prescheck;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.Predicate;
import org.apache.commons.io.FilenameUtils;
import org.apache.poi.util.LittleEndian;
import org.apache.poi.xslf.usermodel.XMLSlideShow;
import org.apache.poi.xslf.usermodel.XSLFPictureData;
import org.apache.poi.xslf.usermodel.XSLFSlide;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;

public class Main {

  public static void main(String[] args) {
    Main main = new Main();

    String filepath;
    try {
       // Parse the string argument into an integer value.
       filepath = args[0];
       boolean valid = main.check(main, filepath);
       if (!valid) System.exit(2);
       	System.exit(0);
    }
    catch (Exception nfe) {
       System.exit(1);
    }

  }

  private boolean check(Main main, String file) {
  	boolean valid = true;
  	XMLSlideShow xmlSlideShow;
      try {
        xmlSlideShow = new XMLSlideShow(new FileInputStream(file));
        valid &= !main.embedsEmf(xmlSlideShow);
        valid &= !main.containsTinyTileBackground(xmlSlideShow);
        valid &= !main.allSlidesAreHidden(xmlSlideShow);
        // Close the resource once we finished reading it
        xmlSlideShow.close();
      } catch (IOException e) {
        valid = false;
      }

      return valid;
  }

    /**
   * Checks if the slide-show file embeds any EMF document
   * 
   * @param xmlSlideShow
   * @return
   */
  private boolean embedsEmf(XMLSlideShow xmlSlideShow) {
    EmfPredicate emfPredicate = new EmfPredicate();
    ArrayList<XSLFPictureData> embeddedEmfFiles = (ArrayList<XSLFPictureData>) CollectionUtils
        .select(xmlSlideShow.getPictureData(), emfPredicate);
    if (embeddedEmfFiles.size() > 0) {
      return true;
    }
    return false;
  }

  /**
   * Checks if the slide-show contains a small background tile image
   * 
   * @param xmlSlideShow
   * @return
   */
  private boolean containsTinyTileBackground(XMLSlideShow xmlSlideShow) {
    TinyTileBackgroundPredicate tinyTileCondition = new TinyTileBackgroundPredicate();
    ArrayList<XSLFPictureData> tileImage = (ArrayList<XSLFPictureData>) CollectionUtils
        .select(xmlSlideShow.getPictureData(), tinyTileCondition);
    if (tileImage.size() > 0) {
      return true;
    }
    return false;
  }

	private boolean allSlidesAreHidden(XMLSlideShow xmlSlideShow) {
		HiddenSlidePredicate hiddenSlidePredicate = new HiddenSlidePredicate();
    ArrayList<XSLFSlide> hiddenSlides = (ArrayList<XSLFSlide>) CollectionUtils
		    .select(xmlSlideShow.getSlides(), hiddenSlidePredicate);
		if (hiddenSlides.size() == xmlSlideShow.getSlides().size()) {
			return true;
		}
		return false;
	}

  private final class EmfPredicate implements Predicate<XSLFPictureData> {
    public boolean evaluate(XSLFPictureData img) {
      return img.getContentType().equals(""image/x-emf"");
    }
  }

  private final class TinyTileBackgroundPredicate
      implements Predicate<XSLFPictureData> {
    public boolean evaluate(XSLFPictureData img) {
        return img.getContentType() != null
                && ((img.getContentType().equals(""image/jpeg"") && LittleEndian.getLong(img.getChecksum()) == 4114937224L) ||
                (img.getContentType().equals(""image/png"") && LittleEndian.getLong(img.getChecksum()) == 3207965638L));
    }
  }

	private final class HiddenSlidePredicate implements Predicate<XSLFSlide> {
		public boolean evaluate(XSLFSlide slide) {
			return !slide.getXmlObject().getShow();
		}
	}
}"
bigbluebutton-web/pres-checker/build.sh,"gradle clean
gradle jar
cp build/libs/*.jar lib"
bigbluebutton-web/pres-checker/run.sh,"#!/bin/sh
exec java -cp ""/usr/share/prescheck/lib/*"" org.bigbluebutton.prescheck.Main $@"
bbb-playback.placeholder.sh,"git clone --branch v5.0.0 --depth 1 https://github.com/bigbluebutton/bbb-playback bbb-playback"
bbb-graphql-client-test/deploy.sh,"#!/usr/bin/env bash
cd ""$(dirname ""$0"")""

for var in ""$@""
do
    if [[ $var == --reset ]] ; then
    	echo ""Performing a full reset...""
      rm -rf node_modules
    fi
done

if [ ! -d ./node_modules ] ; then
	npm install
fi

npm run build
echo ''
echo ''
echo '----------------'
echo 'bbb-graphql-client updated'"
bbb-graphql-middleware/install-graphql-middleware.sh,"#!/bin/bash
if [ ""$EUID"" -ne 0 ]; then
	echo ""Please run this script as root ( or with sudo )"" ;
	exit 1;
fi;

cd ""$(dirname ""$0"")""

#Install Go
sudo apt install golang -y
go version

# Build Graphql Middleware
./build.sh
mv bbb-graphql-middleware /usr/local/bin/bbb-graphql-middleware

# Create service bbb-graphql-middleware
cp ./bbb-graphql-middleware-config.env /etc/default/bbb-graphql-middleware
cp ./bbb-graphql-middleware.service /lib/systemd/system/bbb-graphql-middleware.service
systemctl enable bbb-graphql-middleware
systemctl start bbb-graphql-middleware


# Set nginx location
cp ./graphql.nginx /usr/share/bigbluebutton/nginx
systemctl restart nginx


echo """"
echo """"
echo ""Bbb-graphql-middleware Installed!"""
bbb-graphql-middleware/run-dev.sh,"#!/bin/bash
nodemon --exec go run cmd/bbb-graphql-middleware/main.go  --signal SIGTERM"
bbb-graphql-middleware/build.sh,"#!/bin/bash
CGO_ENABLED=0 go build -o bbb-graphql-middleware cmd/bbb-graphql-middleware/main.go
echo ""Build of bbb-graphql-middleware finished"""
bbb-graphql-middleware/build-and-run.sh,"#!/bin/bash
./build.sh
./main"
bbb-graphql-middleware/demo/client/stress-test.sh,"#!/bin/bash
# Run 10.000 connections with 20 parallel clients (each client will disconnect at a random time - see main.js for more details)
seq 1 10000 | xargs -n 1 -P 20 node main.js"
bbb-graphql-middleware/demo/client/run-watch.sh,"#!/bin/bash
nodemon --exec node main.js --signal SIGTERM"
bbb-graphql-middleware/demo/client/run.sh,"#!/bin/bash
node main.js"
bbb-common-message/src/main/java/org/bigbluebutton/common2/redis/RedisAwareCommunicator.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2018 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.common2.redis;

import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import org.slf4j.Logger;

import io.lettuce.core.RedisClient;
import io.lettuce.core.event.Event;
import io.lettuce.core.event.EventBus;
import io.lettuce.core.event.connection.ConnectedEvent;
import io.lettuce.core.event.connection.ConnectionActivatedEvent;
import io.lettuce.core.event.connection.ConnectionDeactivatedEvent;
import io.lettuce.core.event.connection.DisconnectedEvent;
import reactor.core.Disposable;

public abstract class RedisAwareCommunicator {

    protected RedisClient redisClient;

    protected Disposable eventBusSubscription;

    protected EventBus eventBus;

    protected String host;
    protected String password;
    protected int port;
    protected String clientName;
    protected int expireKey;

    public abstract void start();

    public abstract void stop();

    public void setPassword(String password) {
        this.password = password;
    }

    protected void connectionStatusHandler(Event event, Logger log) {
        //System.out.println(""******** RedisAwareCommunicator - "" + event);

        if (event instanceof ConnectedEvent) {
            log.info(""Connected to redis. clientName=""+ clientName);
        } else if (event instanceof ConnectionActivatedEvent) {
            log.info(""Connected to redis activated. clientName=""+ clientName);
        } else if (event instanceof DisconnectedEvent) {
            log.info(""Disconnected from redis. clientName=""+ clientName);
        } else if (event instanceof ConnectionDeactivatedEvent) {
            log.info(""Connected to redis deactivated. clientName=""+ clientName);
        }
    }

    public void setClientName(String clientName) {
        this.clientName = clientName;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public void setPort(int port) {
        this.port = port;
    }

    public void setExpireKey(int expireKey) {
        this.expireKey = expireKey;
    }

    protected GenericObjectPoolConfig createPoolingConfig() {
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(32);
        config.setMaxIdle(8);
        config.setMinIdle(1);
        config.setTestOnBorrow(true);
        config.setTestOnReturn(true);
        config.setTestWhileIdle(true);
        config.setNumTestsPerEvictionRun(12);
        config.setMaxWaitMillis(5000);
        config.setTimeBetweenEvictionRunsMillis(60000);
        config.setBlockWhenExhausted(true);
        return config;
    }
}"
bbb-common-message/src/main/java/org/bigbluebutton/common2/redis/pubsub/MessageReceiver.java,"package org.bigbluebutton.common2.redis.pubsub;

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

import org.apache.commons.pool2.impl.GenericObjectPool;
import org.bigbluebutton.common2.redis.RedisAwareCommunicator;
import org.slf4j.LoggerFactory;
import org.slf4j.Logger;

import io.lettuce.core.ClientOptions;
import io.lettuce.core.RedisClient;
import io.lettuce.core.RedisFuture;
import io.lettuce.core.RedisURI;
import io.lettuce.core.pubsub.RedisPubSubListener;
import io.lettuce.core.pubsub.StatefulRedisPubSubConnection;
import io.lettuce.core.pubsub.api.async.RedisPubSubAsyncCommands;
import io.lettuce.core.support.ConnectionPoolSupport;

public class MessageReceiver extends RedisAwareCommunicator {
    private static Logger log = LoggerFactory.getLogger(MessageReceiver.class);

    private ReceivedMessageHandler handler;

    GenericObjectPool<StatefulRedisPubSubConnection<String, String>> connectionPool;

    private final Executor runExec = Executors.newSingleThreadExecutor();

    private volatile boolean receiveMessage = false;

    private final String FROM_BBB_APPS_PATTERN = ""from-akka-apps-redis-channel"";

    public void start() {
        log.info(""Ready to receive messages from Redis pubsub."");
        receiveMessage = true;

        RedisURI redisUri = RedisURI.Builder.redis(this.host, this.port).withClientName(this.clientName).build();
        if (!this.password.isEmpty()) {
            redisUri.setPassword(this.password);
        }

        redisClient = RedisClient.create(redisUri);
        redisClient.setOptions(ClientOptions.builder().autoReconnect(true).build());
        eventBus = redisClient.getResources().eventBus();
        eventBusSubscription = eventBus.get().subscribe(e -> connectionStatusHandler(e, log));

        connectionPool = ConnectionPoolSupport.createGenericObjectPool(() -> redisClient.connectPubSub(),
                createPoolingConfig());

        Runnable messageReceiver = new Runnable() {
            public void run() {
                if (receiveMessage) {
                    try (StatefulRedisPubSubConnection<String, String> connection = connectionPool.borrowObject()) {
                        if (receiveMessage) {
                            connection.addListener(new MessageListener());

                            RedisPubSubAsyncCommands<String, String> async = connection.async();
                            RedisFuture<Void> future = async.subscribe(FROM_BBB_APPS_PATTERN);
                        }
                    } catch (Exception e) {
                        log.error(""Error resubscribing to channels: "", e);
                    }
                }
            }
        };

        runExec.execute(messageReceiver);
    }

    public void stop() {
        receiveMessage = false;
        connectionPool.close();
        redisClient.shutdown();
        log.info(""MessageReceiver Stopped"");
    }

    public void setMessageHandler(ReceivedMessageHandler handler) {
        this.handler = handler;
    }

    private class MessageListener implements RedisPubSubListener<String, String> {

        @Override
        public void message(String channel, String message) {
            handler.handleMessage("""", channel, message);
        }

        @Override
        public void message(String pattern, String channel, String message) {
            log.debug(""RECEIVED onPMessage"" + channel + "" message=\n"" + message);
            Runnable task = new Runnable() {
                public void run() {
                    handler.handleMessage(pattern, channel, message);
                }
            };

            runExec.execute(task);
        }

        @Override
        public void subscribed(String channel, long count) {
            log.debug(""Subscribed to the channel: "" + channel);
        }

        @Override
        public void psubscribed(String pattern, long count) {
            log.debug(""Subscribed to the pattern: "" + pattern);
        }

        @Override
        public void unsubscribed(String channel, long count) {
            log.debug(""Unsubscribed from the channel: "" + channel);
        }

        @Override
        public void punsubscribed(String pattern, long count) {
            log.debug(""Unsubscribed from the pattern: "" + pattern);
        }
    }

}"
bbb-common-message/src/main/java/org/bigbluebutton/common2/redis/pubsub/MessageDistributor.java,"package org.bigbluebutton.common2.redis.pubsub;

import java.util.Set;

public class MessageDistributor {
    private ReceivedMessageHandler handler;
    private Set<MessageHandler> listeners;

    public void setMessageListeners(Set<MessageHandler> listeners) {
        this.listeners = listeners;
    }

    public void setMessageHandler(ReceivedMessageHandler handler) {
        this.handler = handler;
        if (handler != null) {
            handler.setMessageDistributor(this);
        }
    }

    public void notifyListeners(String pattern, String channel, String message) {
        for (MessageHandler listener : listeners) {
            listener.handleMessage(pattern, channel, message);
        }
    }
}"
bbb-common-message/src/main/java/org/bigbluebutton/common2/redis/pubsub/MessageHandler.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/
package org.bigbluebutton.common2.redis.pubsub;

public interface MessageHandler {
    void handleMessage(String pattern, String channel, String message);
}"
bbb-common-message/src/main/java/org/bigbluebutton/common2/redis/pubsub/MessageSender.java,"package org.bigbluebutton.common2.redis.pubsub;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

import org.apache.commons.pool2.impl.GenericObjectPool;
import org.bigbluebutton.common2.redis.RedisAwareCommunicator;
import org.slf4j.LoggerFactory;
import org.slf4j.Logger;

import io.lettuce.core.ClientOptions;
import io.lettuce.core.RedisClient;
import io.lettuce.core.RedisFuture;
import io.lettuce.core.RedisURI;
import io.lettuce.core.api.async.RedisAsyncCommands;
import io.lettuce.core.pubsub.StatefulRedisPubSubConnection;
import io.lettuce.core.support.ConnectionPoolSupport;

public class MessageSender extends RedisAwareCommunicator {
    private static Logger log = LoggerFactory.getLogger(MessageSender.class);

    GenericObjectPool<StatefulRedisPubSubConnection<String, String>> connectionPool;

    private volatile boolean sendMessage = false;

    private final Executor msgSenderExec = Executors.newSingleThreadExecutor();
    private final Executor runExec = Executors.newSingleThreadExecutor();
    private BlockingQueue<MessageToSend> messages = new LinkedBlockingQueue<MessageToSend>();

    public void stop() {
        sendMessage = false;
        connectionPool.close();
        redisClient.shutdown();
    }

    public void start() {
        RedisURI redisUri = RedisURI.Builder.redis(this.host, this.port).withClientName(this.clientName).build();
        if (!this.password.isEmpty()) {
            redisUri.setPassword(this.password);
        }

        redisClient = RedisClient.create(redisUri);
        redisClient.setOptions(ClientOptions.builder().autoReconnect(true).build());
        eventBus = redisClient.getResources().eventBus();
        eventBusSubscription = eventBus.get().subscribe(e -> connectionStatusHandler(e, log));

        connectionPool = ConnectionPoolSupport.createGenericObjectPool(() -> redisClient.connectPubSub(),
                createPoolingConfig());

        try {
            sendMessage = true;

            Runnable messageSender = new Runnable() {
                public void run() {
                    while (sendMessage) {
                        try {
                            MessageToSend msg = messages.take();
                            publish(msg.getChannel(), msg.getMessage());
                        } catch (InterruptedException e) {
                            log.warn(""Failed to get org.bigbluebutton.common2.redis.pubsub from queue."");
                        }
                    }
                }
            };
            msgSenderExec.execute(messageSender);
        } catch (Exception e) {
            log.error(""Error subscribing to channels: "" + e.getMessage());
        }

    }

    public void send(String channel, String message) {
        MessageToSend msg = new MessageToSend(channel, message);
        messages.add(msg);
    }

    private void publish(final String channel, final String message) {
        Runnable task = new Runnable() {
            public void run() {
                try (StatefulRedisPubSubConnection<String, String> connection = connectionPool.borrowObject()) {
                    RedisAsyncCommands<String, String> async = connection.async();
                    RedisFuture<Long> future = async.publish(channel, message);
                } catch (Exception e) {
                    log.warn(""Cannot publish the message to redis"", e);
                }
            }
        };

        runExec.execute(task);
    }
}"
bbb-common-message/src/main/java/org/bigbluebutton/common2/redis/pubsub/MessageToSend.java,"package org.bigbluebutton.common2.redis.pubsub;

public class MessageToSend {
    private final String channel;
    private final String message;

    public MessageToSend(String channel, String message) {
        this.channel = channel;
        this.message = message;
    }

    public String getChannel() {
        return channel;
    }

    public String getMessage() {
        return message;
    }
}"
bbb-common-message/src/main/java/org/bigbluebutton/common2/redis/pubsub/ReceivedMessage.java,"package org.bigbluebutton.common2.redis.pubsub;

public class ReceivedMessage {
    private final String pattern;
    private final String channel;
    private final String message;

    public ReceivedMessage(String pattern, String channel, String message) {
        this.pattern = pattern;
        this.channel = channel;
        this.message = message;
    }

    public String getPattern() {
        return pattern;
    }

    public String getChannel() {
        return channel;
    }

    public String getMessage() {
        return message;
    }
}"
bbb-common-message/src/main/java/org/bigbluebutton/common2/redis/pubsub/ReceivedMessageHandler.java,"package org.bigbluebutton.common2.redis.pubsub;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

import org.slf4j.LoggerFactory;
import org.slf4j.Logger;

public class ReceivedMessageHandler {
    private static Logger log = LoggerFactory
            .getLogger(ReceivedMessageHandler.class);

    private BlockingQueue<ReceivedMessage> receivedMessages = new LinkedBlockingQueue<ReceivedMessage>();

    private volatile boolean processMessage = false;

    private final Executor msgProcessorExec = Executors.newSingleThreadExecutor();
    private final Executor runExec = Executors.newSingleThreadExecutor();

    private MessageDistributor handler;

    public void stop() {
        processMessage = false;
    }

    public void start() {
        log.info(""Ready to handle messages from Redis pubsub!"");

        try {
            processMessage = true;

            Runnable messageProcessor = new Runnable() {
                public void run() {
                    while (processMessage) {
                        try {
                            ReceivedMessage msg = receivedMessages.take();
                            processMessage(msg);
                        } catch (InterruptedException e) {
                            log.warn(""Error while taking received message from queue."");
                        }
                    }
                }
            };
            msgProcessorExec.execute(messageProcessor);
        } catch (Exception e) {
            log.error(""Error subscribing to channels: "" + e.getMessage());
        }
    }

    private void processMessage(final ReceivedMessage msg) {
        Runnable task = new Runnable() {
            public void run() {
                if (handler != null) {
                    handler.notifyListeners(msg.getPattern(), msg.getChannel(), msg.getMessage());
                } else {
                    log.warn(""No listeners interested in messages from Redis!"");
                }
            }
        };

        runExec.execute(task);
    }

    public void handleMessage(String pattern, String channel, String message) {
        ReceivedMessage rm = new ReceivedMessage(pattern, channel, message);
        receivedMessages.add(rm);
    }

    public void setMessageDistributor(MessageDistributor h) {
        this.handler = h;
    }
}"
bbb-common-message/src/main/java/org/bigbluebutton/common2/redis/RedisStorageService.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2018 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.common2.redis;

import java.util.HashMap;
import java.util.Map;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import io.lettuce.core.api.sync.BaseRedisCommands;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.lettuce.core.ClientOptions;
import io.lettuce.core.RedisClient;
import io.lettuce.core.RedisURI;
import io.lettuce.core.api.StatefulRedisConnection;
import io.lettuce.core.api.sync.RedisCommands;
import org.apache.commons.codec.digest.DigestUtils;

public class RedisStorageService extends RedisAwareCommunicator {

    private static Logger log = LoggerFactory.getLogger(RedisStorageService.class);

    StatefulRedisConnection<String, String> connection;

    public void start() {
        log.info(""Starting RedisStorageService with client name: clientName={}"", clientName);
        RedisURI redisUri = RedisURI.Builder.redis(this.host, this.port).withClientName(this.clientName)
                .withPassword(this.password).build();

        redisClient = RedisClient.create(redisUri);
        redisClient.setOptions(ClientOptions.builder().autoReconnect(true).build());
        eventBus = redisClient.getResources().eventBus();
        eventBusSubscription = eventBus.get().subscribe(e -> connectionStatusHandler(e, log));

        connection = redisClient.connect();
    }

    public void stop() {
        eventBusSubscription.dispose();
        connection.close();
        redisClient.shutdown();
        log.info(""RedisStorageService Stopped"");
    }

    public String generateSingleUseCaptionToken(String recordId, String caption, Long expirySeconds) {
        Map<String, String> data = new HashMap<String, String>();
        data.put(""recordId"", recordId);
        data.put(""caption"", caption);

        String token = DigestUtils.sha1Hex(recordId + caption + System.currentTimeMillis());
        String key = ""captions:"" + token + "":singleusetoken"";
        RedisCommands<String, String> commands = connection.sync();
        commands.multi();
        commands.hmset(key, data);
        commands.expire(key, expirySeconds);
        commands.exec();

        return token;
    }

    public Boolean validateSingleUseCaptionToken(String token, String recordId, String caption) {
        String key = ""captions:"" + token + "":singleusetoken"";
        RedisCommands<String, String> commands = connection.sync();
        Boolean keyExist = commands.exists(key) == 1;
        if (keyExist) {
            Map <String, String> data = commands.hgetall(key);
            if (data.get(""recordId"").equals(recordId) && data.get(""caption"").equals(caption)) {
                commands.del(key);
                return true;
            }
        }

        return false;
    }

    public void recordMeetingInfo(String meetingId, Map<String, String> info) {
        recordMeeting(Keys.MEETING_INFO + meetingId, info);
    }

    public void recordBreakoutInfo(String meetingId, Map<String, String> breakoutInfo) {
        recordMeeting(Keys.BREAKOUT_MEETING + meetingId, breakoutInfo);
    }

    public void addBreakoutRoom(String parentId, String breakoutId) {
        RedisCommands<String, String> commands = connection.sync();
        commands.sadd(Keys.BREAKOUT_ROOMS + parentId, breakoutId);
    }

    public void record(String meetingId, Map<String, String> event) {
        RedisCommands<String, String> commands = connection.sync();
        Long msgid = commands.incr(""global:nextRecordedMsgId"");
        commands.multi();
        commands.hmset(""recording:"" + meetingId + "":"" + msgid, event);
        commands.rpush(""meeting:"" + meetingId + "":"" + ""recordings"", Long.toString(msgid));
        commands.exec();
    }

    public void storePresentationAnnotations(String meetingId, Map<String, String> event, String msgType) {
        RedisCommands<String, String> commands = connection.sync();      
        
        commands.multi();
        
        switch (msgType) {
            case ""PresAnn"": {
                commands.hmset(event.get(""jobId""), event);
                break;
            }

            case ""ExportJob"": {
                Gson gson = new Gson();
                String exportJobAsJson = gson.toJson(event);
                commands.rpush(""exportJobs"", exportJobAsJson.toString());
                break;
            }

            default: {
                log.error(""Attempted to store PresentationAnnotations message of type: {}"", clientName);
                break;
            }
        }

        commands.exec();
    }

    // @fixme: not used anywhere
    public void removeMeeting(String meetingId) {
        RedisCommands<String, String> commands = connection.sync();
        commands.multi();
        commands.del(Keys.MEETING + meetingId);
        commands.srem(Keys.MEETINGS + meetingId);
        commands.exec();
    }

    public void recordAndExpire(String meetingId, Map<String, String> event) {
        RedisCommands<String, String> commands = connection.sync();

        Long msgid = commands.incr(""global:nextRecordedMsgId"");
        String key = ""recording:"" + meetingId + "":"" + msgid;
        commands.multi();
        commands.hmset(key, event);
        /**
         * We set the key to expire after 14 days as we are still recording the
         * event into redis even if the meeting is not recorded. (ralam sept 23,
         * 2015)
         */
        commands.expire(key, expireKey);
        key = ""meeting:"" + meetingId + "":recordings"";
        commands.rpush(key, Long.toString(msgid));
        commands.expire(key, expireKey);
        commands.exec();
    }

    private String recordMeeting(String key, Map<String, String> info) {
        String result = """";
        RedisCommands<String, String> commands = connection.sync();
        result = commands.hmset(key, info);
        return result;
    }

    public Boolean checkConnectionStatusBasic() {
        BaseRedisCommands command = connection.sync();
        String response = command.ping();

        return response.equals(""PONG"");
    }
}"
bbb-common-message/src/main/java/org/bigbluebutton/common2/redis/Keys.java,"/**
* BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
* 
* Copyright (c) 2018 BigBlueButton Inc. and by respective authors (see below).
*
* This program is free software; you can redistribute it and/or modify it under the
* terms of the GNU Lesser General Public License as published by the Free Software
* Foundation; either version 3.0 of the License, or (at your option) any later
* version.
* 
* BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
*
*/

package org.bigbluebutton.common2.redis;

public final class Keys {
    public static final String MEETING = ""meeting-"";
    public static final String MEETINGS = ""meetings"";
    public static final String MEETING_INFO = ""meeting:info:"";
    public static final String BREAKOUT_MEETING = ""meeting:breakout:"";
    public static final String BREAKOUT_ROOMS = ""meeting:breakout:rooms:"";
}"
bbb-common-message/deploy.sh,"#!/bin/bash

#Publish new common-message .jar
sbt clean
# rm -r target/ project/target/ project/project/
sbt publish publishLocal"
freeswitch.placeholder.sh,"mkdir freeswitch
cd freeswitch
git init
git remote add origin https://github.com/signalwire/freeswitch.git
git fetch --depth 1 origin v1.10.9
git checkout FETCH_HEAD"
docs/build.sh,"#!/bin/bash

set -eu

# Build the docs only for these release branches
BRANCHES=(
  v2.5.x-release
  v2.6.x-release
  # v2.7.x-release
)
REMOTE=""origin""

git fetch --all
current_branch=$(git rev-parse --abbrev-ref HEAD)

for branch in ""${BRANCHES[@]}""; do

  if [ ""$branch"" != ""$current_branch"" ]; then
    git fetch ""$REMOTE"" ""$branch"":""$branch""
    git checkout ""$branch""
    if [ -f docusaurus.config.js ]; then
      version=${branch:1:3}
      echo ""Adding documentation for ${version}""
      yarn docusaurus docs:version ""${version}""
    else
      echo ""Warning: branch $(branch) does not contain a docusaurus.config.js!""
    fi
  fi

done

git checkout ""$current_branch"""
bbb-webhooks.placeholder.sh,"git clone --branch v2.6.0 --depth 1 https://github.com/bigbluebutton/bbb-webhooks bbb-webhooks"
bbb-recording-imex/src/test/java/org/bigbluebutton/RecordingImportHandlerTest.java,"package org.bigbluebutton;

import org.bigbluebutton.api.model.entity.Recording;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class RecordingImportHandlerTest {

    private static final Logger logger = LoggerFactory.getLogger(RecordingImportHandlerTest.class);

    private final RecordingImportHandler handler = RecordingImportHandler.getInstance();

    @Test
    @DisplayName(""RecordIDs should be properly parsed"")
    public void testParseRecordId() {
        String metadataDirectory = ""src/metadata"";

        String[] entries = new File(metadataDirectory).list();
        Set<String> ids = new HashSet<>();

        if (entries == null || entries.length == 0) {
            logger.info(""No recordings were found in {}"", new File(metadataDirectory).getAbsolutePath());
            return;
        }

        for (String entry : entries) {
            String path = metadataDirectory + ""/"" + entry + ""/metadata.xml"";
            Recording recording = handler.importRecording(path, entry, false);
            ids.add(recording.getRecordId());
            assertEquals(entry, recording.getRecordId());
        }

        assertEquals(entries.length, ids.size());
    }
}"
bbb-recording-imex/src/test/java/org/bigbluebutton/RecordingStoreTest.java,"package org.bigbluebutton;

import org.bigbluebutton.api.model.entity.Recording;
import org.bigbluebutton.api.util.DataStore;
import org.junit.jupiter.api.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class RecordingStoreTest {

    private static final Logger logger = LoggerFactory.getLogger(RecordingStoreTest.class);

    private String metadataDirectory = ""src/metadata"";
    private final RecordingImportHandler importHandler = RecordingImportHandler.getInstance();
    private final RecordingExportHandler exportHandler = RecordingExportHandler.getInstance();
    private DataStore dataStore;

    @BeforeAll
    public static void setup() {
        DataStore.getInstance().truncateTables();
    }

    @Test
    @DisplayName(""Recordings should be properly persisted"")
    @Order(1)
    public void testPersist() {
        dataStore = DataStore.getInstance();
        importHandler.importRecordings(metadataDirectory, true);
        List<Recording> recordings = dataStore.findAll(Recording.class);
        String[] entries = new File(metadataDirectory).list();

        if (entries == null || entries.length == 0) {
            logger.info(""No recordings were found in {}"", new File(metadataDirectory).getAbsolutePath());
            return;
        }

        assertTrue(recordings != null);
        assertEquals(entries.length, recordings.size());
    }

    @Test
    @DisplayName(""Recording should be properly retrieved"")
    @Order(2)
    public void testFind() {
        dataStore = DataStore.getInstance();
        String[] entries = new File(metadataDirectory).list();

        if (entries == null || entries.length == 0) {
            logger.info(""No recordings were found in {}"", new File(metadataDirectory).getAbsolutePath());
            return;
        }

        for (String entry : entries) {
            Recording recording = dataStore.findRecordingByRecordId(entry);
            assertTrue(recording != null);
        }
    }

    @Test
    @DisplayName(""Records should be properly exported"")
    @Order(3)
    public void testExportRecording() {
        dataStore = DataStore.getInstance();
        String metadataDirectory = ""src/metadata-export"";

        exportHandler.exportRecordings(metadataDirectory);

        String[] entries = new File(metadataDirectory).list();
        List<Recording> recordings = dataStore.findAll(Recording.class);

        assertEquals(entries.length, recordings.size());
    }
}"
bbb-recording-imex/src/main/java/org/bigbluebutton/RecordingImportHandler.java,"package org.bigbluebutton;

import org.bigbluebutton.api.model.entity.*;
import org.bigbluebutton.api.util.DataStore;
import org.bigbluebutton.api.service.XmlService;
import org.bigbluebutton.api.service.impl.XmlServiceImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.CharacterData;
import org.w3c.dom.*;
import org.xml.sax.InputSource;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;

public class RecordingImportHandler {

    private static final Logger logger = LoggerFactory.getLogger(RecordingImportHandler.class);

    private static RecordingImportHandler instance;
    private DataStore dataStore;
    private XmlService xmlService;

    private RecordingImportHandler() {
        dataStore = DataStore.getInstance();
        xmlService = new XmlServiceImpl();
    }

    public static RecordingImportHandler getInstance() {
        if (instance == null) {
            instance = new RecordingImportHandler();
        }
        return instance;
    }

    public void importRecordings(String directory, boolean persist) {
        logger.info(""Attempting to import recordings from {}"", directory);

        String[] entries = new File(directory).list();

        if (entries == null || entries.length == 0) {
            logger.info(""No recordings were found in the provided directory"");
            return;
        }

        for (String entry : entries) {
            Recording recording = dataStore.findRecordingByRecordId(entry);
            if (recording != null && persist) {
                logger.info(""Record found for {}. Skipping"", entry);
                continue;
            }

            String path = directory + ""/"" + entry + ""/metadata.xml"";
            importRecording(path, entry, persist);
        }
    }

    public Recording importRecording(String path, String recordId, boolean persist) {
        logger.info(""Attempting to import {}"", path);

        String content = null;
        try {
            byte[] encoded = Files.readAllBytes(Paths.get(path));
            content = new String(encoded, StandardCharsets.UTF_8);
        } catch (IOException e) {
            logger.error(""Failed to import {}"", path);
            e.printStackTrace();
        }

        Recording recording = null;

        if (content != null) {
            logger.info(""File content: {}"", content);
            recording = xmlService.xmlToRecording(recordId, content);
        }

        if (recording != null) {
            if (persist)
                dataStore.save(recording);
        }

        return recording;
    }
}"
bbb-recording-imex/src/main/java/org/bigbluebutton/RecordingApp.java,"package org.bigbluebutton;

import java.io.Console;
import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.IntStream;

public class RecordingApp {

    public static void main(String[] args) {
        if (args.length > 0) {
            commandMode(args);
        } else {
            interactiveMode();
        }
    }

    private static void commandMode(String[] args) {
        int i = 0, j;
        String arg;
        char flag;
        boolean export = false;
        boolean persist = false;
        String id = null;
        String path;

        while (i < args.length && args[i].startsWith(""-"")) {
            arg = args[i++];

            if (arg.equals(""--help"")) {
                printUsage();
                return;
            }

            for (j = 1; j < arg.length(); j++) {
                flag = arg.charAt(j);

                switch (flag) {
                case 'e':
                    export = true;
                    break;
                case 'i':
                    export = false;
                    if (i < args.length) {
                        String shouldPersist = args[i++];
                        if (shouldPersist.equalsIgnoreCase(""true""))
                            persist = true;
                        else if (shouldPersist.equalsIgnoreCase(""false""))
                            persist = false;
                        else {
                            System.out.println(""Error: Could not parse persist argument"");
                            return;
                        }
                    } else {
                        System.out.println(""Error: Imports require an argument specifying if they should be persisted"");
                        return;
                    }
                    break;
                case 's':
                    if (i < args.length)
                        id = args[i++];
                    else {
                        System.out.println(
                                ""Error: To import/export a single recording you must provide the recording ID"");
                    }
                    break;
                default:
                    System.out.println(""Error: Illegal option "" + flag);
                }
            }
        }

        if (i < args.length)
            path = args[i];
        else {
            path = createDefaultDirectory();
            if (path == null)
                return;
        }

        executeCommands(export, persist, id, path);
    }

    private static void printUsage() {
        System.out.println(""Usage: {-e|-i <persist>} [-s <id>] [PATH]"");
        System.out.println(""Import/export recording(s) to/from PATH. The default PATH is ""
                + ""\n/var/bigbluebutton/published/presentation"");
        System.out.println(""-e                  export recording(s)"");
        System.out.println(
                ""-i <persist>        import recording(s) and indicate if they should be persisted [true|false]"");
        System.out.println(""-s <id>             ID of single recording to be imported/exported"");
    }

    private static String createDefaultDirectory() {
        Path root = Paths.get(System.getProperty(""user.dir"")).getFileSystem().getRootDirectories().iterator().next();
        String path = root.toAbsolutePath() + ""var/bigbluebutton/published/presentation"";

        File directory = new File(path);
        if (!directory.exists()) {
            boolean created = directory.mkdirs();
            if (!created) {
                System.out.println(""Error: Failed to create default presentation directory"");
                return null;
            }
        }

        return path;
    }

    private static void executeCommands(boolean export, boolean persist, String id, String path) {
        if (!export) {
            RecordingImportHandler handler = RecordingImportHandler.getInstance();
            if (id == null || id.isEmpty())
                handler.importRecordings(path, persist);
            else
                handler.importRecording(path, id, persist);
        } else {
            RecordingExportHandler handler = RecordingExportHandler.getInstance();
            if (id == null || id.isEmpty())
                handler.exportRecordings(path);
            else
                handler.exportRecording(id, path);
        }
    }

    private static void interactiveMode() {
        System.out.println(""Use this application to import and export recording metadata"");

        do {
            int impex = getResponse(""Are you importing or exporting recordings? (1-Import 2-Export 3-Quit) "",
                    new int[] { 1, 2, 3 }, ""Please enter either 1, 2, or 3"");

            if (impex == 1) {
                importRecordings();
            } else if (impex == 2) {
                exportRecordings();
            } else {
                break;
            }
        } while (true);
    }

    private static void importRecordings() {
        RecordingImportHandler handler = RecordingImportHandler.getInstance();
        int importIndividually = getResponse(""Are you importing recordings individually? (1-Yes 2-No) "",
                new int[] { 1, 2 }, ""Please enter either 1 or 2"");
        int persist = getResponse(""Should the imported recording(s) be persisted? (1-Yes 2-No) "", new int[] { 1, 2 },
                ""Please enter either 1 or 2"");
        boolean shouldPersist = persist == 1;

        if (importIndividually == 1) {
            do {
                String path = getResponse(
                        ""Please enter the path to the recording metadata.xml file (enter q to quit): "");

                if (path.equalsIgnoreCase(""q"") || path.equalsIgnoreCase(""quit""))
                    break;

                String recordingId = getResponse(""Please enter the ID of the recording: "");
                handler.importRecording(path, recordingId, shouldPersist);
            } while (true);
        } else {
            String path = getResponse(""Please enter the path to the directory containing the metadata.xml files: "");
            handler.importRecordings(path, shouldPersist);
        }
    }

    private static void exportRecordings() {
        RecordingExportHandler handler = RecordingExportHandler.getInstance();
        int exportAll = getResponse(""Do you want to export all recordings? (1-Yes 2-No) "", new int[] { 1, 2 },
                ""Please enter either 1 or 2"");
        String path = getResponse(""Please enter the path to the directory that the recordings should be exported to: "");

        if (exportAll == 1) {
            handler.exportRecordings(path);
        } else {
            do {
                String response = getResponse(
                        ""Please enter the ID of the recording you would like to export (enter q to quit): "");
                if (response.equalsIgnoreCase(""q"") || response.equalsIgnoreCase(""quit""))
                    break;
                handler.exportRecording(response, path);
            } while (true);
        }
    }

    private static int getResponse(String prompt, int[] options, String error) {
        Console console = System.console();
        String response;
        int result;
        do {
            response = console.readLine(prompt);
            result = parseResponse(response, error);
        } while (!contains(options, result));

        return result;
    }

    private static String getResponse(String prompt) {
        Console console = System.console();
        String response = """";
        do {
            response = console.readLine(prompt);
        } while (response == """");

        return response;
    }

    private static int parseResponse(String response, String error) {
        try {
            int parsedResponse = Integer.parseInt(response);
            return parsedResponse;
        } catch (NumberFormatException e) {
            System.out.println(error);
        }

        return -1;
    }

    private static boolean contains(final int[] array, final int key) {
        return IntStream.of(array).anyMatch(x -> x == key);
    }
}"
bbb-recording-imex/src/main/java/org/bigbluebutton/RecordingExportHandler.java,"package org.bigbluebutton;

import org.bigbluebutton.api.model.entity.Recording;
import org.bigbluebutton.api.util.DataStore;
import org.bigbluebutton.api.service.XmlService;
import org.bigbluebutton.api.service.impl.XmlServiceImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;
import java.io.File;
import java.io.StringReader;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

public class RecordingExportHandler {

    private static final Logger logger = LoggerFactory.getLogger(RecordingExportHandler.class);

    private static RecordingExportHandler instance;
    private DataStore dataStore;
    private XmlService xmlService;

    private RecordingExportHandler() {
        dataStore = DataStore.getInstance();
        xmlService = new XmlServiceImpl();
    }

    public static RecordingExportHandler getInstance() {
        if (instance == null) {
            instance = new RecordingExportHandler();
        }
        return instance;
    }

    public void exportRecordings(String path) {
        List<Recording> recordings = dataStore.findAll(Recording.class);

        for (Recording recording : recordings) {
            exportRecording(recording, path);
        }
    }

    public void exportRecording(String recordId, String path) {
        Recording recording = null;
        if (recordId != null) {
            recording = dataStore.findRecordingByRecordId(recordId);
        }

        if (recording != null) {
            exportRecording(recording, path);
        }
    }

    private void exportRecording(Recording recording, String path) {
        logger.info(""Attempting to export recording {} to {}"", recording.getRecordId(), path);
        try {

            Path dirPath = Paths.get(path);
            File dir = new File(dirPath.toAbsolutePath() + File.separator + recording.getRecordId());
            logger.info(""Checking if directory {} exists"", dir.getAbsolutePath());
            if (!dir.exists()) {
                logger.info(""Directory does not exist, creating"");
                dir.mkdir();
            }

            File file = new File(dir + File.separator + ""metadata.xml"");
            logger.info(""Attempting to create file {}"", file.getAbsolutePath());
            boolean fileCreated = file.createNewFile();

            if (fileCreated) {
                logger.info(""Exporting {}"", recording);

                String xml = xmlService.recordingToXml(recording);

                DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
                DocumentBuilder builder = factory.newDocumentBuilder();
                Document document = builder.parse(new InputSource(new StringReader(xml)));

                document.normalize();
                XPath xPath = XPathFactory.newInstance().newXPath();
                NodeList nodeList = (NodeList) xPath.evaluate(""//text()[normalize-space()='']"", document,
                        XPathConstants.NODESET);

                for (int i = 0; i < nodeList.getLength(); i++) {
                    Node node = nodeList.item(i);
                    node.getParentNode().removeChild(node);
                }

                TransformerFactory transformerFactory = TransformerFactory.newInstance();
                Transformer transformer = transformerFactory.newTransformer();
                transformer.setOutputProperty(OutputKeys.ENCODING, ""UTF-8"");
                transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");
                transformer.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""2"");
                transformer.setOutputProperty(OutputKeys.STANDALONE, ""no"");
                DOMSource source = new DOMSource(document);

                StreamResult result = new StreamResult(file);
                transformer.transform(source, result);
            }
        } catch (Exception e) {
            logger.error(""Failed to export recording {}"", recording.getRecordId());
            e.printStackTrace();
        }
    }
}"
bbb-recording-imex/get-recordings.sh,"#!/bin/bash
while getopts i:r:s:m:o:l: flag
do
   case ""${flag}"" in
      i) MEETING_ID=${OPTARG};;
      r) RECORD_ID=${OPTARG};;
      s) STATE=${OPTARG};;
      m) META=${OPTARG};;
      o) OFFSET=${OPTARG};;
      l) LIMIT=${OPTARG};;
   esac
done

BASE_URL=""""
SUBDIRECTORY=""bigbluebutton/api/""
ENDPOINT=""getRecordings""
QUERY=""""

if ! [[ -z ${MEETING_ID+x} ]]; then QUERY+=""meetingID=$MEETING_ID&""; fi
if ! [[ -z ${RECORD_ID+x} ]]; then QUERY+=""recordID=$RECORD_ID&""; fi
if ! [[ -z ${STATE+x} ]]; then QUERY+=""state=$STATE&""; fi
if ! [[ -z ${META+x} ]]; then QUERY+=""meta=$META&""; fi
if ! [[ -z ${OFFSET+x} ]]; then QUERY+=""offset=$OFFSET&""; fi
if ! [[ -z ${LIMIT+x} ]]; then QUERY+=""limit=$LIMIT""; fi

echo ""query: $QUERY""

INDEX=${#QUERY}-1
if [ ""${QUERY:$INDEX:1}"" = ""&"" ]; then QUERY=${QUERY:0:$INDEX}; fi

echo ""query: $QUERY""

SALT=""""
DATA=""$ENDPOINT$QUERY$SALT""

echo ""data: $DATA""

CHECKSUM=$(echo -n $DATA | sha256sum)
CHECKSUM=${CHECKSUM:0:64}

echo ""sha256 checksum: $CHECKSUM""

QUERY=""?$QUERY""

if ! [[ ${#QUERY} -eq 1 ]]; then QUERY+=""&""; fi

QUERY+=""checksum=$CHECKSUM""

echo ""query: $QUERY""

REQUEST=""$BASE_URL$SUBDIRECTORY$ENDPOINT$QUERY""
echo ""request: $REQUEST""

curl -s -X GET ""$REQUEST"""
bbb-recording-imex/deploy.sh,"#!/bin/bash
JAR_DIR=""$HOME/usr/share/recording-imex""
JAR_NAME=""bbb-recording-imex-1.0-SNAPSHOT-shaded.jar""
RUN_DIR=""$HOME/usr/local/bin""

mkdir -p $JAR_DIR
mkdir -p $RUN_DIR
mvn package -Dmaven.test.skip
cp target/${JAR_NAME} $JAR_DIR
echo '#!/bin/bash
java -jar '${JAR_DIR}'/'${JAR_NAME} '""$@""'> ${RUN_DIR}/recording-imex.sh
chmod +x ${RUN_DIR}/recording-imex.sh"
bigbluebutton-config/bin/apply-lib.sh,"# This is a library of functions for 
#
#  /etc/bigbluebutton/bbb-conf/apply-config.sh
#
# which (if exists) will be run by `bbb-conf --setip` and `bbb-conf --restart` before restarting
# BigBlueButton.
#
# The purpose of apply-config.sh is to make it easy to apply your configuration changes to a BigBlueButton server 
# before BigBlueButton starts
#

### duplicated code: see deb-helper.sh and bbb-conf
if [ -e ""/sys/class/net/venet0:0"" ]; then
    # IP detection for OpenVZ environment
    _dev=""venet0:0""
else
    _dev=$(awk '$2 == 00000000 { print $1 }' /proc/net/route | head -1)
fi
_ips=$(LANG=C ip -4 -br address show dev ""$_dev"" | awk '{ $1=$2=""""; print $0 }')
_ips=${_ips/127.0.0.1\/8/}
read -r IP _ <<< ""$_ips""
IP=${IP/\/*} # strip subnet provided by ip address
if [ -z ""$IP"" ]; then
  read -r IP _ <<< ""$(hostname -I)""
fi

if [ -f /usr/share/bbb-web/WEB-INF/classes/bigbluebutton.properties ]; then
  SERVLET_DIR=/usr/share/bbb-web
fi

BBB_WEB_ETC_CONFIG=/etc/bigbluebutton/bbb-web.properties

# We'll create a newline file to ensure bigbluebutton.properties ends with a newline
tmpfile=$(mktemp /tmp/carriage-return.XXXXXX)
echo ""\n"" > $tmpfile

PROTOCOL=http
if [ -f $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties ]; then
  SERVER_URL=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties $tmpfile $BBB_WEB_ETC_CONFIG | grep -v '#' | sed -n '/^bigbluebutton.web.serverURL/{s/.*\///;p}' | tail -n 1)
  if cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties $tmpfile $BBB_WEB_ETC_CONFIG | grep -v '#' | grep ^bigbluebutton.web.serverURL | tail -n 1 | grep -q https; then
    PROTOCOL=https
  fi
fi

HOST=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties $tmpfile $BBB_WEB_ETC_CONFIG | grep -v '#' | sed -n '/^bigbluebutton.web.serverURL/{s/.*\///;p}' | tail -n 1)

HTML5_CONFIG=/etc/bigbluebutton/bbb-html5.yml
if [ ! -f ""${HTML5_CONFIG}"" ]; then
  touch $HTML5_CONFIG
fi

#
# Enable Looging of the HTML5 client for debugging
#
enableHTML5ClientLog() {
  echo ""  - Enable HTML5 client log to /var/log/nginx/html5-client.log""

  yq e -i '.public.clientLog.external.enabled = true' $HTML5_CONFIG
  yq e -i "".public.clientLog.external.url = \""$PROTOCOL://$HOST/html5log\"""" $HTML5_CONFIG
  yq e -i '.public.app.askForFeedbackOnLogout = true' $HTML5_CONFIG
  chown meteor:meteor $HTML5_CONFIG

  cat > /usr/share/bigbluebutton/nginx/html5-client-log.nginx << HERE
location /html5log {
        access_log /var/log/nginx/html5-client.log postdata;
        echo_read_request_body;
}
HERE

  cat > /etc/nginx/conf.d/html5-client-log.conf << HERE
log_format postdata '\$remote_addr [\$time_iso8601] \$request_body';
HERE

  # We need nginx-full to enable postdata log_format
  if ! dpkg -l | grep -q nginx-full; then
    apt-get install -y nginx-full
  fi

  touch /var/log/nginx/html5-client.log
  chown bigbluebutton:bigbluebutton /var/log/nginx/html5-client.log

  #
  # You can monitor the live HTML5 client logs with the command
  #
  #   tail -f /var/log/nginx/html5-client.log | sed -u 's/\\x22/""/g' | sed -u 's/\\x5C//g'
}

#
# Enable firewall rules to open only 
#
enableUFWRules() {
  echo ""  - Enable Firewall and opening 22/tcp, 80/tcp, 443/tcp and 16384:32768/udp""

  if ! which ufw > /dev/null; then
    apt-get install -y ufw
  fi

  ufw allow OpenSSH
  ufw allow ""Nginx Full""
  ufw allow 16384:32768/udp

   # Check if haproxy is running on this server and, if so, open port 3478 on ufw

  if systemctl is-enabled haproxy> /dev/null 2>&1; then
    if systemctl -q is-active haproxy; then
      echo ""  - Local haproxy detected and running -- opening port 3478""
      ufw allow 3478
      # echo ""  - Forcing FireFox to use turn server""
      # yq e -i '.public.kurento.forceRelayOnFirefox = true' $HTML5_CONFIG
    else
      if grep -q 3478 /etc/ufw/user.rules; then
        echo ""  - Local haproxy not running -- closing port 3478""
        ufw delete allow 3478
      fi
    fi
  else
    if grep -q 3478 /etc/ufw/user.rules; then
      echo ""  - Local haproxy not running -- closing port 3478""
      ufw delete allow 3478
    fi
  fi

  ufw --force enable
}


notCalled() {
#
# This function is not called.

# Instead, it gives you the ability to copy the following text and paste it into the shell to create a starting point for
# apply-config.sh.
#
# By creating apply-config.sh manually, it will not be overwritten by any package updates.  You can call functions in this
# library for common BigBlueButton configuration tasks.

## Start Copying Here
  cat > /etc/bigbluebutton/bbb-conf/apply-config.sh << HERE
#!/bin/bash

# Pull in the helper functions for configuring BigBlueButton
source /etc/bigbluebutton/bbb-conf/apply-lib.sh

# Available configuration options

#enableHTML5ClientLog
#enableUFWRules


# Shorten the FreeSWITCH ""you have been muted"" and ""you have been unmuted"" prompts
# cp -r /etc/bigbluebutton/bbb-conf/sounds /opt/freeswitch/share/freeswitch

HERE
chmod +x /etc/bigbluebutton/bbb-conf/apply-config.sh
## Stop Copying HERE
}
"
bbb-presentation-video.placeholder.sh,"#!/bin/sh
set -ex
RELEASE=4.0.2
cat <<MSG
This tool downloads prebuilt packages built on Github Actions
The corresponding source can be browsed at https://github.com/bigbluebutton/bbb-presentation-video/tree/${RELEASE}
Build logs are at https://github.com/bigbluebutton/bbb-presentation-video/actions/workflows/package.yml?query=branch%3A${RELEASE}
MSG
curl -Lf -o bbb-presentation-video.zip ""https://github.com/bigbluebutton/bbb-presentation-video/releases/download/${RELEASE}/ubuntu-20.04.zip""
rm -rf bbb-presentation-video
unzip -o bbb-presentation-video.zip -d bbb-presentation-video"
build/deb-helper.sh,"#!/bin/bash -e

############################
### BEGIN DEB-HELPERS.SH ###
############################

#
# Adding service to autostart
# $1 = service name
#
startService() {
  app_name=$1
  if hash systemctl > /dev/null 2>&1 && [ ! -f /.dockerenv ]; then
    # if there no .service or .timer (or any other suffix), it will add .service suffix
    if [[ ! $app_name =~ ^.*\.[a-z]*$ ]]; then
      app_name=""$app_name.service""
    fi
    echo ""Adding $app_name to autostart using systemd""
    systemctl enable $app_name
    systemctl start $app_name
  elif hash update-rc.d > /dev/null 2>&1 && [ ! -f /.dockerenv ]; then
    echo ""Adding $app_name to autostart using update-rc.d""
    update-rc.d $app_name defaults
    service $app_name start
  elif hash chkconfig > /dev/null 2>&1; then
    echo ""Adding $app_name to autostart using chkconfig""
    chkconfig --add $app_name
    chkconfig $app_name on
    service $app_name start
  else
    echo ""WARNING: Could not add $app_name to autostart: neither update-rc nor chkconfig found!""
  fi
}

#
# Removing service from autostart
# $1 = service name
#
stopService() {
  app_name=$1
  if hash systemctl > /dev/null 2>&1 && [ ! -f /.dockerenv ]; then
    # if there no .service or .timer (or any other suffix), it will add .service suffix
    if [[ ! $app_name =~ ^.*\.[a-z]*$ ]]; then
      app_name=""$app_name.service""
    fi
    echo ""Removing $app_name from autostart using systemd""
    if systemctl -q is-active $app_name; then
      systemctl stop $app_name
    fi
    if systemctl is-enabled $app_name > /dev/null 2>&1; then
      systemctl disable $app_name
    fi
  elif hash update-rc.d > /dev/null 2>&1 && [ ! -f /.dockerenv ]; then
    echo ""Removing $app_name from autostart using update-rc.d""
    update-rc.d -f $app_name remove
    service $app_name stop
  elif hash chkconfig > /dev/null 2>&1; then
    echo ""Removing $app_name from autostart using chkconfig""
    chkconfig $app_name off
    chkconfig --del $app_name
    service $app_name stop
  else
    echo ""WARNING: Could not remove $app_name from autostart: neither update-rc nor chkconfig found!""
  fi
}

#
# Reload service
# $1 = service name
#
reloadService() {
  app_name=$1
  if hash systemctl > /dev/null 2>&1 && [ ! -f /.dockerenv ]; then
  # if there no .service or .timer (or any other suffix), it will add .service suffix
    if [[ ! $app_name =~ ^.*\.[a-z]*$ ]]; then
      app_name=""$app_name.service""
    fi
    echo ""Reloading $app_name using systemd""
    if systemctl status $app_name > /dev/null 2>&1; then
      systemctl reload-or-restart $app_name
    else
      startService $app_name
    fi
  elif hash service > /dev/null 2>&1; then
    echo ""Reloading $app_name using service""
    service $app_name reload
  else
    echo ""WARNING: Could not reload $app_name: neither update-rc nor chkconfig found!""
  fi
}

#
# Restart service
# $1 = service name
#
restartService() {
  app_name=$1
  if hash systemctl > /dev/null 2>&1 && [ ! -f /.dockerenv ]; then
    # if there no .service or .timer (or any other suffix), it will add .service suffix
    if [[ ! $app_name =~ ^.*\.[a-z]*$ ]]; then
      app_name=""$app_name.service""
    fi
    echo ""Restart $app_name using systemd""
    if systemctl status $app_name > /dev/null 2>&1; then
      systemctl restart $app_name
    else
      startService $app_name
    fi
  elif hash service > /dev/null 2>&1; then
    echo ""Restart $app_name using service""
    service $app_name restart
  else
    echo ""WARNING: Could not restart $app_name: neither update-rc nor chkconfig found!""
  fi
}

#
# Adapted from SBT scripts.  See 
#  https://github.com/sbt/sbt-native-packager/blob/master/src/main/resources/com/typesafe/sbt/packager/linux/control-functions
#

# Adding system user
# $1 = user
# $2 = uid
# $3 = group
# $4 = home directory
# $5 = description
# $6 = shell (defaults to /bin/false)
addUser() {
  user=""$1""
  if [ -z ""$user"" ]; then
    # echo ""usage: addUser user [group] [description] [shell]""
    exit 1
  fi
  uid=""$2""
  if [ -z ""$uid"" ]; then
    uid_flags=""""
  else
    uid_flags=""--uid $uid""
  fi
  if [ -z ""$4"" ]; then
    home_flags=""--no-create-home""
  else
    home_flags=""-d $4""
  fi
  group=${3:-$user}
  descr=${5:-No description}
  shell=${6:-/bin/false}
  if ! getent passwd | grep -q ""^$user:"";
  then
    # echo ""Creating system user: $user in $group with $descr and shell $shell""
    useradd $uid_flags --gid $group $home_flags --system --shell $shell -c ""$descr"" $user
  fi
}


# Adding system group
# $1 = group
# $2 = gid
addGroup() {
  group=""$1""
  gid=""$2""
  if [ -z ""$gid"" ]; then
    gid_flags=""""
  else
    gid_flags=""--gid $gid""
  fi
  if ! getent group | grep -q ""^$group:"" ;
  then
    # echo ""Creating system group: $group""
    groupadd $gid_flags --system $group
  fi
}

# Will return true even if deletion fails
# $1 = user
deleteUser() {
  if hash deluser 2>/dev/null; then
    deluser --quiet --system $1 > /dev/null || true
  elif hash userdel 2>/dev/null; then
    userdel $1
  else
    echo ""WARNING: Could not delete user $1 . No suitable program (deluser, userdel) found""
  fi
}

# Will return true even if deletion fails
# $1 = group
deleteGroup() {
  if hash delgroup 2>/dev/null; then
    delgroup --quiet --system $1 > /dev/null || true
  elif hash groupdel 2>/dev/null; then
    groupdel $1
  else
    echo ""WARNING: Could not delete user $1 . No suitable program (delgroup, groupdel) found""
  fi
}

### duplicated code: see bbb-conf and apply-lib.sh
if [ -e ""/sys/class/net/venet0:0"" ]; then
    # IP detection for OpenVZ environment
    _dev=""venet0:0""
else
    _dev=$(awk '$2 == 00000000 { print $1 }' /proc/net/route | head -1)
fi
_ips=$(LANG=C ip -4 -br address show dev ""$_dev"" | awk '{ $1=$2=""""; print $0 }')
_ips=${_ips/127.0.0.1\/8/}
read -r IP _ <<< ""$_ips""
IP=${IP/\/*} # strip subnet provided by ip address
if [ -z ""$IP"" ]; then
  read -r IP _ <<< ""$(hostname -I)""
fi

if [ -f /etc/redhat-release ]; then
  TOMCAT_SERVICE=tomcat
else
  if grep -q jammy /etc/lsb-release; then
    TOMCAT_SERVICE=tomcat9
  fi
fi

if [ -f /var/lib/$TOMCAT_SERVICE/webapps/bigbluebutton/WEB-INF/classes/bigbluebutton.properties ]; then
  SERVLET_DIR=/var/lib/$TOMCAT_SERVICE/webapps/bigbluebutton
else 
  SERVLET_DIR=/usr/share/bbb-web
fi

PROTOCOL=http
if [ -f $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties ]; then
  SERVER_URL=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | sed -n '/^bigbluebutton.web.serverURL/{s/.*\///;p}')
  if cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | grep bigbluebutton.web.serverURL | grep -q https; then
    PROTOCOL=https
  fi
fi


##########################
### END DEB-HELPERS.SH ###
##########################"
build/push_packages.sh,"#!/bin/bash -xe

# This script uploads the packages to the CI repo server. Its counterpart
# on the server end is ci-repo-upload/cgi-bin/incoming.py. The variable
# ADDITIONAL_PACKAGE_FILES contains a comma-separated list of the package
# files that the change detection decided to re-use for this build, since
# the contents have not changed since that commit.

ADDITIONAL_PACKAGE_FILES=""$(awk '{print $2}' < packages_to_skip.txt | tr '\n' ',' | sed 's/,*$//')""

curl \
    $(for file in artifacts/*.deb; do echo -n ""-F pkgs[]=@${file} "" ; done) \
    -F ""branch=${CI_COMMIT_BRANCH}"" \
    -F ""additional_package_files=${ADDITIONAL_PACKAGE_FILES}"" \
    -F ""gpg_passphrase=${GPG_PASSPHRASE}"" \
    -u ""${PACKAGES_UPLOAD_AUTHENTICATION}"" \
    ""${PACKAGES_UPLOAD_BASE_URL}/cgi-bin/incoming.py"""
build/opts-global.sh,"OPTS=""--vendor BigBlueButon -m ffdixon@bigbluebutton.org --url http://bigbluebutton.org/""
"
build/change_detection.sh,"#!/bin/bash -e

# This script checks which recent commits have not changed a
# particular package and asks the repo server whether it has
# a build of any of those versions (done for all packages).

cd ""$(dirname $0)""
source package-names.inc.sh
cd ..

REQ_JSON=""""

for DEBNAME in ""${!DEBNAME_TO_SOURCEDIR[@]}""
do
	if [ ""$DEBNAME"" == bigbluebutton ] ; then
		# always rebuild the meta package
		continue
	fi
	#echo ""package $DEBNAME""
	SOURCEDIR=""${DEBNAME_TO_SOURCEDIR[$DEBNAME]}""
	if [ ""$SOURCEDIR"" == ""do_not_copy_anything"" ] ; then
		SOURCEDIR=""""
	fi
	LAST_CHANGE=""$(git log -n1 --format=format:%H -- ${SOURCEDIR} ""build/packages-template/$DEBNAME"" ""$DEBNAME.placeholder.sh"" .gitlab-ci.yml build/*.sh)""
	VALID_PACKAGE_VERSIONS=""$(git log --format=%H ""${LAST_CHANGE}^..HEAD"")""
	VALID_PACKAGE_VERSIONS=""$(for HASH in $VALID_PACKAGE_VERSIONS; do echo -n ""${HASH::10} ""; done)""
	VALID_PACKAGE_VERSIONS=""${VALID_PACKAGE_VERSIONS::-1}""
	REQ_JSON=""${REQ_JSON} \""$DEBNAME\"": [\""${VALID_PACKAGE_VERSIONS//$' '/\"",\""}\""],""
done

REQ_JSON=""{${REQ_JSON:1:-1}}""

curl \
    -u ""${PACKAGES_UPLOAD_AUTHENTICATION}"" \
	-X POST \
	--data ""$REQ_JSON"" \
    ""${PACKAGES_UPLOAD_BASE_URL}/cgi-bin/get_compatible_packages.py"" \
	> packages_to_skip.txt

echo ""We will re-use the following packages:""
cat packages_to_skip.txt"
build/packages-template/bbb-web/after-install.sh,"#!/bin/bash -e

escape_quotes() {
    cat <<EOF | sed -e ""s/'/\\\\'/g""
$1
EOF
}

bbb_new_properties() {
	#
	# Setup bigbluebutton.properties for bbb-web
	#
 sed -i ""s/bigbluebutton.web.serverURL=http:\/\/.*/bigbluebutton.web.serverURL=http:\/\/$IP/g"" \
         $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties

 sed -i ""s/screenshareRtmpServer=.*/screenshareRtmpServer=$IP/g"" \
         $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties
}

bbb_config() {
	bbb_new_properties
	
  #
  # Now update the API examples
	#
	SECRET=$(openssl rand -base64 32 | sed 's/=//g' | sed 's/+//g' | sed 's/\///g')

	HOST=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | sed -n '/^bigbluebutton.web.serverURL/{s/.*\///;p}')

  sed -i ""s/securitySalt=.*/securitySalt=$SECRET/g"" \
     $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties

	#
	# XXX
	if id meteor > /dev/null 2>&1 ; then
		if [ -d /var/log/bigbluebutton/html5 ]; then
			chown -R meteor:meteor /var/log/bigbluebutton/html5
		fi
	fi

	#
	# Update the placementsThreshold and imageTagThreshold
	sed -i 's/placementsThreshold=8000/placementsThreshold=800/g' $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties
	sed -i 's/imageTagThreshold=8000/imageTagThreshold=800/g'     $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties

	#
	# Fix links in welcome text
	sed -i 's#<a href=""event:http://www.bigbluebutton.org/html5"">#<a href=""https://www.bigbluebutton.org/html5"" target=""_blank"">#g' \
		$SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties

	sed -i 's#<a href=""http://docs.bigbluebutton.org/"" target=""_blank"">#<a href=""https://docs.bigbluebutton.org/"" target=""_blank"">#g' \
		$SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties

  if [ ! -L /usr/share/bigbluebutton/nginx/web.nginx ]; then
    ln -s /usr/share/bigbluebutton/nginx/web /usr/share/bigbluebutton/nginx/web.nginx
  fi

  if [[ ! -L /usr/share/bbb-web/logs && -d /usr/share/bbb-web/logs ]]; then  # remove old directory (if exists)
    rm -rf /usr/share/bbb-web/logs
  fi

  if [ ! -L /usr/share/bbb-web/logs ]; then  # create symbolic link
    ln -s /var/log/bigbluebutton /usr/share/bbb-web/logs
  fi
  chown bigbluebutton:bigbluebutton /var/log/bigbluebutton
  touch /var/log/bigbluebutton/bbb-web.log
  chown bigbluebutton:bigbluebutton /var/log/bigbluebutton/bbb-web.log

  update-java-alternatives -s java-1.11.0-openjdk-amd64

  # Restart bbb-web to deploy new 
  startService bbb-web.service || echo ""bbb-web.service could not be registered or started""
}

case ""$1"" in
  configure|upgrade|1|2)
  	bbb_config
    ;;

    abort-upgrade|abort-remove|abort-deconfigure)

    ;;

    *)
      echo ""## postinst called with unknown argument \`$1'"" >&2
    ;;
esac

# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.

exit 0

"
build/packages-template/bbb-web/before-install.sh,"#!/bin/bash -e

case ""$1"" in
    install|upgrade|1|2)
    ;;

    abort-upgrade)
    ;;

    *)
        echo ""## preinst called with unknown argument \`$1'"" >&2
    ;;
esac
"
build/packages-template/bbb-web/setenv.sh,"export CATALINA_OPTS=""$CATALINA_OPTS -Xms384m -Xmx384m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/bigbluebutton/diagnostics"""
build/packages-template/bbb-web/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
DISTRO=$(echo $TARGET | cut -d'_' -f3)
set -e -x
echo ""START BUILDING in $PWD""
#
# Clean up directories
STAGING=""$PWD/staging""
rm -rf $STAGING

. ./opts-$DISTRO.sh

#
# Create directory for fpm to process
DIRS=""/var/bigbluebutton/configs /var/log/bigbluebutton /var/log/bigbluebutton/html5""
for dir in $DIRS; do
  mkdir -p ""${STAGING}/${dir}""
done

mkdir -p ~/.sbt/1.0
echo 'resolvers += ""Artima Maven Repository"" at ""https://repo.artima.com/releases""' > ~/.sbt/1.0/global.sbt

##

# [ $DISTRO == ""centos6"" ] && JAVA_HOME=/usr/lib/jvm/java-1.11.0-openjdk-1.11.0.91-1.b14.el6.x86_64

EPHEMERAL_VERSION=0.0.$(date +%s)-SNAPSHOT
sed -i ""s|\(version := \)\"".*|\1\""$EPHEMERAL_VERSION\""|g"" bbb-common-message/build.sbt
find -name build.gradle -exec sed -i ""s|\(.*org.bigbluebutton.*bbb-common-message[^:]*\):.*|\1:$EPHEMERAL_VERSION\""|g"" {} \;
find -name build.sbt -exec sed -i ""s|\(.*org.bigbluebutton.*bbb-common-message[^\""]*\""[ ]*%[ ]*\)\""[^\""]*\""\(.*\)|\1\""$EPHEMERAL_VERSION\""\2|g"" {} \;

sed -i ""s|\(version := \)\"".*|\1\""$EPHEMERAL_VERSION\""|g"" bbb-common-web/build.sbt
find -name build.gradle -exec sed -i ""s|\(.*org.bigbluebutton.*bbb-common-web[^:]*\):.*|\1:$EPHEMERAL_VERSION\""|g"" {} \;
find -name build.sbt -exec sed -i ""s|\(.*org.bigbluebutton.*bbb-common-web[^\""]*\""[ ]*%[ ]*\)\""[^\""]*\""\(.*\)|\1\""$EPHEMERAL_VERSION\""\2|g"" {} \;

sed -i 's/\r$//' bbb-common-web/project/Dependencies.scala
sed -i 's|\(val bbbCommons = \)""[^""]*""$|\1""EPHEMERAL_VERSION""|g' bbb-common-web/project/Dependencies.scala
sed -i ""s/EPHEMERAL_VERSION/$EPHEMERAL_VERSION/g"" bbb-common-web/project/Dependencies.scala

echo start building bbb-common-message
cd bbb-common-message
sbt publish
sbt publishLocal
cd ..
echo end building bbb-common-message

# New project directory containing parts of bbb-web
cd bbb-common-web
sbt update
sbt publish
sbt publishLocal
cd ..

cd bigbluebutton-web
# Build new version of bbb-web
gradle clean
gradle resolveDeps
grails assemble

# Build presentation checker
if [ -d pres-checker ]; then
  cd pres-checker
    gradle clean
    gradle resolveDeps
    gradle jar
    mkdir -p ""$STAGING""/usr/share/prescheck/lib
    cp lib/* ""$STAGING""/usr/share/prescheck/lib
    cp build/libs/bbb-pres-check-0.0.1.jar ""$STAGING""/usr/share/prescheck/lib
    cp run.sh ""$STAGING""/usr/share/prescheck/prescheck.sh
    chmod +x ""$STAGING""/usr/share/prescheck/prescheck.sh
  cd ..
fi

echo $PWD

mkdir -p ""$STAGING""/usr/share/bbb-web
mv build/libs/bigbluebutton-0.10.0.war ""$STAGING""/usr/share/bbb-web

mkdir -p ""$STAGING""/etc/default
cp ../bbb-web.env ""$STAGING""/etc/default/bbb-web

mkdir -p ""$STAGING""/lib/systemd/system
cp ../bbb-web.service ""$STAGING""/lib/systemd/system

pushd ""$STAGING""/usr/share/bbb-web
jar -xvf bigbluebutton-0.10.0.war
rm bigbluebutton-0.10.0.war
popd
pwd

# Copy this as simply 'web' and we'll make a symbolic link later in the .postinst script
mkdir -p ""$STAGING""/usr/share/bigbluebutton/nginx
cp bbb-web.nginx ""$STAGING""/usr/share/bigbluebutton/nginx/web
cp loadbalancer.nginx ""$STAGING""/usr/share/bigbluebutton/nginx/loadbalancer.nginx

mkdir -p ""$STAGING""/var/log/bigbluebutton
# Copy directive for serving SVG files (HTML5) from nginx
if [ -f nginx-confs/presentation-slides.nginx ]; then
  cp nginx-confs/presentation-slides.nginx ""$STAGING""/usr/share/bigbluebutton/nginx
fi

mkdir -p ""$STAGING""/var/bigbluebutton/diagnostics

##
cd ..

fpm -s dir -C ""$STAGING"" -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --before-install before-install.sh      \
    --after-install after-install.sh        \
    --description ""BigBlueButton API"" \
    $DIRECTORIES \
    $OPTS"
build/packages-template/bbb-web/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d zip,unzip,imagemagick,redis-server,xpdf-utils,bbb-libreoffice-docker,psmisc,fonts-crosextra-carlito,fonts-crosextra-caladea,fonts-noto,openjdk-11-jdk,file"""
build/packages-template/bbb-config/after-install.sh,"#!/bin/bash -e

set +x

removeOldOverride() {
    service_name=$1
    # check if override file has been modified. If not it can be safely removed
    if [ -f ""/etc/systemd/system/${service_name}.service.d/override.conf"" ] ; then
        if echo ""d32a00b9a2669b3fe757b8de3470e358  /etc/systemd/system/${service_name}.service.d/override.conf"" | md5sum -c --quiet 2>/dev/null >/dev/null ; then
            rm -f ""/etc/systemd/system/${service_name}.service.d/override.conf""
        fi
    fi
    if [ -d ""/etc/systemd/system/${service_name}.service.d"" ]; then
        if [ $(ls ""/etc/systemd/system/${service_name}.service.d"" |wc -l) = 0 ]; then
            rmdir ""/etc/systemd/system/${service_name}.service.d""
        fi
    fi
}

BIGBLUEBUTTON_USER=bigbluebutton

if ! id freeswitch >/dev/null 2>&1; then
  echo ""Error: FreeSWITCH not installed""
  exit 1
fi

if lsb_release -d | grep -q CentOS; then
  DISTRO=centos
  FREESWITCH=freeswitch
  FREESWITCH_GROUP=daemon
else
  DISTRO=ubuntu
  FREESWITCH=freeswitch
  FREESWITCH_GROUP=freeswitch
fi

#
# Set the permissions to /var/bigbluebutton tomcat (and possibly other services) can write
#
if [ -d /var/bigbluebutton ]; then
  echo -n "".""
  chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/bigbluebutton
  echo -n "".""
  
  chmod o+rx /var/bigbluebutton
 
  #
  # Setup for recordings XXX
  #
  mkdir -p /var/bigbluebutton/recording
  mkdir -p /var/bigbluebutton/recording/raw
  mkdir -p /var/bigbluebutton/recording/process
  mkdir -p /var/bigbluebutton/recording/publish
  mkdir -p /var/bigbluebutton/recording/status
  mkdir -p /var/bigbluebutton/recording/status/recorded
  mkdir -p /var/bigbluebutton/recording/status/archived
  mkdir -p /var/bigbluebutton/recording/status/processed
  mkdir -p /var/bigbluebutton/recording/status/sanity
  echo -n "".""
  chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/bigbluebutton/recording
  
  mkdir -p /var/bigbluebutton/published
  echo -n "".""
  chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/bigbluebutton/published
  
  mkdir -p /var/bigbluebutton/deleted
  echo -n "".""
  chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/bigbluebutton/deleted
  
  mkdir -p /var/bigbluebutton/unpublished
  echo -n "".""
  chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/bigbluebutton/unpublished
  echo
else
  echo ""Warning: BigBlueButton not installed""
fi

if [ -f /usr/share/bbb-apps-akka/conf/application.conf ]; then
  if [ ""$(cat /usr/share/bbb-apps-akka/conf/application.conf | sed -n '/sharedSecret.*/{s/[^""]*""//;s/"".*//;p}')"" == ""changeme"" ]; then
    SECRET=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | grep -v '#' | tr -d '\r' | sed -n '/securitySalt/{s/.*=//;p}')
    sed -i ""s/sharedSecret[ ]*=[ ]*\""[^\""]*\""/sharedSecret=\""$SECRET\""/g"" \
       /usr/share/bbb-apps-akka/conf/application.conf

    HOST=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | grep -v '#' | sed -n '/^bigbluebutton.web.serverURL/{s/.*\///;p}')
    sed -i  ""s/bbbWebAPI[ ]*=[ ]*\""[^\""]*\""/bbbWebAPI=\""http:\/\/$HOST\/bigbluebutton\/api\""/g"" \
       /usr/share/bbb-apps-akka/conf/application.conf
    sed -i ""s/bbbWebHost[ ]*=[ ]*\""[^\""]*\""/bbbWebHost=\""$HOST\""/g"" \
       /usr/share/bbb-apps-akka/conf/application.conf
    sed -i ""s/deskshareip[ ]*=[ ]*\""[^\""]*\""/deskshareip=\""$HOST\""/g"" \
       /usr/share/bbb-apps-akka/conf/application.conf
    sed -i ""s/defaultPresentationURL[ ]*=[ ]*\""[^\""]*\""/defaultPresentationURL=\""http:\/\/$HOST\/default.pdf\""/g"" \
       /usr/share/bbb-apps-akka/conf/application.conf

  fi
fi

#
# Added to enable bbb-record-core to move files #8901
#
usermod bigbluebutton -a -G freeswitch
chmod 0775 /var/freeswitch/meetings

# Verify mediasoup raw media directories ownership and perms
if [ -d /var/mediasoup ]; then
  chown bigbluebutton:bigbluebutton /var/mediasoup
  chmod 0700 /var/mediasoup
fi

if [ -d /var/mediasoup/recordings ]; then
  chmod 0700 /var/mediasoup/recordings
fi

if [ -d /var/mediasoup/screenshare ]; then
  chmod 0700 /var/mediasoup/screenshare
fi

sed -i 's/worker_connections 768/worker_connections 4000/g' /etc/nginx/nginx.conf

if grep -q ""worker_rlimit_nofile"" /etc/nginx/nginx.conf; then
  num=$(grep worker_rlimit_nofile /etc/nginx/nginx.conf | grep -o '[0-9]*')
  if [[ ""$num"" -lt 10000 ]]; then
    sed -i 's/worker_rlimit_nofile [0-9 ]*;/worker_rlimit_nofile 10000;/g' /etc/nginx/nginx.conf
  fi
else
  sed -i 's/events {/worker_rlimit_nofile 10000;\n\nevents {/g' /etc/nginx/nginx.conf
fi

mkdir -p /etc/bigbluebutton/nginx

# symlink default bbb nginx config from package if it does not exist
if [ ! -e /etc/bigbluebutton/nginx/include_default.nginx ] ; then
  ln -s /usr/share/bigbluebutton/include_default.nginx /etc/bigbluebutton/nginx/include_default.nginx
fi

# set full BBB version in settings.yml so it can be displayed in the client
BBB_RELEASE_FILE=/etc/bigbluebutton/bigbluebutton-release
BBB_HTML5_SETTINGS_FILE=/usr/share/meteor/bundle/programs/server/assets/app/config/settings.yml
if [ -f $BBB_RELEASE_FILE ] && [ -f $BBB_HTML5_SETTINGS_FILE ]; then
  BBB_FULL_VERSION=$(cat $BBB_RELEASE_FILE | sed -n '/^BIGBLUEBUTTON_RELEASE/{s/.*=//;p}' | tail -n 1)
  echo ""setting public.app.bbbServerVersion: $BBB_FULL_VERSION in $BBB_HTML5_SETTINGS_FILE ""
  yq e -i "".public.app.bbbServerVersion = \""$BBB_FULL_VERSION\"""" $BBB_HTML5_SETTINGS_FILE
fi

# Fix permissions for logging
chown bigbluebutton:bigbluebutton /var/log/bbb-fsesl-akka

# cleanup old overrides

removeOldOverride bbb-apps-akka
removeOldOverride bbb-fsesl-akka
removeOldOverride bbb-transcode-akka


# re-create the symlink for apply-lib.sh to ensure the latest version is present
if [ -f /etc/bigbluebutton/bbb-conf/apply-lib.sh ]; then
  rm /etc/bigbluebutton/bbb-conf/apply-lib.sh
fi
if [ -f /usr/lib/bbb-conf/apply-lib.sh ]; then
  ln -s /usr/lib/bbb-conf/apply-lib.sh /etc/bigbluebutton/bbb-conf/apply-lib.sh
fi

# Load the overrides
systemctl daemon-reload"
build/packages-template/bbb-config/before-install.sh,"#!/bin/bash -e

case ""$1"" in
    install|upgrade|1|2)

        # We want to ensure Redis is fully started before it signals it is ready to rely on
        mkdir -p /etc/systemd/system/redis-server.service.d
        cat <<HERE > /etc/systemd/system/redis-server.service.d/overrride.conf
[Service]
ExecStartPost=/usr/bin/timeout 30 sh -c 'while ! ss -H -t -l -n sport = :6379 | grep -q ""^LISTEN.*:6379""; do sleep 1; done'
HERE
    ;;

    abort-upgrade)
    ;;

    *)
        echo ""## preinst called with unknown argument \`$1'"" >&2
    ;;
esac"
build/packages-template/bbb-config/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`

# inject dependency to bigbluebutton.target
for unit in freeswitch nginx redis-server; do
  mkdir -p ""staging/usr/lib/systemd/system/${unit}.service.d""
  cp bigbluebutton.conf ""staging/usr/lib/systemd/system/${unit}.service.d/""
done


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#
# Clear staging directory for build
rm -rf staging

#
# Create build directories for markign by fpm
DIRS=""/etc/bigbluebutton \
      /usr/lib/systemd/system \
      /var/bigbluebutton/blank \
      /usr/share/bigbluebutton/blank \
      /var/www/bigbluebutton-default/assets""
for dir in $DIRS; do
  mkdir -p staging$dir
  DIRECTORIES=""$DIRECTORIES --directories $dir""
done

cp bigbluebutton-release staging/etc/bigbluebutton
cp slides/nopdfmark.ps staging/etc/bigbluebutton

# XXX remove /var/bigbluebutton
cp slides/blank* staging/var/bigbluebutton/blank
cp slides/blank* staging/usr/share/bigbluebutton/blank

cp -r assets/* staging/var/www/bigbluebutton-default/assets

mkdir -p staging/usr/bin
cp bin/bbb-conf bin/bbb-record staging/usr/bin
chmod +x staging/usr/bin/bbb-conf

mkdir -p staging/etc/bigbluebutton/bbb-conf
mkdir -p staging/usr/lib/bbb-conf
cp bin/apply-lib.sh staging/usr/lib/bbb-conf

mkdir -p staging/etc/cron.daily
cp cron.daily/* staging/etc/cron.daily

mkdir -p staging/etc/cron.hourly
cp cron.hourly/bbb-resync-freeswitch staging/etc/cron.hourly

mkdir -p staging/usr/share/bigbluebutton/nginx

cp include_default.nginx staging/usr/share/bigbluebutton/

cp bigbluebutton.target staging/usr/lib/systemd/system/

. ./opts-$DISTRO.sh

#
# Build package
fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --after-install after-install.sh \
    --after-remove after-remove.sh \
    --before-install before-install.sh \
    --description ""BigBlueButton configuration utilities"" \
    $DIRECTORIES \
    $OPTS"
build/packages-template/bbb-config/opts-jammy.sh,". ./opts-global.sh

AKKA_APPS=""bbb-fsesl-akka,bbb-apps-akka""
OPTS=""$OPTS -t deb -d netcat-openbsd,stun-client,bbb-html5,bbb-playback-presentation,bbb-playback,bbb-freeswitch-core,$AKKA_APPS,yq"""
build/packages-template/bbb-config/after-remove.sh,"#!/bin/bash -e

case ""$1"" in
   remove|failed-upgrade|abort-upgrade|abort-install|disappear)
   ;;
   purge)
      # remove file deployed by after-install script if it is still a symlink
      if [ ""x$(readlink -f /etc/bigbluebutton/nginx/include_default.nginx)"" = x/usr/share/bigbluebutton/include_default.nginx ] ; then
        rm /etc/bigbluebutton/nginx/include_default.nginx
      fi
   ;;
   upgrade)
   ;;
   *)
      echo ""postinst called with unknown argument \`\$1'"" >&2
   ;;
esac"
build/packages-template/bbb-etherpad/after-install.sh,"#!/bin/bash -e

# avoid missing directories for fresh install
mkdir -p /usr/share/etherpad-lite/.config
mkdir -p /usr/share/etherpad-lite/node_modules

chown etherpad:etherpad /usr/share/etherpad-lite/APIKEY.txt
# minified assets
chown -R etherpad:etherpad /usr/share/etherpad-lite/var
# npm update wants to write this
chown -R etherpad:etherpad /usr/share/etherpad-lite/.config
# etherpad wants to write to this
chown -R etherpad:etherpad /usr/share/etherpad-lite/node_modules
chown root:root /usr/lib/systemd/system/etherpad.service

if [ ! -f /.dockerenv ]; then
  systemctl enable etherpad.service
  systemctl daemon-reload
  startService etherpad.service || echo ""etherpad service could not be registered or started""
fi"
build/packages-template/bbb-etherpad/before-install.sh,"#!/bin/bash -e

addGroup etherpad """"
addUser etherpad """" etherpad /usr/share/etherpad-lite ""etherpad user-daemon"" ""/bin/false""

if [ ! -f /usr/share/etherpad-lite/APIKEY.txt ]; then
  mkdir -p /usr/share/etherpad-lite
  openssl rand -base64 64 | head -n 1 | sed 's/=//g' | sed 's/+//g' | sed 's/\///g' | tr -d '\n' > /usr/share/etherpad-lite/APIKEY.txt
  chown etherpad:etherpad /usr/share/etherpad-lite/
  chown etherpad:etherpad /usr/share/etherpad-lite/APIKEY.txt
  chmod 644 /usr/share/etherpad-lite/APIKEY.txt
fi

if [ -d /usr/share/etherpad-lite/node_modules ]; then
  rm -r /usr/share/etherpad-lite/node_modules
fi

# Clean out old pads before upgrade
redis-cli keys pad:*            | xargs -r redis-cli del
redis-cli keys sessionstorage:* | xargs -r redis-cli del
redis-cli keys globalAuthor:*   | xargs -r redis-cli del
redis-cli keys token2author:*   | xargs -r redis-cli del
redis-cli keys pad2readonly:*   | xargs -r redis-cli del
redis-cli keys readonly2pad:*   | xargs -r redis-cli del
redis-cli keys ueberDB:*        | xargs -r redis-cli del"
build/packages-template/bbb-etherpad/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)
TAG=$(echo $TARGET | cut -d'_' -f4)


#
# Clean up directories
rm -rf staging

#
# package

set +e

# as of March 12, 2022, circa BigBlueButton 2.5-alpha4, we set npm by default to 8.5.0
# however, it seems bbb-etherpad has troubles building with npm as high.
# Setting npm to 6.14.11 which was used successfully for building in BigBlueButton 2.4.x
npm -v
npm i -g npm@6.14.11
npm -v

ls -l node_modules/
ls -l node_modules/ep_etherpad-lite
ls -l src/
# rm -f node_modules/ep_etherpad-lite/package.json # Was preventing npm ci running, see https://github.com/ether/etherpad-lite/issues/4962#issuecomment-916642078
bin/installDeps.sh
set -e

rm -rf ep_pad_ttl
git clone https://github.com/mconf/ep_pad_ttl.git
npm pack ./ep_pad_ttl
npm install ./ep_pad_ttl-*.tgz

rm -rf bbb-etherpad-plugin
git clone https://github.com/alangecker/bbb-etherpad-plugin.git
npm pack ./bbb-etherpad-plugin
npm install ./ep_bigbluebutton_patches-*.tgz

rm -rf ep_redis_publisher
git clone https://github.com/mconf/ep_redis_publisher.git
npm pack ./ep_redis_publisher
npm install ./ep_redis_publisher-*.tgz

npm install ep_cursortrace
npm install ep_disable_chat
npm install --no-save --legacy-peer-deps ep_auth_session

mkdir -p staging/usr/share/etherpad-lite

cp -r CHANGELOG.md CONTRIBUTING.md LICENSE README.md bin doc src tests var node_modules staging/usr/share/etherpad-lite

cp settings.json staging/usr/share/etherpad-lite
git clone https://github.com/alangecker/bbb-etherpad-skin.git staging/usr/share/etherpad-lite/src/static/skins/bigbluebutton

mkdir -p staging/usr/lib/systemd/system
cp etherpad.service staging/usr/lib/systemd/system

mkdir -p staging/usr/share/bigbluebutton/nginx
cp notes.nginx staging/usr/share/bigbluebutton/nginx

rm -rf staging/usr/share/etherpad-lite/src/static/skins/bigbluebutton/.git

##

. ./opts-$DISTRO.sh

#
# Build RPM package
fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --before-install before-install.sh \
    --after-install after-install.sh \
    --before-remove before-remove.sh \
    --after-remove after-remove.sh \
    --description ""The EtherPad Lite components for BigBlueButton"" \
    $DIRECTORIES \
    $OPTS
"
build/packages-template/bbb-etherpad/before-remove.sh,"#!/bin/bash -e

stopService etherpad || echo ""etherpad could not be unregistered or stopped""
"
build/packages-template/bbb-etherpad/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb""
"
build/packages-template/bbb-etherpad/after-remove.sh,"#!/bin/bash -e

case ""$1"" in
   remove|failed-upgrade|abort-upgrade|abort-install|disappear)
   ;;
   purge)
     deleteUser etherpad
     deleteGroup etherpad
   ;;
   upgrade)
   ;;
   *)
      echo ""postinst called with unknown argument \`\$1'"" >&2
   ;;
esac"
build/packages-template/bbb-playback-podcast/after-install.sh,"#!/bin/bash -e

BBB_USER=bigbluebutton

case ""$1"" in
  configure|upgrade|1|2)
    
  TARGET=/usr/local/bigbluebutton/core/scripts/podcast.yml

  if [ -f $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties ]; then
    HOST=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | sed -n '/^bigbluebutton.web.serverURL/{s/.*\///;p}')
  else
    HOST=$IP
  fi

  if [ -f $TARGET ]; then
    yq e -i "".playback_host = \""$HOST\"""" $TARGET
  else
    echo ""No: $TARGET""
    exit 1
  fi
    
    mkdir -p /var/bigbluebutton/published/podcast
    chown -R $BBB_USER:$BBB_USER /var/bigbluebutton/published/podcast
    chmod -R o+rx /var/bigbluebutton/published/
    
    mkdir -p /var/log/bigbluebutton/podcast
    chown -R $BBB_USER:$BBB_USER /var/log/bigbluebutton/podcast
    
    mkdir -p /var/bigbluebutton/recording/publish/podcast
    chown -R $BBB_USER:$BBB_USER /var/bigbluebutton/recording/publish/podcast
    
    if [ -f /var/bigbluebutton/published/podcast/index.html ]; then
      rm /var/bigbluebutton/published/podcast/index.html
    fi
    
  ;;
  
  failed-upgrade)
  ;;

  *)
    echo ""## postinst called with unknown argument \`$1'"" >&2
  ;;
esac
"
build/packages-template/bbb-playback-podcast/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#
# Clear staging directory for build
rm -rf staging

#
# Create build directories for markign by fpm
DIRS=""""
for dir in $DIRS; do
  mkdir -p staging$dir
  DIRECTORIES=""$DIRECTORIES --directories $dir""
done

##

mkdir -p staging/usr/local/bigbluebutton/core
cp -r scripts staging/usr/local/bigbluebutton/core

#mkdir -p staging/var/bigbluebutton
#cp -r playback staging/var/bigbluebutton

mkdir -p staging/usr/share/bigbluebutton/nginx
cp staging/usr/local/bigbluebutton/core/scripts/podcast.nginx staging/usr/share/bigbluebutton/nginx

##

. ./opts-$DISTRO.sh

#
# Build package
fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --post-install before-install.sh \
    --after-install after-install.sh \
    --description ""BigBluebutton playback in podcast"" \
    $DIRECTORIES \
    $OPTS"
build/packages-template/bbb-playback-podcast/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d bbb-record-core,yq"""
build/packages-template/bbb-html5/systemd_start.sh,"#!/bin/bash -e

#Allow to run outside of directory
cd $(dirname $0)

echo ""Starting mongoDB""

#wait for mongo startup
MONGO_OK=0

while [ ""$MONGO_OK"" = ""0"" ]; do
    MONGO_OK=$(ss -lan | grep 127.0.1.1 | grep 27017 &> /dev/null && echo 1 || echo 0)
    sleep 1;
done;

echo ""Mongo started"";

echo ""Initializing replicaset""
mongosh 127.0.1.1 --eval 'rs.initiate({ _id: ""rs0"", members: [ {_id: 0, host: ""127.0.1.1""} ]})'


echo ""Waiting to become a master""
IS_MASTER=""XX""
while [ ""$IS_MASTER"" \!= ""true"" ]; do
    IS_MASTER=$(mongosh mongodb://127.0.1.1:27017/ --eval  'db.isMaster().ismaster' | tail -n 1)
    sleep 0.5;
done;

echo ""I'm the master!""

if [ -z $1 ]
then
  INSTANCE_ID=1
else
  INSTANCE_ID=$1
fi

PORT=$(echo ""3999+$INSTANCE_ID"" | bc)

echo ""instanceId = $INSTANCE_ID   and port = $PORT   and role is backend (in backend file)""

export INSTANCE_ID=$INSTANCE_ID
export BBB_HTML5_ROLE=backend
# this might be already set by a systemd unit override in case this node is run
# behind a load balancer proxy node
if [[ -z $ROOT_URL ]] ; then
  export ROOT_URL=http://127.0.0.1/html5client
fi
export MONGO_OPLOG_URL=mongodb://127.0.1.1/local
export MONGO_URL=mongodb://127.0.1.1/meteor
export NODE_ENV=production
export SERVER_WEBSOCKET_COMPRESSION=0
export BIND_IP=127.0.0.1
PORT=$PORT /usr/lib/bbb-html5/node/bin/node --max-old-space-size=2048 --max_semi_space_size=128 main.js NODEJS_BACKEND_INSTANCE_ID=$INSTANCE_ID
"
build/packages-template/bbb-html5/workers-start.sh,"#!/bin/bash
# Start parallel nodejs processes for bbb-html5. Number varies on restrictions file bbb-html5-with-roles.conf

source /usr/share/meteor/bundle/bbb-html5-with-roles.conf

if [ -f /etc/bigbluebutton/bbb-html5-with-roles.conf ]; then
  source /etc/bigbluebutton/bbb-html5-with-roles.conf
fi

MIN_NUMBER_OF_BACKEND_PROCESSES=1
MAX_NUMBER_OF_BACKEND_PROCESSES=4

MIN_NUMBER_OF_FRONTEND_PROCESSES=0 # 0 means each nodejs process handles both front and backend roles
MAX_NUMBER_OF_FRONTEND_PROCESSES=8


# Start backend nodejs processes
if ((NUMBER_OF_BACKEND_NODEJS_PROCESSES >= MIN_NUMBER_OF_BACKEND_PROCESSES && NUMBER_OF_BACKEND_NODEJS_PROCESSES <= MAX_NUMBER_OF_BACKEND_PROCESSES)); then
  for ((i = 1 ; i <= NUMBER_OF_BACKEND_NODEJS_PROCESSES ; i++)); do
    systemctl start bbb-html5-backend@$i
  done
fi


# Start frontend nodejs processes
if ((NUMBER_OF_FRONTEND_NODEJS_PROCESSES >= MIN_NUMBER_OF_FRONTEND_PROCESSES && NUMBER_OF_FRONTEND_NODEJS_PROCESSES <= MAX_NUMBER_OF_FRONTEND_PROCESSES)); then
  if ((NUMBER_OF_FRONTEND_NODEJS_PROCESSES == 0)); then
    echo 'Need to modify bbb-html5.nginx to ensure backend IPs are used'
  fi
  for ((i = 1 ; i <= NUMBER_OF_FRONTEND_NODEJS_PROCESSES ; i++)); do
    systemctl start bbb-html5-frontend@$i
  done
fi
"
build/packages-template/bbb-html5/mongod_start_pre.sh,"#!/bin/bash

rm -rf /mnt/mongo-ramdisk/* 
mkdir -p /mnt/mongo-ramdisk
if /bin/findmnt | grep -q ""/mnt/mongo-ramdisk""; then
  umount /mnt/mongo-ramdisk/
fi
if [ ! -f /.dockerenv ]; then 
  mount -t tmpfs -o size=512m tmpfs /mnt/mongo-ramdisk
fi

if id mongod &> /dev/null; then
  chown -R mongod:mongod /mnt/mongo-ramdisk
else
  chown -R mongodb:mongodb /mnt/mongo-ramdisk
fi"
build/packages-template/bbb-html5/after-install.sh,"#!/bin/bash -e


HOST=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | grep -v '#' | sed -n '/^bigbluebutton.web.serverURL/{s/.*\///;p}')

if [ ! -L /etc/nginx/sites-enabled/bigbluebutton ]; then
  mkdir -p /etc/nginx/sites-enabled
  ln -s /etc/nginx/sites-available/bigbluebutton /etc/nginx/sites-enabled/bigbluebutton
fi

# This config file was renamed, remove from old path if exists
if [ -f /etc/nginx/conf.d/html5-conn-limit.conf ]; then
  rm -r /etc/nginx/conf.d/html5-conn-limit.conf
fi

cd /usr/share/meteor

# meteor code should be owned by root, config file by meteor user
meteor_owner=$(stat -c %U:%G /usr/share/meteor)
if [[ $meteor_owner != ""root:root"" ]] ; then
    chown -R root:root /usr/share/meteor
fi

TARGET=/usr/share/meteor/bundle/programs/server/assets/app/config/settings.yml

  WSURL=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | grep -v '#' | sed -n '/^bigbluebutton.web.serverURL/{s/.*=//;p}' | sed 's/https/wss/g' | sed s'/http/ws/g')

  yq e -i "".public.kurento.wsUrl = \""$WSURL/bbb-webrtc-sfu\"""" $TARGET

  yq e -i  "".public.pads.url = \""$PROTOCOL://$HOST/pad\"""" $TARGET

  sed -i ""s/proxy_pass .*/proxy_pass http:\/\/$IP:5066;/g"" /usr/share/bigbluebutton/nginx/sip.nginx
  sed -i ""s/server_name  .*/server_name  $IP;/g"" /etc/nginx/sites-available/bigbluebutton

  chmod 600 $TARGET
  chown meteor:meteor $TARGET

if [ ! -f /.dockerenv ]; then
  systemctl enable disable-transparent-huge-pages.service
  systemctl daemon-reload
fi

# set full BBB version in settings.yml so it can be displayed in the client
BBB_RELEASE_FILE=/etc/bigbluebutton/bigbluebutton-release
BBB_HTML5_SETTINGS_FILE=/usr/share/meteor/bundle/programs/server/assets/app/config/settings.yml
if [ -f $BBB_RELEASE_FILE ] && [ -f $BBB_HTML5_SETTINGS_FILE ]; then
  BBB_FULL_VERSION=$(cat $BBB_RELEASE_FILE | sed -n '/^BIGBLUEBUTTON_RELEASE/{s/.*=//;p}' | tail -n 1)
  echo ""setting public.app.bbbServerVersion: $BBB_FULL_VERSION in $BBB_HTML5_SETTINGS_FILE ""
  yq e -i "".public.app.bbbServerVersion = \""$BBB_FULL_VERSION\"""" $BBB_HTML5_SETTINGS_FILE
fi    


# Remove old overrides 
if [ -f /etc/systemd/system/mongod.service.d/override-mongo.conf ] \
  || [ -f /etc/systemd/system/mongod.service.d/override.conf ] \
  || [ -f /usr/lib/systemd/system/mongod.service.d/mongod-service-override.conf ] ; then
  rm -f /etc/systemd/system/mongod.service.d/override-mongo.conf
  rm -f /etc/systemd/system/mongod.service.d/override.conf
  rm -f /usr/lib/systemd/system/mongod.service.d/mongod-service-override.conf 
  systemctl daemon-reload
fi

# Enable Listen Only support in FreeSWITCH
if [ -f /opt/freeswitch/etc/freeswitch/sip_profiles/external.xml ]; then
  sed -i 's/<!--<param name=""enable-3pcc"" value=""true""\/>-->/<param name=""enable-3pcc"" value=""proxy""\/>/g' /opt/freeswitch/etc/freeswitch/sip_profiles/external.xml
fi

chown root:root /usr/lib/systemd/system
chown root:root /usr/lib/systemd/system/bbb-html5.service
chown root:root /usr/lib/systemd/system/disable-transparent-huge-pages.service

# Ensure settings is readable
chmod go+r /usr/share/meteor/bundle/programs/server/assets/app/config/settings.yml

startService bbb-html5 || echo ""bbb-html5 service could not be registered or started""
"
build/packages-template/bbb-html5/before-install.sh,"#!/bin/bash -e

addGroup meteor """"
addUser meteor """" meteor /usr/share/meteor ""meteor user-daemon"" ""/usr/sbin/nologin""

case ""$1"" in
  install|upgrade|1|2)

    if [ -f /usr/share/meteor/bundle/programs/server/node_modules ]; then
      rm -r /usr/share/meteor/bundle/programs/server/node_modules
    fi

  ;;
esac"
build/packages-template/bbb-html5/kill_mongo.sh,"#!/bin/bash
cd `dirname $0`
#Check if mongo is running and kill it
A=1
while [ ""$A"" = 1 ]; do
        sleep 0.1
        killall -9 mongod &> /dev/null
        A=`ps aux | grep mongod | grep rs0 | awk  '{print $2}' | grep [0-9] &> /dev/null && echo 1 || echo 0`
done;
"
build/packages-template/bbb-html5/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)
TAG=$(echo $TARGET | cut -d'_' -f4)
BUILD=$1

#
# Clean up directories
rm -rf staging

#
# package

# New format
if [ -f private/config/settings.yml ]; then
  sed -i ""s/HTML5_CLIENT_VERSION/$(($BUILD))/g"" private/config/settings.yml
fi

mkdir -p staging/usr/share/bigbluebutton/nginx
cp bbb-html5.nginx staging/usr/share/bigbluebutton/nginx

mkdir -p staging/etc/nginx/conf.d
cp bbb-html5-loadbalancer.conf staging/etc/nginx/conf.d
cp bbb-html5-conn-limit.conf staging/etc/nginx/conf.d


mkdir -p staging/etc/systemd/system
cp mongod.service staging/etc/systemd/system

mkdir -p staging/usr/share/meteor

rm -rf /tmp/html5-build
mkdir -p /tmp/html5-build

npm -v
meteor npm -v
meteor node -v
cat .meteor/release

# meteor version control was moved to the Dockerfile of the image used in .gitlab-ci.yml
# meteor update --allow-superuser --release 2.3.6

# Install the npm dependencies needed for the HTML5 client.
# Argument 'c' means package-lock.json will be respected
# --production means we won't be installing devDependencies
meteor npm ci --production

# deleting links as they were repeatedly broken (node_modules/acorn/bin mostly)
# I have not seen this on npm 8+ but meteor npm is still at 6.x right now
# https://forums.meteor.com/t/broken-symbolic-link-on-running-app/57770/3
find node_modules/.bin -xtype l -delete

# Build the HTML5 client https://guide.meteor.com/deployment.html#custom-deployment
# https://docs.meteor.com/environment-variables.html#METEOR-DISABLE-OPTIMISTIC-CACHING - disable caching because we're only building once
# --allow-superuser
# --directory - instead of creating tar.gz and then extracting (which is the default option)
METEOR_DISABLE_OPTIMISTIC_CACHING=1 meteor build /tmp/html5-build --architecture os.linux.x86_64 --allow-superuser --directory

# Install the npm dependencies, then copy to staging
cd /tmp/html5-build/bundle/programs/server/

# Install Meteor related dependencies
# Note that we don't use ""c"" argument as there is no package-lock.json here
# only package.json. The dependencies for bbb-html5 are already installed in
# /usr/share/meteor/bundle/programs/server/npm/node_modules/ and not in
# /usr/share/meteor/bundle/programs/server/node_modules
npm i
cd -
cp -r /tmp/html5-build/bundle staging/usr/share/meteor

# copy over tl;draw fonts due to a preset path
mkdir -p staging/usr/share/meteor/bundle/programs/web.browser/app/files
cp node_modules/@fontsource/*/files/*.woff[2] staging/usr/share/meteor/bundle/programs/web.browser/app/files/

cp systemd_start.sh staging/usr/share/meteor/bundle
chmod +x staging/usr/share/meteor/bundle/systemd_start.sh

cp systemd_start_frontend.sh staging/usr/share/meteor/bundle
chmod +x staging/usr/share/meteor/bundle/systemd_start_frontend.sh

cp workers-start.sh staging/usr/share/meteor/bundle
chmod +x staging/usr/share/meteor/bundle/workers-start.sh

cp bbb-html5-with-roles.conf staging/usr/share/meteor/bundle

cp mongod_start_pre.sh staging/usr/share/meteor/bundle
chmod +x staging/usr/share/meteor/bundle/mongod_start_pre.sh

cp mongo-ramdisk.conf staging/usr/share/meteor/bundle
# cp mongo-ramdisk.conf staging/etc/mongod.conf

mkdir -p staging/usr/lib/systemd/system
cp bbb-html5.service staging/usr/lib/systemd/system
cp disable-transparent-huge-pages.service staging/usr/lib/systemd/system

cp bbb-html5-backend@.service staging/usr/lib/systemd/system
cp bbb-html5-frontend@.service staging/usr/lib/systemd/system


mkdir -p staging/usr/share

# replace v=VERSION with build number in head and css files
if [ -f staging/usr/share/meteor/bundle/programs/web.browser/head.html ]; then
  sed -i ""s/VERSION/$(($BUILD))/g"" staging/usr/share/meteor/bundle/programs/web.browser/head.html
fi

find staging/usr/share/meteor/bundle/programs/web.browser -name '*.css' -exec sed -i ""s/VERSION/$(($BUILD))/g"" '{}' \;

# Compress CSS, Javascript and tensorflow WASM binaries used for virtual backgrounds. Keep the
# uncompressed versions as well so it works with mismatched nginx location blocks
find staging/usr/share/meteor/bundle/programs/web.browser -name '*.js' -exec gzip -k -f -9 '{}' \;
find staging/usr/share/meteor/bundle/programs/web.browser -name '*.css' -exec gzip -k -f -9 '{}' \;
find staging/usr/share/meteor/bundle/programs/web.browser -name '*.wasm' -exec gzip -k -f -9 '{}' \;

mkdir -p staging/etc/nginx/sites-available
cp bigbluebutton.nginx staging/etc/nginx/sites-available/bigbluebutton

mkdir -p staging/usr/share/bigbluebutton/nginx
cp sip.nginx staging/usr/share/bigbluebutton/nginx

mkdir -p staging/var/www/bigbluebutton
touch staging/var/www/bigbluebutton/index.html

. ./opts-$DISTRO.sh

#
# Build RPM package
fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --before-install before-install.sh \
    --after-install after-install.sh \
    --before-remove before-remove.sh \
    --after-remove after-remove.sh \
    --description ""The HTML5 components for BigBlueButton"" \
    $DIRECTORIES \
    $OPTS"
build/packages-template/bbb-html5/systemd_start_frontend.sh,"#!/bin/bash -e

#Allow to run outside of directory
cd $(dirname $0)

echo ""Starting mongoDB""

#wait for mongo startup
MONGO_OK=0

while [ ""$MONGO_OK"" = ""0"" ]; do
    MONGO_OK=$(ss -lan | grep 127.0.1.1 | grep 27017 &> /dev/null && echo 1 || echo 0)
    sleep 1;
done;

echo ""Mongo started"";

echo ""Initializing replicaset""
mongosh 127.0.1.1 --eval 'rs.initiate({ _id: ""rs0"", members: [ {_id: 0, host: ""127.0.1.1""} ]})'


echo ""Waiting to become a master""
IS_MASTER=""XX""
while [ ""$IS_MASTER"" \!= ""true"" ]; do
    IS_MASTER=$(mongosh mongodb://127.0.1.1:27017/ --eval  'db.isMaster().ismaster' | tail -n 1)
    sleep 0.5;
done;

echo ""I'm the master!""

if [ -z $1 ]
then
  INSTANCE_ID=1
else
  INSTANCE_ID=$1
fi

PORT=$(echo ""4099+$INSTANCE_ID"" | bc)

echo ""instanceId = $INSTANCE_ID   and port = $PORT and role is frontend (in frontend file)""

export INSTANCE_ID=$INSTANCE_ID
export BBB_HTML5_ROLE=frontend
# this might be already set by a systemd unit override in case this node is run
# behind a load balancer proxy node
if [[ -z $ROOT_URL ]] ; then
  export ROOT_URL=http://127.0.0.1/html5client
fi
export MONGO_OPLOG_URL=mongodb://127.0.1.1/local
export MONGO_URL=mongodb://127.0.1.1/meteor
export NODE_ENV=production
export SERVER_WEBSOCKET_COMPRESSION='{""level"":5, ""maxWindowBits"":13, ""memLevel"":7, ""requestMaxWindowBits"":13}'
export BIND_IP=127.0.0.1
PORT=$PORT /usr/lib/bbb-html5/node/bin/node --max-old-space-size=2048 --max_semi_space_size=128 main.js
"
build/packages-template/bbb-html5/before-remove.sh,"#!/bin/bash -e

stopService bbb-html5 || echo ""bbb-html5 could not be unregistered or stopped""
"
build/packages-template/bbb-html5/run_mongo.sh,"#!/bin/bash
cd `dirname $0`
./kill_mongo.sh
rm /mnt/mongo-ramdisk/* -rf
mkdir /mnt/mongo-ramdisk/ &> /dev/null
umount /mnt/mongo-ramdisk/  &> /dev/null
if [ ! -f /.dockerenv ]; then
  mount -t tmpfs -o size=512m tmpfs /mnt/mongo-ramdisk/ 
fi

nohup mongod --config ./mongo-ramdisk.conf --oplogSize 8 --replSet rs0 --noauth --nojournal &> /dev/null &


#wait for mongo startup
MONGO_OK=0

while [ ""$MONGO_OK"" = ""0"" ]; do
    MONGO_OK=`ss -lan | grep 127.0.1.1 | grep 27017 &> /dev/null && echo 1 || echo 0`
    sleep 1;
done;

echo ""Mongo started"";

echo ""Initializing replicaset""
mongo 127.0.1.1 --eval 'rs.initiate({ _id: ""rs0"", members: [ {_id: 0, host: ""127.0.1.1""} ]})'


echo ""Waiting to become a master""
IS_MASTER=""XX""
while [ ""$IS_MASTER"" \!= ""true"" ]; do
    IS_MASTER=`mongo mongodb://127.0.1.1:27017/ --eval  'db.isMaster().ismaster' | tail -n 1`
    sleep 0.5;
done;

echo ""I'm the master!""
"
build/packages-template/bbb-html5/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -d bc,bbb-pads,bbb-webrtc-sfu,bbb-export-annotations,bbb-web,bbb-html5-nodejs,bbb-graphql-server,yq,mongodb-org -t deb"""
build/packages-template/bbb-html5/after-remove.sh,"#!/bin/bash -e

case ""$1"" in
   remove|failed-upgrade|abort-upgrade|abort-install|disappear|0|1)

   if [ -L /etc/nginx/sites-enabled/bigbluebutton ]; then
     rm /etc/nginx/sites-enabled/bigbluebutton
   fi

   ;;
   purge)
     deleteUser meteor
     deleteGroup meteor
   ;;
   upgrade)
   ;;
   *)
      echo ""postinst called with unknown argument $1"" >&2
   ;;
esac
"
build/packages-template/bbb-libreoffice-docker/after-install.sh,"#!/bin/bash -e

if ! which docker > /dev/null; then
	echo ""#""
	echo ""# Unable to install bbb-libreoffice-docker -- no docker available""
	echo ""#""
	exit 0
fi

#if ! docker image inspect bbb-soffice > /dev/null 2>&1; then
	cd /usr/share/bbb-libreoffice
	echo ""#""
	echo ""# Building bbb-libreoffice docker image""
	echo ""#""
	docker build -t bbb-soffice docker/
#fi


chmod +x /usr/share/bbb-libreoffice-conversion/convert-local.sh
chmod +x /usr/share/bbb-libreoffice-conversion/convert-remote.sh
chmod +x /usr/share/bbb-libreoffice-conversion/etherpad-export.sh


if [ ! -L /usr/share/bbb-libreoffice-conversion/convert.sh ]; then
	ln -s /usr/share/bbb-libreoffice-conversion/convert-local.sh /usr/share/bbb-libreoffice-conversion/convert.sh
fi

cat > /etc/sudoers.d/zzz-bbb-docker-libreoffice <<HERE
bigbluebutton ALL=(ALL) NOPASSWD: /usr/bin/docker run --rm --memory=1g --memory-swap=1g --network none --env=HOME=/tmp/ -w /tmp/ --user=[0-9][0-9][0-9][0-9][0-9] -v /tmp/bbb-soffice-bigbluebutton/tmp.[0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z]/\:/data/ -v /usr/share/fonts/\:/usr/share/fonts/\:ro --rm bbb-soffice sh -c timeout [0-9][0-9][0-9]s /usr/bin/soffice -env\:UserInstallation=file\:///tmp/ --convert-to pdf --outdir /data /data/file
etherpad ALL=(ALL) NOPASSWD: /usr/bin/docker run --rm --memory=1g --memory-swap=1g --network none --env=HOME=/tmp/ -w /tmp/ --user=[0-9][0-9][0-9][0-9][0-9] -v /tmp/bbb-soffice-etherpad/tmp.[0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z]/\:/data/ -v /usr/share/fonts/\:/usr/share/fonts/\:ro --rm bbb-soffice sh -c timeout [0-9][0-9][0-9]s /usr/bin/soffice -env\:UserInstallation=file\:///tmp/ --convert-to pdf --writer --outdir /data /data/file
etherpad ALL=(ALL) NOPASSWD: /usr/bin/docker run --rm --memory=1g --memory-swap=1g --network none --env=HOME=/tmp/ -w /tmp/ --user=[0-9][0-9][0-9][0-9][0-9] -v /tmp/bbb-soffice-etherpad/tmp.[0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z]/\:/data/ -v /usr/share/fonts/\:/usr/share/fonts/\:ro --rm bbb-soffice sh -c timeout [0-9][0-9][0-9]s /usr/bin/soffice -env\:UserInstallation=file\:///tmp/ --convert-to odt --writer --outdir /data /data/file
etherpad ALL=(ALL) NOPASSWD: /usr/bin/docker run --rm --memory=1g --memory-swap=1g --network none --env=HOME=/tmp/ -w /tmp/ --user=[0-9][0-9][0-9][0-9][0-9] -v /tmp/bbb-soffice-etherpad/tmp.[0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z]/\:/data/ -v /usr/share/fonts/\:/usr/share/fonts/\:ro --rm bbb-soffice sh -c timeout [0-9][0-9][0-9]s /usr/bin/soffice -env\:UserInstallation=file\:///tmp/ --convert-to doc --outdir /data /data/file
HERE

#for i in `seq 1 4` ; do
#
#	SOFFICE_WORK_DIR=""/var/tmp/soffice_""`printf ""%02d\n"" ${i}`
#	mkdir -p $SOFFICE_WORK_DIR
#	chown bigbluebutton:bigbluebutton $SOFFICE_WORK_DIR
#
#        systemctl enable bbb-libreoffice@${i}
#        systemctl start bbb-libreoffice@${i}
#done

exit 0"
build/packages-template/bbb-libreoffice-docker/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

DIRS=""/usr/share/bbb-libreoffice /usr/share/bbb-libreoffice-conversion""
for dir in $DIRS; do
  mkdir -p staging$dir
  DIRECTORIES=""$DIRECTORIES --directories $dir""
done

##

if [ $DISTRO != ""amzn2"" ]; then 
  mkdir -p staging/etc/sudoers.d
  cp assets/zzz-bbb-docker-libreoffice  staging/etc/sudoers.d/zzz-bbb-docker-libreoffice
fi

cp assets/etherpad-export.sh staging/usr/share/bbb-libreoffice-conversion/etherpad-export.sh
cp assets/convert-local.sh  staging/usr/share/bbb-libreoffice-conversion/convert-local.sh
cp assets/convert-remote.sh staging/usr/share/bbb-libreoffice-conversion/convert-remote.sh

chmod +x staging/usr/share/bbb-libreoffice-conversion/convert-local.sh
chmod +x staging/usr/share/bbb-libreoffice-conversion/convert-remote.sh
chmod +x staging/usr/share/bbb-libreoffice-conversion/etherpad-export.sh


cp -r docker staging/usr/share/bbb-libreoffice

##

. ./opts-$DISTRO.sh

fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --after-install after-install.sh        \
    --before-remove before-remove.sh        \
    --after-remove after-remove.sh          \
    --description ""BigBlueButton setup for LibreOffice running in docker"" \
    $DIRECTORIES \
    $OPTS"
build/packages-template/bbb-libreoffice-docker/before-remove.sh,"#!/bin/bash -ex

#NETWORK_CHECK=`docker network inspect bbb-libreoffice &> /dev/null && echo 1 || echo 0`
if docker network inspect bbb-libreoffice &> /dev/null; then
	echo ""removing bbb-libreoffice docker network""
	docker network remove bbb-libreoffice
else
	echo ""not removing bbb-libreoffice docker network""
fi"
build/packages-template/bbb-libreoffice-docker/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d iptables,bbb-record-core,fonts-arkpandora,fonts-crosextra-carlito,fonts-crosextra-caladea,fonts-noto,fonts-noto-cjk,fonts-liberation,fonts-arkpandora,apparmor-utils"""
build/packages-template/bbb-libreoffice-docker/after-remove.sh,"#!/bin/bash -e


if [ $1 == 0 ]; then
  rm -rf /etc/sudoers.d/zzz-bbb-docker-libreoffice
fi"
build/packages-template/bbb-graphql-server/after-install.sh,"#!/bin/bash -e

case ""$1"" in
  configure|upgrade|1|2)

  fc-cache -f

  sudo -u postgres psql -c ""ALTER USER postgres PASSWORD 'bigbluebutton'""
  sudo -u postgres psql -c ""create database bigbluebutton""
  sudo -u postgres psql -U postgres -d bigbluebutton -a -f /etc/default/bbb-graphql-server/bbb_schema.sql --set ON_ERROR_STOP=on
  sudo -u postgres psql -c ""create database hasura_app""
  echo ""Postgresql configured""

  # Apply BBB metadata in Hasura
  /usr/local/bin/hasura /etc/default/bbb-graphql-server/metadata apply
  rm -rf /etc/default/bbb-graphql-server/metadata

  systemctl enable bbb-graphql-server.service
  systemctl daemon-reload
  startService bbb-graphql-server || echo ""bbb-graphql-server service could not be registered or started""
  ;;

  abort-upgrade|abort-remove|abort-deconfigure)
  ;;

  *)
    echo ""postinst called with unknown argument \`$1'"" >&2
    exit 1
  ;;
esac"
build/packages-template/bbb-graphql-server/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)
TAG=$(echo $TARGET | cut -d'_' -f4)
BUILD=$1

#
# Clean up directories
rm -rf staging

#
# package

git clone --branch v2.22.1 https://github.com/iMDT/hasura-graphql-engine.git #TODO
cat hasura-graphql-engine/hasura-graphql.part-a* > hasura-graphql
rm -rf hasura-graphql-engine/
chmod +x hasura-graphql

mkdir -p staging/usr/local/bin/hasura-graphql-engine
cp -r hasura-graphql staging/usr/local/bin/hasura-graphql-engine

mkdir -p staging/etc/default/bbb-graphql-server
cp -r ./hasura-config.env bbb_schema.sql metadata staging/etc/default/bbb-graphql-server

mkdir -p staging/lib/systemd/system/bbb-graphql-server.service  
cp ./bbb-graphql-server.service staging/lib/systemd/system/bbb-graphql-server.service

mkdir -p staging/usr/share/bigbluebutton/nginx
cp graphql.nginx staging/usr/share/bigbluebutton/nginx

mkdir -p staging/usr/local/bin/hasura
mkdir -p hasura-cli
cd hasura-cli
npm install --save-dev hasura-cli
ls -l node_modules
cp -r node_modules/hasura-cli/* ../staging/usr/local/bin/hasura
cd ..
rm -rf hasura-cli

. ./opts-$DISTRO.sh

#
# Build package
fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --after-install after-install.sh \
    --after-remove after-remove.sh \
    --before-remove before-remove.sh \
    --description ""GraphQL server component for BigBlueButton"" \
    $DIRECTORIES \
    $OPTS"
build/packages-template/bbb-graphql-server/before-remove.sh,"#!/bin/bash -e

stopService bbb-graphql-server || echo ""bbb-graphql-server could not be unregistered or stopped"""
build/packages-template/bbb-graphql-server/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -d postgresql,postgresql-contrib -t deb""
# OPTS=""$OPTS -d postgresql,postgresql-contrib,gnupg2,curl,apt-transport-https,ca-certificates,libkrb5-3,libpq5,libnuma1,unixodbc-dev,libmariadb-dev-compat,mariadb-client-10.3 -t deb"""
build/packages-template/bbb-graphql-server/after-remove.sh,"#!/bin/bash -e

case ""$1"" in
   remove|failed-upgrade|abort-upgrade|abort-install|disappear|0|1)

   ;;
   purge)
     # remove Hasura
     rm -rf /usr/local/bin/hasura
   ;;
   upgrade)
   ;;
   *)
      echo ""postinst called with unknown argument $1"" >&2
   ;;
esac
"
build/packages-template/bbb-fsesl-akka/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
DISTRO=$(echo $TARGET | cut -d'_' -f3)
BUILD=$1

##

EPHEMERAL_VERSION=0.0.$(date +%s)-SNAPSHOT
sed -i ""s|\(version := \)\"".*|\1\""$EPHEMERAL_VERSION\""|g"" bbb-common-message/build.sbt
find -name build.gradle -exec sed -i ""s|\(.*org.bigbluebutton.*bbb-common-message[^:]*\):.*|\1:$EPHEMERAL_VERSION'|g"" {} \;
find -name build.sbt -exec sed -i ""s|\(.*org.bigbluebutton.*bbb-common-message[^\""]*\""[ ]*%[ ]*\)\""[^\""]*\""\(.*\)|\1\""$EPHEMERAL_VERSION\""\2|g"" {} \;

sed -i ""s|\(version := \)\"".*|\1\""$EPHEMERAL_VERSION\""|g"" bbb-fsesl-client/build.sbt
find -name build.gradle -exec sed -i ""s|\(.*org.bigbluebutton.*bbb-fsesl-client[^:]*\):.*|\1:$EPHEMERAL_VERSION'|g"" {} \;
find -name build.sbt -exec sed -i ""s|\(.*org.bigbluebutton.*bbb-fsesl-client[^\""]*\""[ ]*%[ ]*\)\""[^\""]*\""\(.*\)|\1\""$EPHEMERAL_VERSION\""\2|g"" {} \;

build_common_messages () {
    cd bbb-common-message
    sbt publish
    sbt publishLocal
    cd ..
}

build_fsesl_client () {
    cd bbb-fsesl-client
    sbt publish
    sbt publishLocal
    cd ..
}

build_common_messages
build_fsesl_client


cd akka-bbb-fsesl
sed -i 's/\r$//' project/Dependencies.scala
sed -i 's|\(val bbbCommons = \)""[^""]*""$|\1""EPHEMERAL_VERSION""|g' project/Dependencies.scala
sed -i 's|\(val bbbFsesl = \)""[^""]*""$|\1""EPHEMERAL_VERSION""|g' project/Dependencies.scala
sed -i ""s/EPHEMERAL_VERSION/$EPHEMERAL_VERSION/g"" project/Dependencies.scala

echo ""enablePlugins(SystemdPlugin)"" >> build.sbt
echo ""serverLoading in Debian := Some(com.typesafe.sbt.packager.archetypes.systemloader.ServerLoader.Systemd)"" >> build.sbt
mkdir -p src/templates
echo '#JAVA_OPTS=""-Dconfig.file=/usr/share/bbb-fsesl-akka/conf/application.conf $JAVA_OPTS""' > src/templates/etc-default

sed -i ""s/^version .*/version := \""$VERSION\""/g"" build.sbt
if [[ -n $EPOCH && $EPOCH -gt 0 ]] ; then
    echo 'version in Debian := ""'$EPOCH:$VERSION'""' >> build.sbt
else
    echo 'version in Debian := ""'1:$VERSION-$BUILD'""' >> build.sbt
fi
sbt debian:packageBin
cp ./target/*.deb ..

##"
build/packages-template/bbb-pads/after-install.sh,"#!/bin/bash -e

case ""$1"" in
  configure|upgrade|1|2)
    TARGET=/usr/local/bigbluebutton/bbb-pads/config/settings.json
    cp /usr/local/bigbluebutton/bbb-pads/config/settings.json.template $TARGET

    if [ -f /usr/share/etherpad-lite/APIKEY.txt ]; then
      API_KEY=$(cat /usr/share/etherpad-lite/APIKEY.txt)
      sed -i ""s/ETHERPAD_API_KEY/\""$API_KEY\""/g"" $TARGET

      startService bbb-pads || echo ""bbb-pads could not be registered or started""
    else
      echo ""bbb-pads missing Etherpad's APIKEY.txt file""
      echo ""bbb-pads could not be registered or started""
    fi
  ;;

  abort-upgrade|abort-remove|abort-deconfigure)
  ;;

  *)
    echo ""postinst called with unknown argument \`$1'"" >&2
    exit 1
  ;;
esac"
build/packages-template/bbb-pads/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`

PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)
TAG=$(echo $TARGET | cut -d'_' -f4)

#
# Clean up directories
rm -rf staging

#
# package

mkdir -p staging/usr/local/bigbluebutton/bbb-pads

find -maxdepth 1 ! -path . ! -name staging $(printf ""! -name %s "" $(cat .build-files)) -exec cp -r {} staging/usr/local/bigbluebutton/bbb-pads/ \;

pushd .
cd staging/usr/local/bigbluebutton/bbb-pads/
npm install --production
popd

mkdir -p staging/usr/lib/systemd/system
cp bbb-pads.service staging/usr/lib/systemd/system

##

. ./opts-$DISTRO.sh

#
# Build RPM package
fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --after-install after-install.sh \
    --before-remove before-remove.sh \
    --description ""BigBlueButton Pads"" \
    $DIRECTORIES \
    $OPTS
"
build/packages-template/bbb-pads/before-remove.sh,"#!/bin/bash -e

stopService bbb-pads || echo ""bbb-pads could not be unregistered or stopped"""
build/packages-template/bbb-pads/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d nodejs,npm,bbb-etherpad,bbb-web"""
build/packages-template/bbb-learning-dashboard/after-install.sh,"#!/bin/bash -e

BIGBLUEBUTTON_USER=bigbluebutton

# set ownership of activity directory
chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/bigbluebutton/learning-dashboard/
#
# Restart nginx to take advantage of the updates to nginx configuration
#
reloadService nginx
"
build/packages-template/bbb-learning-dashboard/before-install.sh,"#!/bin/bash -e"
build/packages-template/bbb-learning-dashboard/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`
BUILD=$1

PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#
# Clean up directories
rm -rf staging

#
# Create directory for fpm to process
DIRS=""""
for dir in $DIRS; do
  mkdir -p staging$dir
  DIRECTORIES=""$DIRECTORIES --directories $dir""
done

##

mkdir -p staging/var/bigbluebutton/learning-dashboard

mkdir -p staging/usr/share/bigbluebutton/nginx
cp learning-dashboard.nginx staging/usr/share/bigbluebutton/nginx


# install dependencies, create build, copy build over to destination
npm ci --omit=dev
DISABLE_ESLINT_PLUGIN=true npm run build
cp -r build/* staging/var/bigbluebutton/learning-dashboard

##

. ./opts-$DISTRO.sh

fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --before-install before-install.sh \
    --after-install after-install.sh        \
    --after-remove  after-remove.sh        \
    --depends unzip                        \
    --description ""BigBlueButton bbb-learning-dashboard"" \
    $DIRECTORIES \
    $OPTS
"
build/packages-template/bbb-learning-dashboard/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d nginx"""
build/packages-template/bbb-learning-dashboard/after-remove.sh,"#!/bin/bash -e

if [ ""$1"" = ""remove"" ]; then
	rm -fr /var/bigbluebutton/learning-dashboard
fi"
build/packages-template/bbb-html5-nodejs/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

NODE_VERSION=""14.21.2""
NODE_DIRNAME=""node-v${NODE_VERSION}-linux-x64""

#
# Clean up directories
rm -rf staging

pushd .
mkdir -p staging/usr/lib/bbb-html5/node
cd staging/usr/lib/bbb-html5/node

wget --waitretry=30 --timeout=20 --retry-connrefused --retry-on-host-error --retry-on-http-error=404,522 https://nodejs.org/dist/v${NODE_VERSION}/${NODE_DIRNAME}.tar.gz
if [ -f ${NODE_DIRNAME}.tar.gz ]; then
    tar xfz ${NODE_DIRNAME}.tar.gz
    mv ${NODE_DIRNAME}/* .
    rmdir ${NODE_DIRNAME}
    rm ${NODE_DIRNAME}.tar.gz
fi

popd

##

fpm -s dir -t deb -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --description ""Include a specific NodeJS version for bbb-html5"" \
    $DIRECTORIES \
    $OPTS"
build/packages-template/bbb-record-core/after-install.sh,"#!/bin/bash -e

BBB_USER=bigbluebutton

case ""$1"" in
  configure|upgrade|1|2)
    
    TARGET=/usr/local/bigbluebutton/core/scripts/bigbluebutton.yml

    if [ -f /usr/local/bigbluebutton/core/lib/recordandplayback.rb ]; then
      sed -i ""s/require 'recordandplayback\/webrtc_deskshare_archiver/#require 'recordandplayback\/webrtc_deskshare_archiver/g"" /usr/local/bigbluebutton/core/lib/recordandplayback.rb
    fi

  if [ -f /etc/ImageMagick-6/policy.xml ]; then
    sed -i 's/<policy domain=""coder"" rights=""none"" pattern=""PDF"" \/>/<policy domain=""coder"" rights=""write"" pattern=""PDF"" \/>/g' /etc/ImageMagick-6/policy.xml
  fi

    if [ -f $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties ]; then
      HOST=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | sed -n '/^bigbluebutton.web.serverURL/{s/.*\///;p}')
    else
      HOST=$IP
    fi

    yq e -i "".playback_host = \""$HOST\"""" $TARGET

    chmod +r $TARGET

    # Run recording link fixup/upgrade script
    # Don't abort on failure; users can manually run it later, too
    if id $BBB_USER > /dev/null 2>&1 ; then
      mkdir -p /var/bigbluebutton/recording/status
      chown $BBB_USER:$BBB_USER /var/bigbluebutton/recording/status

      mkdir -p /var/bigbluebutton/events
      chown $BBB_USER:$BBB_USER /var/bigbluebutton/events

      mkdir -p /var/bigbluebutton/recording
      mkdir -p /var/bigbluebutton/recording/raw
      mkdir -p /var/bigbluebutton/recording/process
      mkdir -p /var/bigbluebutton/recording/publish
      mkdir -p /var/bigbluebutton/recording/status/recorded
      mkdir -p /var/bigbluebutton/recording/status/archived
      mkdir -p /var/bigbluebutton/recording/status/processed
      mkdir -p /var/bigbluebutton/recording/status/sanity
      mkdir -p /var/bigbluebutton/recording/status/published
      chown -R $BBB_USER:$BBB_USER /var/bigbluebutton/recording

      mkdir -p /var/bigbluebutton/captions
      chown -R $BBB_USER:$BBB_USER /var/bigbluebutton/captions

      mkdir -p /var/bigbluebutton/published
      chown $BBB_USER:$BBB_USER /var/bigbluebutton/published

      mkdir -p /var/bigbluebutton/deleted
      chown $BBB_USER:$BBB_USER /var/bigbluebutton/deleted

      mkdir -p /var/bigbluebutton/unpublished
      chown $BBB_USER:$BBB_USER /var/bigbluebutton/unpublished

      mkdir -p /var/bigbluebutton/basic_stats
      chown $BBB_USER:$BBB_USER /var/bigbluebutton/basic_stats

      chown -R $BBB_USER:$BBB_USER /var/log/bigbluebutton
      chmod 755 /var/log/bigbluebutton

      if [ -f /var/log/bigbluebutton/bbb-rap-worker.log ]; then
        chown $BBB_USER:$BBB_USER /var/log/bigbluebutton/bbb-rap-worker.log
      fi

      if [ -f /var/log/bigbluebutton/sanity.log ]; then
        chown $BBB_USER:$BBB_USER /var/log/bigbluebutton/sanity.log
      fi
      if [ -f /var/log/bigbluebutton/post_process.log ]; then
        chown $BBB_USER:$BBB_USER /var/log/bigbluebutton/post_process.log
      fi
      if [ -f /var/log/bigbluebutton/bbb-recording-cleanup.log ]; then
        chown $BBB_USER:$BBB_USER /var/log/bigbluebutton/bbb-recording-cleanup.log
      fi
    fi

    if id freeswitch >/dev/null 2>&1; then
      chown -R freeswitch:freeswitch /var/freeswitch/meetings
    else
      echo ""Error: FreeSWITCH not installed""
    fi

    systemctl enable bbb-rap-resque-worker.service
    systemctl enable bbb-rap-starter.service
    systemctl enable bbb-rap-caption-inbox.service
  ;;
  
  *)
    echo ""## postinst called with unknown argument \`$1'"" >&2
  ;;
esac

if dpkg -l | grep -q nginx; then
  reloadService nginx
fi

systemctl daemon-reload"
build/packages-template/bbb-record-core/before-install.sh,"#!/bin/bash -e

addGroup bigbluebutton """"
addUser bigbluebutton """" bigbluebutton /home/bigbluebutton ""bigbluebutton"" ""/bin/false"""
build/packages-template/bbb-record-core/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#
# Clean up directories
rm -rf staging

#
# Create directory for fpm to process
DIRS=""/usr/local/bigbluebutton/core \
      /etc/logrotate.d \
      /var/bigbluebutton/recording/status/ended \
      /var/bigbluebutton/captions/inbox \
      /var/bigbluebutton/recording/status""
for dir in $DIRS; do
  mkdir -p staging$dir
done

##

mkdir -p staging/var/log/bigbluebutton
cp -r scripts lib Gemfile Gemfile.lock  staging/usr/local/bigbluebutton/core

pushd staging/usr/local/bigbluebutton/core
  bundle config set --local deployment true
  bundle install
  # Remove unneeded files to reduce package size
  bundle clean
  rm -r vendor/bundle/ruby/*/cache
  find vendor/bundle -name '*.o' -delete
popd

cp Rakefile  staging/usr/local/bigbluebutton/core
cp bbb-record-core.logrotate staging/etc/logrotate.d

SYSTEMDSYSTEMUNITDIR=$(pkg-config --variable systemdsystemunitdir systemd)
mkdir -p ""staging${SYSTEMDSYSTEMUNITDIR}""
cp systemd/* ""staging${SYSTEMDSYSTEMUNITDIR}""

if [ -f ""staging/usr/local/bigbluebutton/core/scripts/basic_stats.nginx"" ]; then \
  mkdir -p staging/usr/share/bigbluebutton/nginx; \
  mv staging/usr/local/bigbluebutton/core/scripts/basic_stats.nginx staging/usr/share/bigbluebutton/nginx; \
fi

##

. ./opts-$DISTRO.sh

fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --before-install before-install.sh        \
    --after-install after-install.sh    \
    --before-remove before-remove.sh    \
    --description ""BigBlueButton record and playback"" \
    $DIRECTORIES \
    $OPTS"
build/packages-template/bbb-record-core/before-remove.sh,"#!/bin/bash -e

stopService bbb-record-core.timer || echo ""bbb-record-core could not be unregistered or stopped""
"
build/packages-template/bbb-record-core/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d bbb-mkclean,ffmpeg,gir1.2-pango-1.0,libcurl4,libncurses5,libsystemd0,poppler-utils,python3,python3-attr,python3-cairo,python3-gi,python3-gi-cairo,python3-icu,python3-lxml,redis-server,rsync,ruby,ruby-bundler,zlib1g,yq"""
build/packages-template/bbb-freeswitch-core/after-install.sh,"#!/bin/bash -e


case ""$1"" in
  configure|upgrade|1|2)
    if [ -f /tmp/vars.xml ]; then
      cp /tmp/vars.xml /opt/freeswitch/etc/freeswitch/vars.xml
      # Needed for bbb-webrtc-sfu
      sed -i 's/,VP8//g' /opt/freeswitch/etc/freeswitch/vars.xml
      mv -f /tmp/vars.xml /tmp/_vars.xml
    else
      sed -i ""s@<X-PRE-PROCESS cmd=\""set\"" data=\""local_ip_v4=.*\""/>@<X-PRE-PROCESS cmd=\""set\"" data=\""local_ip_v4=$IP\""/>@g""  /opt/freeswitch/etc/freeswitch/vars.xml
    fi

    # Fix issue #14670 (we do it here to fix a previously broken install)
    if grep -q ""data=\""local_ip_v4=\"""" /opt/freeswitch/etc/freeswitch/vars.xml; then
      sed -i ""s@<X-PRE-PROCESS cmd=\""set\"" data=\""local_ip_v4=.*\""/>@<X-PRE-PROCESS cmd=\""set\"" data=\""local_ip_v4=$IP\""/>@g""  /opt/freeswitch/etc/freeswitch/vars.xml
    fi

    sed -n 's/,VP8//g' /opt/freeswitch/etc/freeswitch/vars.xml

    SOURCE=/tmp/external.xml
    TARGET=/opt/freeswitch/etc/freeswitch/sip_profiles/external.xml

    # Determine if there are ws-binding and wss-binding values to propagate
    if [ -f $SOURCE ]; then
      if xmlstarlet sel -t -v '//param[@name=""ws-binding""]/@value' $SOURCE > /dev/null 2>&1; then
        WS_BINDING=$(xmlstarlet sel -t -v '//param[@name=""ws-binding""]/@value' $SOURCE)
        xmlstarlet edit --inplace --update '//param[@name=""ws-binding""]/@value' --value ""$WS_BINDING"" $TARGET
      fi
      if xmlstarlet sel -t -v '//param[@name=""wss-binding""]/@value' $SOURCE > /dev/null 2>&1; then
        WSS_BINDING=$(xmlstarlet sel -t -v '//param[@name=""wss-binding""]/@value' $SOURCE)
        xmlstarlet edit --inplace --update '//param[@name=""wss-binding""]/@value' --value ""$WSS_BINDING"" $TARGET
      fi 
      mv -f $SOURCE ""${SOURCE}_""
    fi 

    if [ -f /tmp/verto.conf.xml ]; then
      cp /tmp/verto.conf.xml /opt/freeswitch/conf/autoload_configs/verto.conf.xml
      mv -f /tmp/verto.conf.xml /tmp/_verto.conf.xml
    fi

    if [ -f /tmp/event_socket.conf.xml ]; then
      ESL_PASSWORD=$(xmlstarlet sel -t -m 'configuration/settings/param[@name=""password""]' -v @value /tmp/event_socket.conf.xml)
      if [ ! -z ""$ESL_PASSWORD"" ]; then
        xmlstarlet edit --inplace --update '//param[@name=""password""]/@value' --value ""$ESL_PASSWORD"" /opt/freeswitch/etc/freeswitch/autoload_configs/event_socket.conf.xml
      fi
      mv -f /tmp/event_socket.conf.xml /tmp/event_socket.conf.xml_
    fi



    chown freeswitch:daemon /var/freeswitch/meetings
    chown -R freeswitch:daemon /opt/freeswitch/var
    chown -R freeswitch:daemon /opt/freeswitch/etc
    chmod -R g-rwx,o-rwx /opt/freeswitch/etc
  ;;

  abort-upgrade|abort-remove|abort-deconfigure)
  ;;

  *)
    echo ""## postinst called with unknown argument \`$1'"" >&2
  ;;
esac

ldconfig
if [ -f /.dockerenv ]; then
  # To make it easier to run within Docker, disable IPV6
  sed -i 's/::/0.0.0.0/g' /opt/freeswitch/etc/freeswitch/autoload_configs/event_socket.conf.xml

  if [ -f /opt/freeswitch/conf/sip_profiles/external-ipv6.xml ]; then
    mv /opt/freeswitch/conf/sip_profiles/external-ipv6.xml /opt/freeswitch/conf/sip_profiles/external-ipv6.xml_
  fi
  if [ -f /opt/freeswitch/conf/sip_profiles/internal-ipv6.xml ]; then
    mv /opt/freeswitch/conf/sip_profiles/internal-ipv6.xml /opt/freeswitch/conf/sip_profiles/internal-ipv6.xml_
  fi
else
  startService freeswitch.service || echo ""freeswitch.service could not be registered or started""
fi
"
build/packages-template/bbb-freeswitch-core/before-install.sh,"#!/bin/bash -e

case ""$1"" in
    install|upgrade|1|2)
        
        addGroup freeswitch """"
        addUser freeswitch """" freeswitch /opt/freeswitch ""freeswitch"" /usr/sbin/nologin

        rm -f /tmp/external.xml
        if [ -f /opt/freeswitch/etc/freeswitch/sip_profiles/external.xml ]; then
                cp /opt/freeswitch/etc/freeswitch/sip_profiles/external.xml /tmp/external.xml
        fi

        rm -f /tmp/vars.xml
        if [ -f /opt/freeswitch/etc/freeswitch/vars.xml ]; then
                cp /opt/freeswitch/etc/freeswitch/vars.xml /tmp/vars.xml
        fi

        rm -f /tmp/event_socket.conf.xml
        if [ -f /opt/freeswitch/etc/freeswitch/autoload_configs/event_socket.conf.xml ]; then
                cp /opt/freeswitch/etc/freeswitch/autoload_configs/event_socket.conf.xml /tmp/event_socket.conf.xml
        fi


	if [ -f /.dockerenv ]; then
           # To make it easier, we'll override how systemd runs freeswitch
	   mkdir -p /etc/systemd/system/freeswitch.service.d
           cat <<HERE > /etc/systemd/system/freeswitch.service.d/override.conf
[Service]
Type=simple
Environment=""DAEMON_OPTS=-nonat -nf""
HERE
	fi

    ;;

    abort-upgrade)
    ;;

    *)
        echo ""## preinst called with unknown argument \`$1'"" >&2
    ;;
esac
"
build/packages-template/bbb-freeswitch-core/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

BUILDDIR=$PWD
DESTDIR=$BUILDDIR/staging
CONFDIR=$DESTDIR/opt/freeswitch/etc/freeswitch

#
# Clear staging directory for build

rm -rf $DESTDIR
mkdir -p $DESTDIR

##

. ./opts-$DISTRO.sh

cp modules.conf $BUILDDIR/freeswitch
cd $BUILDDIR/freeswitch

pushd .

# sofia-sip start
if [ ! -d sofia-sip ]; then
  git clone https://github.com/freeswitch/sofia-sip.git
fi
cd sofia-sip/
git checkout v1.13.12
./bootstrap.sh
./configure

make -j $(nproc)
make install
cd ..
# sofia-sip end

# spandsp start
if [ ! -d spandsp ]; then
  git clone https://github.com/freeswitch/spandsp.git
fi
cd spandsp/
git checkout e59ca8fb8b1591e626e6a12fdc60a2ebe83435ed
./bootstrap.sh
./configure

make -j $(nproc)
make install

popd
# spandsp end



# libks start
if [ ! -d libks ]; then
  git clone https://github.com/signalwire/libks.git
fi
cd libks/
git checkout v1.8.2

cmake .
make

make install
cd ..
# libks end

ldconfig

# we already cloned the FS repo in freeswitch.placeholder.sh and selected tag/branch

cd $BUILDDIR/freeswitch

patch -p0 < $BUILDDIR/floor.patch
patch -p0 --ignore-whitespace < $BUILDDIR/audio.patch       # Provisional patch for https://github.com/signalwire/freeswitch/pull/1531

# Patch: https://github.com/signalwire/freeswitch/pull/1914
#   There are some long-standing issues with the way FreeSWITCH changes
#   candidate pairs based on connectivity checks. That generally manifests
#   as: 1) an asymmetric start time between inbound and outbound audio (eg
#   inbound audio takes 20 seconds to come in while outbound works right out
#   of the bat 2) wrong pairs being picked initially and FS taking longer
#   than ideal to find a new one 3) 1006s 4) ...
#
#   This ports signalwire/freeswitch/pull/1914 in an attempt to mitigate
#   the aforementioned issues. The PR description explains the rationale
#   rather well and seems sound.
patch -p1 < $BUILDDIR/1914.patch

./bootstrap.sh

./configure --disable-core-odbc-support --disable-core-pgsql-support \
    --without-python --without-erlang --without-java \
    --prefix=/opt/freeswitch CFLAGS=""-Wno-error"" CXXFLAGS=""-Wno-error""

# Overrides for generating debug version
#   --prefix=/opt/freeswitch CFLAGS=""-Wno-error -Og -ggdb"" CXXFLAGS=""-Wno-error -Og -ggdb""

make -j $(nproc)
make install

mkdir -p $DESTDIR/opt
cp -r /opt/freeswitch $DESTDIR/opt

cd $BUILDDIR

	mkdir -p $DESTDIR/lib/systemd/system
	cp freeswitch.service.${DISTRO} $DESTDIR/lib/systemd/system/freeswitch.service

	mkdir -p $DESTDIR/lib/systemd/system
	cp freeswitch.conf $DESTDIR/lib/systemd/system

        mkdir -p $DESTDIR/var/freeswitch/meetings
	echo ""This directory holds *.wav files for FreeSWITCH"" > $DESTDIR/var/freeswitch/meetings/readme.txt

	rm -rf $CONFDIR/*
	cp -r bbb-voice-conference/config/freeswitch/conf/* $CONFDIR

	pushd $DESTDIR/opt/freeswitch
	ln -s ./etc/freeswitch conf
	ln -s ./var/log/freeswitch log
	popd

	# Install libraries for sofia-sip and spandsp
        mkdir -p $DESTDIR/etc/ld.so.conf.d
	cat > $DESTDIR/etc/ld.so.conf.d/freeswitch.conf << HERE
/opt/freeswitch/lib
HERE

	files=""sip-date sip-dig sip-options stunc addrinfo localinfo""
	for file in $files; do
	  cp /usr/local/bin/$file $DESTDIR/opt/freeswitch/bin
	done

	cp -P /usr/local/lib/lib* $DESTDIR/opt/freeswitch/lib

  if [ -f /etc/system-release ]; then
    cp /usr/lib64/libopusfile.so.0.4.4 $DESTDIR/opt/freeswitch/lib
    cp /usr/lib64/libopusurl.so.0.4.4 $DESTDIR/opt/freeswitch/lib
    pushd $DESTDIR/opt/freeswitch/lib
      ln -s libopusfile.so.0.4.4 libopusfile.so
      ln -s libopusurl.so.0.4.4 libopusurl.so
    popd
  fi

  mkdir -p $DESTDIR/usr/local/bin
	cp fs_clibbb $DESTDIR/usr/local/bin
	chmod +x $DESTDIR/usr/local/bin/fs_clibbb

	rm -rf $DESTDIR/usr/lib/tmpfiles.d

fpm -s dir -C $DESTDIR -n $PACKAGE \
    --version $VERSION --epoch 2 \
    --before-install before-install.sh      \
    --after-install after-install.sh        \
    --before-remove before-remove.sh        \
    --after-remove after-remove.sh         \
    --description ""BigBlueButton build of FreeSWITCH"" \
    $DIRECTORIES                            \
    $OPTS"
build/packages-template/bbb-freeswitch-core/before-remove.sh,"#!/bin/bash -e

stopService freeswitch || echo ""FreeSWITCH could not be unregistered or stopped""
"
build/packages-template/bbb-freeswitch-core/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d xmlstarlet,libfreetype6,libcurl4,libspeex1,libspeexdsp1,libopus0,libsndfile1,libopusenc0,libopusfile0,liblua5.2-0,libjbig0,libldns3,bbb-freeswitch-sounds"""
build/packages-template/bbb-freeswitch-core/after-remove.sh,"#!/bin/bash -e

# Deleting user: bigbluebutton and group: bigbluebutton
case ""$1"" in
   remove|failed-upgrade|abort-upgrade|abort-install|disappear|0)
   ;;
   purge)
        deleteUser freeswitch
   ;;
   upgrade)
   ;;
   *)
      echo ""postrm called with unknown argument \`\$1'"" >&2
   ;;
esac"
build/packages-template/bbb-webrtc-sfu/after-install.sh,"#!/bin/bash -e

source /etc/lsb-release

case ""$1"" in
  configure|upgrade|1|2)

    TARGET=/usr/local/bigbluebutton/bbb-webrtc-sfu/config/default.yml

    cp /usr/local/bigbluebutton/bbb-webrtc-sfu/config/default.example.yml $TARGET
    chown bigbluebutton:bigbluebutton $TARGET

      # Set mediasoup IPs
      yq e -i "".mediasoup.webrtc.listenIps[0].announcedIp = \""$IP\"""" $TARGET
      yq e -i "".mediasoup.plainRtp.listenIp.announcedIp = \""$IP\"""" $TARGET

      FREESWITCH_IP=$(xmlstarlet sel -t -v '//X-PRE-PROCESS[@cmd=""set"" and starts-with(@data, ""local_ip_v4="")]/@data' /opt/freeswitch/conf/vars.xml | sed 's/local_ip_v4=//g')
      if [ ""$FREESWITCH_IP"" != """" ]; then
        yq e -i "".freeswitch.ip = \""$FREESWITCH_IP\"""" $TARGET
        yq e -i "".freeswitch.sip_ip = \""$FREESWITCH_IP\"""" $TARGET
      else
        # Looks like the FreeSWITCH package is being installed, let's fall back to the default value
        yq e -i "".freeswitch.ip = \""$IP\"""" $TARGET
        yq e -i "".freeswitch.sip_ip = \""$IP\"""" $TARGET
      fi
 
    cd /usr/local/bigbluebutton/bbb-webrtc-sfu
    mkdir -p node_modules

    # there's a problem rebuilding bufferutil
    # do not abort in case npm rebuild return something different than 0
    #npm config set unsafe-perm true
    #npm rebuild || true

    mkdir -p /var/log/bbb-webrtc-sfu/
    touch /var/log/bbb-webrtc-sfu/bbb-webrtc-sfu.log

    yq e -i "".recordWebcams = true"" $TARGET
    if id bigbluebutton > /dev/null 2>&1 ; then
      chown -R bigbluebutton:bigbluebutton /usr/local/bigbluebutton/bbb-webrtc-sfu /var/log/bbb-webrtc-sfu/
    else
      echo ""#""
      echo ""# Warning: Unable to assign ownership of bigbluebutton to kurento files""
      echo ""#""
    fi

    # Creates the mediasoup raw media file dir if needed
    if [ ! -d /var/mediasoup ]; then
      mkdir -p /var/mediasoup
    fi

    chmod 644 $TARGET
    chown bigbluebutton:bigbluebutton $TARGET

    reloadService nginx
    startService bbb-webrtc-sfu        || echo ""bbb-webrtc-sfu could not be registered or started""

  ;;

  abort-upgrade|abort-remove|abort-deconfigure)

  ;;

  *)
    echo ""postinst called with unknown argument \`$1'"" >&2
    exit 1
  ;;
esac
"
build/packages-template/bbb-webrtc-sfu/before-install.sh,"#!/bin/bash -e

case ""$1"" in
	install|upgrade|1|2)
		# there might be remaining files from older BBB versions
		# BBB 2.3 and earlier did an npm rebuild in the after-install script.
		rm -rf /usr/local/bigbluebutton/bbb-webrtc-sfu/node_modules
	;;

	abort-upgrade)
	;;

	*)
		echo ""preinst called with unknown argument \`$1'"" >&2
		exit 1
	;;
esac
"
build/packages-template/bbb-webrtc-sfu/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#
# Clean up directories
rm -rf staging

#
# Create directory for fpm to process
DIRS=""/usr/share/bigbluebutton/nginx /usr/local/bigbluebutton/bbb-webrtc-sfu /etc/logrotate.d /usr/lib/systemd/system /etc/cron.hourly""
for dir in $DIRS; do
  mkdir -p staging$dir
done

##

mkdir -p staging/usr/local/bigbluebutton/bbb-webrtc-sfu

find -maxdepth 1 ! -path . ! -name staging $(printf ""! -name %s "" $(cat .build-files)) -exec cp -r {} staging/usr/local/bigbluebutton/bbb-webrtc-sfu/ \;

pushd .
cd staging/usr/local/bigbluebutton/bbb-webrtc-sfu/

# this is required because it is referenced as a submodule here
rm -rf .git
# npm install expects this to be a git repository
git init

if [ ""$DISTRO"" == ""focal"" ]; then
  # this is a workaround so that the post-install command will find the pegjs binary
  export PATH=$PWD/node_modules/pegjs/bin:$PATH
  npm install --unsafe-perm --production
else
  npm install --unsafe-perm --production
fi

# clean out stuff that is not required in the final package. Most of this are object files from dependant libraries
rm -rf node_modules/mediasoup/worker/out/Release/subprojects
rm -rf node_modules/mediasoup/worker/out/Release/mediasoup-worker.p
rm -rf node_modules/mediasoup/worker/out/Release/deps
popd

cp webrtc-sfu.nginx staging/usr/share/bigbluebutton/nginx

cp bbb-webrtc-sfu.service staging/usr/lib/systemd/system
cp bbb-webrtc-sfu.logrotate staging/etc/logrotate.d
rm -rf staging/usr/local/bigbluebutton/bbb-webrtc-sfu/.git

. ./opts-$DISTRO.sh

fpm -s dir -C ./staging -n $PACKAGE                 \
    --version $VERSION --epoch $EPOCH \
    --after-install after-install.sh                \
    --before-install before-install.sh              \
    --before-remove before-remove.sh                \
    --description ""BigBlueButton WebRTC SFU""        \
    $DIRECTORIES                                    \
    $OPTS"
build/packages-template/bbb-webrtc-sfu/before-remove.sh,"#!/bin/bash -e

stopService bbb-webrtc-sfu || echo ""bbb-webrtc-sfu could not be registered or started"""
build/packages-template/bbb-webrtc-sfu/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d git-core,nginx,bbb-apps-akka,nodejs,npm,build-essential,xmlstarlet,bbb-webrtc-recorder,yq"""
build/packages-template/bbb-playback/after-install.sh,"#!/bin/bash -e

BIGBLUEBUTTON_USER=bigbluebutton

case ""$1"" in
  configure|upgrade|1|2)

    BBB_PLAYBACK_VERSION=2.3
    BBB_PLAYBACK_HOMEPAGE=playback/presentation
    BBB_PLAYBACK_BASE=/var/bigbluebutton/$BBB_PLAYBACK_HOMEPAGE
    BBB_PLAYBACK=$BBB_PLAYBACK_BASE/$BBB_PLAYBACK_VERSION
    chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER $BBB_PLAYBACK

    reloadService nginx

  ;;

  failed-upgrade)
  ;;

  *)
    echo ""## postinst called with unknown argument \`$1'"" >&2
  ;;
esac"
build/packages-template/bbb-playback/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)
TAG=$(echo $TARGET | cut -d'_' -f4)

#
# Clean up directories

rm -rf staging

#
# Package

BBB_PLAYBACK_VERSION=2.3
BBB_PLAYBACK_HOMEPAGE=playback/presentation
BBB_PLAYBACK_BASE=staging/var/bigbluebutton/$BBB_PLAYBACK_HOMEPAGE
BBB_PLAYBACK=$BBB_PLAYBACK_BASE/$BBB_PLAYBACK_VERSION
if ! which sponge ; then
    apt-get -y install moreutils
fi
jq '.styles.url = ""/playback/presentation/2.3""' src/config.json | sponge src/config.json

export REACT_APP_BBB_PLAYBACK_BUILD=$(git rev-parse --short HEAD)

npm install
npm run-script build

mkdir -p $BBB_PLAYBACK_BASE
cp -r ./build $BBB_PLAYBACK

mkdir -p staging/usr/share/bigbluebutton/nginx
cp playback.nginx staging/usr/share/bigbluebutton/nginx

##

. ./opts-$DISTRO.sh

#
# Build RPM package

fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --after-install after-install.sh \
    --description ""BigBlueButton playback"" \
    $DIRECTORIES \
    $OPTS"
build/packages-template/bbb-playback/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d bbb-record-core"""
build/packages-template/bbb-apps-akka/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
DISTRO=$(echo $TARGET | cut -d'_' -f3)
BUILD=$1

##

EPHEMERAL_VERSION=0.0.$(date +%s)-SNAPSHOT
sed -i ""s|\(version := \)\"".*|\1\""$EPHEMERAL_VERSION\""|g"" bbb-common-message/build.sbt
find -name build.gradle -exec sed -i ""s|\(.*org.bigbluebutton.*bbb-common-message[^:]*\):.*|\1:$EPHEMERAL_VERSION'|g"" {} \;
find -name build.sbt -exec sed -i ""s|\(.*org.bigbluebutton.*bbb-common-message[^\""]*\""[ ]*%[ ]*\)\""[^\""]*\""\(.*\)|\1\""$EPHEMERAL_VERSION\""\2|g"" {} \;

export JAVA_TOOL_OPTIONS=-Dfile.encoding=UTF8

cd bbb-common-message
sbt publish
sbt publishLocal
cd ..

cd akka-bbb-apps
sed -i 's/\r$//' project/Dependencies.scala
sed -i 's|\(val bbbCommons = \)""[^""]*""$|\1""EPHEMERAL_VERSION""|g' project/Dependencies.scala
sed -i ""s/EPHEMERAL_VERSION/$EPHEMERAL_VERSION/g"" project/Dependencies.scala

echo ""enablePlugins(SystemdPlugin)"" >> build.sbt
echo ""serverLoading in Debian := Some(com.typesafe.sbt.packager.archetypes.systemloader.ServerLoader.Systemd)"" >> build.sbt
mkdir -p src/templates
echo '#JAVA_OPTS=""-Dconfig.file=/usr/share/bbb-apps-akka/conf/application.conf $JAVA_OPTS""' > src/templates/etc-default

sed -i ""s/^version .*/version := \""$VERSION\""/g"" build.sbt
# set epoch if its greater than 0
if [[ -n $EPOCH && $EPOCH -gt 0 ]] ; then
    echo 'version in Debian := ""'$EPOCH:$VERSION'""' >> build.sbt
else
    echo 'version in Debian := ""'1:$VERSION-$BUILD'""' >> build.sbt
fi
sbt update
sbt debian:packageBin
cp ./target/*.deb ..

##
"
build/packages-template/bbb-webrtc-recorder/after-install.sh,"#!/bin/bash -e

BIGBLUEBUTTON_USER=bigbluebutton

case ""$1"" in
  configure|upgrade|1|2)

    if id $BIGBLUEBUTTON_USER > /dev/null 2>&1 ; then
      chown $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/lib/bbb-webrtc-recorder
      chmod 0700 /var/lib/bbb-webrtc-recorder
    fi

    systemctl enable bbb-webrtc-recorder
  ;;

  *)
    echo ""## postinst called with unknown argument \`$1'"" >&2
  ;;
esac

systemctl daemon-reload"
build/packages-template/bbb-webrtc-recorder/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)
BUILD=$1

# Clean up directories
rm -rf staging
rm -rf ./build

# Create directories for fpm to process
DIRS=""/usr/lib/systemd/system /usr/bin /etc/default/ /etc/bbb-webrtc-recorder /var/lib/bbb-webrtc-recorder""
for dir in $DIRS; do
  mkdir -p staging$dir
done

mkdir -p ./build
cp ./packaging/env ./build/env
git config --global --add safe.directory ${PWD}
APP_VERSION=$(cat ./VERSION)
GOMOD=$(go list -m)
APP_REV=$(git rev-parse --short HEAD)
echo $GOMOD ${APP_VERSION[@]} $COMMIT
go mod tidy
go build -o ./build/bbb-webrtc-recorder \
  -ldflags=""-X '$GOMOD/internal.AppVersion=v${APP_VERSION[0]}-${APP_VERSION[1]} (${APP_REV})'"" \
  ./cmd/bbb-webrtc-recorder

cp ./build/bbb-webrtc-recorder staging/usr/bin
cp ./build/env staging/etc/default/bbb-webrtc-recorder
cp ./config/bbb-webrtc-recorder.yml staging/etc/bbb-webrtc-recorder/bbb-webrtc-recorder.yml
cp bbb-webrtc-recorder.service staging/usr/lib/systemd/system

. ./opts-$DISTRO.sh

fpm -s dir -C ./staging -n $PACKAGE                 \
    --version $VERSION --epoch $EPOCH               \
    --after-install after-install.sh                \
    --before-remove before-remove.sh                \
    --description ""BigBlueButton WebRTC Recorder""   \
    $DIRECTORIES                                    \
    $OPTS"
build/packages-template/bbb-webrtc-recorder/before-remove.sh,"#!/bin/bash -e

stopService bbb-webrtc-recorder || echo ""bbb-webrtc-recorer could not be registered or started""
"
build/packages-template/bbb-webrtc-recorder/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d redis-server"""
build/packages-template/bbb-playback-screenshare/after-install.sh,"#!/bin/bash -e

if [ -f /etc/redhat-release ]; then
  DISTRIB_ID=centos
else
  . /etc/lsb-release    # Get value for DISTRIB_ID
fi


case ""$1"" in
  configure|upgrade|1|2)
    
    mkdir -p /var/bigbluebutton/published/screenshare
    chown -R bigbluebutton:bigbluebutton /var/bigbluebutton/published/screenshare
    chmod -R o+rx /var/bigbluebutton/published/
    
    mkdir -p /var/log/bigbluebutton/screenshare
    chown -R bigbluebutton:bigbluebutton /var/log/bigbluebutton/screenshare
    
    mkdir -p /var/bigbluebutton/recording/publish/screenshare
    chown -R bigbluebutton:bigbluebutton /var/bigbluebutton/recording/publish/screenshare
    
    if [ -f /var/bigbluebutton/published/screenshare/index.html ]; then
      rm /var/bigbluebutton/published/screenshare/index.html
    fi
 
    if [ ! -f /.dockerenv ]; then
      systemctl restart nginx
    fi
    
  ;;
  
  failed-upgrade)
  ;;

  *)
    echo ""## postinst called with unknown argument \`$1'"" >&2
  ;;
esac
"
build/packages-template/bbb-playback-screenshare/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#
# Clear staging directory for build
rm -rf staging

#
# Create build directories for markign by fpm
DIRS=""""
for dir in $DIRS; do
  mkdir -p staging$dir
  DIRECTORIES=""$DIRECTORIES --directories $dir""
done

##

mkdir -p staging/usr/local/bigbluebutton/core
cp -r scripts staging/usr/local/bigbluebutton/core

chmod +x staging/usr/local/bigbluebutton/core/scripts/process/screenshare.rb
chmod +x staging/usr/local/bigbluebutton/core/scripts/publish/screenshare.rb

mkdir -p staging/usr/local/bigbluebutton/core/playback/screenshare
cp -r playback/* staging/usr/local/bigbluebutton/core/playback/screenshare

mkdir -p staging/usr/share/bigbluebutton/nginx
mv staging/usr/local/bigbluebutton/core/scripts/recording-screenshare.nginx staging/usr/share/bigbluebutton/nginx

##

. ./opts-$DISTRO.sh

#
# Build package
fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --post-install before-install.sh \
    --after-install after-install.sh \
    --description ""BigBluebutton playback of screenshare"" \
    $DIRECTORIES \
    $OPTS
"
build/packages-template/bbb-playback-screenshare/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d bbb-record-core"""
build/packages-template/bigbluebutton/build.sh,"#!/bin/bash -ex

if [ -z ""$VERSION"" ]; then
  echo ""[ERROR] no \$VERSION passed in environment, exiting""
  exit 1
fi

if [ -n ""$EPOCH"" ]; then
  VERSION=""$EPOCH:$VERSION""
fi

if [ -n ""$CI_PROJECT_DIR"" ]; then
  cp $CI_PROJECT_DIR/packages_to_skip.txt .
fi

PKGS=""bbb-apps-akka
bbb-config
bbb-etherpad
bbb-export-annotations
bbb-freeswitch-core
bbb-freeswitch-sounds
bbb-fsesl-akka
bbb-html5
bbb-learning-dashboard
bbb-libreoffice-docker
bbb-mkclean
bbb-pads
bbb-playback
bbb-playback-presentation
bbb-record-core
bbb-web
bbb-webrtc-sfu
bbb-webrtc-recorder""

DEPENDENCIES=$(
  for PKG in $PKGS; do
    PKG_VERSION=""$VERSION""
    OLDER_VERSION=""$(grep ""$PKG "" packages_to_skip.txt)""
    if [ -n ""$OLDER_VERSION"" ]; then
      PKG_VERSION=$(echo $OLDER_VERSION | tr '_' ' ' | cut -f3 -d ' ')
    fi
    # add 2: epoch if not already in filename
    if [[ ""$PKG_VERSION"" != ""2:""* ]]; then
      PKG_VERSION=""2:${PKG_VERSION}""
    fi
    echo "" $PKG (= $PKG_VERSION)""
  done | tr '\n' ',' | tail -c +2 | head -c -1
  )

cat <<EOF > control
Section: web
Priority: optional
Homepage: https://bigbluebutton.org/
Standards-Version: 3.9.2

Package: bigbluebutton
Version: $VERSION
Maintainer: ffdixon@bigbluebutton.org
Depends: $DEPENDENCIES
Architecture: amd64
Copyright: license.txt
Description: Virtual Classroom
  BigBlueButton is a virtual classroom for online teaching and learning. It was built for online learning, has a large community of teachers and developers that constantly work to improve it, and is deeply embedded into the world’s major learning management system. Users run BigBlueButton within their browsers with no additional software to install.
EOF

equivs-build control"
build/packages-template/bbb-playback-video/after-install.sh,"#!/bin/bash -e

if [ -f /etc/redhat-release ]; then
  DISTRIB_ID=centos
else
  . /etc/lsb-release    # Get value for DISTRIB_ID
fi

BIGBLUEBUTTON_USER=bigbluebutton

case ""$1"" in
  configure|upgrade|1|2)
    
    TARGET=/usr/local/bigbluebutton/core/scripts/video.yml

    chmod +r $TARGET
    
    mkdir -p /var/bigbluebutton/published/video
    chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/bigbluebutton/published/video
    chmod -R o+rx /var/bigbluebutton/published/
    
    mkdir -p /var/log/bigbluebutton/video
    chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/log/bigbluebutton/video
    
    mkdir -p /var/bigbluebutton/recording/publish/video
    chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/bigbluebutton/recording/publish/video
    
    if [ -f /var/bigbluebutton/published/video/index.html ]; then
      rm /var/bigbluebutton/published/video/index.html
    fi
    
    reloadService nginx
  ;;
  
  failed-upgrade)
  ;;

  *)
    echo ""## postinst called with unknown argument \`$1'"" >&2
  ;;
esac
"
build/packages-template/bbb-playback-video/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#
# Clear staging directory for build
rm -rf staging

#
# Create build directories for markign by fpm
DIRS=""""
for dir in $DIRS; do
  mkdir -p staging$dir
  DIRECTORIES=""$DIRECTORIES --directories $dir""
done

##

mkdir -p staging/usr/local/bigbluebutton/core
cp -r scripts staging/usr/local/bigbluebutton/core
cp -r playback staging/usr/local/bigbluebutton/core

mkdir -p staging/usr/share/bigbluebutton/nginx
mv staging/usr/local/bigbluebutton/core/scripts/playback-video.nginx staging/usr/share/bigbluebutton/nginx

##

. ./opts-$DISTRO.sh

#
# Build package
fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --post-install before-install.sh \
    --after-install after-install.sh \
    --description ""BigBluebutton playback of presentation"" \
    $DIRECTORIES \
    $OPTS"
build/packages-template/bbb-playback-video/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d bbb-record-core -d bbb-presentation-video,yq"""
build/packages-template/bbb-playback-notes/after-install.sh,"#!/bin/bash -e
BIGBLUEBUTTON_USER=bigbluebutton

case ""$1"" in
  configure|upgrade|1|2)

    TARGET=/usr/local/bigbluebutton/core/scripts/notes.yml

    chmod +r $TARGET
 
    mkdir -p /var/bigbluebutton/published/notes
    chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/bigbluebutton/published/notes
    chmod -R o+rx /var/bigbluebutton/published/
    
    mkdir -p /var/log/bigbluebutton/notes
    chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/log/bigbluebutton/notes
    
    mkdir -p /var/bigbluebutton/recording/publish/notes
    chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/bigbluebutton/recording/publish/notes
    
    if [ -f /var/bigbluebutton/published/notes/index.html ]; then
      rm /var/bigbluebutton/published/notes/index.html
    fi
    
    systemctl reload nginx
  ;;
  
  failed-upgrade)
  ;;

  *)
    echo ""## postinst called with unknown argument \`$1'"" >&2
  ;;
esac
"
build/packages-template/bbb-playback-notes/before-install.sh,"#!/bin/bash -e"
build/packages-template/bbb-playback-notes/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#
# Clear staging directory for build
rm -rf staging

#
# Create build directories for markign by fpm
DIRS=""""
for dir in $DIRS; do
  mkdir -p staging$dir
  DIRECTORIES=""$DIRECTORIES --directories $dir""
done

##

mkdir -p staging/usr/local/bigbluebutton/core
cp -r scripts staging/usr/local/bigbluebutton/core

chmod +x staging/usr/local/bigbluebutton/core/scripts/process/notes.rb
chmod +x staging/usr/local/bigbluebutton/core/scripts/publish/notes.rb

mkdir -p staging/usr/share/bigbluebutton/nginx
cp scripts/notes-playback.nginx staging/usr/share/bigbluebutton/nginx

##

. ./opts-$DISTRO.sh

#
# Build package
fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --post-install before-install.sh \
    --after-install after-install.sh \
    --description ""BigBluebutton playback of notes"" \
    $DIRECTORIES \
    $OPTS
"
build/packages-template/bbb-playback-notes/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d bbb-record-core"""
build/packages-template/bbb-freeswitch-sounds/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#VERSION=1.6.7

#
# Clear staging directory for build
rm -rf staging

#
# Create directory for fpm to process
#DIRS=""/opt/freeswitch \
#      /var/freeswitch/meetings""
#for dir in $DIRS; do
#  mkdir -p staging$dir
#  DIRECTORIES=""$DIRECTORIES --directories $dir""
#done

##

##

DESTDIR=staging
CONFDIR=$DESTDIR/opt/freeswitch/etc/freeswitch

mkdir -p $DESTDIR/opt/freeswitch/share/freeswitch

if [ ! -f sounds.tar.gz ] ; then
  wget http://bigbluebutton.org/downloads/sounds.tar.gz -O sounds.tar.gz
fi
tar xvfz sounds.tar.gz -C $DESTDIR/opt/freeswitch/share/freeswitch

#
# Overwrite ""your are now muted""/""you are now unmuted"" with short audio sounds.  Thanks senfcall.de!
#
rm -f mute-and-unmute-sounds-master.zip
wget https://gitlab.senfcall.de/senfcall-public/mute-and-unmute-sounds/-/archive/master/mute-and-unmute-sounds-master.zip
rm -rf mute-and-unmute-sounds-master
unzip mute-and-unmute-sounds-master.zip

pushd mute-and-unmute-sounds-master/sounds
 find . -name ""*.wav"" -exec /bin/bash -c ""sox -v 0.3  {} /tmp/tmp.wav; cp /tmp/tmp.wav ../../$DESTDIR/opt/freeswitch/share/freeswitch/sounds/en/us/callie/conference/{}"" \;
popd

. ./opts-$DISTRO.sh

fpm -s dir -C $DESTDIR -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --description ""FreeSWITCH Sounds"" \
    $DIRECTORIES                            \
    $OPTS
"
build/packages-template/bbb-freeswitch-sounds/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb""
"
build/packages-template/bbb-webhooks/after-install.sh,"#!/bin/bash -e

case ""$1"" in
  configure|upgrade|1|2)

    TARGET=/usr/local/bigbluebutton/bbb-webhooks/config/default.yml

    cp /usr/local/bigbluebutton/bbb-webhooks/config/default.example.yml $TARGET
    chmod 644 $TARGET
    chown bigbluebutton:bigbluebutton $TARGET

    BBB_SECRET=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | grep securitySalt | cut -d= -f2)
    BBB_HOST=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | sed -n '/^bigbluebutton.web.serverURL/{s/.*\///;p}')

    yq e -i  "".bbb.sharedSecret  = \""$BBB_SECRET\"""" $TARGET
    yq e -i  "".bbb.serverDomain = \""$BBB_HOST\"""" $TARGET
    yq e -i  '.bbb.auth2_0 = true' $TARGET
    yq e -i  '.server.port = 3005' $TARGET
    yq e -i  '.hooks.getRaw = false' $TARGET

    cd /usr/local/bigbluebutton/bbb-webhooks
    mkdir -p node_modules

    npm config set unsafe-perm true
    npm rebuild || true

    mkdir -p /var/log/bbb-webhooks/
    touch /var/log/bbb-webhooks/bbb-webhooks.log
    chown -R bigbluebutton:bigbluebutton /usr/local/bigbluebutton/bbb-webhooks /var/log/bbb-webhooks/

    reloadService nginx
    startService bbb-webhooks || echo ""bbb-webhooks could not be registered or started""

  ;;

  abort-upgrade|abort-remove|abort-deconfigure)

  ;;

  *)
    echo ""postinst called with unknown argument \`$1'"" >&2
    exit 1
  ;;
esac
"
build/packages-template/bbb-webhooks/before-install.sh,"#!/bin/bash -e

case ""$1"" in
	install|upgrade|1|2)
	;;

	abort-upgrade)
	;;

	*)
		echo ""preinst called with unknown argument \`$1'"" >&2
		exit 1
	;;
esac
"
build/packages-template/bbb-webhooks/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#
# Clean up directories
rm -rf staging

#
# Create directory for fpm to process
DIRS=""/usr/share/bigbluebutton/nginx /usr/local/bigbluebutton/bbb-webhooks""
for dir in $DIRS; do
  mkdir -p staging$dir
done

##

mkdir -p staging/usr/local/bigbluebutton/bbb-webhooks

find -maxdepth 1 ! -path . ! -name staging $(printf ""! -name %s "" $(cat .build-files)) -exec cp -r {} staging/usr/local/bigbluebutton/bbb-webhooks/ \;

pushd .
cd staging/usr/local/bigbluebutton/bbb-webhooks/
npm install --production
popd

cp webhooks.nginx staging/usr/share/bigbluebutton/nginx/webhooks.nginx

mkdir -p staging/usr/lib/systemd/system
cp bbb-webhooks.service staging/usr/lib/systemd/system

##

. ./opts-$DISTRO.sh

fpm -s dir -C ./staging -n $PACKAGE                 \
    --version $VERSION --epoch $EPOCH \
    --after-install after-install.sh                \
    --before-install before-install.sh              \
    --before-remove before-remove.sh                \
    --description ""BigBlueButton Webhooks""          \
    $DIRECTORIES                                    \
    $OPTS"
build/packages-template/bbb-webhooks/before-remove.sh,"#!/bin/bash -e

stopService bbb-webhooks || echo ""bbb-webhooks could not be registered or started""
"
build/packages-template/bbb-webhooks/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d nodejs,npm,yq"""
build/packages-template/bbb-playback-presentation/after-install.sh,"#!/bin/bash -e

if [ -f /etc/redhat-release ]; then
  DISTRIB_ID=centos
else
  . /etc/lsb-release    # Get value for DISTRIB_ID
fi

BIGBLUEBUTTON_USER=bigbluebutton

case ""$1"" in
  configure|upgrade|1|2)
    
    TARGET=/usr/local/bigbluebutton/core/scripts/presentation.yml

    chmod +r $TARGET
    
    mkdir -p /var/bigbluebutton/published/presentation
    chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/bigbluebutton/published/presentation
    chmod -R o+rx /var/bigbluebutton/published/
    
    mkdir -p /var/log/bigbluebutton/presentation
    chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/log/bigbluebutton/presentation
    
    mkdir -p /var/bigbluebutton/recording/publish/presentation
    chown -R $BIGBLUEBUTTON_USER:$BIGBLUEBUTTON_USER /var/bigbluebutton/recording/publish/presentation
    
    if [ -f /var/bigbluebutton/published/presentation/index.html ]; then
      rm /var/bigbluebutton/published/presentation/index.html
    fi
    
  ;;
  
  failed-upgrade)
  ;;

  *)
    echo ""## postinst called with unknown argument \`$1'"" >&2
  ;;
esac
"
build/packages-template/bbb-playback-presentation/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#
# Clear staging directory for build
rm -rf staging

#
# Create build directories for markign by fpm
DIRS=""""
for dir in $DIRS; do
  mkdir -p staging$dir
  DIRECTORIES=""$DIRECTORIES --directories $dir""
done

##

mkdir -p staging/usr/local/bigbluebutton/core
cp -r scripts staging/usr/local/bigbluebutton/core

mkdir -p staging/var/bigbluebutton
cp -r playback staging/var/bigbluebutton

mkdir -p staging/usr/share/bigbluebutton/nginx
mv staging/usr/local/bigbluebutton/core/scripts/presentation.nginx staging/usr/share/bigbluebutton/nginx

##

. ./opts-$DISTRO.sh

#
# Build package
fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --post-install before-install.sh \
    --after-install after-install.sh \
    --description ""BigBluebutton playback of presentation"" \
    $DIRECTORIES \
    $OPTS"
build/packages-template/bbb-playback-presentation/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d bbb-record-core,yq"""
build/packages-template/bbb-mkclean/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#VERSION=0.8.7

#
# Clean up directories
rm -rf staging

if [ ! -f mkclean-0.8.10.tar.bz2 ]; then
    wget https://netcologne.dl.sourceforge.net/project/matroska/mkclean/mkclean-0.8.10.tar.bz2 -O mkclean-0.8.10.tar.bz2
fi
if ! sha256sum -c mkclean.sha256sum ; then
    exit 1
fi

if [ ! -d mkclean-0.8.10 ]; then
  tar -vxjf mkclean-0.8.10.tar.bz2
fi

cd mkclean-0.8.10

make -C corec/tools/coremake
corec/tools/coremake/coremake $(corec/tools/coremake/system_output.sh)

make
cd ..

mkdir -p staging/usr/bin
cp mkclean-0.8.10/release/gcc_linux_x64/mkclean staging/usr/bin

##

. ./opts-$DISTRO.sh


fpm -s dir -t deb -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --description ""Clean and optimize Matroska and WebM files"" \
    $DIRECTORIES \
    $OPTS
"
build/packages-template/bbb-mkclean/opts-jammy.sh,""
build/packages-template/bbb-export-annotations/after-install.sh,"#!/bin/bash -e

case ""$1"" in
  configure|upgrade|1|2)

  fc-cache -f
  if [ ! -f /.dockerenv ]; then
    systemctl enable bbb-export-annotations.service
    systemctl daemon-reload
    startService bbb-export-annotations.service || echo ""bbb-export-annotations service could not be registered or started""
  fi
  ;;

  abort-upgrade|abort-remove|abort-deconfigure)
  ;;

  *)
    echo ""postinst called with unknown argument \`$1'"" >&2
    exit 1
  ;;
esac"
build/packages-template/bbb-export-annotations/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`

PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)
TAG=$(echo $TARGET | cut -d'_' -f4)

#
# Clean up directories
rm -rf staging

#
# package

mkdir -p staging/usr/local/bigbluebutton/bbb-export-annotations
mkdir -p staging/usr/local/share/fonts/

find -maxdepth 1 ! -path . ! -name staging $(printf ""! -name %s "" $(cat .build-files)) -exec cp -r {} staging/usr/local/bigbluebutton/bbb-export-annotations/ \;

pushd .
cd staging/usr/local/bigbluebutton/bbb-export-annotations/
npm install --production
popd

mkdir -p staging/usr/lib/systemd/system
cp bbb-export-annotations.service staging/usr/lib/systemd/system

#
# Install fonts
cp fonts/* staging/usr/local/share/fonts/

##

. ./opts-$DISTRO.sh

#
# Build package
fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --after-install after-install.sh \
    --before-remove before-remove.sh \
    --description ""BigBlueButton Export Annotations"" \
    $DIRECTORIES \
    $OPTS
"
build/packages-template/bbb-export-annotations/before-remove.sh,"#!/bin/bash -e

stopService bbb-export-annotations || echo ""bbb-export-annotations could not be unregistered or stopped"""
build/packages-template/bbb-export-annotations/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d nodejs,npm,bbb-apps-akka,bbb-web,cairosvg,ghostscript,imagemagick"""
build/packages-template/bbb-lti/after-install.sh,"#!/bin/bash -e

escape_quotes() {
    cat <<EOF | sed -e ""s/'/\\\\'/g""
$1
EOF
}

change_var_value () {
  sed -i ""s<^\(${2}\).*<\1=${3}<"" $1;
}


bbb_new_properties() {
  #
  # Setup lti-config.properties for bbb-lti
  #
  HOST=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | sed -n '/^bigbluebutton.web.serverURL/{s/.*\///;p}')

  sed -i ""s/^bigbluebuttonURL=.*/bigbluebuttonURL=$PROTOCOL:\/\/$HOST\/bigbluebutton/g"" \
    /usr/share/bbb-lti/WEB-INF/classes/lti-config.properties

  sed -i ""s/^ltiEndPoint=.*/ltiEndPoint=$HOST/g"" \
    /usr/share/bbb-lti/WEB-INF/classes/lti-config.properties

  BBB_SECRET=$(cat $SERVLET_DIR/WEB-INF/classes/bigbluebutton.properties | grep securitySalt | cut -d= -f2);
  change_var_value /usr/share/bbb-lti/WEB-INF/classes/lti-config.properties bigbluebuttonSalt $BBB_SECRET

  HASH=""$RANDOM$(date +%s)$$$RANDOM""
  LTI_SECRET=$(echo $HASH | md5sum | md5sum | sed 's/  -//')

  sed -i ""s/^ltiConsumers=bbb:.*/ltiConsumers=bbb:$LTI_SECRET/g"" \
        /usr/share/bbb-lti/WEB-INF/classes/lti-config.properties
}


lti_config() {
  #
  # We need for Tomcat to deploy the web app
  #

  #
  # At this point. /var/tmp/lti.war holds the newer version of bbb-lti
  # but it's not deployed yet
  #

  bbb_new_properties

  if [[ ! -L /usr/share/bbb-lti/logs && -d /usr/share/bbb-lti/logs ]]; then  # remove old directory (if exists)
    rm -rf /usr/share/bbb-lti/logs
  fi

  if [ ! -L /usr/share/bbb-lti/logs ]; then  # create symbolic link
    ln -s /var/log/bigbluebutton /usr/share/bbb-lti/logs
  fi

  touch /var/log/bigbluebutton/bbb-lti.log
  chown bigbluebutton:bigbluebutton /var/log/bigbluebutton/bbb-lti.log

  startService bbb-lti.service || echo ""bbb-lti.service could not be registered or started""
}

case ""$1"" in
  configure|upgrade|0|1)

    lti_config
    ;;

    abort-upgrade|abort-remove|abort-deconfigure)
    ;;

  *)
    echo ""postinst called with unknown argument \`$1'"" >&2
    exit 1
    ;;
esac
"
build/packages-template/bbb-lti/before-install.sh,"#!/bin/bash -e

case ""$1"" in
    install|upgrade|1|2)

    ;;

    abort-upgrade)
    ;;

    *)
        echo ""## preinst called with unknown argument \`$1'"" >&2
    ;;
esac
"
build/packages-template/bbb-lti/build.sh,"#!/bin/bash -ex

TARGET=`basename $(pwd)`


PACKAGE=$(echo $TARGET | cut -d'_' -f1)
VERSION=$(echo $TARGET | cut -d'_' -f2)
DISTRO=$(echo $TARGET | cut -d'_' -f3)

#
# Clean up directories
rm -rf staging

#
# Create directory for fpm to process
DIRS=""/usr/share/bbb-lti""
for dir in $DIRS; do
  mkdir -p staging$dir
  DIRECTORIES=""$DIRECTORIES --directories $dir""
done

##

# After extracting out bbb-lti into its own repository there is an additional directory level
if [ -d bbb-lti ]; then
  cd bbb-lti/
fi

gradle clean
gradle resolveDeps
grails assemble

cd ..

mkdir -p staging/usr/lib/systemd/system
cp bbb-lti.service staging/usr/lib/systemd/system

mkdir -p staging/usr/share/bigbluebutton/nginx
cp bbb-lti/lti.nginx  staging/usr/share/bigbluebutton/nginx

mkdir -p staging/usr/share/bbb-lti
cp bbb-lti/build/libs/bbb-lti-0.5.war staging/usr/share/bbb-lti

cd staging/usr/share/bbb-lti
jar -xvf bbb-lti-0.5.war
rm bbb-lti-0.5.war
cd ../../../..

cp run-prod.sh staging/usr/share/bbb-lti
chmod +x staging/usr/share/bbb-lti/run-prod.sh

##

. ./opts-$DISTRO.sh

fpm -s dir -C ./staging -n $PACKAGE \
    --version $VERSION --epoch $EPOCH \
    --after-install after-install.sh        \
    --depends unzip                        \
    --description ""BigBlueButton endpoint for LTI"" \
    $DIRECTORIES \
    $OPTS
"
build/packages-template/bbb-lti/opts-jammy.sh,". ./opts-global.sh

OPTS=""$OPTS -t deb -d bbb-web"""
build/packages-template/bbb-lti/run-prod.sh,"#!/bin/bash
java -Dgrails.env=prod -Dserver.port=8181 -Xms384m -Xmx384m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/bigbluebutton/diagnostics -cp WEB-INF/lib/*:/:WEB-INF/classes/:. org.springframework.boot.loader.WarLauncher
"
build/get_external_dependencies.sh,"#!/bin/bash -xe

cd ""$(dirname ""$0"")/..""

# get the list of stuff that needs to be downloaded from
# .gitlab-ci.yml, so we don't need to maintain it in two places.
DEPENDENCIES=$(python3 -c 'import yaml; print("" "".join(yaml.load(open("".gitlab-ci.yml""), Loader=yaml.SafeLoader)[""get_external_dependencies""][""artifacts""][""paths""]))')

for DEPENDENCY in $DEPENDENCIES; do
    DOWNLOAD_COMMAND_FILE=""${DEPENDENCY}.placeholder.sh""
    echo ""getting component ${DOWNLOAD_COMMAND_FILE}...""
    bash -xe ""$DOWNLOAD_COMMAND_FILE"" &
done

wait

set +x

echo ""downloaded external dependencies:""
for DEPENDENCY in $DEPENDENCIES; do
    du --summarize -h ""$DEPENDENCY""
done"
build/setup-inside-docker.sh,"#!/bin/bash -ex

if [ ""$LOCAL_BUILD"" != 1 ] ; then
    echo ""we are building in CI, check whether this package is marked as skippable""
    EXISTING_VERSION=""$(grep ""$1 "" packages_to_skip.txt || (( $? == 1 )))""
    if [ -n ""$EXISTING_VERSION"" ]; then
        echo ""Package $1 can be reused from a previous build""
        echo ""$EXISTING_VERSION""
        exit 0
    fi
else
    echo ""we are building locally, don't check packages_to_skip.txt (LOCAL_BUILD=1)""
fi

BUILD_DIR=""$PWD""

cd ""$(dirname ""$0"")""
source package-names.inc.sh

# source is in the parent directory of the 'build' dir
SOURCE=$(dirname $PWD)

# use persistent cache dirs
for dir in .gradle .grails .ivy2 .m2; do
    mkdir -p ""${SOURCE}/cache/${dir}""
    ln -s ""${SOURCE}/cache/${dir}"" ""/root/${dir}""
done

VERSION_NUMBER=""$(cat ""$SOURCE/bigbluebutton-config/bigbluebutton-release"" | cut -d '=' -f2 | cut -d ""-"" -f1)""
# this contains stuff like alpha4 etc
VERSION_ADDON=""$(cat ""$SOURCE/bigbluebutton-config/bigbluebutton-release"" | cut -d '=' -f2 | cut -d ""-"" -f2)""
BUILD_NUMBER=${BUILD_NUMBER:=1}
EPOCH=${EPOCH:=2}

if [[ $BUILD_TYPE == 'release' ]]; then
    # release build package version will be something like
    # 2:2.3.0-1 for epoch 2, BBB Version 2.3.0 and build number 1
    VERSION=""${VERSION_NUMBER}""
else
    # devel builds
    # 2:2.3.0~alpha4+20210729T022518-git.abcdef
    VERSION=""${VERSION_NUMBER}~${VERSION_ADDON}+${COMMIT_DATE}-git.${GIT_REV}""
fi

DISTRO=jammy
CACHE_DIR=""/root/""
mkdir -p ""$CACHE_DIR""

build_package() {
    PACKAGE=""$1""
    PACKAGE_SOURCEDIR=${DEBNAME_TO_SOURCEDIR[$PACKAGE]:=$PACKAGE}

    TARGET=""${PACKAGE}_${VERSION}_${DISTRO}""

    TMP=/tmp/build
    rm -rf ""$TMP/$TARGET""
    mkdir -p ""$TMP/$TARGET""
    
    # copy the stuff in packages-template over
    cp -a ""./packages-template/${PACKAGE}/."" ""$TMP/$TARGET/"";

    # some packages do not need source files from the repo (e.g. the bigbluebutton meta-package)
    if [[ ""$PACKAGE_SOURCEDIR"" != ""do_not_copy_anything"" ]] ; then
        # some packages have multiple source dirs, in this case, copy all of them
        # to the build directory
        if [[ ""$PACKAGE_SOURCEDIR"" = *' '* ]]; then
            for ITEM in $PACKAGE_SOURCEDIR; do
                cp -a ""${SOURCE}/${ITEM}"" ""${TMP}/${TARGET}/""
            done
        else
            # for packages with only one source directory, copy that directory's contents
            # directly into the build dir
            cp -a ""${SOURCE}/${PACKAGE_SOURCEDIR}/."" ""${TMP}/${TARGET}/""
        fi
    fi

    # global fpm options for all packages
    cp opts-global.sh ""$TMP/$TARGET""

    # prepend deb-helper.sh to all pre/post-install/remove scripts
    for file in before-install.sh after-install.sh after-remove.sh before-remove.sh; do
        if [ -f ""./packages-template/$PACKAGE/$file"" ] ; then
            cat deb-helper.sh ""./packages-template/$PACKAGE/$file"" > ""$TMP/$TARGET/$file""
        fi
    done

    echo ""list all files in build directory: -------------------------""
    ls -al ""$TMP/$TARGET""

    pushd ""$TMP/$TARGET""
    echo ""starting build.sh: -----------------------------------------""
    VERSION=""$VERSION"" EPOCH=""$EPOCH"" ./build.sh $BUILD_NUMBER
    popd
}

mkdir -p ""${BUILD_DIR}/artifacts""
build_package ""$1""
cp ""$TMP""/""$TARGET""/*.deb ""${BUILD_DIR}/artifacts/"""
build/package-names.inc.sh,"declare -A DEBNAME_TO_SOURCEDIR

DEBNAME_TO_SOURCEDIR[bbb-apps-akka]=""akka-bbb-apps bbb-common-message""
DEBNAME_TO_SOURCEDIR[bbb-config]=""bigbluebutton-config""
DEBNAME_TO_SOURCEDIR[bbb-etherpad]=""bbb-etherpad""
DEBNAME_TO_SOURCEDIR[bbb-export-annotations]=""bbb-export-annotations""
DEBNAME_TO_SOURCEDIR[bbb-freeswitch-core]=""freeswitch bbb-voice-conference""
DEBNAME_TO_SOURCEDIR[bbb-freeswitch-sounds]=""do_not_copy_anything""
DEBNAME_TO_SOURCEDIR[bbb-fsesl-akka]=""akka-bbb-fsesl bbb-common-message bbb-fsesl-client""
DEBNAME_TO_SOURCEDIR[bbb-graphql-server]=""bbb-graphql-server""
DEBNAME_TO_SOURCEDIR[bbb-html5]=""bigbluebutton-html5""
DEBNAME_TO_SOURCEDIR[bbb-html5-nodejs]=""do_not_copy_anything""
DEBNAME_TO_SOURCEDIR[bbb-learning-dashboard]=""bbb-learning-dashboard""
DEBNAME_TO_SOURCEDIR[bbb-libreoffice-docker]=""bbb-libreoffice""
DEBNAME_TO_SOURCEDIR[bbb-lti]=""bbb-lti""
DEBNAME_TO_SOURCEDIR[bbb-mkclean]=""do_not_copy_anything""
DEBNAME_TO_SOURCEDIR[bbb-pads]=""bbb-pads""
DEBNAME_TO_SOURCEDIR[bbb-playback]=""bbb-playback""
DEBNAME_TO_SOURCEDIR[bbb-playback-notes]=""record-and-playback/notes""
DEBNAME_TO_SOURCEDIR[bbb-playback-podcast]=""record-and-playback/podcast""
DEBNAME_TO_SOURCEDIR[bbb-playback-presentation]=""record-and-playback/presentation""
DEBNAME_TO_SOURCEDIR[bbb-playback-screenshare]=""record-and-playback/screenshare""
DEBNAME_TO_SOURCEDIR[bbb-playback-video]=""record-and-playback/video""
DEBNAME_TO_SOURCEDIR[bbb-record-core]=""record-and-playback/core""
DEBNAME_TO_SOURCEDIR[bbb-web]=""bigbluebutton-web bbb-common-web bbb-common-message""
DEBNAME_TO_SOURCEDIR[bbb-webhooks]=""bbb-webhooks""
DEBNAME_TO_SOURCEDIR[bbb-webrtc-sfu]=""bbb-webrtc-sfu""
DEBNAME_TO_SOURCEDIR[bbb-webrtc-recorder]=""bbb-webrtc-recorder""
DEBNAME_TO_SOURCEDIR[bigbluebutton]=""do_not_copy_anything""

export DEBNAME_TO_SOURCEDIR"
build/setup.sh,"#!/bin/bash -ex

PACKAGE_TO_BUILD=""$1""
if [ -z ""$PACKAGE_TO_BUILD"" ]; then
    set +x
    echo ""please provide a package name as first parameter, e.g.""
    echo ""build/setup.sh bbb-freeswitch-core""
    exit 1
fi

cd ""$(dirname ""$0"")""
cd ..

mkdir -p artifacts

DOCKER_IMAGE=$(python3 -c 'import yaml; print(yaml.load(open(""./.gitlab-ci.yml""), Loader=yaml.SafeLoader)[""default""][""image""])')

LOCAL_BUILD=1
if [ ""$LOCAL_BUILD"" != 1 ] ; then
    GIT_REV=""${CI_COMMIT_SHA:0:10}""
else
    GIT_REV=$(git rev-parse HEAD)
    GIT_REV=""local-build-${GIT_REV:0:10}""
fi
COMMIT_DATE=""$(git log -n1 --pretty='format:%cd' --date=format:'%Y%m%dT%H%M%S')""

# Arrange to write the docker container ID to a temp file, then run
# the container detached and immediately attach it (without stdin) so
# we can catch CTRL-C in this script and kill the container if so.

DOCKER_CONTAINER_ID_FILE=$(mktemp)
rm $DOCKER_CONTAINER_ID_FILE

kill_docker() {
   if [[ -r $DOCKER_CONTAINER_ID_FILE ]]; then
      sudo docker kill $(cat $DOCKER_CONTAINER_ID_FILE)
      sudo rm $DOCKER_CONTAINER_ID_FILE
   fi
   tput cnorm
   exit 1
}

trap 'kill_docker' SIGINT SIGTERM

# -v ""$CACHE_DIR/dev"":/root/dev
sudo docker run --rm --detach --cidfile $DOCKER_CONTAINER_ID_FILE \
        --env GIT_REV=$GIT_REV --env COMMIT_DATE=$COMMIT_DATE --env LOCAL_BUILD=$LOCAL_BUILD \
        --mount type=bind,src=""$PWD"",dst=/mnt \
        --mount type=bind,src=""${PWD}/artifacts,dst=/artifacts"" \
        -t ""$DOCKER_IMAGE"" /mnt/build/setup-inside-docker.sh ""$PACKAGE_TO_BUILD""
        
#        -v ""$CACHE_DIR/$DISTRO/.gradle:/root/.gradle"" \
#        -v ""$CACHE_DIR/$DISTRO/.grails:/root/.grails"" \
#        -v ""$CACHE_DIR/$DISTRO/.ivy2:/root/.ivy2"" \
#        -v ""$CACHE_DIR/$DISTRO/.m2:/root/.m2"" \
#        -v ""$TMP/$TARGET:$TMP/$TARGET""  \

docker attach --no-stdin $(cat $DOCKER_CONTAINER_ID_FILE)
sudo rm $DOCKER_CONTAINER_ID_FILE

find artifacts"
bbb-pads.placeholder.sh,"git clone --branch v1.4.1 --depth 1 https://github.com/bigbluebutton/bbb-pads bbb-pads"
