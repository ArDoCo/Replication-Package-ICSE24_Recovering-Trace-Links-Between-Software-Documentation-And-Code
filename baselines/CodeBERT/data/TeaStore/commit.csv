commit_id,summary,diff,files,commit_time
tools/build_docker.sh,"#!/bin/bash
push_flag='false'
registry=''     # e.g. 'descartesresearch/'

print_usage() {
  printf ""Usage: docker_build.sh [-p] [-r REGISTRY_NAME]\n""
}

while getopts 'pr:' flag; do
  case ""${flag}"" in
    p) push_flag='true' ;;
    r) registry=""${OPTARG}"" ;;
    *) print_usage
       exit 1 ;;
  esac
done

docker build -t ""${registry}teastore-db"" ../utilities/tools.descartes.teastore.database/
docker build -t ""${registry}teastore-kieker-rabbitmq"" ../utilities/tools.descartes.teastore.kieker.rabbitmq/
docker build -t ""${registry}teastore-base"" ../utilities/tools.descartes.teastore.dockerbase/
perl -i -pe's|.*FROM descartesresearch/|FROM '""${registry}""'|g' ../services/tools.descartes.teastore.*/Dockerfile
docker build -t ""${registry}teastore-registry"" ../services/tools.descartes.teastore.registry/
docker build -t ""${registry}teastore-persistence"" ../services/tools.descartes.teastore.persistence/
docker build -t ""${registry}teastore-image"" ../services/tools.descartes.teastore.image/
docker build -t ""${registry}teastore-webui"" ../services/tools.descartes.teastore.webui/
docker build -t ""${registry}teastore-auth"" ../services/tools.descartes.teastore.auth/
docker build -t ""${registry}teastore-recommender"" ../services/tools.descartes.teastore.recommender/
perl -i -pe's|.*FROM '""${registry}""'|FROM descartesresearch/|g' ../services/tools.descartes.teastore.*/Dockerfile

if [ ""$push_flag"" = 'true' ]; then
  docker push ""${registry}teastore-db""
  docker push ""${registry}teastore-kieker-rabbitmq""
  docker push ""${registry}teastore-base""
  docker push ""${registry}teastore-registry""
  docker push ""${registry}teastore-persistence""
  docker push ""${registry}teastore-image""
  docker push ""${registry}teastore-webui""
  docker push ""${registry}teastore-auth""
  docker push ""${registry}teastore-recommender""
fi"
tools/test_webui.sh,"#!/bin/bash

# Tests the TeaStore WebUI for working endpoints

HOST=${1}           # usually localhost
PROTO=${2}          # supports 'http' and 'https'
WEBUI_PORT=${3}     # 8080 for http, 8443 for https

# Checks HTML GET response for failure/error for given HTTP URL endpoint
function send_request () {
  URL=""${PROTO}://${HOST}:${WEBUI_PORT}/tools.descartes.teastore.webui/${1}""
  RES=""$(curl -ks ""${URL}"")""
  if echo ""${RES}"" | grep -E -i 'error|fail|exception'
  then
    echo ""Request for URL '${URL}' failed.""
    echo ""[START HTML]${RES}[END HTML]""
    exit 1
  fi
}

# Check if login works
function check_login () {
  URL_VALID=""${PROTO}://${HOST}:${WEBUI_PORT}/tools.descartes.teastore.webui/loginAction?username=user2&password=password""
  if (( $(curl -kLs -X POST ""${URL_VALID}"" | grep -c '<title>TeaStore Home</title>') != 1 ));
  then
    echo ""Login Check Error: Valid login should forward to TeaStore home!""
    exit 1
  fi
  URL_INVALID=""${PROTO}://${HOST}:${WEBUI_PORT}/tools.descartes.teastore.webui/loginAction?username=testuser&password=password""
  if (( $(curl -kLs -X POST ""${URL_INVALID}"" | grep -c '<title>TeaStore Login</title>') != 1 ));
  then
    echo ""Login Check Error: Invalid login should forward to TeaStore login!""
    exit 1
  fi
}

# adds a product to cart and checks if it is present
function check_add_to_cart () {
  if (( $(curl -kLs -c - -X POST ""${PROTO}://${HOST}:${WEBUI_PORT}/tools.descartes.teastore.webui/cartAction?addToCart=&productid=${1}"" | grep -c ""name=\""productid\"" value=\""${1}\"""") < 1 ));
  then
    echo ""Couldn't add product ${1} to cart!""
    exit 1
  fi
}

function check_ads () {
  if (( $(curl -ks ""${PROTO}://${HOST}:${WEBUI_PORT}/tools.descartes.teastore.webui/product?id=${1}"" | grep -c 'Are you interested in') == 0 ));
  then
    echo ""No ads available! Check recommender service!""
    exit 1
  fi
}

function check_images () {
  if (( $(curl -ks ""${PROTO}://${HOST}:${WEBUI_PORT}/tools.descartes.teastore.webui/product?id=${1}"" | tr '\n' ' ' | grep -cEo 'class=""productpicture""\s+src=""""') > 0 ));
  then
    echo ""No product image available! Check image service!""
    exit 1
  fi
}

# Checks if products are available
function check_products () {
  COUNTER=${1}
  URL=""${PROTO}://${HOST}:${WEBUI_PORT}/tools.descartes.teastore.webui/""
  mapfile -t CATEGORIES < <( curl -ks ""${URL}"" | grep -oP ""category=\\d+"" | grep -oP ""\\d+"" )
  if (( ${#CATEGORIES[@]} == 0 ));
  then
    echo ""No categories in WebUI!""
    exit 1
  fi
  for cat in ""${CATEGORIES[@]}""
  do
    mapfile -t PRODUCTS < <( curl -kLs -X POST ""${PROTO}://${HOST}:${WEBUI_PORT}/tools.descartes.teastore.webui/category?category=${cat}&number=30"" | grep -oP 'product\?id=\d+' | grep -oP '\d+' )
    if (( ${#PRODUCTS[@]} == 0 ));
    then
      echo ""No products for category ${cat}!""
      exit 1
    fi
    for prod in ""${PRODUCTS[@]}""
    do
      if (( ${COUNTER} > 0 ))
      then
        check_add_to_cart ""${prod}""
        COUNTER=$(( COUNTER - 1 ))
      else
        # at last, check if images and ads are available
        check_ads ${prod}
        check_images ${prod}
        return 0
      fi
    done
  done
}

function check_status () {
  if (( $(curl -ks ""${PROTO}://${HOST}:${WEBUI_PORT}/tools.descartes.teastore.webui/status"" | grep -c OK) != 5  ));
  then
    echo ""Status was not OK!""
    exit 1
  fi
}

# whitelist tests
check_status
check_login
check_products 5

# blacklist tests
send_request
send_request login
send_request profile

echo ""WebUI test finished successully!"""
tools/test_kieker.sh,"#!/bin/bash

# Checks the teastore-rabbitmq for traces (works only in 'kieker mode'!)

HOST=${1} # usually 'localhost'
PORT=${2} # usually '8081', accesses the tomcat web interface of rabbitmq for the kieker logs
URL=""http://${HOST}:${PORT}/logs/""

LOG_NAME=$(curl -s ""${URL}"" | grep -Eo -m 1 'kieker-.{,30}-UTC--/' | head -n 1)

if [ -z ""${LOG_NAME}"" ]
then
  echo 'No logs available!'
  exit 1
else
  if (( $(curl -s ""${URL}${LOG_NAME}kieker.map"" | grep -ci 'record') > 0 ));
  then
    DATA_NAME=$(curl -s ""${URL}${LOG_NAME}"" | grep -Eo -m 1 'kieker-.{,30}-UTC-001.dat' | head -n 1)
    DATA=$(curl -s ""${URL}${LOG_NAME}${DATA_NAME}"")
    if (( $(echo ""${DATA}"" | grep -cEi 'webui|auth|image|persistence|recommender|registry') > 0 ));
    then
      echo 'Kieker Test finished successfully!'
      exit 0
    else
      echo 'Dat data empty!'
      exit 1
    fi
  else
    echo 'Map data empty!'
    exit 1
  fi
fi"
services/tools.descartes.teastore.auth/src/test/java/tools/descartes/teastore/auth/security/ShaSecurityProviderTest.java,"package tools.descartes.teastore.auth.security;

import org.junit.Assert;
import org.junit.Test;

import tools.descartes.teastore.entities.message.SessionBlob;

/**
 * Test for the SHASecurityProviuder.
 * 
 * @author Simon
 *
 */
public class ShaSecurityProviderTest {

  /**
   * checks security token behavior.
   */
  @Test
  public void test() {
    ShaSecurityProvider provider = new ShaSecurityProvider();
    SessionBlob blob = new SessionBlob();
    blob.setSID(""1234"");
    blob.setUID(123456L);
    Assert.assertTrue(provider.validate(blob) == null);
    provider.secure(blob);
    Assert.assertTrue(provider.validate(blob) != null);
    blob.setUID(13L);
    Assert.assertTrue(provider.validate(blob) == null);
    provider.secure(blob);
    Assert.assertTrue(provider.validate(blob) != null);
  }

}"
services/tools.descartes.teastore.auth/src/test/java/tools/descartes/teastore/auth/security/ConstantKeyProviderTest.java,"package tools.descartes.teastore.auth.security;

import org.junit.Assert;
import org.junit.Test;

import tools.descartes.teastore.entities.message.SessionBlob;

/**
 * Test for the ConstantKeyProvider.
 * 
 * @author Simon
 *
 */
public class ConstantKeyProviderTest {

  /**
   * checks the getKey() functionality.
   */
  @Test
  public void test() {
    Assert.assertEquals(""thebestsecretkey"", new ConstantKeyProvider().getKey(null));
    Assert.assertEquals(""thebestsecretkey"", new ConstantKeyProvider().getKey(new SessionBlob()));
  }

}"
services/tools.descartes.teastore.auth/src/main/java/tools/descartes/teastore/auth/security/ShaSecurityProvider.java,"package tools.descartes.teastore.auth.security;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import tools.descartes.teastore.entities.message.SessionBlob;

/**
 * Secruity provider using AES.
 * 
 * @author Simon
 *
 */
public class ShaSecurityProvider implements ISecurityProvider {

  @Override
  public IKeyProvider getKeyProvider() {
    return new ConstantKeyProvider();
  }

  @Override
  public SessionBlob secure(SessionBlob blob) {
    if (blob.getUID() == null || blob.getSID() == null) {
      return blob;
    }
    blob.setToken(null);
    String blobString = blobToString(blob);
    blob.setToken(getSha512(blobString));
    return blob;
  }

  private String blobToString(SessionBlob blob) {
    ObjectMapper o = new ObjectMapper();
    try {
      return URLEncoder.encode(o.writeValueAsString(blob), ""UTF-8"");
    } catch (JsonProcessingException | UnsupportedEncodingException e) {
      throw new IllegalStateException(""Could not save blob!"");
    }
  }

  @Override
  public SessionBlob validate(SessionBlob blob) {
    if (blob.getToken() == null) {
      return null;
    }

    String token = blob.getToken();
    blob.setToken(null);
    String blobString = blobToString(blob);
    String validationToken = getSha512(blobString);
    if (validationToken.equals(token)) {
      return blob;
    }
    return null;
  }

  private String getSha512(String passwordToHash) {
    String generatedPassword = null;
    try {
      String salt = getKeyProvider().getKey(null);
      MessageDigest md = MessageDigest.getInstance(""SHA-512"");
      md.update(salt.getBytes(""UTF-8""));
      byte[] bytes = md.digest(passwordToHash.getBytes(""UTF-8""));
      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < bytes.length; i++) {
        sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
      }
      generatedPassword = sb.toString();
    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
      e.printStackTrace();
    }
    return generatedPassword;
  }
}"
services/tools.descartes.teastore.auth/src/main/java/tools/descartes/teastore/auth/security/ISessionIdGenerator.java,"package tools.descartes.teastore.auth.security;

/**
 * Generator for Session ids.
 * 
 * @author Simon
 *
 */
public interface ISessionIdGenerator {

  /**
   * Generates session id.
   * 
   * @return session id
   */
  public String getSessionId();
}"
services/tools.descartes.teastore.auth/src/main/java/tools/descartes/teastore/auth/security/ConstantKeyProvider.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.auth.security;

import tools.descartes.teastore.entities.message.SessionBlob;

/**
 * Class for testing. Provides a constant key. DO NOT ADOPT THIS FOR ANY REAL
 * PRODUCTION WORKLOAD!
 * 
 * @author Joakim von Kistowski
 *
 */
public class ConstantKeyProvider implements IKeyProvider {

  /**
   * {@inheritDoc}
   */
  @Override
  public String getKey(SessionBlob blob) {
    return ""thebestsecretkey"";
  }

}"
services/tools.descartes.teastore.auth/src/main/java/tools/descartes/teastore/auth/security/ISecurityProvider.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.auth.security;

import tools.descartes.teastore.entities.message.SessionBlob;

/**
 * Utilities for securing (e.g. encrypting) session blobs.
 * 
 * @author Joakim von Kistowski
 *
 */
public interface ISecurityProvider {

  /**
   * Get the key provider for this security provider.
   * 
   * @return The key provider.
   */
  public IKeyProvider getKeyProvider();

  /**
   * Secures a session blob. May encrypt or hash values within the blob.
   * 
   * @param blob
   *          The blob to secure.
   * @return A secure blob to be passed on to the web ui.
   */
  public SessionBlob secure(SessionBlob blob);

  /**
   * Validates a secured session blob. Returns a valid and readable (e.g.
   * decrypted) blob. Returns null for invalid blobs.
   * 
   * @param blob
   *          The blob to secure.
   * @return The valid and readable (e.g. decrypted) blob. Returns null for
   *         invalid blobs.
   */
  public SessionBlob validate(SessionBlob blob);

}"
services/tools.descartes.teastore.auth/src/main/java/tools/descartes/teastore/auth/security/IKeyProvider.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.auth.security;

import tools.descartes.teastore.entities.message.SessionBlob;

/**
 * Provides keys for the security provider. The key provider must ensure that
 * keys accross replicated stores are consistent.
 * 
 * @author Joakim von Kistowski
 *
 */
public interface IKeyProvider {

  /**
   * Returns a key for a session blob. Key must be the same, regardless of the
   * store instance upon which this call is made.
   * 
   * @param blob
   *          The blob to secure.
   * @return The key.
   */
  public String getKey(SessionBlob blob);

}"
services/tools.descartes.teastore.auth/src/main/java/tools/descartes/teastore/auth/security/RandomSessionIdGenerator.java,"package tools.descartes.teastore.auth.security;

import java.util.Random;

/**
 * Generates random session id.
 * 
 * @author Simon
 *
 */
public class RandomSessionIdGenerator implements ISessionIdGenerator {

  private static Random random = new Random();

  @Override
  public String getSessionId() {
    return """" + random.nextInt();
  }

}"
services/tools.descartes.teastore.auth/src/main/java/tools/descartes/teastore/auth/security/BCryptProvider.java,"package tools.descartes.teastore.auth.security;

import org.mindrot.jbcrypt.BCrypt;

/**
 * Wrapper for BCrypt.
 * @author Simon
 *
 */
public final class BCryptProvider {

  /**
   * Hides default constructor.
   */
  private BCryptProvider() {
    
  }
  
  /**
   * validate password using BCrypt.
   * @param password password
   * @param password2 other password
   * @return true if password is correct
   */
  public static boolean checkPassword(String password, String password2) {
    return BCrypt.checkpw(password, password2);
  }
}"
services/tools.descartes.teastore.auth/src/main/java/tools/descartes/teastore/auth/startup/AuthStartup.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.auth.startup;

import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

import io.opentracing.util.GlobalTracer;
import tools.descartes.teastore.registryclient.RegistryClient;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.tracing.Tracing;
import tools.descartes.teastore.registryclient.util.RESTClient;

/**
 * Application Lifecycle Listener implementation class Registry Client Startup.
 *
 * @author Simon Eismann
 *
 */
@WebListener
public class AuthStartup implements ServletContextListener {

  private static final int REST_READ_TIMOUT = 1750;

  /**
   * Also set this accordingly in RegistryClientStartup.
   */

  /**
   * Empty constructor.
   */
  public AuthStartup() {

  }

  /**
   * shutdown routine.
   * @see ServletContextListener#contextDestroyed(ServletContextEvent)
   * @param event The servlet context event at destruction.
   */
  public void contextDestroyed(ServletContextEvent event) {
    RegistryClient.getClient().unregister(event.getServletContext().getContextPath());
  }

  /**
   * startup routine.
   * @see ServletContextListener#contextInitialized(ServletContextEvent)
   * @param event The servlet context event at initialization.
   */
  public void contextInitialized(ServletContextEvent event) {
    GlobalTracer.register(Tracing.init(Service.AUTH.getServiceName()));
    RESTClient.setGlobalReadTimeout(REST_READ_TIMOUT);
    ServiceLoadBalancer.preInitializeServiceLoadBalancers(Service.PERSISTENCE);
    RegistryClient.getClient().register(event.getServletContext().getContextPath());
  }

}"
services/tools.descartes.teastore.auth/src/main/java/tools/descartes/teastore/auth/rest/AuthUserActionsRest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.auth.rest;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.auth.security.BCryptProvider;
import tools.descartes.teastore.auth.security.RandomSessionIdGenerator;
import tools.descartes.teastore.auth.security.ShaSecurityProvider;
import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.User;
import tools.descartes.teastore.entities.message.SessionBlob;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.rest.LoadBalancedCRUDOperations;
import tools.descartes.teastore.registryclient.util.NotFoundException;
import tools.descartes.teastore.registryclient.util.TimeoutException;

/**
 * Rest endpoint for the store user actions.
 * 
 * @author Simon
 */
@Path(""useractions"")
@Produces({ ""application/json"" })
@Consumes({ ""application/json"" })
public class AuthUserActionsRest {

  /**
   * Persists order in database.
   * 
   * @param blob
   *          SessionBlob
   * @param totalPriceInCents
   *          totalPrice
   * @param addressName
   *          address
   * @param address1
   *          address
   * @param address2
   *          address
   * @param creditCardCompany
   *          creditcard
   * @param creditCardNumber
   *          creditcard
   * @param creditCardExpiryDate
   *          creditcard
   * @return Response containing SessionBlob
   */
  @POST
  @Path(""placeorder"")
  public Response placeOrder(SessionBlob blob,
      @QueryParam(""totalPriceInCents"") long totalPriceInCents,
      @QueryParam(""addressName"") String addressName, @QueryParam(""address1"") String address1,
      @QueryParam(""address2"") String address2,
      @QueryParam(""creditCardCompany"") String creditCardCompany,
      @QueryParam(""creditCardNumber"") String creditCardNumber,
      @QueryParam(""creditCardExpiryDate"") String creditCardExpiryDate) {
    if (new ShaSecurityProvider().validate(blob) == null || blob.getOrderItems().isEmpty()) {
      return Response.status(Response.Status.NOT_FOUND).build();
    }

    blob.getOrder().setUserId(blob.getUID());
    blob.getOrder().setTotalPriceInCents(totalPriceInCents);
    blob.getOrder().setAddressName(addressName);
    blob.getOrder().setAddress1(address1);
    blob.getOrder().setAddress2(address2);
    blob.getOrder().setCreditCardCompany(creditCardCompany);
    blob.getOrder().setCreditCardExpiryDate(creditCardExpiryDate);
    blob.getOrder().setCreditCardNumber(creditCardNumber);
    blob.getOrder().setTime(LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));

    long orderId;
    try {
      orderId = LoadBalancedCRUDOperations.sendEntityForCreation(Service.PERSISTENCE, ""orders"",
          Order.class, blob.getOrder());
    } catch (LoadBalancerTimeoutException e) {
      return Response.status(408).build();
    } catch (NotFoundException e) {
      return Response.status(404).build();
    }
    for (OrderItem item : blob.getOrderItems()) {
      try {
        item.setOrderId(orderId);
        LoadBalancedCRUDOperations.sendEntityForCreation(Service.PERSISTENCE, ""orderitems"",
            OrderItem.class, item);
      } catch (TimeoutException e) {
        return Response.status(408).build();
      } catch (NotFoundException e) {
        return Response.status(404).build();
      }
    }
    blob.setOrder(new Order());
    blob.getOrderItems().clear();
    blob = new ShaSecurityProvider().secure(blob);
    return Response.status(Response.Status.OK).entity(blob).build();
  }

  /**
   * User login.
   * 
   * @param blob
   *          SessionBlob
   * @param name
   *          Username
   * @param password
   *          password
   * @return Response with SessionBlob containing login information.
   */
  @POST
  @Path(""login"")
  public Response login(SessionBlob blob, @QueryParam(""name"") String name,
      @QueryParam(""password"") String password) {
    User user;
    try {
      user = LoadBalancedCRUDOperations.getEntityWithProperties(Service.PERSISTENCE, ""users"",
          User.class, ""name"", name);
    } catch (TimeoutException e) {
      return Response.status(408).build();
    } catch (NotFoundException e) {
      return Response.status(Response.Status.OK).entity(blob).build();
    }

    if (user != null && BCryptProvider.checkPassword(password, user.getPassword())
    ) {
      blob.setUID(user.getId());
      blob.setSID(new RandomSessionIdGenerator().getSessionId());
      blob = new ShaSecurityProvider().secure(blob);
      return Response.status(Response.Status.OK).entity(blob).build();
    }
    return Response.status(Response.Status.OK).entity(blob).build();
  }

  /**
   * User logout.
   * 
   * @param blob
   *          SessionBlob
   * @return Response with SessionBlob
   */
  @POST
  @Path(""logout"")
  public Response logout(SessionBlob blob) {
    blob.setUID(null);
    blob.setSID(null);
    blob.setOrder(new Order());
    blob.getOrderItems().clear();
    return Response.status(Response.Status.OK).entity(blob).build();
  }

  /**
   * Checks if user is logged in.
   * 
   * @param blob
   *          Sessionblob
   * @return Response with true if logged in
   */
  @POST
  @Path(""isloggedin"")
  public Response isLoggedIn(SessionBlob blob) {
    return Response.status(Response.Status.OK).entity(new ShaSecurityProvider().validate(blob))
        .build();
  }

}"
services/tools.descartes.teastore.auth/src/main/java/tools/descartes/teastore/auth/rest/ReadyRest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.auth.rest;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.Response;

/**
 * Rest endpoint for the store cart.
 * 
 * @author Simon
 */
@Path(""ready"")
@Produces({ ""application/json"" })
public class ReadyRest {


  /**
   * This methods checks, if the service is ready.
   * 
   * @return True, if recommender is ready; false, if not.
   */
  @GET
  @Path(""isready"")
  public Response isReady() {
    return Response.ok(String.valueOf(true)).build();
  }

}"
services/tools.descartes.teastore.auth/src/main/java/tools/descartes/teastore/auth/rest/AuthCartRest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.auth.rest;

import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.PUT;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.auth.security.ShaSecurityProvider;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.message.SessionBlob;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.rest.LoadBalancedCRUDOperations;
import tools.descartes.teastore.registryclient.util.NotFoundException;
import tools.descartes.teastore.registryclient.util.TimeoutException;

/**
 * Rest endpoint for the store cart.
 * 
 * @author Simon
 */
@Path(""cart"")
@Produces({ ""application/json"" })
@Consumes({ ""application/json"" })
public class AuthCartRest {

  /**
   * Adds product to cart. If the product is already in the cart the quantity is
   * increased.
   * 
   * @param blob
   *          Sessionblob
   * @param pid
   *          productid
   * @return Response containing session blob with updated cart
   */
  @POST
  @Path(""add/{pid}"")
  public Response addProductToCart(SessionBlob blob, @PathParam(""pid"") final Long pid) {
    Product product;
    try {
      product = LoadBalancedCRUDOperations.getEntity(Service.PERSISTENCE, ""products"", Product.class,
          pid);
    } catch (TimeoutException e) {
      return Response.status(408).build();
    } catch (NotFoundException e) {
      return Response.status(404).build();
    }

    for (OrderItem orderItem : blob.getOrderItems()) {
      if (orderItem.getProductId() == pid) {
        orderItem.setQuantity(orderItem.getQuantity() + 1);
        blob = new ShaSecurityProvider().secure(blob);
        return Response.status(Response.Status.OK).entity(blob).build();
      }
    }
    OrderItem item = new OrderItem();
    item.setProductId(pid);
    item.setQuantity(1);
    item.setUnitPriceInCents(product.getListPriceInCents());
    blob.getOrderItems().add(item);
    blob = new ShaSecurityProvider().secure(blob);
    return Response.status(Response.Status.OK).entity(blob).build();
  }

  /**
   * Remove product from cart.
   * 
   * @param blob
   *          Sessionblob
   * @param pid
   *          product id
   * @return Response containing Sessionblob with updated cart
   */
  @POST
  @Path(""remove/{pid}"")
  public Response removeProductFromCart(SessionBlob blob, @PathParam(""pid"") final Long pid) {
    OrderItem toRemove = null;
    for (OrderItem item : blob.getOrderItems()) {
      if (item.getProductId() == pid) {
        toRemove = item;
      }
    }
    if (toRemove != null) {
      blob.getOrderItems().remove(toRemove);
      blob = new ShaSecurityProvider().secure(blob);
      return Response.status(Response.Status.OK).entity(blob).build();
    } else {
      return Response.status(Response.Status.NOT_FOUND).build();
    }
  }

  /**
   * Updates quantity of product in cart.
   * 
   * @param blob
   *          Sessionblob
   * @param pid
   *          Productid
   * @param quantity
   *          New quantity
   * @return Response containing Sessionblob with updated cart
   */
  @PUT
  @Path(""{pid}"")
  public Response updateQuantity(SessionBlob blob, @PathParam(""pid"") final Long pid,
      @QueryParam(""quantity"") int quantity) {
    for (OrderItem item : blob.getOrderItems()) {
      if (item.getProductId() == pid) {
        item.setQuantity(quantity);
        blob = new ShaSecurityProvider().secure(blob);
        return Response.status(Response.Status.OK).entity(blob).build();
      }
    }
    return Response.status(Response.Status.NOT_FOUND).build();
  }

}"
services/tools.descartes.teastore.registry/src/main/java/tools/descartes/teastore/registry/servlet/IndexServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registry.servlet;

import java.io.IOException;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Index Servlet for Registry. Provides some basic debug information for
 * deployers and testers.
 * @author Joakim von Kistowski
 */
@WebServlet(""/index"")
public class IndexServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public IndexServlet() {
        super();
    }

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 * @param request The request.
	 * @param response The response.
	 * @throws ServletException In case of servlet Exception.
	 * @throws IOException In case of IOException.
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.getWriter().println(""This is the registry module running at ""
	+ request.getProtocol() + ""://"" + request.getLocalAddr() + "":""
				+ request.getLocalPort() + ""/"" + request.getContextPath());
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 * @param request The request.
	 * @param response The response.
	 * @throws ServletException In case of servlet Exception.
	 * @throws IOException In case of IOException.
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}

}"
services/tools.descartes.teastore.registry/src/main/java/tools/descartes/teastore/registry/rest/RegistryREST.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registry.rest;

import java.util.List;

import jakarta.ws.rs.DELETE;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.PUT;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;

/**
 * Rest endpoint for the registry.
 * @author Simon
 */
@Path(""services"")
@Produces({ ""application/json"" })
public class RegistryREST {

	/**
	 * Register a service at a location.
	 * @param name Service name
	 * @param location service location
	 * @return boolean success indicator
	 */
	@PUT
	@Path(""{name}/{location}"")
	public Response register(@PathParam(""name"") final String name, @PathParam(""location"") final String location) {
		boolean success = Registry.getRegistryInstance().register(name, location);
		if (success) {
			return Response.status(Status.CREATED).build();
		}
		return Response.ok().build();
	}

	/**
	 * Unregister a service at a location.
	 * @param name Service name
	 * @param location service location
	 * @return boolean success indicator
	 */
	@DELETE
	@Path(""{name}/{location}"")
	public Response unregister(@PathParam(""name"") final String name, @PathParam(""location"") final String location) {
		boolean success = Registry.getRegistryInstance().unregister(name, location);
		if (success) {
			return Response.status(Response.Status.OK).build();
		}
		return Response.status(Response.Status.NOT_FOUND).build();
	}

	/**
	 * Get list of all instances of a service.
	 * @param name service name
	 * @return list of all instance
	 */
	@GET
	@Path(""{name}"")
	public Response getInstances(@PathParam(""name"") final String name) {
		List<String> locations = Registry.getRegistryInstance().getLocations(name);
		return Response.status(Response.Status.OK).entity(locations).build();
	}

}"
services/tools.descartes.teastore.registry/src/main/java/tools/descartes/teastore/registry/rest/HeartbeatInfo.java,"package tools.descartes.teastore.registry.rest;

/**
 * Datacontainer for the information about the heartbeats.
 * @author Simon
 *
 */
public class HeartbeatInfo {
	
	private long lastHeartbeat;
	
	/**
	 * Contructor for the heartbeat info.
	 */
	public HeartbeatInfo() {
		this.lastHeartbeat = System.currentTimeMillis();
	}
	
	/**
	 * Registers new heartbeat.
	 */
	public void newHeartbeat() {
		this.lastHeartbeat = System.currentTimeMillis();
	}
	
	/**
	 * Checks if the service is still considered alive.
	 * Extensionpoint for more complex mechanisms.
	 * @return true if alive
	 */
	public boolean isAlive() {
		return System.currentTimeMillis() - lastHeartbeat < 10000;
	}
}"
services/tools.descartes.teastore.registry/src/main/java/tools/descartes/teastore/registry/rest/Registry.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registry.rest;

import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Registry for the services.
 * 
 * @author Simon Eismann
 *
 */
public final class Registry {

  private static Registry registry = new Registry();
  private Map<String, List<String>> serviceLocationMap = new HashMap<String, List<String>>();
  private Map<String, HeartbeatInfo> heartbeatMap = Collections
      .synchronizedMap(new HashMap<String, HeartbeatInfo>());
  private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
  private Lock readLock = readWriteLock.readLock();
  private Lock writeLock = readWriteLock.writeLock();
  private static final Logger LOG = LoggerFactory.getLogger(Registry.class);

  private Registry() {
  }

  /**
   * Getter for singleton registry.
   * 
   * @return registry singleton
   */
  public static Registry getRegistryInstance() {
    return registry;
  }

  /**
   * Returns all locations for a service.
   * 
   * @param name
   *          Name of the service
   * @return List over all locations
   */
  public List<String> getLocations(String name) {
    List<String> locations;
    readLock.lock();
    try {
      locations = serviceLocationMap.get(name);
    } finally {
      readLock.unlock();
    }

    writeLock.lock();
    try {
      if (locations == null) {
        locations = new LinkedList<String>();
        serviceLocationMap.put(name, locations);
      }
    } finally {
      writeLock.unlock();
    }
    return locations;
  }

  private void updateHeartbeatMap(String name, String location) {
    HeartbeatInfo info = heartbeatMap.get(name + location);
    if (info == null) {
      heartbeatMap.put(name + location, new HeartbeatInfo());
    } else {
      info.newHeartbeat();
    }
  }

  /**
   * Unregisters a service instance from the registry.
   * 
   * @param name
   *          name of the service
   * @param location
   *          instance location
   * @return boolean success indicator
   */
  public boolean unregister(String name, String location) {
    writeLock.lock();
    try {
      List<String> locations = serviceLocationMap.get(name);
      if (locations == null) {
        return false;
      }

      boolean removed = locations.remove(location);
      if (locations.size() == 0) {
        serviceLocationMap.remove(name);
      }

      if (removed) {
        LOG.info(""Unregistered "" + name + ""@"" + location);
      }
      return removed;
    } finally {
      writeLock.unlock();
    }
  }

  /**
   * Registers a service instance from the registry.
   * 
   * @param name
   *          name of the service
   * @param location
   *          instance location
   * @return boolean success indicator
   */
  public boolean register(String name, String location) {
    updateHeartbeatMap(name, location);

    writeLock.lock();
    try {
      List<String> locations = getLocations(name);
      if (locations.contains(location)) {
        return false;
      }
    
      serviceLocationMap.get(name).add(location);
      LOG.info(""Registered "" + name + ""@"" + location);
      return true;
    } finally {
      writeLock.unlock();
    }
  }
  
  /**
   * removes service instances from the registry based on heartbeat.
   */
  public void heartBeatCleanup() {
    writeLock.lock();
    try {
      serviceLocationMap.entrySet().stream().forEach(entry -> {
        for (Iterator<String> iter = entry.getValue().iterator(); iter.hasNext();) {
          String location = iter.next();
          if (!heartbeatMap.get(entry.getKey() + location).isAlive()) {
            iter.remove();
            LOG.warn(
                ""Removed "" + entry.getKey() + ""@"" + location + "" since it failed the heartbeat!"");
          }
        }
      });
    } finally {
      writeLock.unlock();
    }
  }
}"
services/tools.descartes.teastore.registry/src/main/java/tools/descartes/teastore/registry/rest/RegistryStartup.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registry.rest;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Application Lifecycle Listener implementation class Registry Client Startup.
 *
 * @author Simon Eismann
 *
 */
@WebListener
public class RegistryStartup implements ServletContextListener {

  private static final Logger LOG = LoggerFactory.getLogger(RegistryStartup.class);
  /**
   * Also set this accordingly in RegistryClientStartup.
   */
  private static final int HEARTBEAT_INTERVAL_MS = 2500;

  private static ScheduledExecutorService heartbeatScheduler;

  /**
   * Empty constructor.
   */
  public RegistryStartup() {

  }

  /**
   * @see ServletContextListener#contextDestroyed(ServletContextEvent)
   * @param arg0
   *          The servlet context event at destruction.
   */
  public void contextDestroyed(ServletContextEvent arg0) {
    heartbeatScheduler.shutdownNow();
    LOG.info(""Shutdown registry"");
  }

  /**
   * @see ServletContextListener#contextInitialized(ServletContextEvent)
   * @param arg0
   *          The servlet context event at initialization.
   */
  public void contextInitialized(ServletContextEvent arg0) {
    heartbeatScheduler = Executors.newSingleThreadScheduledExecutor();
    heartbeatScheduler.scheduleAtFixedRate(new Runnable() {
      @Override
      public void run() {
        Registry.getRegistryInstance().heartBeatCleanup();
      }
    }, HEARTBEAT_INTERVAL_MS, HEARTBEAT_INTERVAL_MS, TimeUnit.MILLISECONDS);
    LOG.info(""Registry online"");
  }
}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/storage/TestNoStorage.java,"package tools.descartes.teastore.image.storage;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.when;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import tools.descartes.teastore.image.StoreImage;

public class TestNoStorage {

  @Mock
  private StoreImage image;

  @Before
  public void initialize() {
    MockitoAnnotations.openMocks(this);
    when(image.getId()).thenReturn(0L);
  }

  @Test
  public void testDataExists() {
    NoStorage<StoreImage> uut = new NoStorage<>();
    assertFalse(uut.dataExists(image.getId()));
  }

  @Test
  public void testLoadData() {
    NoStorage<StoreImage> uut = new NoStorage<>();
    assertNull(uut.loadData(image.getId()));
  }

  @Test
  public void testSaveData() {
    NoStorage<StoreImage> uut = new NoStorage<>();
    assertFalse(uut.saveData(image));
  }

  @Test
  public void testDataIsStorable() {
    NoStorage<StoreImage> uut = new NoStorage<>();
    assertFalse(uut.dataIsStorable(image));
  }

  @Test
  public void testDeleteData() {
    NoStorage<StoreImage> uut = new NoStorage<>();
    assertFalse(uut.deleteData(image));
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/storage/TestDriveStorage.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.storage;

public class TestDriveStorage {

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/storage/rules/TestStoreLargeImages.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.storage.rules;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.mockito.Mockito.when;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import tools.descartes.teastore.entities.ImageSizePreset;
import tools.descartes.teastore.image.StoreImage;

public class TestStoreLargeImages {

  @Mock
  private StoreImage mockedLargeImg;
  @Mock
  private StoreImage mockedIconImg;
  @Mock
  private StoreImage mockedMainImg;
  @Mock
  private StoreImage mockedPreviewImg;

  @Before
  public void initialize() {
    MockitoAnnotations.openMocks(this);
    when(mockedLargeImg.getSize()).thenReturn(ImageSizePreset.FULL.getSize());
    when(mockedIconImg.getSize()).thenReturn(ImageSizePreset.ICON.getSize());
    when(mockedMainImg.getSize()).thenReturn(ImageSizePreset.MAIN_IMAGE.getSize());
    when(mockedPreviewImg.getSize()).thenReturn(ImageSizePreset.PREVIEW.getSize());
  }

  @Test
  public void testRule() {
    StoreLargeImages uut = new StoreLargeImages();
    assertTrue(uut.test(mockedLargeImg));
    assertFalse(uut.test(mockedIconImg));
    assertFalse(uut.test(mockedMainImg));
    assertFalse(uut.test(mockedPreviewImg));
    assertFalse(uut.test(null));
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/storage/rules/TestStoreAll.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.storage.rules;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import tools.descartes.teastore.image.StoreImage;

public class TestStoreAll {

  @Mock
  private StoreImage mockedImg;

  @Before
  public void initialize() {
    MockitoAnnotations.openMocks(this);
  }

  @Test
  public void testRule() {
    StoreAll<StoreImage> uut = new StoreAll<>();
    assertTrue(uut.test(mockedImg));
    assertTrue(uut.test(null));
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/TestImageDB.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import tools.descartes.teastore.entities.ImageSize;
import tools.descartes.teastore.entities.ImageSizePreset;

public class TestImageDB {

  private static final long PRODUCT_ID = 1234567890;
  private static final String NAME = ""testname"";
  private static final long PRODUCT_IMAGE_ID = 99;
  private static final long PRODUCT_IMAGE_ID_LARGE = 999;
  private static final long NAME_IMAGE_ID = 200;
  private ImageSize size = ImageSizePreset.ICON.getSize();
  private ImageSize sizeLarge = ImageSizePreset.FULL.getSize();
  private ImageDB uut;

  @Mock
  private ImageDBKey mockedProductKey;
  @Mock
  private ImageDBKey mockedNameKey;

  @Before
  public void initialize() {
    MockitoAnnotations.openMocks(this);
    when(mockedProductKey.isProductKey()).thenReturn(true);
    when(mockedProductKey.getProductID()).thenReturn(PRODUCT_ID);
    when(mockedProductKey.getWebUIName()).thenReturn(null);
    when(mockedNameKey.isProductKey()).thenReturn(false);
    when(mockedNameKey.getProductID()).thenReturn(0L);
    when(mockedNameKey.getWebUIName()).thenReturn(NAME);
    uut = new ImageDB();
  }

  @Test
  public void testConstructor() {
    ImageDB uut = new ImageDB();
    new ImageDB(uut);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorNull() {
    new ImageDB(null);
  }

  @Test
  public void testHasImageID() {
    uut.setImageMapping(mockedProductKey, PRODUCT_IMAGE_ID, size);
    assertTrue(uut.hasImageID(mockedProductKey, size));
    assertFalse(uut.hasImageID(mockedNameKey, size));

    uut = new ImageDB();
    uut.setImageMapping(mockedNameKey, NAME_IMAGE_ID, size);
    assertTrue(uut.hasImageID(mockedNameKey, size));
    assertFalse(uut.hasImageID(mockedProductKey, size));
  }

  @Test(expected = NullPointerException.class)
  public void testHasImageIDNull() {
    uut.hasImageID((ImageDBKey) null, size);
  }

  @Test
  public void testSetImageMappingAndGetImageID() {
    assertEquals(0, uut.getImageID(mockedProductKey, size));
    assertEquals(0, uut.getImageID(mockedProductKey, size));
    assertEquals(0, uut.getImageID(mockedProductKey, null));

    uut = new ImageDB();
    uut.setImageMapping(mockedProductKey, PRODUCT_IMAGE_ID, size);
    assertEquals(0, uut.getImageID(mockedProductKey, null));
    assertEquals(PRODUCT_IMAGE_ID, uut.getImageID(mockedProductKey, size));
    assertNotEquals(NAME_IMAGE_ID, uut.getImageID(mockedProductKey, size));
    assertNotEquals(0, uut.getImageID(mockedProductKey, size));

    assertEquals(0, uut.getImageID(mockedNameKey, null));
    assertEquals(0, uut.getImageID(mockedNameKey, size));
    assertNotEquals(PRODUCT_IMAGE_ID, uut.getImageID(mockedNameKey, size));

    uut = new ImageDB();
    uut.setImageMapping(mockedProductKey, PRODUCT_IMAGE_ID, size);
    uut.setImageMapping(mockedNameKey, NAME_IMAGE_ID, size);
    assertEquals(PRODUCT_IMAGE_ID, uut.getImageID(mockedProductKey, size));
    assertNotEquals(NAME_IMAGE_ID, uut.getImageID(mockedProductKey, size));
    assertNotEquals(0, uut.getImageID(mockedProductKey, size));

    assertEquals(NAME_IMAGE_ID, uut.getImageID(mockedNameKey, size));
    assertNotEquals(PRODUCT_IMAGE_ID, uut.getImageID(mockedNameKey, size));
    assertNotEquals(0, uut.getImageID(mockedNameKey, size));

    uut.setImageMapping(mockedProductKey, PRODUCT_IMAGE_ID_LARGE, sizeLarge);
    assertEquals(0, uut.getImageID(mockedProductKey, null));
    assertEquals(PRODUCT_IMAGE_ID, uut.getImageID(mockedProductKey, size));
    assertNotEquals(PRODUCT_IMAGE_ID_LARGE, uut.getImageID(mockedProductKey, size));
    assertNotEquals(0, uut.getImageID(mockedProductKey, size));
    assertNotEquals(NAME_IMAGE_ID, uut.getImageID(mockedProductKey, size));

    assertEquals(0, uut.getImageID(mockedNameKey, null));
    assertEquals(0, uut.getImageID(mockedNameKey, sizeLarge));
    assertNotEquals(PRODUCT_IMAGE_ID_LARGE, uut.getImageID(mockedNameKey, sizeLarge));
    assertNotEquals(PRODUCT_IMAGE_ID, uut.getImageID(mockedNameKey, sizeLarge));
    assertNotEquals(NAME_IMAGE_ID, uut.getImageID(mockedNameKey, sizeLarge));

    assertEquals(NAME_IMAGE_ID, uut.getImageID(mockedNameKey, size));
    assertNotEquals(0, uut.getImageID(mockedNameKey, size));
    assertNotEquals(PRODUCT_IMAGE_ID, uut.getImageID(mockedNameKey, size));
    assertNotEquals(PRODUCT_IMAGE_ID_LARGE, uut.getImageID(mockedNameKey, size));
  }

  @Test(expected = NullPointerException.class)
  public void testGetImageIDNull() {
    uut.setImageMapping(mockedProductKey, PRODUCT_IMAGE_ID, size);
    uut.setImageMapping(mockedNameKey, NAME_IMAGE_ID, size);

    uut.getImageID((ImageDBKey) null, size);
  }

  @Test
  public void testGetImageSize() {
    assertNull(uut.getImageSize(PRODUCT_IMAGE_ID));

    uut.setImageMapping(mockedProductKey, PRODUCT_IMAGE_ID, size);
    assertNull(uut.getImageSize(NAME_IMAGE_ID));
    assertEquals(size, uut.getImageSize(PRODUCT_IMAGE_ID));

    uut.setImageMapping(mockedProductKey, PRODUCT_IMAGE_ID_LARGE, sizeLarge);
    assertNull(uut.getImageSize(NAME_IMAGE_ID));
    assertNotEquals(sizeLarge, uut.getImageSize(PRODUCT_IMAGE_ID));
    assertEquals(size, uut.getImageSize(PRODUCT_IMAGE_ID));
  }

  @Test(expected = NullPointerException.class)
  public void testSetImageMappingKeyNull() {
    uut.setImageMapping((ImageDBKey) null, NAME_IMAGE_ID, size);
  }

  @Test(expected = NullPointerException.class)
  public void testSetImageMappingNameNull() {
    uut.setImageMapping((String) null, NAME_IMAGE_ID, size);
  }

  @Test(expected = NullPointerException.class)
  public void testSetImageMappingProductSizeNull() {
    uut.setImageMapping(PRODUCT_ID, PRODUCT_IMAGE_ID, null);
  }

  @Test(expected = NullPointerException.class)
  public void testSetImageMappingNameSizeNull() {
    uut.setImageMapping(NAME, NAME_IMAGE_ID, null);
  }

  @Test(expected = NullPointerException.class)
  public void testSetImageMappingKeySizeNull() {
    uut.setImageMapping(mockedNameKey, NAME_IMAGE_ID, null);
  }
}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/TestImageDBKey.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

public class TestImageDBKey {

  private static final long TEST_PRODUCT_KEY = 120;
  private static final String TEST_FILENAME = ""testfilename"";

  @Test
  public void testConstructor() {
	new ImageDBKey(TEST_PRODUCT_KEY);
	new ImageDBKey(TEST_FILENAME);
  }

  @Test
  public void testIsProductKey() {
    ImageDBKey uut = new ImageDBKey(TEST_PRODUCT_KEY);
    assertTrue(uut.isProductKey());
    uut = new ImageDBKey(TEST_FILENAME);
    assertFalse(uut.isProductKey());
  }

  @Test
  public void testGetProductID() {
    ImageDBKey uut = new ImageDBKey(TEST_PRODUCT_KEY);
    assertEquals(TEST_PRODUCT_KEY, uut.getProductID());
    assertNull(uut.getWebUIName());
  }

  @Test
  public void testGetWebUIName() {
    ImageDBKey uut = new ImageDBKey(TEST_FILENAME);
    assertEquals(TEST_FILENAME, uut.getWebUIName());
    assertEquals(0, uut.getProductID());
  }
}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/TestStoreImage.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assert.assertArrayEquals;
import static org.mockito.Mockito.when;

import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.Base64;

import javax.imageio.ImageIO;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import tools.descartes.teastore.entities.ImageSizePreset;

public class TestStoreImage {

  private static final String IMG_STRING = ""data:image/png;base64,"";
  private static final String IMG_DATA = ""iVBORw0KGgoAAAANSUhEUgAAAM0AAADNCAMAAAAsYgRbAAAAGXRFWHRTb2Z0d""
      + ""2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABJQTFRF3NSmzMewPxIG//ncJEJsldTou1jHgAAAARBJREFUeNrs2EE""
      + ""KgCAQBVDLuv+V20dENbMY831wKz4Y/VHb/5RGQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0PzMWtya""
      + ""GhoaGhoaGhoaGhoaGhoxtb0QGhoaGhoaGhoaGhoaGhoaMbRLEvv50VTQ9OTQ5OpyZ01GpM2g0bfmDQaL7S+ofFC6xv""
      + ""3ZpxJiywakzbvd9r3RWPS9I2+MWk0+kbf0Hih9Y17U0nTHibrDDQ0NDQ0NDQ0NDQ0NDQ0NTXbRSL/AK72o6GhoaGho""
      + ""RlL8951vwsNDQ0NDQ1NDc0WyHtDTEhDQ0NDQ0NTS5MdGhoaGhoaGhoaGhoaGhoaGhoaGhoaGposzSHAAErMwwQ2HwR""
      + ""QAAAAAElFTkSuQmCC"";
  private static final long IMG_ID0 = 0L;
  private static final long IMG_ID1 = 6648764502374L;

  private BufferedImage img;
  @Mock
  private StoreImage mockedImg0;
  @Mock
  private StoreImage mockedImg1;

  private BufferedImage convertToImage(byte[] data) {
    ByteArrayInputStream bais = new ByteArrayInputStream(Base64.getDecoder().decode(data));
    BufferedImage bi = null;
    try {
      bi = ImageIO.read(bais);
    } catch (IOException e) {

    }
    return bi;
  }

  @Before
  public void initialize() {
    MockitoAnnotations.openMocks(this);
    when(mockedImg0.getByteSize()).thenReturn((long) IMG_DATA.getBytes().length);
    when(mockedImg0.getByteArray()).thenReturn(IMG_DATA.getBytes());
    when(mockedImg0.getId()).thenReturn(IMG_ID0);
    when(mockedImg0.getImage()).thenReturn(img);
    when(mockedImg1.getId()).thenReturn(IMG_ID1);

    img = convertToImage(IMG_DATA.getBytes());
    if (img == null)
      throw new NullPointerException();
  }

  @Test
  public void testConstructor() {
    new StoreImage(IMG_ID0, img, ImageSizePreset.ICON.getSize());
    new StoreImage(IMG_ID0, IMG_DATA.getBytes(), ImageSizePreset.ICON.getSize());
    new StoreImage(mockedImg0);
  }

  @Test(expected = NullPointerException.class)
  public void testByteArrayConstructorNull() {
    new StoreImage(IMG_ID0, (byte[]) null, ImageSizePreset.ICON.getSize());
  }

  @Test(expected = NullPointerException.class)
  public void testImageConstructorNull() {
    new StoreImage(IMG_ID0, (BufferedImage) null, ImageSizePreset.ICON.getSize());
  }

  @Test(expected = NullPointerException.class)
  public void testByteArrayConstructorSizeNull() {
    new StoreImage(IMG_ID0, IMG_DATA.getBytes(), null);
  }

  @Test(expected = NullPointerException.class)
  public void testImageConstructorSizeNull() {
    new StoreImage(IMG_ID0, img, null);
  }

  @Test(expected = NullPointerException.class)
  public void testCopyConstructorNull() {
    new StoreImage(null);
  }

  @Test
  public void testGetID() {
    StoreImage uut = new StoreImage(IMG_ID1, img, ImageSizePreset.ICON.getSize());
    assertEquals(IMG_ID1, uut.getId());
  }

  @Test
  public void testGetImage() {
    StoreImage uut = new StoreImage(IMG_ID1, IMG_DATA.getBytes(), ImageSizePreset.ICON.getSize());
    BufferedImage bi = uut.getImage();
    if (bi == null)
      fail();
    assertEquals(bi.getWidth(), img.getWidth());
    assertEquals(bi.getHeight(), img.getHeight());
  }

  @Test
  public void testGetSize() {
    StoreImage uut = new StoreImage(IMG_ID1, IMG_DATA.getBytes(), ImageSizePreset.ICON.getSize());
    assertEquals(ImageSizePreset.ICON.getSize(), uut.getSize());
  }

  @Test
  public void testGetByteSize() {
    StoreImage uut = new StoreImage(IMG_ID1, IMG_DATA.getBytes(), ImageSizePreset.ICON.getSize());
    assertEquals(IMG_DATA.getBytes().length, uut.getByteSize());
  }

  @Test
  public void testGetBase64() {
    StoreImage uut = new StoreImage(IMG_ID1, IMG_DATA.getBytes(), ImageSizePreset.ICON.getSize());
    assertEquals(IMG_DATA, uut.getBase64());
  }

  @Test
  public void testGetByteArray() {
    StoreImage uut = new StoreImage(IMG_ID1, IMG_DATA.getBytes(), ImageSizePreset.ICON.getSize());
    assertArrayEquals(IMG_DATA.getBytes(), uut.getByteArray());
  }

  @Test
  public void testToString() {
    StoreImage uut = new StoreImage(IMG_ID1, IMG_DATA.getBytes(), ImageSizePreset.ICON.getSize());
    assertEquals(IMG_STRING + IMG_DATA, uut.toString());
  }

  @SuppressWarnings(""unlikely-arg-type"")
  @Test
  public void testEquals() {
    StoreImage uut = new StoreImage(IMG_ID1, IMG_DATA.getBytes(), ImageSizePreset.ICON.getSize());
    StoreImage test = new StoreImage(uut);
    assertTrue(uut.equals(uut));
    assertFalse(uut.equals(null));
    assertFalse(uut.equals(mockedImg0));
    assertTrue(uut.equals(test));
    assertFalse(uut.equals(img));
  }

  @Test
  public void testHashCode() {
    StoreImage uut = new StoreImage(IMG_ID1, IMG_DATA.getBytes(), ImageSizePreset.ICON.getSize());
    int result = 31 + (int) (IMG_ID1 ^ (IMG_ID1 >>> 32));
    assertEquals(uut.hashCode(), result);
  }
}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/TestImageScaler.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image;

import static org.junit.Assert.assertEquals;

import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.Base64;

import javax.imageio.ImageIO;

import org.junit.Before;
import org.junit.Test;

import tools.descartes.teastore.entities.ImageSize;
import tools.descartes.teastore.entities.ImageSizePreset;

public class TestImageScaler {

  private static final String IMG_DATA = ""iVBORw0KGgoAAAANSUhEUgAAAM0AAADNCAMAAAAsYgRbAAAAGXRFWHRTb2Z0d""
      + ""2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABJQTFRF3NSmzMewPxIG//ncJEJsldTou1jHgAAAARBJREFUeNrs2EE""
      + ""KgCAQBVDLuv+V20dENbMY831wKz4Y/VHb/5RGQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0PzMWtya""
      + ""GhoaGhoaGhoaGhoaGhoxtb0QGhoaGhoaGhoaGhoaGhoaMbRLEvv50VTQ9OTQ5OpyZ01GpM2g0bfmDQaL7S+ofFC6xv""
      + ""3ZpxJiywakzbvd9r3RWPS9I2+MWk0+kbf0Hih9Y17U0nTHibrDDQ0NDQ0NDQ0NDQ0NDQ0NTXbRSL/AK72o6GhoaGho""
      + ""RlL8951vwsNDQ0NDQ1NDc0WyHtDTEhDQ0NDQ0NTS5MdGhoaGhoaGhoaGhoaGhoaGhoaGhoaGposzSHAAErMwwQ2HwR""
      + ""QAAAAAElFTkSuQmCC"";

  private BufferedImage img;
  private int widthBefore;
  private int heightBefore;

  @Before
  public void initialize() {
    ByteArrayInputStream bais = new ByteArrayInputStream(
        Base64.getDecoder().decode(IMG_DATA.getBytes()));
    try {
      img = ImageIO.read(bais);
    } catch (IOException e) {
      System.out.println(""IOException while reading from input stream. Message: "" + e.getMessage());
      e.printStackTrace();
    }
    widthBefore = img.getWidth();
    heightBefore = img.getHeight();
  }

  // We can only test that it scales correctly, it is not really feasible to test
  // for the correct content.
  @Test
  public void testScale() {
    BufferedImage uut = ImageScaler.scale(img, ImageSizePreset.FULL.getSize());
    assertEquals(ImageSizePreset.FULL.getSize().getWidth(), uut.getWidth());
    assertEquals(ImageSizePreset.FULL.getSize().getHeight(), uut.getHeight());
    uut = ImageScaler.scale(img, ImageSizePreset.ICON.getSize());
    assertEquals(ImageSizePreset.ICON.getSize().getWidth(), uut.getWidth());
    assertEquals(ImageSizePreset.ICON.getSize().getHeight(), uut.getHeight());

    uut = ImageScaler.scale(img, 2.2);
    assertEquals((int) (widthBefore * 2.2), uut.getWidth());
    assertEquals((int) (heightBefore * 2.2), uut.getHeight());
    uut = ImageScaler.scale(img, 0.33);
    assertEquals((int) (widthBefore * 0.33), uut.getWidth());
    assertEquals((int) (heightBefore * 0.33), uut.getHeight());
    uut = ImageScaler.scale(img, 1.0);
    assertEquals(widthBefore, uut.getWidth());
    assertEquals(heightBefore, uut.getHeight());
    uut = ImageScaler.scale(img, 0.001);
    assertEquals(1, uut.getWidth());
    assertEquals(1, uut.getHeight());

    uut = ImageScaler.scale(img, 1.0, 2.5);
    assertEquals(widthBefore, uut.getWidth());
    assertEquals((int) (heightBefore * 2.5), uut.getHeight());
    uut = ImageScaler.scale(img, 2.5, 1.0);
    assertEquals((int) (widthBefore * 2.5), uut.getWidth());
    assertEquals(heightBefore, uut.getHeight());
    uut = ImageScaler.scale(img, 0.5, 4.0);
    assertEquals((int) (widthBefore * 0.5), uut.getWidth());
    assertEquals((int) (heightBefore * 4.0), uut.getHeight());
    uut = ImageScaler.scale(img, 4.0, 0.5);
    assertEquals((int) (widthBefore * 4.0), uut.getWidth());
    assertEquals((int) (heightBefore * 0.5), uut.getHeight());

    uut = ImageScaler.scale(img, 807);
    assertEquals(807, uut.getWidth());
    assertEquals(807, uut.getHeight());
    uut = ImageScaler.scale(img, 122);
    assertEquals(122, uut.getWidth());
    assertEquals(122, uut.getHeight());
    uut = ImageScaler.scale(img, widthBefore);
    assertEquals(widthBefore, uut.getWidth());
    assertEquals(widthBefore, uut.getHeight());

    uut = ImageScaler.scale(img, widthBefore, 654);
    assertEquals(widthBefore, uut.getWidth());
    assertEquals(654, uut.getHeight());
    uut = ImageScaler.scale(img, 654, heightBefore);
    assertEquals(654, uut.getWidth());
    assertEquals(heightBefore, uut.getHeight());
    uut = ImageScaler.scale(img, 111, 555);
    assertEquals(111, uut.getWidth());
    assertEquals(555, uut.getHeight());
    uut = ImageScaler.scale(img, 555, 111);
    assertEquals(555, uut.getWidth());
    assertEquals(111, uut.getHeight());
    uut = ImageScaler.scale(img, 1, 1);
    assertEquals(1, uut.getWidth());
    assertEquals(1, uut.getHeight());
  }

  @Test(expected = NullPointerException.class)
  public void testScaleImageSizeNull() {
    ImageScaler.scale(img, (ImageSize) null);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testScaleFactorZero() {
    ImageScaler.scale(img, 0.0);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testScaleFactorBelowZero() {
    ImageScaler.scale(img, -1.34);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testScaleFactorTwoZero() {
    ImageScaler.scale(img, 0.0, 0.0);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testScaleFactorTwoSingleBelowZero() {
    ImageScaler.scale(img, 1.5, -2.0);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testScaleFactorTwoBelowZero() {
    ImageScaler.scale(img, -1.22, -2.22);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testScalePixelZero() {
    ImageScaler.scale(img, 0);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testScalePixelBelowOne() {
    ImageScaler.scale(img, -4);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testScalePixelTwoZero() {
    ImageScaler.scale(img, 0, 0);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testScalePixelTwoSIngleBelowZero() {
    ImageScaler.scale(img, 5, -6);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testScalePixelTwoBelowOne() {
    ImageScaler.scale(img, -4, -6);
  }

  @Test(expected = NullPointerException.class)
  public void testScaleImageNull() {
    ImageScaler.scale(null, 50);
  }
}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/TestRandomReplacement.java,"package tools.descartes.teastore.image.cache;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Random;

import org.junit.Test;


public class TestRandomReplacement extends AbstractCacheTestInit {

  @Test
  public void testConstructorSimple() {
    new RandomReplacement<DummyData>();
  }

  @Test
  public void testConstructorSize() {
    new RandomReplacement<DummyData>(24 * 1024 * 1024);
    new RandomReplacement<DummyData>(1);
  }

  @Test
  public void testConstructorSizePredicate() {
    new RandomReplacement<DummyData>(1, predicate -> true);
  }

  @Test
  public void testConstructorStorageSizePredicate() {
    new RandomReplacement<DummyData>(storage, 1, predicate -> true);
  }

  @Test
  public void testConstructorStorageSizePredicateSeed() {
    new RandomReplacement<DummyData>(storage, 1, predicate -> true, 800);
    new RandomReplacement<DummyData>(storage, 1, predicate -> true, -123);
    new RandomReplacement<DummyData>(storage, 1, predicate -> true, 0);
  }

  @Test
  public void testConstructorStorageNull() {
    new RandomReplacement<DummyData>(null, 1, predicate -> true);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorPredicateNull() {
    new RandomReplacement<DummyData>(1, null);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorZeroSize() {
    new RandomReplacement<DummyData>(0);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorNegativeSize() {
    new RandomReplacement<DummyData>(-1);
  }

  @Test
  public void testCacheData() {
    long seed = 800L;
    Random rand = new Random(seed);
    // Standard caching behavior
    RandomReplacement<DummyData> uut = new RandomReplacement<>(storage, 6500,
        predicate -> predicate != null, seed);
    uut.cacheData(c0);
    assertTrue(uut.dataIsInCache(c0.getId()));
    uut.cacheData(c1);
    assertTrue(uut.dataIsInCache(c1.getId()));
    uut.cacheData(c2);
    assertTrue(uut.dataIsInCache(c2.getId()));

    ArrayList<DummyData> cacheValues = new ArrayList<>();
    cacheValues.add(c0);
    cacheValues.add(c1);
    cacheValues.add(c2);

    uut.cacheData(c3);
    determineReplacement(cacheValues, rand, c3);
    assertEquals(cacheValues.contains(c0), uut.dataIsInCache(c0.getId()));
    assertEquals(cacheValues.contains(c1), uut.dataIsInCache(c1.getId()));
    assertEquals(cacheValues.contains(c2), uut.dataIsInCache(c2.getId()));
    assertEquals(cacheValues.contains(c3), uut.dataIsInCache(c3.getId()));
    uut.cacheData(c3);
    assertEquals(cacheValues.contains(c0), uut.dataIsInCache(c0.getId()));
    assertEquals(cacheValues.contains(c1), uut.dataIsInCache(c1.getId()));
    assertEquals(cacheValues.contains(c2), uut.dataIsInCache(c2.getId()));
    assertEquals(cacheValues.contains(c3), uut.dataIsInCache(c3.getId()));
    uut.cacheData(c0);
    determineReplacement(cacheValues, rand, c0);
    assertEquals(cacheValues.contains(c0), uut.dataIsInCache(c0.getId()));
    assertEquals(cacheValues.contains(c1), uut.dataIsInCache(c1.getId()));
    assertEquals(cacheValues.contains(c2), uut.dataIsInCache(c2.getId()));
    assertEquals(cacheValues.contains(c3), uut.dataIsInCache(c3.getId()));
  }

  private void determineReplacement(ArrayList<DummyData> cacheValues, Random rand, DummyData data) {
    long size = 0;
    while (size < data.getByteSize()) {
      int nextElement = rand.nextInt(cacheValues.size());
      size += cacheValues.get(nextElement).getByteSize();
      cacheValues.remove(nextElement);
    }
    cacheValues.add(data);
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/TestAbstractCache.java,"package tools.descartes.teastore.image.cache;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.when;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import tools.descartes.teastore.image.StoreImage;
import tools.descartes.teastore.image.cache.entry.ICacheEntry;
import tools.descartes.teastore.image.storage.IDataStorage;

public class TestAbstractCache {

  private ArrayList<ICacheEntry<StoreImage>> entries;

  @Mock
  private StoreImage c0;
  @Mock
  private StoreImage c1;
  @Mock
  private StoreImage c2;
  @Mock
  private StoreImage c3;
  @Mock
  private StoreImage c4;
  @Mock
  private IDataStorage<StoreImage> storageAll;
  @Mock
  private IDataStorage<StoreImage> storageNone;

  @Before
  public void initialize() {
    MockitoAnnotations.openMocks(this);
    when(c0.getId()).thenReturn(0L);
    when(c0.getByteSize()).thenReturn(1000L);
    when(c1.getId()).thenReturn(1L);
    when(c1.getByteSize()).thenReturn(2000L);
    when(c2.getId()).thenReturn(2L);
    when(c2.getByteSize()).thenReturn(3000L);
    when(c3.getId()).thenReturn(3L);
    when(c3.getByteSize()).thenReturn(4000L);
    when(c4.getId()).thenReturn(4L);
    when(c4.getByteSize()).thenReturn(1000L, 1000L, 1000L, 3000L);
    when(storageAll.dataExists(anyLong())).thenReturn(false);
    when(storageAll.dataExists(0)).thenReturn(true);
    when(storageAll.dataExists(1)).thenReturn(true);
    when(storageAll.dataExists(2)).thenReturn(true);
    when(storageAll.dataExists(3)).thenReturn(true);
    when(storageAll.loadData(anyLong())).thenReturn(null);
    when(storageAll.loadData(0)).thenReturn(c0);
    when(storageAll.loadData(1)).thenReturn(c1);
    when(storageAll.loadData(2)).thenReturn(c2);
    when(storageAll.loadData(3)).thenReturn(c3);
    when(storageAll.saveData(any())).thenReturn(true);
    when(storageAll.saveData(c3)).thenReturn(false);
    when(storageAll.dataIsStorable(any())).thenReturn(true);
    when(storageAll.deleteData(any())).thenReturn(false);
    when(storageAll.deleteData(c0)).thenReturn(true, false);
    when(storageAll.deleteData(c1)).thenReturn(true, false);
    when(storageAll.deleteData(c2)).thenReturn(true, false);
    when(storageAll.deleteData(c3)).thenReturn(true, false);
    when(storageNone.dataIsStorable(any())).thenReturn(false);

    entries = new ArrayList<>();
  }

  @Test
  public void testConstructor() {
    new AbstractCacheWrapper(entries, storageAll, 1, predicate -> true);
  }

  @Test
  public void testConstructorStorageNull() {
    new AbstractCacheWrapper(entries, null, 1, predicate -> true);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorCollectionNull() {
    new AbstractCacheWrapper(null, storageAll, 1, predicate -> true);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorPredicateNull() {
    new AbstractCacheWrapper(entries, storageAll, 1, null);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorZeroSize() {
    new AbstractCacheWrapper(entries, storageAll, 0, predicate -> true);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorNegativeSize() {
    new AbstractCacheWrapper(entries, storageAll, -1, predicate -> true);
  }

  @Test
  public void testGetMaxCacheSize() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, storageAll,
        IDataCache.STD_MAX_CACHE_SIZE, predicate -> true);
    assertEquals(IDataCache.STD_MAX_CACHE_SIZE, uut.getMaxCacheSize());
    uut = new AbstractCacheWrapper(entries, storageAll, 1234567890, predicate -> true);
    assertEquals(1234567890, uut.getMaxCacheSize());
  }

  @Test
  public void testGetCurrentCacheSize() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, storageAll,
        IDataCache.STD_MAX_CACHE_SIZE, predicate -> true);
    assertEquals(0, uut.getCurrentCacheSize());
    uut.cacheData(c0);
    assertEquals(c0.getByteSize(), uut.getCurrentCacheSize());
    uut.cacheData(c1);
    assertEquals(c0.getByteSize() + c1.getByteSize(), uut.getCurrentCacheSize());
  }

  @Test
  public void testGetFreeSpace() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, storageAll,
        IDataCache.STD_MAX_CACHE_SIZE, predicate -> true);
    assertEquals(IDataCache.STD_MAX_CACHE_SIZE, uut.getFreeSpace());
    uut.cacheData(c0);
    assertEquals(IDataCache.STD_MAX_CACHE_SIZE - c0.getByteSize(), uut.getFreeSpace());
    uut.cacheData(c1);
    assertEquals(IDataCache.STD_MAX_CACHE_SIZE - (c0.getByteSize() + c1.getByteSize()),
        uut.getFreeSpace());
  }

  @Test
  public void testHasStorageFor() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, null, 6500, predicate -> true);
    assertTrue(uut.hasStorageFor(c0.getByteSize()));
    assertTrue(uut.hasStorageFor(c1.getByteSize()));
    assertTrue(uut.hasStorageFor(c2.getByteSize()));
    assertTrue(uut.hasStorageFor(c3.getByteSize()));
    uut.cacheData(c0);
    uut.cacheData(c1);
    assertTrue(uut.hasStorageFor(c0.getByteSize()));
    assertTrue(uut.hasStorageFor(c1.getByteSize()));
    assertTrue(uut.hasStorageFor(c2.getByteSize()));
    assertFalse(uut.hasStorageFor(c3.getByteSize()));
    uut.cacheData(c2);
    assertFalse(uut.hasStorageFor(c0.getByteSize()));
    assertFalse(uut.hasStorageFor(c1.getByteSize()));
    assertFalse(uut.hasStorageFor(c2.getByteSize()));
    assertFalse(uut.hasStorageFor(c3.getByteSize()));
  }

  @Test
  public void testUncacheData() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, storageAll, 20000,
        predicate -> true);
    uut.uncacheData(c0);
    assertFalse(uut.dataIsInCache(c0.getId()));
    uut.cacheData(c0);
    uut.cacheData(c1);
    uut.cacheData(c2);
    uut.cacheData(c3);

    assertTrue(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertTrue(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));

    uut.uncacheData(c2);
    assertTrue(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));

    uut.uncacheData(c2);
    assertTrue(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));

    uut.uncacheData(c3);
    assertTrue(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertFalse(uut.dataIsInCache(c3.getId()));

    entries.clear();
    uut = new AbstractCacheWrapper(entries, storageAll, 2000, predicate -> true);
    uut.cacheData(c4);
    uut.uncacheData(c4);
    assertEquals(0, uut.getCurrentCacheSize());
  }

  @Test
  public void testDataIsCachable() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, storageAll, 20000,
        predicate -> true);
    assertTrue(uut.dataIsCachable(c0));
    assertTrue(uut.dataIsCachable(c1));
    assertTrue(uut.dataIsCachable(c2));
    assertTrue(uut.dataIsCachable(c3));

    entries.clear();
    uut = new AbstractCacheWrapper(entries, storageAll, 20000, predicate -> false);
    assertFalse(uut.dataIsCachable(c0));
    assertFalse(uut.dataIsCachable(c1));
    assertFalse(uut.dataIsCachable(c2));
    assertFalse(uut.dataIsCachable(c3));

    entries.clear();
    uut = new AbstractCacheWrapper(entries, storageAll, 20000,
        predicate -> predicate.getId() == c1.getId() || predicate.getId() == c3.getId());
    assertFalse(uut.dataIsCachable(c0));
    assertTrue(uut.dataIsCachable(c1));
    assertFalse(uut.dataIsCachable(c2));
    assertTrue(uut.dataIsCachable(c3));
  }

  @Test
  public void testDataIsInCache() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, storageAll, 20000,
        predicate -> true);
    uut.cacheData(c0);
    uut.cacheData(c1);
    assertTrue(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertFalse(uut.dataIsInCache(c3.getId()));
  }

  @Test
  public void testClearCache() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, storageAll, 20000,
        predicate -> true);
    uut.clearCache();
    uut.cacheData(c0);
    uut.cacheData(c1);
    assertTrue(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    uut.clearCache();
    assertFalse(uut.dataIsInCache(c0.getId()));
    assertFalse(uut.dataIsInCache(c1.getId()));
  }

  @Test
  public void testSetMaxCacheSize() {
    final long startSize = 1100;
    final long newSize = 5000;
    final long smallSize = 1000;
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, storageAll, startSize,
        predicate -> true);
    assertEquals(startSize, uut.getMaxCacheSize());

    uut.cacheData(c0);
    assertTrue(uut.dataIsInCache(c0.getId()));
    assertEquals(startSize, uut.getMaxCacheSize());

    assertTrue(uut.setMaxCacheSize(newSize));
    assertEquals(newSize, uut.getMaxCacheSize());
    uut.cacheData(c1);
    assertTrue(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));

    assertTrue(uut.setMaxCacheSize(smallSize));
    assertEquals(smallSize, uut.getMaxCacheSize());
    assertFalse(uut.dataIsInCache(c0.getId()));
    assertFalse(uut.dataIsInCache(c1.getId()));

  }

  @Test
  public void testDataExists() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, null, 20000, predicate -> true);
    assertFalse(uut.dataExists(c0.getId()));

    uut.cacheData(c0);
    uut.cacheData(c2);
    assertTrue(uut.dataExists(c0.getId()));
    assertFalse(uut.dataExists(c1.getId()));
    assertTrue(uut.dataExists(c2.getId()));
    assertFalse(uut.dataExists(c3.getId()));

    entries.clear();
    uut = new AbstractCacheWrapper(entries, storageAll, 20000, predicate -> true);
    assertTrue(uut.dataExists(c0.getId()));
    assertTrue(uut.dataExists(c1.getId()));
    assertTrue(uut.dataExists(c2.getId()));
    assertTrue(uut.dataExists(c3.getId()));
  }

  @Test
  public void testLoadData() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, null, 20000, predicate -> true);

    uut.cacheData(c0);
    uut.cacheData(c2);
    assertEquals(c0, uut.loadData(c0.getId()));
    assertEquals(null, uut.loadData(c1.getId()));
    assertEquals(c2, uut.loadData(c2.getId()));
    assertEquals(null, uut.loadData(c3.getId()));

    entries.clear();
    uut = new AbstractCacheWrapper(entries, storageAll, 20000, predicate -> true);
    assertEquals(c0, uut.loadData(c0.getId()));
    assertEquals(c1, uut.loadData(c1.getId()));
    assertEquals(c2, uut.loadData(c2.getId()));
    assertEquals(c3, uut.loadData(c3.getId()));
  }

  @Test
  public void testSaveData() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, storageAll, 20000,
        predicate -> true);
    assertTrue(uut.saveData(c0));
    assertTrue(uut.saveData(c1));
    assertTrue(uut.saveData(c2));
    assertFalse(uut.saveData(c3));

    assertTrue(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertTrue(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));

    assertFalse(uut.saveData(null));

    entries.clear();
    uut = new AbstractCacheWrapper(entries, null, 20000, predicate -> true);
    assertFalse(uut.saveData(c0));
    assertFalse(uut.saveData(c1));
    assertFalse(uut.saveData(c2));
    assertFalse(uut.saveData(c3));

    assertTrue(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertTrue(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));

    assertFalse(uut.saveData(null));
  }

  @Test
  public void testDataIsStorable() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, storageAll, 20000,
        predicate -> true);
    assertTrue(uut.dataIsStorable(c0));
    assertTrue(uut.dataIsStorable(null));

    entries.clear();
    uut = new AbstractCacheWrapper(entries, storageNone, 20000, predicate -> true);
    assertFalse(uut.dataIsStorable(c0));
    assertFalse(uut.dataIsStorable(null));
  }

  @Test
  public void testDeleteData() {
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, storageAll, 20000,
        predicate -> true);
    uut.cacheData(c0);
    uut.cacheData(c1);

    assertTrue(uut.deleteData(c0));
    assertFalse(uut.deleteData(c0));
    assertTrue(uut.deleteData(c1));
    assertFalse(uut.deleteData(c1));
  }

  @Test
  public void testCacheData() {
    // Standard caching behavior
    AbstractCacheWrapper uut = new AbstractCacheWrapper(entries, storageAll, 6500,
        predicate -> predicate != null);
    uut.cacheData(c0);
    assertTrue(uut.dataIsInCache(c0.getId()));
    uut.cacheData(c1);
    assertTrue(uut.dataIsInCache(c1.getId()));
    uut.cacheData(null);

    uut.cacheData(c3);
    assertFalse(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));

    // Caching duplicate
    uut.cacheData(c3);
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));

    // Test cache that denies all entries
    entries.clear();
    uut = new AbstractCacheWrapper(entries, storageAll, 6500, predicate -> false);
    uut.cacheData(c0);
    assertFalse(uut.dataIsInCache(c0.getId()));
    uut.cacheData(c1);
    assertFalse(uut.dataIsInCache(c1.getId()));

    // Test not caching items larger than the max cache size (should not modify
    // already cached data)
    entries.clear();
    uut = new AbstractCacheWrapper(entries, storageAll, 1000, predicate -> true);
    uut.cacheData(c3);
    assertFalse(uut.dataIsInCache(c3.getId()));
  }
}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/TestFirstInFirstOut.java,"package tools.descartes.teastore.image.cache;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

public class TestFirstInFirstOut extends AbstractCacheTestInit {

  @Test
  public void testConstructorSimple() {
    new FirstInFirstOut<DummyData>();
  }

  @Test
  public void testConstructorSize() {
    new FirstInFirstOut<DummyData>(24 * 1024 * 1024);
    new FirstInFirstOut<DummyData>(1);
  }

  @Test
  public void testConstructorSizePredicate() {
    new FirstInFirstOut<DummyData>(1, predicate -> true);
  }

  @Test
  public void testConstructorStorageSizePredicate() {
    new FirstInFirstOut<DummyData>(storage, 1, predicate -> true);
  }

  @Test
  public void testConstructorStorageNull() {
    new FirstInFirstOut<DummyData>(null, 1, predicate -> true);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorPredicateNull() {
    new FirstInFirstOut<DummyData>(1, null);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorZeroSize() {
    new FirstInFirstOut<DummyData>(0);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorNegativeSize() {
    new FirstInFirstOut<DummyData>(-1);
  }

  @Test
  public void testCacheData() {
    // Standard caching behavior
    FirstInFirstOut<DummyData> uut = new FirstInFirstOut<>(storage, 6500,
        predicate -> predicate != null);
    uut.cacheData(c0);
    assertTrue(uut.dataIsInCache(c0.getId()));
    uut.cacheData(c1);
    assertTrue(uut.dataIsInCache(c1.getId()));
    uut.cacheData(c2);
    assertTrue(uut.dataIsInCache(c2.getId()));

    uut.cacheData(c3);
    assertFalse(uut.dataIsInCache(c0.getId()));
    assertFalse(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));
    uut.cacheData(c3);
    assertFalse(uut.dataIsInCache(c0.getId()));
    assertFalse(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));
    uut.cacheData(c0);
    assertTrue(uut.dataIsInCache(c0.getId()));
    assertFalse(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/TestLastInFirstOut.java,"package tools.descartes.teastore.image.cache;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

public class TestLastInFirstOut extends AbstractCacheTestInit {

  @Test
  public void testConstructorSimple() {
    new LastInFirstOut<DummyData>();
  }

  @Test
  public void testConstructorSize() {
    new LastInFirstOut<DummyData>(24 * 1024 * 1024);
    new LastInFirstOut<DummyData>(1);
  }

  @Test
  public void testConstructorSizePredicate() {
    new LastInFirstOut<DummyData>(1, predicate -> true);
  }

  @Test
  public void testConstructorStorageSizePredicate() {
    new LastInFirstOut<DummyData>(storage, 1, predicate -> true);
  }

  @Test
  public void testConstructorStorageNull() {
    new LastInFirstOut<DummyData>(null, 1, predicate -> true);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorPredicateNull() {
    new LastInFirstOut<DummyData>(1, null);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorZeroSize() {
    new LastInFirstOut<DummyData>(0);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorNegativeSize() {
    new LastInFirstOut<DummyData>(-1);
  }

  @Test
  public void testCacheData() {
    // Standard caching behavior
    LastInFirstOut<DummyData> uut = new LastInFirstOut<>(storage, 6500,
        predicate -> predicate != null);
    uut.cacheData(c0);
    assertTrue(uut.dataIsInCache(c0.getId()));
    uut.cacheData(c1);
    assertTrue(uut.dataIsInCache(c1.getId()));
    uut.cacheData(c2);
    assertTrue(uut.dataIsInCache(c2.getId()));

    uut.cacheData(c3);
    assertTrue(uut.dataIsInCache(c0.getId()));
    assertFalse(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));
    uut.cacheData(c3);
    assertTrue(uut.dataIsInCache(c0.getId()));
    assertFalse(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));
    uut.cacheData(c1);
    assertTrue(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertFalse(uut.dataIsInCache(c3.getId()));
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/AbstractCacheTestInit.java,"package tools.descartes.teastore.image.cache;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.when;

import org.junit.Before;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import tools.descartes.teastore.image.storage.IDataStorage;

public class AbstractCacheTestInit {

  protected DummyData c0 = new DummyData(0L, 1000L);
  protected DummyData c1 = new DummyData(1L, 2000L);
  protected DummyData c2 = new DummyData(2L, 3000L);
  protected DummyData c3 = new DummyData(3L, 4000L);
  @Mock
  protected IDataStorage<DummyData> storage;

  @Before
  public void initialize() {
    MockitoAnnotations.openMocks(this);
    // when(c0.getId()).thenReturn(0L);
    // when(c0.getByteSize()).thenReturn(1000L);
    // when(c0.equals(any())).thenReturn(false);
    // when(c0.equals(c0)).thenReturn(true);
    // when(c1.getId()).thenReturn(1L);
    // when(c1.getByteSize()).thenReturn(2000L);
    // when(c1.equals(any())).thenReturn(false);
    // when(c1.equals(c1)).thenReturn(true);
    // when(c2.getId()).thenReturn(2L);
    // when(c2.getByteSize()).thenReturn(3000L);
    // when(c2.equals(any())).thenReturn(false);
    // when(c2.equals(c2)).thenReturn(true);
    // when(c3.getId()).thenReturn(3L);
    // when(c3.getByteSize()).thenReturn(4000L);
    // when(c3.equals(any())).thenReturn(false);
    // when(c3.equals(c3)).thenReturn(true);
    when(storage.dataExists(anyLong())).thenReturn(false);
    when(storage.dataExists(0)).thenReturn(true);
    when(storage.dataExists(1)).thenReturn(true);
    when(storage.dataExists(2)).thenReturn(true);
    when(storage.dataExists(3)).thenReturn(true);
    when(storage.loadData(anyLong())).thenReturn(null);
    when(storage.loadData(0)).thenReturn(c0);
    when(storage.loadData(1)).thenReturn(c1);
    when(storage.loadData(2)).thenReturn(c2);
    when(storage.loadData(3)).thenReturn(c3);
    when(storage.saveData(any())).thenReturn(true);
    when(storage.saveData(c3)).thenReturn(false);
    when(storage.dataIsStorable(any())).thenReturn(true);
    when(storage.deleteData(any())).thenReturn(false);
    when(storage.deleteData(c0)).thenReturn(true, false);
    when(storage.deleteData(c1)).thenReturn(true, false);
    when(storage.deleteData(c2)).thenReturn(true, false);
    when(storage.deleteData(c3)).thenReturn(true, false);
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/TestLeastRecentlyUsed.java,"package tools.descartes.teastore.image.cache;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

public class TestLeastRecentlyUsed extends AbstractCacheTestInit {

  @Test
  public void testConstructorSimple() {
    new LeastRecentlyUsed<DummyData>();
  }

  @Test
  public void testConstructorSize() {
    new LeastRecentlyUsed<DummyData>(24 * 1024 * 1024);
    new LeastRecentlyUsed<DummyData>(1);
  }

  @Test
  public void testConstructorSizePredicate() {
    new LeastRecentlyUsed<DummyData>(1, predicate -> true);
  }

  @Test
  public void testConstructorStorageSizePredicate() {
    new LeastRecentlyUsed<DummyData>(storage, 1, predicate -> true);
  }

  @Test
  public void testConstructorStorageNull() {
    new LeastRecentlyUsed<DummyData>(null, 1, predicate -> true);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorPredicateNull() {
    new LeastRecentlyUsed<DummyData>(1, null);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorZeroSize() {
    new LeastRecentlyUsed<DummyData>(0);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorNegativeSize() {
    new LeastRecentlyUsed<DummyData>(-1);
  }

  @Test
  public void testCacheData() {
    // Standard caching behavior
    LeastRecentlyUsed<DummyData> uut = new LeastRecentlyUsed<>(storage, 6500,
        predicate -> predicate != null);
    uut.cacheData(c0);
    assertTrue(uut.dataIsInCache(c0.getId()));
    uut.cacheData(c1);
    assertTrue(uut.dataIsInCache(c1.getId()));
    uut.cacheData(c2);
    assertTrue(uut.dataIsInCache(c2.getId()));
    uut.loadData(c2.getId());
    uut.loadData(c1.getId());

    uut.cacheData(c3);
    assertFalse(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));
    uut.cacheData(c3);
    assertFalse(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/entry/TestAbstractEntry.java,"package tools.descartes.teastore.image.cache.entry;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import tools.descartes.teastore.image.StoreImage;

public class TestAbstractEntry {

  private static final long MOCKED_BYTE_SIZE = 5000;
  private static final long MOCKED_ID = 1234567890;

  @Mock
  private StoreImage mockedImg;
  @Mock
  private StoreImage mockedImgNotEqual;
  @Mock
  private AbstractEntry<StoreImage> nullEntry;

  @Before
  public void initialize() {
    MockitoAnnotations.openMocks(this);
    when(mockedImg.getByteSize()).thenReturn(MOCKED_BYTE_SIZE);
    when(mockedImg.getId()).thenReturn(MOCKED_ID);
    when(mockedImgNotEqual.getByteSize()).thenReturn(300L);
    when(mockedImgNotEqual.getId()).thenReturn(9876543210L);
    when(nullEntry.getData()).thenReturn(null);
  }

  @Test
  public void testConstructor() {
    new AbstractEntryWrapper(mockedImg);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorNull() {
    new AbstractEntryWrapper(null);
  }

  @Test
  public void testUseCount() {
    AbstractEntryWrapper uut = new AbstractEntryWrapper(mockedImg);
    uut.wasUsed();
  }

  @Test
  public void testGetData() {
    AbstractEntryWrapper uut = new AbstractEntryWrapper(mockedImg);
    assertEquals(mockedImg, uut.getData());
  }

  @Test
  public void testGetByteSize() {
    AbstractEntryWrapper uut = new AbstractEntryWrapper(mockedImg);
    assertEquals(MOCKED_BYTE_SIZE, uut.getByteSize());
  }

  @Test
  public void testGetID() {
    AbstractEntryWrapper uut = new AbstractEntryWrapper(mockedImg);
    assertEquals(MOCKED_ID, uut.getId());
  }

  @Test
  public void testEquals() {
    AbstractEntryWrapper uut = new AbstractEntryWrapper(mockedImg);
    AbstractEntryWrapper uut2 = new AbstractEntryWrapper(mockedImgNotEqual);
    assertTrue(uut.equals(uut));
    assertFalse(uut.equals(uut2));
    assertFalse(uut.equals(null));
    assertFalse(uut.equals(nullEntry));
  }
}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/entry/TestSimpleEntry.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache.entry;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import tools.descartes.teastore.image.StoreImage;

public class TestSimpleEntry {

  @Mock
  private StoreImage mockedImg;

  @Before
  public void initialize() {
    MockitoAnnotations.openMocks(this);
  }

  @Test
  public void testConstructor() {
    new SimpleEntry<>(mockedImg);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorNull() {
    new SimpleEntry<StoreImage>(null);
  }

  @Test
  public void testUseCount() {
    SimpleEntry<StoreImage> uut = new SimpleEntry<>(mockedImg);
    uut.wasUsed();
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/entry/TestTimedEntry.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache.entry;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import tools.descartes.teastore.image.StoreImage;

public class TestTimedEntry {

  @Mock
  private StoreImage mockedImg;

  @Before
  public void initialize() {
    MockitoAnnotations.openMocks(this);
  }

  @Test
  public void testConstructor() {
    new TimedEntry<>(mockedImg);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorNull() {
    new TimedEntry<StoreImage>(null);
  }

  @Test
  public void testTime() {
    TimedEntry<StoreImage> uut = new TimedEntry<>(mockedImg);
    assertNotEquals(0L, uut.getTime());
    long uutTime = uut.getTime();
    uut.wasUsed();
    assertNotEquals(uutTime, uut.getTime());
    long currentTime = System.nanoTime();
    uut.wasUsed();
    assertEquals(currentTime, uut.getTime(), 5e5);
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/entry/AbstractEntryWrapper.java,"package tools.descartes.teastore.image.cache.entry;

import tools.descartes.teastore.image.StoreImage;

public class AbstractEntryWrapper extends AbstractEntry<StoreImage> {

  public AbstractEntryWrapper(StoreImage data) {
    super(data);
  }

  @Override
  public void wasUsed() {

  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/entry/TestCountedEntry.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache.entry;

import static org.junit.Assert.assertEquals;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import tools.descartes.teastore.image.StoreImage;

public class TestCountedEntry {

  @Mock
  private StoreImage mockedImg;

  @Before
  public void initialize() {
    MockitoAnnotations.openMocks(this);
  }

  @Test
  public void testConstructor() {
    new CountedEntry<>(mockedImg);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorNull() {
    new CountedEntry<StoreImage>(null);
  }

  @Test
  public void testUseCount() {
    CountedEntry<StoreImage> uut = new CountedEntry<>(mockedImg);
    assertEquals(0, uut.getUseCount());
    uut.wasUsed();
    assertEquals(1, uut.getUseCount());
    uut.wasUsed();
    uut.wasUsed();
    assertEquals(3, uut.getUseCount());
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/AbstractCacheWrapper.java,"package tools.descartes.teastore.image.cache;

import java.util.ArrayList;
import java.util.function.Predicate;

import tools.descartes.teastore.image.StoreImage;
import tools.descartes.teastore.image.cache.entry.ICacheEntry;
import tools.descartes.teastore.image.storage.IDataStorage;

public final class AbstractCacheWrapper
    extends AbstractCache<ArrayList<ICacheEntry<StoreImage>>, StoreImage, ICacheEntry<StoreImage>> {

  public AbstractCacheWrapper(ArrayList<ICacheEntry<StoreImage>> entries,
      IDataStorage<StoreImage> cachedStorage, long maxCacheSize,
      Predicate<StoreImage> cachingRule) {
    super(entries, cachedStorage, maxCacheSize, cachingRule);
  }

  @Override
  protected void removeEntryByCachingStrategy() {
    dataRemovedFromCache(getEntries().remove(0).getByteSize());
  }

  @Override
  protected ICacheEntry<StoreImage> createEntry(StoreImage data) {
    return new DummyEntry(data);
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/DummyData.java,"package tools.descartes.teastore.image.cache;

import tools.descartes.teastore.image.cache.entry.ICachable;

public class DummyData implements ICachable<DummyData> {

  private long byteSize;
  private long id;

  public DummyData(long id, long byteSize) {
    this.byteSize = byteSize;
    this.id = id;
  }

  @Override
  public long getByteSize() {
    return byteSize;
  }

  @Override
  public long getId() {
    return id;
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (int) (id ^ (id >>> 32));
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    DummyData other = (DummyData) obj;
    if (id != other.id) {
      return false;
    }
    return true;
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/TestLeastFrequentlyUsed.java,"package tools.descartes.teastore.image.cache;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;


public class TestLeastFrequentlyUsed extends AbstractCacheTestInit {

  @Test
  public void testConstructorSimple() {
    new LeastFrequentlyUsed<DummyData>();
  }

  @Test
  public void testConstructorSize() {
    new LeastFrequentlyUsed<DummyData>(24 * 1024 * 1024);
    new LeastFrequentlyUsed<DummyData>(1);
  }

  @Test
  public void testConstructorSizePredicate() {
    new LeastFrequentlyUsed<DummyData>(1, predicate -> true);
  }

  @Test
  public void testConstructorStorageSizePredicate() {
    new LeastFrequentlyUsed<DummyData>(storage, 1, predicate -> true);
  }

  @Test
  public void testConstructorStorageNull() {
    new LeastFrequentlyUsed<DummyData>(null, 1, predicate -> true);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorPredicateNull() {
    new LeastFrequentlyUsed<DummyData>(1, null);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorZeroSize() {
    new LeastFrequentlyUsed<DummyData>(0);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorNegativeSize() {
    new LeastFrequentlyUsed<DummyData>(-1);
  }

  @Test
  public void testCacheData() {
    // Standard caching behavior
    LeastFrequentlyUsed<DummyData> uut = new LeastFrequentlyUsed<>(storage, 6500,
        predicate -> predicate != null);
    uut.cacheData(c0);
    assertTrue(uut.dataIsInCache(c0.getId()));
    uut.cacheData(c1);
    assertTrue(uut.dataIsInCache(c1.getId()));
    uut.cacheData(c2);
    assertTrue(uut.dataIsInCache(c2.getId()));
    uut.loadData(c0.getId());
    uut.loadData(c1.getId());
    uut.loadData(c1.getId());
    uut.cacheData(c3);
    assertFalse(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));
    uut.cacheData(c3);
    assertFalse(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/DummyEntry.java,"package tools.descartes.teastore.image.cache;

import tools.descartes.teastore.image.StoreImage;
import tools.descartes.teastore.image.cache.entry.ICacheEntry;

public final class DummyEntry implements ICacheEntry<StoreImage> {

  private final StoreImage data;

  public DummyEntry(StoreImage data) {
    this.data = data;
  }

  @Override
  public void wasUsed() {
  }

  @Override
  public long getByteSize() {
    return data.getByteSize();
  }

  @Override
  public long getId() {
    return data.getId();
  }

  @Override
  public StoreImage getData() {
    return data;
  }

  @Override
  public int hashCode() {
    return 0;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    DummyEntry other = (DummyEntry) obj;
    if (data == null) {
      if (other.data != null)
        return false;
    } else if (data.getId() != other.data.getId())
      return false;
    return true;
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/TestMostRecentlyUsed.java,"package tools.descartes.teastore.image.cache;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;


public class TestMostRecentlyUsed extends AbstractCacheTestInit {

  @Test
  public void testConstructorSimple() {
    new MostRecentlyUsed<DummyData>();
  }

  @Test
  public void testConstructorSize() {
    new MostRecentlyUsed<DummyData>(24 * 1024 * 1024);
    new MostRecentlyUsed<DummyData>(1);
  }

  @Test
  public void testConstructorSizePredicate() {
    new MostRecentlyUsed<DummyData>(1, predicate -> true);
  }

  @Test
  public void testConstructorStorageSizePredicate() {
    new MostRecentlyUsed<DummyData>(storage, 1, predicate -> true);
  }

  @Test
  public void testConstructorStorageNull() {
    new MostRecentlyUsed<DummyData>(null, 1, predicate -> true);
  }

  @Test(expected = NullPointerException.class)
  public void testConstructorPredicateNull() {
    new MostRecentlyUsed<DummyData>(1, null);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorZeroSize() {
    new MostRecentlyUsed<DummyData>(0);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testConstructorNegativeSize() {
    new MostRecentlyUsed<DummyData>(-1);
  }

  @Test
  public void testCacheData() {
    // Standard caching behavior
    MostRecentlyUsed<DummyData> uut = new MostRecentlyUsed<>(storage, 6500,
        predicate -> predicate != null);
    uut.cacheData(c0);
    assertTrue(uut.dataIsInCache(c0.getId()));
    uut.cacheData(c1);
    assertTrue(uut.dataIsInCache(c1.getId()));
    uut.cacheData(c2);
    assertTrue(uut.dataIsInCache(c2.getId()));
    uut.loadData(c0.getId());

    uut.cacheData(c3);
    assertFalse(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));
    uut.cacheData(c3);
    assertFalse(uut.dataIsInCache(c0.getId()));
    assertTrue(uut.dataIsInCache(c1.getId()));
    assertFalse(uut.dataIsInCache(c2.getId()));
    assertTrue(uut.dataIsInCache(c3.getId()));
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/cache/rules/TestCacheAll.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache.rules;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import tools.descartes.teastore.image.StoreImage;

public class TestCacheAll {

  @Mock
  private StoreImage mockedImg;

  @Before
  public void initialize() {
    MockitoAnnotations.openMocks(this);
  }

  @Test
  public void testRule() {
    CacheAll<StoreImage> uut = new CacheAll<>();
    assertTrue(uut.test(mockedImg));
    assertTrue(uut.test(null));
  }

}"
services/tools.descartes.teastore.image/src/test/java/tools/descartes/teastore/image/TestImageProvider.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image;

public class TestImageProvider {

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/storage/IDataStorage.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.storage;

import tools.descartes.teastore.image.cache.entry.ICachable;

/**
 * Generic data storage interface providing all necessary methods for saving and loading data to the storage.
 * @author Norbert Schmitt
 *
 * @param <T> Entry Type implementing ICachable.
 */
public interface IDataStorage<T extends ICachable<T>> {

  /**
   * Check whether data with the given ID resides in the storage.
   * @param id ID to check for.
   * @return True if the data with the given ID is found, otherwise false.
   */
  public boolean dataExists(long id);

  /**
   * Returns the data with the given ID if it resides in the storage.
   * @param id ID of data to load.
   * @return The data if it resides in storage or NULL if ID does not reside in storage.
   */
  public T loadData(long id);

  /**
   * Save data in the storage.
   * @param data Data to save in the storage.
   * @return True if data was saved in the storage, otherwise false.
   */
  public boolean saveData(T data);

  /**
   * Checks whether data can be saved in the storage according to the storage rule.
   * @param data Data to check if it complies with the storage rule and can be stored.
   * @return True if the data complies with the storage rule, otherwise false.
   */
  public boolean dataIsStorable(T data);

  /**
   * Removes the data from storage.
   * @param data Data to be removed from storage.
   * @return True if the data was deleted, otherwise false.
   */
  public boolean deleteData(T data);
}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/storage/DriveStorage.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.storage;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.HashMap;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.Predicate;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.entities.ImageSize;
import tools.descartes.teastore.image.ImageDB;
import tools.descartes.teastore.image.StoreImage;

/**
 * Storage implementation that saves data in a directory on the physical disc.
 * @author Norbert Schmitt
 */
public class DriveStorage implements IDataStorage<StoreImage> {

  private Path workingDir;
  private ImageDB imgDB;
  private Predicate<StoreImage> storageRule;
  private Logger log = LoggerFactory.getLogger(DriveStorage.class);

  private final HashMap<Long, ReadWriteLock> lockedIDs = new HashMap<>();
  private final ReadWriteLock mapLock = new ReentrantReadWriteLock();

  /**
   * Standard constructor creating a storage in the working directory on the physical disc.
   * @param workingDir Working directory on the physical disc where the data is stored.
   * @param imgDB Image database containing the IDs for the data.
   * @param storageRule Storage rule which data can be stored.
   */
  public DriveStorage(Path workingDir, ImageDB imgDB, Predicate<StoreImage> storageRule) {
    if (workingDir == null) {
      log.error(""The supplied working directory is null."");
      throw new NullPointerException(""The supplied working directory is null."");
    }
    if (imgDB == null) {
      log.error(""The supplied image database is null."");
      throw new NullPointerException(""The supplied image database is null."");
    }
    if (storageRule == null) {
      log.error(""The supplied rule to determine if an image can be stored is null."");
      throw new NullPointerException(
          ""The supplied rule to determine if an image can be stored is null."");
    }

    this.workingDir = workingDir.normalize();
    this.imgDB = imgDB;
    this.storageRule = storageRule;
  }

  @Override
  public boolean dataExists(long id) {
    return workingDir.resolve(Long.toString(id)).toFile().exists();
  }

  private ReadWriteLock getIDLock(long id) {
    ReadWriteLock l = null;
    mapLock.writeLock().lock();
    try {
      if (lockedIDs.containsKey(id)) {
        l = lockedIDs.get(id);
      } else {
        l = new ReentrantReadWriteLock();
        lockedIDs.put(id, l);
      }
    } finally {
      mapLock.writeLock().unlock();
    }
    return l;
  }

  /**
   * Returns the stored image on the physical disc for a given image id at the given path.
   * @param imgFile Image file path to load binary data.
   * @param id Image id to acquire the correct lock prohibiting write access to the file.
   * @return The image stored on disc or NULL if an IOException occurred during reading.
   */
  protected StoreImage loadFromDisk(Path imgFile, long id) {
    byte[] imgData = null;

    // Try aquiring a lock for a file.
    ReadWriteLock l = getIDLock(id);
    l.readLock().lock();
    try {
      imgData = Files.readAllBytes(imgFile);
    } catch (IOException ioException) {
      log.warn(""An IOException occured while trying to read the file \"""" + imgFile.toAbsolutePath()
          + ""\"" from disk. Returning null."", ioException);
    } finally {
      l.readLock().unlock();
    }

    if (imgData == null) {
      return null;
    }

    ImageSize size = imgDB.getImageSize(id);
    if (size == null) {
      return null;
    }

    return new StoreImage(id, imgData, size);
  }

  @Override
  public StoreImage loadData(long id) {
    Path imgFile = workingDir.resolve(Long.toString(id));
    if (!imgFile.toFile().exists()) {
      return null;
    }

    return loadFromDisk(imgFile, id);
  }

  @Override
  public boolean saveData(StoreImage data) {
    // We return true so we do not trigger an error. This is intended
    if (!dataIsStorable(data)) {
      return true;
    }

    Path imgFile = workingDir.resolve(Long.toString(data.getId()));
    if (imgFile.toFile().exists()) {
      return true;
    }

    ReadWriteLock l = getIDLock(data.getId());
    l.writeLock().lock();

    try {
      Files.write(imgFile, data.getByteArray(), StandardOpenOption.CREATE, StandardOpenOption.WRITE,
          StandardOpenOption.TRUNCATE_EXISTING);
    } catch (IOException ioException) {
      log.warn(""An IOException occured while trying to write the file \"""" + imgFile.toAbsolutePath()
          + ""\"" to disk."", ioException);
      return false;
    } finally {
      l.writeLock().unlock();
    }

    return true;
  }

  @Override
  public boolean dataIsStorable(StoreImage data) {
    return storageRule.test(data);
  }

  @Override
  public boolean deleteData(StoreImage data) {
    Path imgFile = workingDir.resolve(Long.toString(data.getId()));
    if (!imgFile.toFile().exists()) {
      return true;
    }

    boolean result = false;

    ReadWriteLock l = getIDLock(data.getId());
    l.writeLock().lock();
    try {
      result = imgFile.toFile().delete();
    } finally {
      l.writeLock().unlock();
    }

    return result;
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/storage/NoStorage.java,"package tools.descartes.teastore.image.storage;

import tools.descartes.teastore.image.cache.entry.ICachable;

/**
 * This is a dummy implementations to allows the image provider to be used as a cache only.
 * @author Norbert Schmitt
 *
 * @param <T> Entry Type implementing ICachable.
 */
public class NoStorage<T extends ICachable<T>> implements IDataStorage<T> {

  @Override
  public boolean dataExists(long id) {
    return false;
  }

  @Override
  public T loadData(long id) {
    return null;
  }

  @Override
  public boolean saveData(T data) {
    return false;
  }

  @Override
  public boolean dataIsStorable(T data) {
    return false;
  }

  @Override
  public boolean deleteData(T data) {
    return false;
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/storage/rules/StoreAll.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.storage.rules;

import java.util.function.Predicate;

import tools.descartes.teastore.image.cache.entry.ICachable;

/**
 * Rule for all images.
 * @author Norbert
 *
 * @param <T> cachable class
 */
public class StoreAll<T extends ICachable<T>> implements Predicate<T> {

  @Override
  public boolean test(T t) {
    return true;
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/storage/rules/StoreLargeImages.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.storage.rules;

import java.util.function.Predicate;

import tools.descartes.teastore.entities.ImageSizePreset;
import tools.descartes.teastore.image.StoreImage;

/**
 * Rule for large images.
 * @author Norbert
 *
 */
public class StoreLargeImages implements Predicate<StoreImage> {

  @Override
  public boolean test(StoreImage t) {
   if (t == null) {
     return false;
   } 
   return t.getSize().equals(ImageSizePreset.FULL.getSize());
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/ImageProvider.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image;

import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.entities.ImageSize;
import tools.descartes.teastore.entities.ImageSizePreset;
import tools.descartes.teastore.image.setup.ImageIDFactory;
import tools.descartes.teastore.image.storage.IDataStorage;

/**
 * The actual image provider class containing the mapping between products, web interface static images, the 
 * cache and underlying storage. Only one instance of an image provider can exist.
 * @author Norbert Schmitt
 */
public enum ImageProvider {

  /**
   * Instance of the image provider.
   */
  IP;

  /**
   * Standard image identifier if a product or web interface image cannot be found in the cache and storage.
   */
  public static final String IMAGE_NOT_FOUND = ""notFound"";

  private ImageDB db;
  private IDataStorage<StoreImage> storage;
  private Logger log = LoggerFactory.getLogger(ImageProvider.class);

  private ImageProvider() {

  }

  /**
   * Assign the image provider the mapping between products and web interface static images.
   * @param imgDB Image database, mapping between products and web interface static images.
   */
  public void setImageDB(ImageDB imgDB) {
	if (imgDB != null) {
	  db = imgDB;
	}
  }

  /**
   * Assign the storage containing all available images. This can either be a cache or the actual hard drive storage.
   * @param imgStorage Image storage containing all available images.
   */
  public void setStorage(IDataStorage<StoreImage> imgStorage) {
	if (imgStorage != null) {
      storage = imgStorage;
	}
  }

  /**
   * Searches and returns the requested product images in the requested sizes. If an image can not be found, the 
   * standard ""not found"" image is returned. If an image is found in the incorrect size, the largest size of this image 
   * will be scaled and the scaled version will be moved to storage and returned.
   * @param images Map of product IDs and image sizes to search for.
   * @return Map between product IDs and base64 encoded image data as string.
   */
  public Map<Long, String> getProductImages(Map<Long, ImageSize> images) {
    Map<Long, String> result = new HashMap<>();
    for (Map.Entry<Long, ImageSize> entry : images.entrySet()) {
      String imgStr = getImageFor(new ImageDBKey(entry.getKey()), entry.getValue());
      if (imgStr == null) {
        continue;
      }
      result.put(entry.getKey(), imgStr);
    }
    return result;
  }

  /**
   * Searches and returns the requested web interface images in the requested sizes. If an image can not be found, the 
   * standard ""not found"" image is returned. If an image is found in the incorrect size, the largest size of this image 
   * will be scaled and the scaled version will be moved to storage and returned.
   * @param images Map of product IDs and image sizes to search for.
   * @return Map between product IDs and base64 encoded image data as string.
   */
  public Map<String, String> getWebUIImages(Map<String, ImageSize> images) {
    Map<String, String> result = new HashMap<>();
    for (Map.Entry<String, ImageSize> entry : images.entrySet()) {
      String imgStr = getImageFor(new ImageDBKey(entry.getKey()), entry.getValue());
      if (imgStr == null) {
        continue;
      }
      result.put(entry.getKey(), imgStr);
    }
    return result;
  }

  private StoreImage scaleAndRegisterImg(BufferedImage image, ImageDBKey key, ImageSize size) {
    StoreImage storedImg = new StoreImage(ImageIDFactory.ID.getNextImageID(),
        ImageScaler.scale(image, size), size);
    db.setImageMapping(key, storedImg.getId(), size);
    storage.saveData(storedImg);
    return storedImg;
  }

  private String getImageFor(ImageDBKey key, ImageSize size) {
    if (db == null || storage == null) {
      log.warn(""Image provider not correctly initialized. Missing image database and storage."");
      return null;
    }
    if (key == null || size == null) {
      log.info(""Supplied image key or size are null."");
      return null;
    }
    if (!key.isProductKey() && (key.getWebUIName() == null || key.getWebUIName().isEmpty())) {
      log.info(""Supplied image key invalid. Is neither web image nor product image."");
      return null;
    }

    ImageSize stdSize = ImageSizePreset.STD_IMAGE_SIZE;
    StoreImage storedImg = null;

    // Try to retrieve image from disk or from cache
    long imgID = db.getImageID(key, size);
    if (imgID != 0) {
      storedImg = storage.loadData(imgID);
    }

    // If we dont have the image in the right size, get the biggest one and scale it
    if (storedImg == null) {
      storedImg = storage.loadData(db.getImageID(key, stdSize));
      if (storedImg != null) {
        storedImg = scaleAndRegisterImg(storedImg.getImage(), key, size);
      } else {
        storedImg = storage.loadData(db.getImageID(IMAGE_NOT_FOUND, size));
        if (storedImg == null) {
          storedImg = storage.loadData(db.getImageID(IMAGE_NOT_FOUND, stdSize));
          if (storedImg == null) {
            return null;
          }
          storedImg = scaleAndRegisterImg(storedImg.getImage(), new ImageDBKey(IMAGE_NOT_FOUND),
              size);
        }
      }
    }

    return storedImg.toString();
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/setup/StorageRule.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.setup;

import java.util.Arrays;

/**
 * This enum contains the different storage rule implementations and their string representation.
 * @author Norbert Schmitt
 */
public enum StorageRule {

  /**
   * Store all data without restrictions.
   */
  ALL(""All""), 
  
  /** 
   * Store only images if their size is equal to {@link tools.descartes.teastore.entities.ImageSizePreset.FULL}.
   */
  FULL_SIZE_IMG(""Full-size-images"");

  /**
   * Standard storage rule implementation used by the image provider service.
   */
  public static final StorageRule STD_STORAGE_RULE = ALL;

  private final String strRepresentation;

  private StorageRule(String strRepresentation) {
    this.strRepresentation = strRepresentation;
  }
  
  /**
   * Returns the string representation of the used storage rule implementation.
   * @return String representation.
   */
  public String getStrRepresentation() {
    return strRepresentation;
  }

  /**
   * Convert string representation to the correct object. Will return the standard storage rule implementation if the 
   * string representation is unknown.
   * @param strStorageRule String representation of the storage rule implementation.
   * @return Enum value of the storage rule implementation.
   */
  public static StorageRule getStorageRuleFromString(String strStorageRule) {
    return Arrays.asList(StorageRule.values()).stream()
        .filter(mode -> mode.strRepresentation.equals(strStorageRule)).findFirst()
        .orElse(STD_STORAGE_RULE);
  }
}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/setup/ImageCreator.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.setup;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.util.Random;
import java.util.stream.Stream;

import tools.descartes.teastore.entities.ImageSize;

/**
 * Helper class drawing images from random shapes and texts.
 * @author Norbert Schmitt
 */
public final class ImageCreator {

  /**
   * Random number generator seed.
   */
  public static final long STD_SEED = 12345;
  
  /**
   * Standard number of shapes added for each image.
   */
  public static final int STD_NR_OF_SHAPES_PER_IMAGE = 10;
  
  /**
   * Maximum RGB color code used in determining the color of the background, a shape or text.
   */
  public static final int MAX_RGB = 255;
  
  /**
   * Maximum font size of random text in an image.
   */
  public static final int MAX_FONT_SIZE = 200;
  
  /**
   * Maximum number of characters of random text in an image.
   */
  public static final int MAX_TEXT_LENGTH = 30;
  
  /**
   * Maximum number for ascii character.
   */
  public static final int MAX_CHAR_SIZE = 255;

  private ImageCreator() {
	  
  }
  
  /**
   * Create an image with the given number of shapes, with the given size. The shapes will be added to the supplied 
   * buffered image using the given random number generator.
   * @param shapesPerImage Number of shapes added to the buffered image.
   * @param categoryImg Image added at the end representing the product category.
   * @param size Size of the image in pixel.
   * @param rand Random number generator.
   * @return Returns the given buffered image with the added shapes and category image.
   */
  public static BufferedImage createImage(int shapesPerImage, BufferedImage categoryImg,
      ImageSize size, Random rand) {
    BufferedImage img = new BufferedImage(size.getWidth(), size.getHeight(), BufferedImage.OPAQUE);
    Graphics2D graphics = img.createGraphics();
    graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION,
        RenderingHints.VALUE_INTERPOLATION_BICUBIC);

    switchColor(graphics, rand);
    graphics.fillRect(0, 0, size.getWidth(), size.getHeight());

    for (int i = 0; i < shapesPerImage; i++) {
      switch (rand.nextInt(4)) {
      case 0:
        makeRectangle(graphics, size, rand);
        break;
      case 1:
        makeLine(graphics, size, rand);
        break;
      case 2:
        makeOval(graphics, size, rand);
        break;
      case 3:
        makeText(graphics, size, rand);
        break;
      default:
        makeRectangle(graphics, size, rand);
        break;
      }
    }

    if (categoryImg != null) {
      drawCategoryImage(graphics, size, categoryImg, rand);
    }

    graphics.dispose();
    return img;
  }

  private static void drawCategoryImage(Graphics2D graphics, ImageSize maxSize,
      BufferedImage categoryImg, Random rand) {
    graphics.drawImage(categoryImg, rand.nextInt(maxSize.getWidth() - categoryImg.getWidth()),
        rand.nextInt(maxSize.getHeight() - categoryImg.getHeight()), categoryImg.getWidth(),
        categoryImg.getHeight(), null);
  }

  private static void switchColor(Graphics2D graphics, Random rand) {
    graphics.setColor(
        new Color(rand.nextInt(MAX_RGB + 1), rand.nextInt(MAX_RGB + 1), rand.nextInt(MAX_RGB + 1)));
  }

  private static void makeRectangle(Graphics2D graphics, ImageSize maxSize, Random rand) {
    switchColor(graphics, rand);

    int x = rand.nextInt(maxSize.getWidth());
    int y = rand.nextInt(maxSize.getHeight());

    Rectangle r = new Rectangle(x, y, rand.nextInt(maxSize.getWidth() - x) + 1,
        rand.nextInt(maxSize.getHeight() - y) + 1);

    if (rand.nextBoolean()) {
      graphics.fill(r);
    }

    graphics.draw(r);
  }

  private static void makeLine(Graphics2D graphics, ImageSize maxSize, Random rand) {
    switchColor(graphics, rand);

    graphics.drawLine(rand.nextInt(maxSize.getWidth()), rand.nextInt(maxSize.getHeight()),
        rand.nextInt(maxSize.getWidth()), rand.nextInt(maxSize.getHeight()));
  }

  private static void makeOval(Graphics2D graphics, ImageSize maxSize, Random rand) {
    switchColor(graphics, rand);

    int x = rand.nextInt(maxSize.getWidth());
    int y = rand.nextInt(maxSize.getHeight());
    int width = rand.nextInt(maxSize.getWidth() - x) + 1;
    int height = rand.nextInt(maxSize.getHeight() - y) + 1;

    if (rand.nextBoolean()) {
      graphics.fillOval(x, y, width, height);
    }

    graphics.drawOval(x, y, width, height);
  }

  private static void makeText(Graphics2D graphics, ImageSize maxSize, Random rand) {
    switchColor(graphics, rand);

    String fontName = Font.SANS_SERIF;
    switch (rand.nextInt(4)) {
    case 0:
      fontName = Font.SANS_SERIF;
      break;
    case 1:
      fontName = Font.MONOSPACED;
      break;
    case 2:
      fontName = Font.SERIF;
      break;
    case 3:
      fontName = Font.DIALOG;
      break;
    default:
      fontName = Font.SANS_SERIF;
      break;
    }

    int fontStyle = Font.PLAIN;
    switch (rand.nextInt(3)) {
    case 0:
      fontStyle = Font.PLAIN;
      break;
    case 1:
      fontStyle = Font.BOLD;
      break;
    case 2:
      fontStyle = Font.ITALIC;
      break;
    default:
      fontStyle = Font.PLAIN;
      break;
    }

    int fontSize = rand.nextInt(MAX_FONT_SIZE + 1);

    graphics.setFont(new Font(fontName, fontStyle, fontSize));

    int textLength = rand.nextInt(MAX_TEXT_LENGTH + 1);
    String str = Stream.generate(() -> rand.nextInt(MAX_CHAR_SIZE)).limit(textLength)
        .map(i -> (char) i.intValue())
        .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();

    graphics.drawString(str, rand.nextInt(maxSize.getWidth()), rand.nextInt(maxSize.getHeight()));
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/setup/ImageIDFactory.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.setup;

import java.util.concurrent.atomic.AtomicLong;

/**
 * Singleton helper class generating unique image identifiers.
 * @author Norbert Schmitt
 */
public enum ImageIDFactory {

  /**
   * Instance of the image id factory.
   */
  ID;

  private AtomicLong nextID = new AtomicLong(1);

  private ImageIDFactory() {

  }

  /**
   * Returns the next unique image identifier.
   * @return The next unique image identifier.
   */
  public long getNextImageID() {
    return nextID.getAndIncrement();
  }

  /**
   * Sets the first image identifier to start with.
   * @param nextID The image identifier to start with.
   */
  public void startAtID(long nextID) {
    this.nextID.set(nextID);
  }
}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/setup/CachingMode.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.setup;

import java.util.Arrays;

/**
 * This enum contains the different cache implementations and their string representation.
 * @author Norbert Schmitt
 */
public enum CachingMode {

  /**
   * First in first out cache.
   */
  FIFO(""FIFO""), 
  /**
   * Last in first out cache.
   */
  LIFO(""LIFO""), 
  /**
   * Random replacement cache.
   */
  RR(""RR""), 
  /**
   * Least frequently used cache.
   */
  LFU(""LFU""), 
  /**
   * Least recently used cache.
   */
  LRU(""LRU""), 
  /**
   * Most recently used cache.
   */
  MRU(""MRU""), 
  /**
   * Use no cache (Cache disabled).
   */
  NONE(""Disabled"");

  /**
   * Standard cache implementation used by the image provider service.
   */
  public static final CachingMode STD_CACHING_MODE = LFU;

  private final String strRepresentation;

  private CachingMode(String strRepresentation) {
    this.strRepresentation = strRepresentation;
  }

  /**
   * Returns the string representation of the used cache implementation.
   * @return String representation.
   */
  public String getStrRepresentation() {
    return strRepresentation;
  }

  /**
   * Convert string representation to the correct object. Will return the standard cache implementation if the string 
   * representation is unknown.
   * @param strCachingMode String representation of the cache implementation.
   * @return Enum value of the cache implementation.
   */
  public static CachingMode getCachingModeFromString(String strCachingMode) {
    return Arrays.asList(CachingMode.values()).stream()
        .filter(mode -> mode.strRepresentation.equals(strCachingMode)).findFirst()
        .orElse(STD_CACHING_MODE);
  }
}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/setup/CreatorFactory.java,"package tools.descartes.teastore.image.setup;

import java.awt.image.BufferedImage;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.ImageSize;
import tools.descartes.teastore.entities.ImageSizePreset;
import tools.descartes.teastore.image.ImageDB;

/**
 * Helper class creating image generation runnables for image provider setup.
 * @author Norbert Schmitt
 */
public class CreatorFactory {

  private int shapesPerImage = 0;
  private ImageSize imgSize = ImageSizePreset.STD_IMAGE_SIZE;
  private Path workingDir = SetupController.SETUP.getWorkingDir();
  private Map<Category, BufferedImage> categoryImages;
  private List<Long> products;
  private List<Category> categories;
  private ImageDB imgDB;
  private AtomicLong nrOfImagesGenerated;

  private final Logger log = LoggerFactory.getLogger(CreatorFactory.class);

  /**
   * Standard constructor defining all necessary information to create image generation runnables.
   * @param shapesPerImage Number of shapes per generated image.
   * @param imgDB Image database to add image to.
   * @param imgSize Size of the images to generate.
   * @param workingDir Directory to store images.
   * @param products Product IDs for which images will be generated.
   * @param categoryImages Category images that are added after random shapes for the image have been generated.
   * @param nrOfImagesGenerated Current number of images that have been generated by all runnables.
   */
  public CreatorFactory(int shapesPerImage, ImageDB imgDB, ImageSize imgSize, Path workingDir,
      Map<Category, List<Long>> products, Map<Category, BufferedImage> categoryImages,
      AtomicLong nrOfImagesGenerated) {
    if (imgDB == null) {
      log.error(""Supplied image database is null."");
      throw new NullPointerException(""Supplied image database is null."");
    }
    if (products == null) {
      log.error(""Supplied product map is null."");
      throw new NullPointerException(""Supplied product map is null."");
    }
    if (nrOfImagesGenerated == null) {
      log.error(""Supplied counter for images generated is null."");
      throw new NullPointerException(""Supplied counter for images generated is null."");
    }

    if (workingDir == null) {
      log.info(""Supplied working directory is null. Set to value {}."",
          SetupController.SETUP.getWorkingDir());
    } else {
      this.workingDir = workingDir;
    }
    if (categoryImages == null) {
      log.info(""Supplied category images are null. Defaulting to not add category images."");
    } else {
      this.categoryImages = categoryImages;
    }
    if (imgSize == null) {
      log.info(""Supplied image size is null. Defaulting to standard size of {}."",
          ImageSizePreset.STD_IMAGE_SIZE);
    } else {
      this.imgSize = imgSize;
    }
    if (shapesPerImage < 0) {
      log.info(""Number of shapes per image cannot be below 0, was {}. Set to 0."", shapesPerImage);
    } else {
      this.shapesPerImage = shapesPerImage;
    }
    this.products = products.entrySet().stream().flatMap(e -> e.getValue().stream())
        .collect(Collectors.toList());
    this.categories = products.entrySet().stream()
        .flatMap(e -> e.getValue().stream().map(x -> e.getKey())).collect(Collectors.toList());
    this.imgDB = imgDB;
    this.nrOfImagesGenerated = nrOfImagesGenerated;
  }

  /**
   * Create the image generation runnable.
   * @return Image generation runnable.
   */
  public Runnable newRunnable() {
    return new CreatorRunner(imgDB, imgSize, products.remove(0), shapesPerImage,
        categoryImages.getOrDefault(categories.remove(0), null), workingDir, nrOfImagesGenerated);
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/setup/CachingRule.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.setup;

import java.util.Arrays;

/**
 * This enum contains the different caching rule implementations and their string representation.
 * @author Norbert Schmitt
 */
public enum CachingRule {

  /**
   * Cache all data without restrictions.
   */
  ALL(""All"");

  /**
   * Standard caching rule implementation used by the image provider service.
   */
  public static final CachingRule STD_CACHING_RULE = ALL;

  private final String strRepresentation;

  private CachingRule(String strRepresentation) {
    this.strRepresentation = strRepresentation;
  }

  /**
   * Returns the string representation of the used caching rule implementation.
   * @return String representation.
   */
  public String getStrRepresentation() {
    return strRepresentation;
  }

  /**
   * Convert string representation to the correct object. Will return the standard caching rule implementation if the 
   * string representation is unknown.
   * @param strCachingRule String representation of the caching rule implementation.
   * @return Enum value of the caching rule implementation.
   */
  public static CachingRule getCachingRuleFromString(String strCachingRule) {
    return Arrays.asList(CachingRule.values()).stream()
        .filter(mode -> mode.strRepresentation.equals(strCachingRule)).findFirst()
        .orElse(STD_CACHING_RULE);
  }
}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/setup/StorageMode.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.setup;

import java.util.Arrays;

/**
 * This enum contains the different storage implementations and their string representation.
 * @author Norbert Schmitt
 */
public enum StorageMode {

  /**
   * Store all images on the pyhsical drive.
   */
  DRIVE(""Drive"");

  /**
   * Standard storage implementation used by the image provider service.
   */
  public static final StorageMode STD_STORAGE_MODE = DRIVE;

  private final String strRepresentation;

  private StorageMode(String strRepresentation) {
    this.strRepresentation = strRepresentation;
  }

  /**
   * Returns the string representation of the used storage implementation.
   * @return String representation.
   */
  public String getStrRepresentation() {
    return strRepresentation;
  }

  /**
   * Convert string representation to the correct object. Will return the standard storage implementation if the 
   * string representation is unknown.
   * @param strStorageMode String representation of the storage implementation.
   * @return Enum value of the storage implementation.
   */
  public static StorageMode getStorageModeFromString(String strStorageMode) {
    return Arrays.asList(StorageMode.values()).stream()
        .filter(mode -> mode.strRepresentation.equals(strStorageMode)).findFirst()
        .orElse(STD_STORAGE_MODE);
  }
}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/setup/CreatorRunner.java,"package tools.descartes.teastore.image.setup;

import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.channels.ClosedByInterruptException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Base64;
import java.util.Random;
import java.util.concurrent.atomic.AtomicLong;

import javax.imageio.ImageIO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.entities.ImageSize;
import tools.descartes.teastore.entities.ImageSizePreset;
import tools.descartes.teastore.image.ImageDB;
import tools.descartes.teastore.image.StoreImage;

/**
 * Image generation runnable to generate a single image. 
 * @author Norbert Schmitt
 *
 */
public class CreatorRunner implements Runnable {

  private final long productID;
  private final ImageDB imgDB;
  private final ImageSize size;
  private final Path workingDir;
  private final int shapesPerImage;
  private final BufferedImage categoryImage;
  private final AtomicLong nrOfImagesGenerated;

  private final Logger log = LoggerFactory.getLogger(CreatorRunner.class);

  /**
   * Creates a new runnable object to generate a single image.
   * @param imgDB Image database to add image to.
   * @param size Size of the images to generate
   * @param productID Product ID for which the images will be generated.
   * @param shapesPerImage Number of shapes per generated image.
   * @param categoryImage Category images that are added after random shapes for the image have been generated.
   * @param workingDir Directory to store image.
   * @param nrOfImagesGenerated Current number of images that have been generated by all runnables.
   */
  public CreatorRunner(ImageDB imgDB, ImageSize size, long productID, int shapesPerImage,
      BufferedImage categoryImage, Path workingDir, AtomicLong nrOfImagesGenerated) {
    this.imgDB = imgDB;
    this.productID = productID;
    this.shapesPerImage = shapesPerImage;
    this.categoryImage = categoryImage;
    this.workingDir = workingDir;
    this.nrOfImagesGenerated = nrOfImagesGenerated;
    if (size != null) {
      this.size = size;
    } else {
      this.size = ImageSizePreset.STD_IMAGE_SIZE;
    }
  }

  @Override
  public void run() {
    long imgID = ImageIDFactory.ID.getNextImageID();
    Random rand = new Random(productID);

    // All products must be added to the database
    imgDB.setImageMapping(productID, imgID, size);

    // Resolve path and create a new image
    Path imgFile = workingDir.resolve(String.valueOf(imgID));

    BufferedImage img = ImageCreator.createImage(shapesPerImage, categoryImage, size, rand);
    ByteArrayOutputStream stream = new ByteArrayOutputStream();

    try {
      ImageIO.write(img, StoreImage.STORE_IMAGE_FORMAT, stream);
      Files.write(imgFile, Base64.getEncoder().encode(stream.toByteArray()),
          StandardOpenOption.CREATE, StandardOpenOption.WRITE,
          StandardOpenOption.TRUNCATE_EXISTING);
    } catch (IOException ioException) {
      if (!(ioException instanceof ClosedByInterruptException)) {
        log.warn(""An IOException occured while writing image with ID "" + String.valueOf(imgID)
            + "" to file "" + imgFile.toAbsolutePath() + ""."", ioException);
      } else {
        log.warn(""An exception was thrown during image creation with ID "" + String.valueOf(imgID)
            + "" to file "" + imgFile.toAbsolutePath() + ""."", ioException);
      }
    }

    nrOfImagesGenerated.incrementAndGet();
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/setup/SetupController.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.setup;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import javax.imageio.ImageIO;
import jakarta.ws.rs.core.GenericType;
import jakarta.ws.rs.core.Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.registryclient.RegistryClient;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.rest.HttpWrapper;
import tools.descartes.teastore.registryclient.rest.ResponseWrapper;
import tools.descartes.teastore.registryclient.util.NotFoundException;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.ImageSize;
import tools.descartes.teastore.entities.ImageSizePreset;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.image.ImageDB;
import tools.descartes.teastore.image.ImageProvider;
import tools.descartes.teastore.image.StoreImage;
import tools.descartes.teastore.image.cache.FirstInFirstOut;
import tools.descartes.teastore.image.cache.IDataCache;
import tools.descartes.teastore.image.cache.LastInFirstOut;
import tools.descartes.teastore.image.cache.LeastFrequentlyUsed;
import tools.descartes.teastore.image.cache.LeastRecentlyUsed;
import tools.descartes.teastore.image.cache.MostRecentlyUsed;
import tools.descartes.teastore.image.cache.RandomReplacement;
import tools.descartes.teastore.image.cache.rules.CacheAll;
import tools.descartes.teastore.image.storage.DriveStorage;
import tools.descartes.teastore.image.storage.IDataStorage;
import tools.descartes.teastore.image.storage.rules.StoreAll;
import tools.descartes.teastore.image.storage.rules.StoreLargeImages;

/**
 * Image provider setup class. Connects to the persistence service to collect all available products and generates
 * images from the received products and their category. Searches for existing images to be used in the web interface
 * and adds them to the storage / cache.
 * @author Norbert Schmitt
 */
public enum SetupController {

  /**
   * Instance of the setup controller.
   */
  SETUP;

  /**
   * Constants used during image provider setup.
   * @author Norbert Schmitt
   */
  private interface SetupControllerConstants {

	/**
	 * Standard working directory in which the images are stored.
	 */
    public static final Path STD_WORKING_DIR = Paths.get(""images"");

    /**
     * Longest wait period before querying the persistence again if it is finished creating entries.
     */
    public final int PERSISTENCE_CREATION_MAX_WAIT_TIME = 120000;

    /**
     * Wait time in ms before checking again for an existing persistence service.
     */
    public static final List<Integer> PERSISTENCE_CREATION_WAIT_TIME = Arrays.asList(1000, 2000,
        5000, 10000, 30000, 60000);

    /**
     * Number of available logical cpus for image creation.
     */
    public static final int CREATION_THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();

    /**
     * Wait time in ms for the image creation thread pool to terminate all threads.
     */
    public static final long CREATION_THREAD_POOL_WAIT = 500;

    /**
     * Wait time in ms (per image to generate) before an image provider service is registered if there is another
     * image provider service registered.
     */
    public static final long CREATION_THREAD_POOL_WAIT_PER_IMG_NR = 70;
  }

  private StorageRule storageRule = StorageRule.STD_STORAGE_RULE;
  private CachingRule cachingRule = CachingRule.STD_CACHING_RULE;
  private Path workingDir = SetupControllerConstants.STD_WORKING_DIR;
  private long cacheSize = IDataCache.STD_MAX_CACHE_SIZE;
  private StorageMode storageMode = StorageMode.STD_STORAGE_MODE;
  private CachingMode cachingMode = CachingMode.STD_CACHING_MODE;
  private long nrOfImagesToGenerate = 0;
  private long nrOfImagesExisting = 0;
  private long nrOfImagesForCategory = 0;
  private AtomicLong nrOfImagesGenerated = new AtomicLong();
  private HashMap<String, BufferedImage> categoryImages = new HashMap<>();
  private ImageDB imgDB = new ImageDB();
  private IDataStorage<StoreImage> storage = null;
  private IDataCache<StoreImage> cache = null;
  private ScheduledThreadPoolExecutor imgCreationPool = new ScheduledThreadPoolExecutor(
      SetupControllerConstants.CREATION_THREAD_POOL_SIZE);
  private Logger log = LoggerFactory.getLogger(SetupController.class);
  private AtomicBoolean isFinished = new AtomicBoolean();

  private SetupController() {

  }

  private void waitForPersistence() {
    // We have to wait for the database that all entries are created before
    // generating images (which queries persistence). Yes we want to wait forever in
    // case the persistence is
    // not answering.
    Iterator<Integer> waitTimes = SetupControllerConstants.PERSISTENCE_CREATION_WAIT_TIME
        .iterator();
    while (true) {
      Response result = null;
      try {
        result = ServiceLoadBalancer.loadBalanceRESTOperation(Service.PERSISTENCE, ""generatedb"",
            String.class,
            client -> ResponseWrapper
                .wrap(HttpWrapper.wrap(client.getService().path(client.getApplicationURI())
                    .path(client.getEndpointURI()).path(""finished"")).get()));
      } catch (NotFoundException notFound) {
        log.info(""No persistence found."", notFound);
      } catch (LoadBalancerTimeoutException timeout) {
        log.info(""Persistence call timed out."", timeout);
      } catch (NullPointerException npe) {
        log.info(""ServiceLoadBalancerResult was null!"");
      }

      if (result != null && Boolean.parseBoolean(result.readEntity(String.class))) {
    		result.close();
    	  break;
      }

      try {
    	int nextWaitTime = SetupControllerConstants.PERSISTENCE_CREATION_MAX_WAIT_TIME;
    	if (waitTimes.hasNext()) {
    		nextWaitTime = waitTimes.next();
    	}
        log.info(""Persistence not reachable. Waiting for {}ms."", nextWaitTime);
        Thread.sleep(nextWaitTime);
      } catch (InterruptedException interrupted) {
        log.warn(""Thread interrupted while waiting for persistence to be available."", interrupted);
      }
    }
  }

  private void fetchProductsForCategory(Category category, HashMap<Category, List<Long>> products) {
    waitForPersistence();

    Response result = null;
    try {
      result = ServiceLoadBalancer.loadBalanceRESTOperation(Service.PERSISTENCE, ""products"",
          Product.class,
          client -> ResponseWrapper.wrap(HttpWrapper.wrap(client.getService()
              .path(client.getApplicationURI()).path(client.getEndpointURI()).path(""category"")
              .path(String.valueOf(category.getId())).queryParam(""start"", 0).queryParam(""max"", -1))
              .get()));
    } catch (NotFoundException notFound) {
      log.error(""No persistence found but should be online."", notFound);
      throw notFound;
    } catch (LoadBalancerTimeoutException timeout) {
      log.error(""Persistence call timed out but should be reachable."", timeout);
      throw timeout;
    }

    if (result == null) {
      products.put(category, new ArrayList<>());
      log.info(""No products for category {} ({}) found."", category.getName(), category.getId());
    } else {
      List<Long> tmp = convertToIDs(result.readEntity(new GenericType<List<Product>>() {
      }));
      products.put(category, tmp);
      result.close();
      log.info(""Category {} ({}) contains {} products."", category.getName(), category.getId(),
          tmp.size());
    }
  }

  private List<Category> fetchCategories() {
    waitForPersistence();

    List<Category> categories = null;
    Response result = null;
    try {
      result = ServiceLoadBalancer.loadBalanceRESTOperation(Service.PERSISTENCE, ""categories"",
          Category.class,
          client -> ResponseWrapper.wrap(HttpWrapper.wrap(
              client.getService().path(client.getApplicationURI()).path(client.getEndpointURI()))
              .get()));
    } catch (NotFoundException notFound) {
      log.error(""No persistence found but should be online."", notFound);
      throw notFound;
    } catch (LoadBalancerTimeoutException timeout) {
      log.error(""Persistence call timed out but should be reachable."", timeout);
      throw timeout;
    }

    if (result == null) {
      log.warn(""No categories found."");
    } else {
      categories = result.readEntity(new GenericType<List<Category>>() {
      });
      result.close();
      log.info(""{} categories found."", categories.size());
    }

    if (categories == null) {
      return new ArrayList<Category>();
    }
    return categories;
  }

  private List<Long> convertToIDs(List<Product> products) {
    if (products == null) {
      return new ArrayList<>();
    }
    return products.stream().map(product -> product.getId()).collect(Collectors.toList());
  }

  private HashMap<Category, BufferedImage> matchCategoriesToImage(List<Category> categories) {
    HashMap<Category, BufferedImage> result = new HashMap<>();

    List<String> imageNames = categoryImages.entrySet().stream().map(e -> e.getKey())
        .collect(Collectors.toList());
    for (String name : imageNames) {
      for (Category category : categories) {
        String[] tmp = category.getName().split("","");
        if (tmp[0].toLowerCase().replace("" "", ""-"").equals(name)) {
          log.info(""Found matching category {} ({}) for image {}."", category.getName(),
              category.getId(), name + ""."" + StoreImage.STORE_IMAGE_FORMAT);
          result.put(category, categoryImages.get(name));
        }
      }
    }
    return result;
  }

  /**
   * Generates images for the product IDs and categories received from the persistence service.
   */
  public void generateImages() {
    List<Category> categories = fetchCategories();
    HashMap<Category, List<Long>> products = new HashMap<>();
    categories.forEach(cat -> fetchProductsForCategory(cat, products));

    generateImages(products, matchCategoriesToImage(categories));
  }

  /**
   * Generates images for the given product IDs and categories.
   * @param products Map of categories and the corresponding products.
   * @param categoryImages Category image representing a specific category.
   */
  public void generateImages(Map<Category, List<Long>> products,
      Map<Category, BufferedImage> categoryImages) {
    nrOfImagesToGenerate = products.entrySet().stream().flatMap(e -> e.getValue().stream()).count();

    CreatorFactory factory = new CreatorFactory(ImageCreator.STD_NR_OF_SHAPES_PER_IMAGE, imgDB,
        ImageSizePreset.STD_IMAGE_SIZE, workingDir, products, categoryImages, nrOfImagesGenerated);

    // Schedule all image creation tasks
    for (long i = 0; i < nrOfImagesToGenerate; i++) {
      imgCreationPool.execute(factory.newRunnable());
    }

    log.info(""Image creator thread started. {} {} sized images to generate using {} threads."",
        nrOfImagesToGenerate, ImageSizePreset.STD_IMAGE_SIZE.toString(),
        SetupControllerConstants.CREATION_THREAD_POOL_SIZE);
  }

  /**
   * Search for category images in the resource folder.
   */
  public void detectCategoryImages() {
    log.info(""Trying to find images that indicate categories in generated images."");

    String resPath = ""categoryimg"" + File.separator + ""black-tea.png"";
    File dir = getPathToResource(resPath).toFile();

    if (dir != null) {
      log.info(""Found resource directory with category images at {}."",
          dir.toPath().toAbsolutePath().toString());
    } else {
      log.info(""Resource path {} not found."", resPath);
      return;
    }

    nrOfImagesForCategory = 0;
    if (dir.exists() && dir.isDirectory()) {
      File[] fileList = dir.listFiles();
      if (fileList == null) {
    	  return;
      }
      for (File file : fileList) {
        if (file.isFile() && file.getName().endsWith(StoreImage.STORE_IMAGE_FORMAT)) {
          try {
            categoryImages.put(file.getName().substring(0, file.getName().length() - 4),
                ImageIO.read(file));
            nrOfImagesForCategory++;
          } catch (IOException ioException) {
            log.warn(
                ""An IOException occured while reading image file "" + file.getAbsolutePath() + ""."",
                ioException);
          }
        }
      }
    }
    log.info(""Found {} images for categories."", nrOfImagesForCategory);
  }

  /**
   * Create the working directory in which all generated images are stored if it is not existing.
   */
  public void createWorkingDir() {
    if (!workingDir.toFile().exists()) {
      if (!workingDir.toFile().mkdir()) {
        log.error(""Standard working directory \"""" + workingDir.toAbsolutePath()
            + ""\"" could not be created."");
        throw new IllegalArgumentException(""Standard working directory \""""
            + workingDir.toAbsolutePath() + ""\"" could not be created."");
      } else {
        log.info(""Working directory {} created."", workingDir.toAbsolutePath().toString());
      }
    } else {
      log.info(""Working directory {} already existed."", workingDir.toAbsolutePath().toString());
    }
  }

  /**
   * Returns the path to a given resource, category image or web interface image.
   * @param resource Resource to find path.
   * @return Path to the given resource or NULL if the resource could not be found.
   */
  public Path getPathToResource(String resource) {
    // Rework the code piece fetching the existing images until the next
    // comment
    URL url = this.getClass().getResource(resource);
    Path dir = null;
    String path = """";
    try {
      path = URLDecoder.decode(url.getPath(), ""UTF-8"");
      if (path.contains("":"")) {
        path = path.substring(3);
      }
      dir = Paths.get(path).getParent();
    } catch (UnsupportedEncodingException e) {
      log.warn(""The resource path \"""" + path + ""\"" could not be decoded with UTF-8."");
    }
    // End of rework
    return dir;
  }

  /**
   * Search for web interface images and add them to the existing image database.
   */
  public void detectExistingImages() {
    detectExistingImages(imgDB);
  }

  /**
   * Search for web interface images and add them to the given image database.
   * @param db Image database found web interface images will be added to.
   */
  public void detectExistingImages(ImageDB db) {
    if (db == null) {
      log.error(""The supplied image database is null."");
      throw new NullPointerException(""The supplied image database is null."");
    }

    String resPath = ""existingimg"" + File.separator + ""front.png"";
    Path dir = getPathToResource(resPath);

    if (dir != null) {
      log.info(""Found resource directory with existing images at {}."",
          dir.toAbsolutePath().toString());
    } else {
      log.info(""Resource path {} not found."", resPath);
      return;
    }

    File currentDir = dir.toFile();

    if (currentDir.exists() && currentDir.isDirectory()) {
      File[] fileList = currentDir.listFiles();
      if (fileList == null) {
    	  return;
      }
      for (File file : fileList) {
        if (file.isFile() && file.getName().endsWith(StoreImage.STORE_IMAGE_FORMAT)) {
          long imageID = ImageIDFactory.ID.getNextImageID();

          BufferedImage buffImg = null;
          // Copy files to correct file with the image id number
          try {
            buffImg = ImageIO.read(file);

          } catch (IOException ioException) {
            log.warn(""An IOException occured while reading the file "" + file.getAbsolutePath()
                + "" from disk."", ioException.getMessage());
          } finally {
            if (buffImg == null) {
              log.warn(""The file \"""" + file.toPath().toAbsolutePath() + ""\"" could not be read."");
              continue;
            }
          }

          db.setImageMapping(
              file.getName().substring(0,
                  file.getName().length() - StoreImage.STORE_IMAGE_FORMAT.length() - 1),
              imageID, new ImageSize(buffImg.getWidth(), buffImg.getHeight()));
          StoreImage img = new StoreImage(imageID, buffImg, ImageSizePreset.FULL.getSize());

          try {
            Files.write(workingDir.resolve(String.valueOf(imageID)), img.getByteArray(),
                StandardOpenOption.CREATE, StandardOpenOption.WRITE,
                StandardOpenOption.TRUNCATE_EXISTING);
          } catch (IOException ioException) {
            log.warn(""An IOException occured while writing the image with ID ""
                + String.valueOf(imageID) + "" to the file ""
                + workingDir.resolve(String.valueOf(imageID)).toAbsolutePath() + ""."",
                ioException.getMessage());
          }
          // Increment to have correct number of images for the limited drive storage
          nrOfImagesExisting++;
        }
      }
    }

    log.info(""Scanned path {} for existing images. {} images found."",
        dir.toAbsolutePath().toString(), nrOfImagesExisting);
  }

  /**
   * Sets the cache size of the specific implementation.
   * @param cacheSize Positive cache size in bytes.
   * @return True if the cache size was set successfully, otherwise false.
   */
  public boolean setCacheSize(long cacheSize) {
    if (cacheSize < 0) {
      log.info(""Tried to set cache size to a value below zero. Keeping old value"");
      return false;
    }
    if (cache == null) {
      log.info(""No cache defined."");
      return false;
    }
    return cache.setMaxCacheSize(cacheSize);
  }

  /**
   * Delete all images from the current working directory.
   */
  public void deleteImages() {
    deleteUnusedImages(new ArrayList<>());
  }

  /**
   * Delete all images from the current working directory, except the images with the IDs given.
   * @param imagesToKeep List of images to keep.
   */
  public void deleteUnusedImages(List<Long> imagesToKeep) {
    File currentDir = workingDir.toFile();
    int nrOfImagesDeleted = 0;

    if (currentDir.exists() && currentDir.isDirectory()) {
      File[] fileList = currentDir.listFiles();
      if (fileList == null) {
        return;
      }
      for (File file : fileList) {
        if (file.isFile() && !imagesToKeep.contains(Long.parseLong(file.getName()))) {
          boolean isDeleted = file.delete();
          if (isDeleted) {
            nrOfImagesDeleted++;
          }
        }
      }
    }

    log.info(""Deleted images in working directory {}. {} images deleted."",
        workingDir.toAbsolutePath().toString(), nrOfImagesDeleted);
  }

  /**
   * Deletes the current working directory.
   */
  public void deleteWorkingDir() {
    File currentDir = workingDir.toFile();
    boolean isDeleted = false;

    if (currentDir.exists() && currentDir.isDirectory()) {
      isDeleted = currentDir.delete();
    }

    if (isDeleted) {
      log.info(""Deleted working directory {}."", workingDir.toAbsolutePath().toString());
    } else {
      log.info(""Working directory {} not deleted."", workingDir.toAbsolutePath().toString());
    }
  }

  /**
   * Sets up the storage, storage rule, cache implementation and caching rule according to the configuration.
   */
  public void setupStorage() {
    Predicate<StoreImage> storagePredicate = new StoreAll<StoreImage>();
    switch (storageRule) {
    case ALL:
      break;
    case FULL_SIZE_IMG:
      storagePredicate = new StoreLargeImages();
      break;
    default:
      break;
    }

    // We only support Drive Storage at this moment
    storage = new DriveStorage(workingDir, imgDB, storagePredicate);
    /*
    switch (storageMode) {
    case DRIVE:
      storage = new DriveStorage(workingDir, imgDB, storagePredicate);
      break;
    default:
      storage = new DriveStorage(workingDir, imgDB, storagePredicate);
      break;
    }
    */

    Predicate<StoreImage> cachePredicate = null;
    switch (cachingRule) {
    case ALL:
      cachePredicate = new CacheAll<StoreImage>();
      break;
    default:
      cachePredicate = new CacheAll<StoreImage>();
      break;
    }

    cache = null;
    switch (cachingMode) {
    case FIFO:
      cache = new FirstInFirstOut<StoreImage>(storage, cacheSize, cachePredicate);
      break;
    case LIFO:
      cache = new LastInFirstOut<StoreImage>(storage, cacheSize, cachePredicate);
      break;
    case RR:
      cache = new RandomReplacement<StoreImage>(storage, cacheSize, cachePredicate);
      break;
    case LFU:
      cache = new LeastFrequentlyUsed<StoreImage>(storage, cacheSize, cachePredicate);
      break;
    case LRU:
      cache = new LeastRecentlyUsed<StoreImage>(storage, cacheSize, cachePredicate);
      break;
    case MRU:
      cache = new MostRecentlyUsed<StoreImage>(storage, cacheSize, cachePredicate);
      break;
    case NONE:
      break;
    default:
      break;
    }

    log.info(""Storage setup done."");
  }

  /**
   * Give the image provider the configured image database and cache / storage object containing all images referenced
   * in the image database.
   */
  public void configureImageProvider() {
    ImageProvider.IP.setImageDB(imgDB);
    if (cache == null) {
    	ImageProvider.IP.setStorage(storage);
    } else {
    	ImageProvider.IP.setStorage(cache);
    }

    log.info(""Storage and image database handed over to image provider"");
  }

  /**
   * Returns the current working directory.
   * @return Current working directory.
   */
  public Path getWorkingDir() {
    return workingDir;
  }

  /**
   * Checks whether the setup is finished and complete or not.
   * @return True if the setup is finished and complete, otherwise false.
   */
  public boolean isFinished() {
    if (storage == null) {
      return false;
    }
    if (imgCreationPool.getQueue().size() != 0) {
      return false;
    }
    return isFinished.get();
  }

  /**
   * Returns a string containing the current state of the image provider setup and configuration settings.
   * @return A string containing the current state of the image provider setup and configuration settings.
   */
  public String getState() {
    StringBuilder sb = new StringBuilder();

    sb.append(""Image Provider State:"").append(System.lineSeparator());
    sb.append(""---------------------"").append(System.lineSeparator());
    sb.append(""Working Directory: "").append(workingDir.toAbsolutePath().toString())
        .append(System.lineSeparator());
    sb.append(""Storage Mode: "").append(storageMode.getStrRepresentation())
        .append(System.lineSeparator());
    sb.append(""Storage Rule: "").append(storageRule.getStrRepresentation())
        .append(System.lineSeparator());
    sb.append(""Caching Mode: "").append(cachingMode.getStrRepresentation())
        .append(System.lineSeparator());
    sb.append(""Caching Rule: "").append(cachingRule.getStrRepresentation())
        .append(System.lineSeparator());
    String poolState = ""Running"";
    if (imgCreationPool.getQueue().size() == 0) {
    	poolState = ""Finished"";
    }
    sb.append(""Creator Thread: "").append(poolState)
        .append(System.lineSeparator());
    sb.append(""Images Created: "").append(String.valueOf(nrOfImagesGenerated.get())).append("" / "")
        .append(String.valueOf(nrOfImagesToGenerate)).append(System.lineSeparator());
    sb.append(""Pre-Existing Images Found: "").append(String.valueOf(nrOfImagesExisting))
        .append(System.lineSeparator());
    sb.append(""Category Images Found: "").append(String.valueOf(nrOfImagesForCategory))
        .append(System.lineSeparator());

    return sb.toString();
  }

  private void waitAndStopImageCreation(boolean terminate, long waitTime) {
    // Stop image creation to have sort of a steady state to work on
    // Shutdown now will finish all running tasks and not schedule new threads
    // Shutdown does allow the thread pool to finish all available tasks but no new
    // ones
    if (terminate) {
      imgCreationPool.shutdownNow();
      log.info(""Send termination signal to image creation thread pool."");
    } else {
      imgCreationPool.shutdown();
      log.info(""Send shutdown signal to image creation thread pool."");
    }
    try {
      if (imgCreationPool.awaitTermination(waitTime, TimeUnit.MILLISECONDS)) {
        log.info(""Image creation stopped."");
      } else {
        log.warn(""Image creation thread pool not terminating after {}ms. Stop waiting."", waitTime);
      }
    } catch (InterruptedException interruptedException) {
      log.warn(""Waiting for image creation thread pool termination interrupted by exception."",
          interruptedException);
    }
    // Maybe we need to keep a reference to the old thread pool if it has not
    // finished properly yet.
    imgCreationPool = new ScheduledThreadPoolExecutor(
        SetupControllerConstants.CREATION_THREAD_POOL_SIZE);
  }

  private boolean isFirstImageProvider() {
    return RegistryClient.getClient().getServersForService(Service.IMAGE).size() == 0;
  }

  /*
   * Convenience methods
   */

  /**
   * Deletes all images and the current working directory.
   */
  public void teardown() {
    deleteImages();
    deleteWorkingDir();
  }

  /**
   * Deletes all images and the current working directory and starts the setup by generating product images and
   * adding web interface images to the image database. The final cache / storage and image database is then handed
   * over to the image provider instance. If this image provider service is the not the first image provider and other
   * image provider services are registered, the registration is delayed until all images are generated.
   */
  public void startup() {
    // Delete all images in case the image provider was not shutdown gracefully last
    // time, leaving images on disk
    isFinished.set(false);
    deleteImages();
    deleteWorkingDir();
    createWorkingDir();
    detectExistingImages();
    detectCategoryImages();
    generateImages();
    setupStorage();
    configureImageProvider();
    // Check if this is the first image provider. If not, wait for termination of
    // the image creation before registering
    if (!isFirstImageProvider()) {
      waitAndStopImageCreation(false,
          ((nrOfImagesToGenerate - nrOfImagesGenerated.get())
              / SetupControllerConstants.CREATION_THREAD_POOL_SIZE)
              * SetupControllerConstants.CREATION_THREAD_POOL_WAIT_PER_IMG_NR);
    }
    isFinished.set(true);
  }

  /**
   * Deletes all images and the current working directory and starts the setup by generating product images and
   * adding web interface images to the image database. The final cache / storage and image database is then handed
   * over to the image provider instance. The reconfiguration and image generation takes place in a background thread.
   * This service remains registered and might receive request from other services.
   */
  public void reconfiguration() {
    Thread x = new Thread() {

      @Override
      public void run() {
        waitAndStopImageCreation(true, SetupControllerConstants.CREATION_THREAD_POOL_WAIT);
        imgDB = new ImageDB();

        isFinished.set(false);
        deleteImages();
        detectExistingImages();
        detectCategoryImages();
        generateImages();
        setupStorage();
        configureImageProvider();
        isFinished.set(true);
      }
    };
    x.start();
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/setup/ImageProviderStartup.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.setup;

import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

import io.opentracing.util.GlobalTracer;
import tools.descartes.teastore.registryclient.RegistryClient;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.StartupCallback;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.tracing.Tracing;

/**
 * Application Lifecycle Listener implementation class Registry Client Startup.
 *
 * @author Simon Eismann
 *
 */
@WebListener
public class ImageProviderStartup implements ServletContextListener {

  /**
   * Empty constructor.
   */
  public ImageProviderStartup() {

  }

  /**
   * @see ServletContextListener#contextDestroyed(ServletContextEvent)
   * @param event
   *          The servlet context event at destruction.
   */
  public void contextDestroyed(ServletContextEvent event) {
    RegistryClient.getClient().unregister(event.getServletContext().getContextPath());
    SetupController.SETUP.teardown();
  }

  /**
   * @see ServletContextListener#contextInitialized(ServletContextEvent)
   * @param event
   *          The servlet context event at initialization.
   */
  public void contextInitialized(ServletContextEvent event) {
    GlobalTracer.register(Tracing.init(Service.IMAGE.getServiceName()));
    ServiceLoadBalancer.preInitializeServiceLoadBalancers(Service.PERSISTENCE);
    RegistryClient.getClient().runAfterServiceIsAvailable(Service.PERSISTENCE,
        new StartupCallback() {
          @Override
          public void callback() {
            SetupController.SETUP.startup();
            RegistryClient.getClient().register(event.getServletContext().getContextPath());
          }
        }, Service.IMAGE);
  }
}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/ImageScaler.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image;

import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.entities.ImageSize;

/**
 * Utility class with static methods to scale a
 * {@link java.awt.image.BufferedImage} to a given size or by a given ratio,
 * returning a copy of the {@link java.awt.image.BufferedImage} with the scaled
 * size and identical content.
 * 
 * @author Norbert Schmitt
 *
 */
public final class ImageScaler {

  private static Logger log = LoggerFactory.getLogger(ImageScaler.class);

  private ImageScaler() {
	  
  }
  
  /**
   * Scales a given image by rendering the supplied image to the size, determined
   * by the given {@link tools.descartes.teastore.entities.ImageSize}. The method
   * will throw a {@link java.lang.NullPointerException} if the supplied image or
   * size is null.
   * 
   * @param image
   *          Image to scale to the given size
   * @param size
   *          Size to scale image to
   * @return New image scaled to the given
   *         {@link tools.descartes.teastore.entities.ImageSize}
   */
  public static BufferedImage scale(BufferedImage image, ImageSize size) {
    if (size == null) {
      log.error(""The supplied image size is null."");
      throw new NullPointerException(""The supplied image size is null."");
    }

    return scale(image, size.getWidth(), size.getHeight());
  }

  /**
   * Scales a given image by rendering the supplied image by the given scaling
   * factor. Width and height are scaled by the same factor. Ratios above one will
   * result in larger images and ratios below one will result in smaller images.
   * The new image size is calculated by multiplying the ratio with the old image
   * size. Numbers behind the decimal point will dropped (integer arithmetics).
   * The method will throw an {@link java.lang.IllegalArgumentException} if the
   * scaling factor is 0 or below. A {@link java.lang.NullPointerException} will
   * be thrown if the supplied image is null.
   * 
   * @param image
   *          Image to scale by the given ratio
   * @param scalingFactor
   *          Ratio to scale image
   * @return New image scaled by the given ratio
   */
  public static BufferedImage scale(BufferedImage image, double scalingFactor) {
    if (scalingFactor <= 0.0) {
      log.error(""The supplied scaling factor is 0 or below."");
      throw new IllegalArgumentException(""The supplied scaling factor is 0 or below."");
    }

    return scale(image, scalingFactor, scalingFactor);
  }

  /**
   * Scales a given image by rendering the supplied image by the two given scaling
   * factors for width and height. Width and height are scaled independently.
   * Ratios above one will result in larger images and ratios below one will
   * result in smaller images. The new image size is calculated by multiplying the
   * ratio with the old image size. Numbers behind the decimal point will dropped
   * (integer arithmetics). The method will throw an
   * {@link java.lang.IllegalArgumentException} if either of the two scaling
   * factors is 0 or below. A {@link java.lang.NullPointerException} will be
   * thrown if the supplied image is null.
   * 
   * @param image
   *          Image to scale by the two given ratio
   * @param widthScaling
   *          Ratio to scale image width
   * @param heightScaling
   *          Ratio to scale image height
   * @return New image scaled by the given ratios
   */
  public static BufferedImage scale(BufferedImage image, double widthScaling,
      double heightScaling) {
    if (widthScaling <= 0.0) {
      log.error(""The supplied width scaling factor is 0 or below."");
      throw new IllegalArgumentException(""The supplied width scaling factor is 0 or below."");
    }
    if (heightScaling <= 0.0) {
      log.error(""The supplied height scaling factor is 0 or below."");
      throw new IllegalArgumentException(""The supplied height scaling factor is 0 or below."");
    }

    int newWidth = (int) (image.getWidth() * widthScaling);
    if (newWidth == 0) {
      newWidth = 1;
    }
    
    int newHeight = (int) (image.getHeight() * heightScaling);
    if (newHeight == 0) {
      newHeight = 1;
    }
    
    return scale(image, newWidth, newHeight);
  }

  /**
   * Scales a given image by rendering the supplied image to the given size. The
   * method will return a new image with the given size as width and height. The
   * method will throw an {@link java.lang.IllegalArgumentException} if the pixel
   * size is 0 or below. A {@link java.lang.NullPointerException} will be thrown
   * if the supplied image is null
   * 
   * @param image
   *          Image to scale to the given size
   * @param size
   *          Size to scale image to in pixel
   * @return New image scaled to the given size
   */
  public static BufferedImage scale(BufferedImage image, int size) {
    if (size <= 0) {
      log.error(""The supplied pixel size is below 1."");
      throw new IllegalArgumentException(""The supplied pixel size is below 1."");
    }

    return scale(image, size, size);
  }

  /**
   * Scales a given image by rendering the supplied image with the given width and
   * height into a new image and returning the new image. The method will throw an
   * {@link java.lang.IllegalArgumentException} if either of the two image sizes
   * is 0 or below. A {@link java.lang.NullPointerException} will be thrown if the
   * supplied image is null.
   * 
   * @param image
   *          Image to scale to the given width and height
   * @param width
   *          Width to scale image to
   * @param height
   *          Height to scale image to
   * @return New image scaled to the given width and height
   */
  public static BufferedImage scale(BufferedImage image, int width, int height) {
    if (image == null) {
      log.error(""The supplied image is null."");
      throw new NullPointerException(""The supplied image is null."");
    }
    if (width <= 0) {
      log.error(""The supplied pixel width is below 1."");
      throw new IllegalArgumentException(""The supplied pixel width is below 1."");
    }
    if (height <= 0) {
      log.error(""The supplied pixel height is below 1."");
      throw new IllegalArgumentException(""The supplied pixel height is below 1."");
    }

    BufferedImage scaledImg = new BufferedImage(width, height, BufferedImage.TRANSLUCENT);
    Graphics2D graphics = scaledImg.createGraphics();
    graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION,
        RenderingHints.VALUE_INTERPOLATION_BICUBIC);
    graphics.drawImage(image, 0, 0, width, height, null);
    graphics.dispose();
    return scaledImg;
  }
}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/AbstractQueueCache.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache;

import java.util.LinkedList;
import java.util.function.Predicate;

import tools.descartes.teastore.image.cache.entry.ICachable;
import tools.descartes.teastore.image.cache.entry.SimpleEntry;
import tools.descartes.teastore.image.storage.IDataStorage;

/**
 * Abstract cache class using a queue as internal collection for cache entries.
 * @author Norbert Schmitt
 *
 * @param <T> Entry Type implementing ICachable.
 */
public abstract class AbstractQueueCache<T extends ICachable<T>>
    extends AbstractCache<LinkedList<SimpleEntry<T>>, T, SimpleEntry<T>> {

  /**
   * Base constructor used by specific implementations.
   * @param cachedStorage Storage object to query if an entry is not found in the cache.
   * @param maxCacheSize Maximum memory used by the cache in bytes.
   * @param cachingRule Caching rule determining if data should be cached.
   */
  public AbstractQueueCache(IDataStorage<T> cachedStorage, long maxCacheSize,
      Predicate<T> cachingRule) {
    super(new LinkedList<>(), cachedStorage, maxCacheSize, cachingRule);
  }

  /*
   * Implementations of abstract superclass
   */

  @Override
  public SimpleEntry<T> createEntry(T data) {
    return new SimpleEntry<T>(data);
  }

  @Override
  protected abstract void removeEntryByCachingStrategy();

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/RandomReplacement.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache;

import java.util.Random;
import java.util.function.Predicate;

import tools.descartes.teastore.image.cache.entry.ICachable;
import tools.descartes.teastore.image.cache.rules.CacheAll;
import tools.descartes.teastore.image.storage.IDataStorage;

/**
 * Random replacement (RR) cache implementation.
 * @author Norbert Schmitt
 *
 * @param <T> Entry Type implementing ICachable.
 */
public class RandomReplacement<T extends ICachable<T>> extends AbstractQueueCache<T> {

  private Random rand = new Random();

  /**
   * RR cache standard constructor setting the maximum cache size to the standard value 
   * {@link tools.descartes.teastore.image.cache.IDataCache.STD_MAX_CACHE_SIZE} and allowing all data to be cached.
   */
  public RandomReplacement() {
    this(IDataCache.STD_MAX_CACHE_SIZE);
  }

  /**
   * RR cache constructor setting the maximum cache size to the given size and allowing all data to be cached.
   * @param maxCacheSize Maximum cache size in bytes.
   */
  public RandomReplacement(long maxCacheSize) {
    this(maxCacheSize, new CacheAll<T>());
  }

  /**
   * RR cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   */
  public RandomReplacement(long maxCacheSize, Predicate<T> cachingRule) {
    this(null, maxCacheSize, cachingRule);
  }

  /**
   * RR cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule. This constructor also lets you set the underlying storage, queried if an entry is not 
   * found in the cache.
   * @param cachedStorage Storage object to query if an entry is not found in the cache.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   */
  public RandomReplacement(IDataStorage<T> cachedStorage, long maxCacheSize,
      Predicate<T> cachingRule) {
    super(cachedStorage, maxCacheSize, cachingRule);
  }

  /**
   * RR cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule. This constructor also lets you set the underlying storage, queried if an entry is not 
   * found in the cache. The given seed will be used for the random number generator to behave deterministically.
   * @param cachedStorage Storage object to query if an entry is not found in the cache.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   * @param seed Specified seed for the random number generator.
   */
  public RandomReplacement(IDataStorage<T> cachedStorage, long maxCacheSize,
      Predicate<T> cachingRule, long seed) {
    super(cachedStorage, maxCacheSize, cachingRule);
    setSeed(seed);
  }

  /**
   * Sets the seed for the random number generator to the given value.
   * @param seed Specified seed for the random number generator.
   */
  public void setSeed(long seed) {
    rand.setSeed(seed);
  }

  @Override
  protected void removeEntryByCachingStrategy() {
    dataRemovedFromCache(getEntries().remove(rand.nextInt(getEntries().size())).getByteSize());
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/LastInFirstOut.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache;

import java.util.function.Predicate;

import tools.descartes.teastore.image.cache.entry.ICachable;
import tools.descartes.teastore.image.cache.rules.CacheAll;
import tools.descartes.teastore.image.storage.IDataStorage;

/**
 * LIFO cache implementation.
 * @author Norbert Schmitt
 *
 * @param <T> Entry Type implementing ICachable.
 */
public class LastInFirstOut<T extends ICachable<T>> extends AbstractQueueCache<T> {

  /**
   * LIFO cache standard constructor setting the maximum cache size to the standard value 
   * {@link tools.descartes.teastore.image.cache.IDataCache.STD_MAX_CACHE_SIZE} and allowing all data to be cached.
   */
  public LastInFirstOut() {
    this(IDataCache.STD_MAX_CACHE_SIZE);
  }
  
  /**
   * LIFO cache constructor setting the maximum cache size to the given size and allowing all data to be cached.
   * @param maxCacheSize Maximum cache size in bytes.
   */
  public LastInFirstOut(long maxCacheSize) {
    this(maxCacheSize, new CacheAll<T>());
  }
  
  /**
   * LIFO cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   */
  public LastInFirstOut(long maxCacheSize, Predicate<T> cachingRule) {
    this(null, maxCacheSize, cachingRule);
  }

  /**
   * LIFO cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule. This constructor also lets you set the underlying storage, queried if an entry is not 
   * found in the cache.
   * @param cachedStorage Storage object to query if an entry is not found in the cache.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   */
  public LastInFirstOut(IDataStorage<T> cachedStorage, long maxCacheSize,
      Predicate<T> cachingRule) {
    super(cachedStorage, maxCacheSize, cachingRule);
  }

  @Override
  protected void removeEntryByCachingStrategy() {
    dataRemovedFromCache(getEntries().pollLast().getData().getByteSize());
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/IDataCache.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache;

import tools.descartes.teastore.image.cache.entry.ICachable;
import tools.descartes.teastore.image.storage.IDataStorage;

/**
 * Interface defining all functions available to a cache. This interface extends 
 * {@link tools.descartes.teastore.image.storage.IDataStorage} to allow multiple cache levels.
 * @author Norbert Schmitt
 *
 * @param <T> Entry Type implementing ICachable.
 */
public interface IDataCache<T extends ICachable<T>> extends IDataStorage<T> {

  /**
   * Standard cache size of 3MiB.
   */
  public static final long STD_MAX_CACHE_SIZE = 3 * 1024 * 1024;

  /**
   * Returns the maximum cache size in bytes.
   * @return Maximum cache size in bytes.
   */
  public long getMaxCacheSize();

  /**
   * Returns the current size of the data in the cache in bytes.
   * @return Current size of the data in the cache in bytes.
   */
  public long getCurrentCacheSize();

  /**
   * Returns the remaining space for data in bytes.
   * @return Remaining space for data in bytes.
   */
  public long getFreeSpace();

  /**
   * Checks if there is enough space left for the given size.
   * @param size Size to check for in bytes.
   * @return True if the cache has enough memory left or false otherwise.
   */
  public boolean hasStorageFor(long size);

  /**
   * Inserts data into the cache if allowed by the caching rule. Will evict one or more entries if not enough memory 
   * is left.
   * @param data Data object to cache.
   */
  public void cacheData(T data);

  /**
   * Remove data from cache.
   * @param data Data to be removed from cache.
   */
  public void uncacheData(T data);

  /**
   * Checks whether data is cachable according to the caching rule.
   * @param data Data to be checked if it is cachable.
   * @return True if the caching rule allows caching of the given object or false otherwise.
   */
  public boolean dataIsCachable(T data);

  /**
   * Checks whether a given ID resides in the cache.
   * @param id ID to check if it resides in the cache.
   * @return True if the data with the given ID resides in cache or false otherwise.
   */
  public boolean dataIsInCache(long id);

  /**
   * Resets the cache and deletes all elements from it.
   */
  public void clearCache();

  /**
   * Changes the maximum cache size. If the new cache size is smaller than before, entries could be evicted according 
   * to the eviction strategy.
   * @param cacheSize Positive maximum size of the cache in bytes.
   * @return True if the new cache size was successfully set or false otherwise.
   */
  public boolean setMaxCacheSize(long cacheSize);

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/FirstInFirstOut.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache;

import java.util.function.Predicate;

import tools.descartes.teastore.image.cache.entry.ICachable;
import tools.descartes.teastore.image.cache.rules.CacheAll;
import tools.descartes.teastore.image.storage.IDataStorage;

/**
 * FIFO cache implementation.
 * @author Norbert Schmitt
 *
 * @param <T> Entry Type implementing ICachable.
 */
public class FirstInFirstOut<T extends ICachable<T>> extends AbstractQueueCache<T> {

  /**
   * FIFO cache standard constructor setting the maximum cache size to the standard value 
   * {@link tools.descartes.teastore.image.cache.IDataCache.STD_MAX_CACHE_SIZE} and allowing all data to be cached.
   */
  public FirstInFirstOut() {
    this(IDataCache.STD_MAX_CACHE_SIZE);
  }

  /**
   * FIFO cache constructor setting the maximum cache size to the given size and allowing all data to be cached.
   * @param maxCacheSize Maximum cache size in bytes.
   */
  public FirstInFirstOut(long maxCacheSize) {
    this(maxCacheSize, new CacheAll<T>());
  }

  /**
   * FIFO cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   */
  public FirstInFirstOut(long maxCacheSize, Predicate<T> cachingRule) {
    this(null, maxCacheSize, cachingRule);
  }

  /**
   * FIFO cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule. This constructor also lets you set the underlying storage, queried if an entry is not 
   * found in the cache.
   * @param cachedStorage Storage object to query if an entry is not found in the cache.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   */
  public FirstInFirstOut(IDataStorage<T> cachedStorage, long maxCacheSize,
      Predicate<T> cachingRule) {
    super(cachedStorage, maxCacheSize, cachingRule);
  }

  @Override
  protected void removeEntryByCachingStrategy() {
    dataRemovedFromCache(getEntries().pollFirst().getData().getByteSize());
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/LeastFrequentlyUsed.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache;

import java.util.function.Predicate;

import tools.descartes.teastore.image.cache.entry.CountedEntry;
import tools.descartes.teastore.image.cache.entry.ICachable;
import tools.descartes.teastore.image.cache.rules.CacheAll;
import tools.descartes.teastore.image.storage.IDataStorage;

/**
 * Least frequently used (LFU) cache implementation.
 * @author Norbert Schmitt
 *
 * @param <T> Entry Type implementing ICachable.
 */
public class LeastFrequentlyUsed<T extends ICachable<T>>
    extends AbstractTreeCache<T, CountedEntry<T>> {

  /**
   * LFU cache standard constructor setting the maximum cache size to the standard value 
   * {@link tools.descartes.teastore.image.cache.IDataCache.STD_MAX_CACHE_SIZE} and allowing all data to be cached.
   */
  public LeastFrequentlyUsed() {
    this(IDataCache.STD_MAX_CACHE_SIZE);
  }

  /**
   * LFU cache constructor setting the maximum cache size to the given size and allowing all data to be cached.
   * @param maxCacheSize Maximum cache size in bytes.
   */
  public LeastFrequentlyUsed(long maxCacheSize) {
    this(maxCacheSize, new CacheAll<T>());
  }

  /**
   * LFU cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   */
  public LeastFrequentlyUsed(long maxCacheSize, Predicate<T> cachingRule) {
    this(null, maxCacheSize, cachingRule);
  }

  /**
   * LFU cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule. This constructor also lets you set the underlying storage, queried if an entry is not 
   * found in the cache.
   * @param cachedStorage Storage object to query if an entry is not found in the cache.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   */
  public LeastFrequentlyUsed(IDataStorage<T> cachedStorage, long maxCacheSize,
      Predicate<T> cachingRule) {
    super(cachedStorage, maxCacheSize, cachingRule,
        (a, b) -> {
          if (a.getId() == b.getId()) {
            return 0;
          } else if (a.getUseCount() - b.getUseCount() != 0) {
        	  return a.getUseCount() - b.getUseCount();
          } else if (a.getId() < b.getId()) {
        	  return -1;
          } else {
        	  return 1;
          }
        });
  }

  @Override
  protected CountedEntry<T> createEntry(T data) {
    return new CountedEntry<T>(data);
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/LeastRecentlyUsed.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache;

import java.util.function.Predicate;

import tools.descartes.teastore.image.cache.entry.ICachable;
import tools.descartes.teastore.image.cache.entry.TimedEntry;
import tools.descartes.teastore.image.cache.rules.CacheAll;
import tools.descartes.teastore.image.storage.IDataStorage;

/**
 * Least recently used (LRU) cache implementation.
 * @author Norbert Schmitt
 *
 * @param <T> Entry Type implementing ICachable.
 */
public class LeastRecentlyUsed<T extends ICachable<T>> extends AbstractTreeCache<T, TimedEntry<T>> {

  /**
   * LRU cache standard constructor setting the maximum cache size to the standard value 
   * {@link tools.descartes.teastore.image.cache.IDataCache.STD_MAX_CACHE_SIZE} and allowing all data to be cached.
   */
  public LeastRecentlyUsed() {
    this(IDataCache.STD_MAX_CACHE_SIZE);
  }

  /**
   * LRU cache constructor setting the maximum cache size to the given size and allowing all data to be cached.
   * @param maxCacheSize Maximum cache size in bytes.
   */
  public LeastRecentlyUsed(long maxCacheSize) {
    this(maxCacheSize, new CacheAll<T>());
  }

  /**
   * LRU cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   */
  public LeastRecentlyUsed(long maxCacheSize, Predicate<T> cachingRule) {
    this(null, maxCacheSize, cachingRule);
  }

  /**
   * LRU cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule. This constructor also lets you set the underlying storage, queried if an entry is not 
   * found in the cache.
   * @param cachedStorage Storage object to query if an entry is not found in the cache.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   */
  public LeastRecentlyUsed(IDataStorage<T> cachedStorage, long maxCacheSize,
      Predicate<T> cachingRule) {
    super(cachedStorage, maxCacheSize, cachingRule,
        (a, b) -> {
          if (a.getTime() - b.getTime() < 0) {
        	return -1;
          } else if (a.getTime() - b.getTime() > 0) {
        	return 1;
          } else if (a.getId() < b.getId()) {
        	return -1;
          } else if (a.getId() == b.getId()) {
        	return 0;
          } else {
        	return 1;
          }
        });
  }

  @Override
  protected TimedEntry<T> createEntry(T data) {
    return new TimedEntry<>(data);
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/MostRecentlyUsed.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache;

import java.util.function.Predicate;

import tools.descartes.teastore.image.cache.entry.ICachable;
import tools.descartes.teastore.image.cache.entry.TimedEntry;
import tools.descartes.teastore.image.cache.rules.CacheAll;
import tools.descartes.teastore.image.storage.IDataStorage;

/**
 * Most recently used (MRU) cache implementation.
 * @author Norbert Schmitt
 *
 * @param <T> Entry Type implementing ICachable.
 */
public class MostRecentlyUsed<T extends ICachable<T>> extends AbstractTreeCache<T, TimedEntry<T>> {

  /**
   * MRU cache standard constructor setting the maximum cache size to the standard value 
   * {@link tools.descartes.teastore.image.cache.IDataCache.STD_MAX_CACHE_SIZE} and allowing all data to be cached.
   */
  public MostRecentlyUsed() {
    this(IDataCache.STD_MAX_CACHE_SIZE);
  }
	
  /**
   * MRU cache constructor setting the maximum cache size to the given size and allowing all data to be cached.
   * @param maxCacheSize Maximum cache size in bytes.
   */
  public MostRecentlyUsed(long maxCacheSize) {
    this(maxCacheSize, new CacheAll<T>());
  }

  /**
   * MRU cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   */
  public MostRecentlyUsed(long maxCacheSize, Predicate<T> cachingRule) {
    this(null, maxCacheSize, cachingRule);
  }

  /**
   * MRU cache constructor setting the maximum cache size to the given size and caching only data that is tested true 
   * for the given caching rule. This constructor also lets you set the underlying storage, queried if an entry is not 
   * found in the cache.
   * @param cachedStorage Storage object to query if an entry is not found in the cache.
   * @param maxCacheSize Maximum cache size in bytes.
   * @param cachingRule Cache rule determining which data will be cached.
   */
  public MostRecentlyUsed(IDataStorage<T> cachedStorage, long maxCacheSize, Predicate<T> cachingRule) {
    super(cachedStorage, maxCacheSize, cachingRule, (a, b) -> {
      if (a.getTime() - b.getTime() < 0) {
    	return 1;
      } else if (a.getTime() - b.getTime() > 0) {
    	return -1;
      } else if (a.getId() < b.getId()) {
    	return -1;
      } else if (a.getId() == b.getId()) {
    	return 0;
      } else {
    	return -1;
      }
    });
  }

  @Override
  protected TimedEntry<T> createEntry(T data) {
    return new TimedEntry<>(data);
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/AbstractTreeCache.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache;

import java.util.Comparator;
import java.util.TreeSet;
import java.util.function.Predicate;

import tools.descartes.teastore.image.cache.entry.ICachable;
import tools.descartes.teastore.image.cache.entry.ICacheEntry;
import tools.descartes.teastore.image.storage.IDataStorage;

/**
 * Abstract cache class using a sorted tree as internal collection for cache entries.
 * @author Norbert Schmitt
 *
 * @param <T> Entry Type implementing ICachable.
 * @param <F> Entry Wrapper Type.
 */
public abstract class AbstractTreeCache<T extends ICachable<T>, F extends ICacheEntry<T>>
    extends AbstractCache<TreeSet<F>, T, F> {

  /**
   * Base constructor used by specific implementations.
   * @param cachedStorage Storage object to query if an entry is not found in the cache.
   * @param maxCacheSize Maximum memory used by the cache in bytes.
   * @param cachingRule Caching rule determining if data should be cached.
   * @param ordering Predicate determining the eviction strategy (sorting if the internal tree) if no memory is left. 
   */
  public AbstractTreeCache(IDataStorage<T> cachedStorage, long maxCacheSize,
      Predicate<T> cachingRule, Comparator<F> ordering) {
    super(new TreeSet<>(ordering), cachedStorage, maxCacheSize, cachingRule);
  }

  @Override
  protected abstract F createEntry(T data);

  @Override
  protected void removeEntryByCachingStrategy() {
    dataRemovedFromCache(getEntries().pollFirst().getByteSize());
  }

  @Override
  protected void reorderAndTag(F data) {
    getEntries().remove(data);
    data.wasUsed();
    getEntries().add(data);
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/AbstractCache.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache;

import java.util.Collection;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.Predicate;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.image.cache.entry.ICachable;
import tools.descartes.teastore.image.cache.entry.ICacheEntry;
import tools.descartes.teastore.image.storage.IDataStorage;
import tools.descartes.teastore.image.storage.NoStorage;

/**
 * Abstract base class for all cache implementations.
 * @author Norbert Schmitt
 *
 * @param <S> Internal Storage Type.
 * @param <T> Entry Type implementing ICachable.
 * @param <F> Entry Wrapper Type.
 */
public abstract class AbstractCache<S extends Collection<F>, T extends ICachable<T>, F extends ICacheEntry<T>>
    implements IDataCache<T> {

  private IDataStorage<T> cachedStorage;
  private S entries;
  private long maxCacheSize;
  private long currentCacheSize;
  private Predicate<T> cachingRule;
  private Logger log = LoggerFactory.getLogger(AbstractCache.class);
  private final ReadWriteLock lock = new ReentrantReadWriteLock();

  /**
   * Basic abstract cache constructor for subclasses.  
   * @param entries Collection to store entries.
   * @param cachedStorage Storage object to query if an entry is not found in the cache.
   * @param maxCacheSize Maximum memory used by the cache in bytes.
   * @param cachingRule Caching rule determining if data should be cached.
   */
  public AbstractCache(S entries, IDataStorage<T> cachedStorage, long maxCacheSize,
      Predicate<T> cachingRule) {
    if (entries == null) {
      log.error(""The provided internal storage object is null."");
      throw new NullPointerException(""The provided internal storage object is null."");
    }
    if (cachingRule == null) {
      log.error(""The provided caching rule is null."");
      throw new NullPointerException(""The provided caching rule is null."");
    }

    if (cachedStorage == null) {
      log.info(""No underlying disk storage supplied, assuming no data is stored on disk."");
      this.cachedStorage = new NoStorage<T>();
    } else {
      this.cachedStorage = cachedStorage;
    }
    this.entries = entries;
    this.cachingRule = cachingRule;
    setMaxCacheSize(maxCacheSize);
  }
  
  /**
   * Returns the storage object queried if entry cannot be found in the cache.
   * @return Storage object.
   */
  protected IDataStorage<T> getCachedStorage() {
	  return cachedStorage;
  }
  
  /**
   * Returns the collection containing all cached entries.
   * @return Entry collection.
   */
  protected S getEntries() {
	  return entries;
  }

  private F findInEntries(long id) {
    return entries.stream().filter(entry -> entry.getId() == id).findFirst().orElse(null);
  }

  private T getData(long id, boolean markUsed) {
    F data = null;
    if (markUsed) {
      lock.writeLock().lock();
      try {
        data = findInEntries(id);
        if (data != null) {
          // Set entries must be reordered. A change in the object itself will not trigger
          // a reordering
          reorderAndTag(data);
        }
      } finally {
        lock.writeLock().unlock();
      }
    } else {
      lock.readLock().lock();
      try {
        data = findInEntries(id);
      } finally {
        lock.readLock().unlock();
      }
    }
    if (data != null) {
      return data.getData();
    }
    return null;
  }

  /*
   * Implementations for interface IDataCache
   */

  @Override
  public long getMaxCacheSize() {
    return maxCacheSize;
  }

  @Override
  public boolean setMaxCacheSize(long maxCacheSize) {
    if (maxCacheSize <= 0) {
      log.error(""The provided cache size is negative. Must be positive."");
      throw new IllegalArgumentException(""The provided cache size is negative. Must be positive."");
    }

    lock.writeLock().lock();
    try {
      this.maxCacheSize = maxCacheSize;
      // If the new cache size is smaller than the old one, we might need to evict
      // entries
      while (getFreeSpace() < 0) {
        removeEntryByCachingStrategy();
      }
    } finally {
      lock.writeLock().unlock();
    }
    return true;
  }

  @Override
  public long getCurrentCacheSize() {
    long size = 0;
    lock.readLock().lock();
    try {
      size = currentCacheSize;
    } finally {
      lock.readLock().unlock();
    }
    return size;
  }

  @Override
  public long getFreeSpace() {
    return maxCacheSize - getCurrentCacheSize();
  }

  @Override
  public boolean hasStorageFor(long size) {
    return size <= getFreeSpace();
  }

  @Override
  public void cacheData(T data) {
    if (!dataIsCachable(data) || dataIsInCache(data.getId())) {
      return;
    }

    if (data.getByteSize() > maxCacheSize) {
      return;
    }

    lock.writeLock().lock();
    try {
      while (!hasStorageFor(data.getByteSize())) {
        removeEntryByCachingStrategy();
      }
      addEntry(createEntry(data));
    } finally {
      lock.writeLock().unlock();
    }
  }

  @Override
  public void uncacheData(T data) {
    lock.writeLock().lock();
    try {
      if (entries.remove(createEntry(data))) {
        dataRemovedFromCache(data.getByteSize());
      }
    } finally {
      lock.writeLock().unlock();
    }
  }

  @Override
  public boolean dataIsCachable(T data) {
    return cachingRule.test(data);
  }

  @Override
  public boolean dataIsInCache(long id) {
    return getData(id, false) != null;
  }

  @Override
  public void clearCache() {
    lock.writeLock().lock();
    try {
      entries.clear();
      currentCacheSize = 0;
    } finally {
      lock.writeLock().unlock();
    }
  }

  /*
   * Implementations for interface IDataStorage
   */

  @Override
  public boolean dataExists(long id) {
    boolean result = false;
    lock.readLock().lock();
    try {
      if (dataIsInCache(id)) {
        result = true;
      } else {
        result = cachedStorage.dataExists(id);
      }
    } finally {
      lock.readLock().unlock();
    }
    return result;
  }

  @Override
  public T loadData(long id) {
    // Search entry in cache
    T entry = getData(id, true);
    if (entry == null) {
      // No entry in cache found, search in underlying storage
      entry = cachedStorage.loadData(id);
      if (entry == null) {
        return null;
      }
      // Data found, cache it and return
      cacheData(entry);
    }
    return entry;
  }

  @Override
  public boolean saveData(T data) {
    if (data == null) {
      return false;
    }

    cacheData(data);
    return cachedStorage.saveData(data);
  }

  @Override
  public boolean dataIsStorable(T data) {
    return cachedStorage.dataIsStorable(data);
  }

  @Override
  public boolean deleteData(T data) {
    uncacheData(data);
    return cachedStorage.deleteData(data);
  }

  /*
   * Modifier for current cache size
   */

  /**
   * Changes the current memory size of this cache by subtracting the given byte size from the current size.
   * @param size Bytes removed from cache.
   */
  protected void dataRemovedFromCache(long size) {
    lock.writeLock().lock();
    try {
      if (size > currentCacheSize) {
        currentCacheSize = 0;
      } else {
        currentCacheSize -= size;
      }
    } finally {
      lock.writeLock().unlock();
    }
  }

  /**
   * Changes the current memory size of this cache by adding the given byte size to the current size.
   * @param size Bytes added to cache.
   */
  protected void dataAddedToCache(long size) {
    lock.writeLock().lock();
    try {
      currentCacheSize += size;
    } finally {
      lock.writeLock().unlock();
    }
  }

  /*
   * Abstract methods to store data that is implementation specific
   */

  /**
   * Creates a wrapper object that can be stored in the cache, containing the given data.
   * @param data Data to wrap in cache entry wrapper object.
   * @return Wrapped cache entry.
   */
  protected abstract F createEntry(T data);

  /**
   * Inserts a given entry wrapper object into the cache.
   * @param data Wrapper object to insert into internal collection.
   */
  protected void addEntry(F data) {
    if (entries.add(data)) {
      dataAddedToCache(data.getByteSize());
    }
  }

  /**
   * Evicts one entry in the cache according to the caching strategy of a specific implementation.
   */
  protected abstract void removeEntryByCachingStrategy();

  /**
   * Tags an element as used and restores order in the entry collection as the wrapper object has changed.
   * @param data Wrapper object to tag as used.
   */
  protected void reorderAndTag(F data) {
    // In the best case, we only have to tag the data as used
    data.wasUsed();
  }
}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/entry/ICacheEntry.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache.entry;

/**
 * Basic wrapper type stored by all cache implementations. It wraps the data
 * stored in a cache.
 * 
 * @author Norbert Schmitt
 *
 * @param <T>
 *          The data type that should be cached. Must implement
 *          {@link tools.descartes.teastore.image.cache.entry.ICachable}.
 */
public interface ICacheEntry<T extends ICachable<T>> extends ICachable<T> {

  /**
   * Method signaling to the wrapper that this entry was read from the cache.
   */
  public void wasUsed();

  /**
   * Returns the cachable data stored in this wrapper class.
   * 
   * @return The cachable data
   */
  public T getData();

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/entry/CountedEntry.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache.entry;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * Wrapper class for caches with a replacement strategy that relies on counting
 * how often the entry was retrieved from cache. For example the
 * {@link tools.descartes.teastore.image.cache.LeastFrequentlyUsed}.
 * 
 * @author Norbert Schmitt
 *
 * @param <D>
 *          Cachable data that must implement
 *          {@link tools.descartes.teastore.image.cache.entry.ICachable}
 */
public class CountedEntry<D extends ICachable<D>> extends AbstractEntry<D> {

  private AtomicInteger useCount = new AtomicInteger();

  /**
   * Basic constructor storing the cachable data. If the cachable data supplied is
   * null, a {@link java.lang.NullPointerException} is thrown.
   * 
   * @param data
   *          Cachable data
   */
  public CountedEntry(D data) {
    super(data);
  }

  /**
   * Returns how often the entry was retrieved from cache.
   * 
   * @return Number of times this entry was retrieved from cache
   */
  public int getUseCount() {
    return useCount.get();
  }

  @Override
  public void wasUsed() {
    useCount.incrementAndGet();
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/entry/TimedEntry.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache.entry;

import java.util.concurrent.atomic.AtomicLong;

/**
 * Wrapper class for caches with a replacement strategy that relies on a
 * timestamp when the entry was retrieved from cache. For example the
 * {@link tools.descartes.teastore.image.cache.LeastRecentlyUsed} or
 * {@link tools.descartes.teastore.image.cache.MostRecentlyUsed}.
 * 
 * @author Norbert Schmitt
 *
 * @param <D>
 *          Cachable data that must implement
 *          {@link tools.descartes.teastore.image.cache.entry.ICachable}
 */
public class TimedEntry<D extends ICachable<D>> extends AbstractEntry<D> {

  private AtomicLong time = new AtomicLong();

  /**
   * Basic constructor storing the cachable data. If the cachable data supplied is
   * null, a {@link java.lang.NullPointerException} is thrown.
   * 
   * @param data
   *          Cachable data
   */
  public TimedEntry(D data) {
    super(data);
    wasUsed();
  }

  /**
   * Returns the last time this entry was retrieved from cache.
   * 
   * @return The last time in nanoseconds
   */
  public long getTime() {
    return time.get();
  }

  @Override
  public void wasUsed() {
    time.set(System.nanoTime());
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/entry/AbstractEntry.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache.entry;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Base wrapper class for cachable data types.
 * 
 * @author Norbert Schmitt
 *
 * @param <D>
 *          Cachable data that must implement
 *          {@link tools.descartes.teastore.image.cache.entry.ICachable}
 */
public abstract class AbstractEntry<D extends ICachable<D>> implements ICacheEntry<D> {

  private D data;
  private Logger log = LoggerFactory.getLogger(AbstractEntry.class);

  /**
   * Basic constructor storing the cachable data. If the cachable data supplied is
   * null, a {@link java.lang.NullPointerException} is thrown.
   * 
   * @param data
   *          Cachable data
   */
  public AbstractEntry(D data) {
    if (data == null) {
      log.error(""The supplied data is null."");
      throw new NullPointerException(""Supplied data is null."");
    }

    this.data = data;
  }

  @Override
  public D getData() {
    return data;
  }

  @Override
  public abstract void wasUsed();

  @Override
  public long getId() {
    return data.getId();
  }

  @Override
  public long getByteSize() {
    return data.getByteSize();
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    if (data == null) {
      result = prime * result + 0;
    } else {
      result = prime * result + data.hashCode();
    }
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    AbstractEntry<?> other = (AbstractEntry<?>) obj;
    if (data == null) {
      if (other.data != null) {
        return false;
      }
    } else if (!data.equals(other.data)) {
      return false;
    }
    return true;
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/entry/SimpleEntry.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache.entry;

/**
 * Instantiable wrapper class not storing any additional data aparat from the
 * cachable data.
 * 
 * @author Norbert Schmitt
 *
 * @param <D>
 *          Cachable data that must implement
 *          {@link tools.descartes.teastore.image.cache.entry.ICachable}
 */
public class SimpleEntry<D extends ICachable<D>> extends AbstractEntry<D> {

  /**
   * Basic constructor storing the cachable data. If the cachable data supplied is
   * null, a {@link java.lang.NullPointerException} is thrown.
   * 
   * @param data
   *          Cachable data
   */
  public SimpleEntry(D data) {
    super(data);
  }

  @Override
  public void wasUsed() {
    // There is nothing to do.
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/entry/ICachable.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache.entry;

/**
 * Interface that must be imlemented if it should use the cache implementations
 * provided in the package {@link tools.descartes.teastore.image.cache}. Each
 * cachable data type must have a unique ID and a byte size to be identifiable
 * and the cache can determine if there is enough space left.
 * 
 * @author Norbert Schmitt
 *
 * @param <D>
 *          Data type that must implement this interface.
 */
public interface ICachable<D extends ICachable<D>> {

  /**
   * Returns the byte size of the cachable data.
   * 
   * @return The byte size of the cachable data
   */
  public long getByteSize();

  /**
   * Returns the unique identifier of the cachable data.
   * 
   * @return The unique identifier of the cachable data
   */
  public long getId();

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/cache/rules/CacheAll.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.cache.rules;

import java.util.function.Predicate;

import tools.descartes.teastore.image.cache.entry.ICachable;

/**
 * Standard caching rule allowing to cache all data inserted into a cache.
 * @author Norbert Schmitt
 *
 * @param <T> Entry Type implementing ICachable.
 */
public class CacheAll<T extends ICachable<T>> implements Predicate<T> {

  @Override
  public boolean test(T t) {
    return true;
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/rest/ImageProviderEndpoint.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image.rest;

import java.util.HashMap;
import java.util.stream.Collectors;

import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.entities.ImageSize;
import tools.descartes.teastore.image.ImageProvider;
import tools.descartes.teastore.image.setup.SetupController;

/**
 * The image provider REST endpoints for querying and controlling the image provider service.
 * @author Norbert Schmitt
 */
@Path(""image"")
@Produces({ ""application/json"" })
@Consumes({ ""application/json"" })
public class ImageProviderEndpoint {

  /**
   * Queries the image provider for the given product IDs in the given size, provided as strings.
   * @param images Map of product IDs and the corresponding image size as string.
   * @return Map of product IDs and the image data as base64 encoded string.
   */
  @POST
  @Path(""getProductImages"")
  public Response getProductImages(HashMap<Long, String> images) {
    return Response.ok()
        .entity(ImageProvider.IP.getProductImages(images.entrySet().parallelStream().collect(
            Collectors.toMap(e -> e.getKey(), e -> ImageSize.parseImageSize(e.getValue())))))
        .build();
  }

  /**
   * Queries the image provider for the given web interface image names in the given size, provided as strings.
   * @param images Map of web interface image names and the corresponding image size as string.
   * @return Map of web interface image names and the image data as base64 encoded string.
   */
  @POST
  @Path(""getWebImages"")
  public Response getWebUIImages(HashMap<String, String> images) {
    return Response.ok()
        .entity(ImageProvider.IP.getWebUIImages(images.entrySet().parallelStream().collect(
            Collectors.toMap(e -> e.getKey(), e -> ImageSize.parseImageSize(e.getValue())))))
        .build();
  }

  /**
   * Signals the image provider to regenerate all product images. This is usually necessary if the product database
   * changed.
   * @return Returns status code 200.
   */
  @GET
  @Path(""regenerateImages"")
  public Response regenerateImages() {
    SetupController.SETUP.reconfiguration();
    return Response.ok().build();
  }

  /**
   * Checks if the setup of the image provider and image generation has finished.
   * @return Returns true if the setup is finished.
   */
  @GET
  @Path(""finished"")
  public Response isFinished() {
    if (SetupController.SETUP.isFinished()) {
      return Response.ok(true).build();
    } else {
      return Response.serverError().entity(false).build();
    }
  }

  /**
   * Checks the current state, configuration settings, number of images, cache size, etc., of the image provider.
   * @return Returns a string containing the current state and configuration.
   */
  @GET
  @Path(""state"")
  @Produces({ ""text/plain"" })
  public Response getState() {
    return Response.ok().entity(SetupController.SETUP.getState()).build();
  }

  /**
   * Sets the cache size to the given value.
   * @param cacheSize The new cache size in bytes. Cache size must be positive.
   * @return True if the cache size was set successfully, otherwise false.
   */
  @POST
  @Path(""setCacheSize"")
  public Response setCacheSize(long cacheSize) {
    return Response.ok().entity(SetupController.SETUP.setCacheSize(cacheSize)).build();
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/ImageDBKey.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image;

/**
 * Entry for an image database ({@link tools.descartes.teastore.image.ImageDB}). 
 * @author Norbert Schmitt
 */
public class ImageDBKey {

  private final long productID;
  private final String webuiName;
  private final boolean isProductKey;

  /**
   * This entry will represent a product id in the image database.
   * @param productID Product id.
   */
  public ImageDBKey(long productID) {
    this.productID = productID;
    webuiName = null;
    isProductKey = true;
  }

  /**
   * This entry will represents a product id in the image database.
   * @param webuiName Web UI image name.
   */
  public ImageDBKey(String webuiName) {
    this.webuiName = webuiName;
    productID = 0;
    isProductKey = false;
  }

  /**
   * Checks whether this image database entry represents a product or a static image for the web interface. 
   * @return True if this image database entry represents a product id, otherwise false.
   */
  public boolean isProductKey() {
    return isProductKey;
  }

  /**
   * Returns the stored product id this entry represents or zero if it represents a web interface entry.
   * @return Product id or zero if it is a web interface entry.
   */
  public long getProductID() {
    return productID;
  }

  /**
   * Returns the stored web interface name or NULL if it represents a product id.
   * @return Web interface image name or NULL if it represents a product id.
   */
  public String getWebUIName() {
    return webuiName;
  }

}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/ImageDB.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.entities.ImageSize;

/**
 * Image database storing the relation between image names, product IDs and
 * image IDs as well as the available image size.
 * 
 * @author Norbert Schmitt
 */
public class ImageDB {

  // Internal storage container to allow mapping product IDs and image names (for
  // non-generated images) to images
  // with different sizes
  private HashMap<Long, Map<Long, ImageSize>> products = new HashMap<>();
  private HashMap<String, Map<Long, ImageSize>> webui = new HashMap<>();
  private HashMap<Long, ImageSize> sizes = new HashMap<>();
  private final Logger log = LoggerFactory.getLogger(ImageDB.class);

  // Locking
  private final ReadWriteLock lock = new ReentrantReadWriteLock();

  /**
   * Standard constructor creating a new and empty image database.
   */
  public ImageDB() {

  }

  /**
   * Copy constructor making a shallow copy of the given image database. If the
   * database to copy is null, a {@link java.lang.NullPointerException} will be
   * thrown.
   * 
   * @param copy
   *          Image database to copy.
   */
  public ImageDB(ImageDB copy) {
    if (copy == null) {
      log.error(""The supplied image database to copy is null."");
      throw new NullPointerException(""The supplied image database to copy is null."");
    }

    this.products = new HashMap<>(copy.products);
    this.webui = new HashMap<>(copy.webui);
    this.sizes = new HashMap<>(copy.sizes);
  }

  /**
   * Checks whether a given image key (product ID or name) is available in the
   * given size. If the given image key is null, a
   * {@link java.lang.NullPointerException} will be thrown.
   * 
   * @param imageKey
   *          Image key to check for
   * @param imageSize
   *          Image size to check for
   * @return True if the image was found in the correct size, otherwise false
   */
  public boolean hasImageID(ImageDBKey imageKey, ImageSize imageSize) {
    if (imageKey == null) {
      log.error(""The supplied image key is null."");
      throw new NullPointerException(""The supplied image key is null."");
    }

    if (imageKey.isProductKey()) {
      return hasImageID(imageKey.getProductID(), imageSize);
    }
    return hasImageID(imageKey.getWebUIName(), imageSize);
  }

  /**
   * Checks whether a given product ID is available in the given size.
   * 
   * @param productID
   *          Product ID to check for
   * @param imageSize
   *          Image size to check for
   * @return True if the image was found in the correct size, otherwise false
   */
  public boolean hasImageID(long productID, ImageSize imageSize) {
    return findImageID(productID, imageSize, products) != 0;
  }

  /**
   * Checks whether a given image name is available in the given size.
   * 
   * @param name
   *          Image name to check for
   * @param imageSize
   *          Image size to check for
   * @return True if the image was found in the correct size, otherwise false
   */
  public boolean hasImageID(String name, ImageSize imageSize) {
    return findImageID(name, imageSize, webui) != 0;
  }

  /**
   * Finds and returns the image ID for the given image key (product ID or name)
   * and size. If the image key cannot be found or is not available in the given
   * size, 0 will be returned. If the image key is null, a
   * {@link java.lang.NullPointerException} will be thrown.
   * 
   * @param imageKey
   *          Image key to find
   * @param imageSize
   *          Image size to find
   * @return The image ID if the image with the size was found, otherwise 0
   */
  public long getImageID(ImageDBKey imageKey, ImageSize imageSize) {
    if (imageKey == null) {
      log.error(""The supplied image key is null."");
      throw new NullPointerException(""The supplied image key is null."");
    }

    if (imageKey.isProductKey()) {
      return getImageID(imageKey.getProductID(), imageSize);
    }
    return getImageID(imageKey.getWebUIName(), imageSize);
  }

  /**
   * Finds and returns the image ID for the given product ID and size. If the
   * product ID cannot be found or is not available in the given size, 0 will be
   * returned.
   * 
   * @param productID
   *          Product ID to find
   * @param imageSize
   *          Image size to find
   * @return The image ID if the image with the size was found, otherwise 0
   */
  public long getImageID(long productID, ImageSize imageSize) {
    return findImageID(productID, imageSize, products);
  }

  /**
   * Finds and returns the image ID for the given image name and size. If the name
   * cannot be found or is not available in the given size, 0 will be returned.
   * 
   * @param name
   *          Image name to find
   * @param imageSize
   *          Image size to find
   * @return The image ID if the image with the size was found, otherwise 0
   */
  public long getImageID(String name, ImageSize imageSize) {
    return findImageID(name, imageSize, webui);
  }

  // Does actually all the heavy lifting for the getImageID methods
  private <K> long findImageID(K key, ImageSize imageSize, HashMap<K, Map<Long, ImageSize>> db) {
    Optional<Map.Entry<Long, ImageSize>> img = null;
    lock.readLock().lock();
    try {
      img = db.getOrDefault(key, new HashMap<>()).entrySet().stream()
          .filter(t -> t.getValue().equals(imageSize)).findFirst();
    } finally {
      lock.readLock().unlock();
    }

    if (img.isPresent()) {
      return img.get().getKey();
    }

    return 0;
  }

  /**
   * Returns the image size for a given image ID or null if it could not be found.
   * 
   * @param imageID
   *          The image ID to get the image size for
   * @return The image size or null if the ID could not be found
   */
  public ImageSize getImageSize(long imageID) {
    ImageSize result = null;
    lock.readLock().lock();
    try {
      result = sizes.getOrDefault(imageID, null);
    } finally {
      lock.readLock().unlock();
    }
    return result;
  }

  /**
   * Creates a new mapping between, an image key (either product ID or name), the
   * unique image ID and the size of the image. If the image key or image size is
   * null, a {@link java.lang.NullPointerException} will be thrown.
   * 
   * @param imageKey
   *          The image key, either product ID or image name
   * @param imageID
   *          The unique image ID
   * @param imageSize
   *          The size of the image
   */
  public void setImageMapping(ImageDBKey imageKey, long imageID, ImageSize imageSize) {
    if (imageKey == null) {
      log.error(""The supplied image key is null."");
      throw new NullPointerException(""The supplied image key is null."");
    }

    if (imageKey.isProductKey()) {
      setImageMapping(imageKey.getProductID(), imageID, imageSize);
    } else {
      setImageMapping(imageKey.getWebUIName(), imageID, imageSize);
    }
  }

  /**
   * Creates a new mapping between, a product ID, the unique image ID and the size
   * of the image. If the image size is null, a
   * {@link java.lang.NullPointerException} will be thrown.
   * 
   * @param productID
   *          The product ID
   * @param imageID
   *          The unique image ID
   * @param imageSize
   *          The size of the image
   */
  public void setImageMapping(long productID, long imageID, ImageSize imageSize) {
    map(productID, imageID, imageSize, products);
  }

  /**
   * Creates a new mapping between, an image name, the unique image ID and the
   * size of the image. If the image name or size is null, a
   * {@link java.lang.NullPointerExcpetion} will be thrown.
   * 
   * @param name
   *          The image name
   * @param imageID
   *          The unique image ID
   * @param imageSize
   *          The size of the image
   */
  public void setImageMapping(String name, long imageID, ImageSize imageSize) {
    if (name == null) {
      log.error(""The supplied image name is null."");
      throw new NullPointerException(""The supplied image name is null."");
    }

    map(name, imageID, imageSize, webui);
  }

  // Actually creates the image mapping
  private <K> void map(K key, long imageID, ImageSize imageSize,
      HashMap<K, Map<Long, ImageSize>> db) {
    if (imageSize == null) {
      log.error(""Supplied image size is null."");
      throw new NullPointerException(""Supplied image size is null."");
    }

    // In case the product ID or image name is not known, we create a new map to
    // store the mapping
    Map<Long, ImageSize> images = new HashMap<>();

    lock.writeLock().lock();
    try {
      if (db.containsKey(key)) {
        images = db.get(key);
      }

      // Add the new mapping to the internal map and put it back into the correct
      // database (map)
      images.put(imageID, imageSize);
      db.put(key, images);
      sizes.put(imageID, imageSize);
    } finally {
      lock.writeLock().unlock();
    }
  }

  /**
   * Removes an image id from the database. This will not delete an image but just remove all connections between a 
   * product or WebUI id and the given image id.
   * @param imageID Image ID to remove from this database.
   */
  public void removeImageMapping(long imageID) {
    lock.writeLock().lock();
    try {
      unmap(imageID, webui);
      unmap(imageID, products);
      sizes.remove(imageID);
    } finally {
      lock.writeLock().unlock();
    }
  }

  private <K> void unmap(long imageID, HashMap<K, Map<Long, ImageSize>> db) {
    Map.Entry<String, Map<Long, ImageSize>> img = webui.entrySet().stream()
        .filter(entry -> entry.getValue().containsKey(imageID)).findFirst().orElse(null);
    if (img != null) {
      webui.remove(img.getKey());
    }
  }
}"
services/tools.descartes.teastore.image/src/main/java/tools/descartes/teastore/image/StoreImage.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.image;

import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.Base64;

import javax.imageio.ImageIO;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.entities.ImageSize;
import tools.descartes.teastore.image.cache.entry.ICachable;

/**
 * Entity for images provided by the image-provider service.
 * 
 * @author Norbert Schmitt
 *
 */
public class StoreImage implements ICachable<StoreImage> {

  /**
   * Standard image format for storage (reading and writing).
   */
  public static final String STORE_IMAGE_FORMAT = ""png"";

  /**
   * String prepended in the
   * 
   * <pre>
   * src
   * </pre>
   * 
   * attribute of an image tag for embedding the image data.
   */
  public static final String STORE_IMAGE_DATA_STRING = ""data:image/"" + STORE_IMAGE_FORMAT
      + "";base64,"";

  private final long id;
  private byte[] data;
  private ImageSize size;
  private Logger log = LoggerFactory.getLogger(StoreImage.class);

  /**
   * Creates a new store image with a given id and size. The image is converted
   * from the Java internal representation to a base64 encoded byte array.
   * 
   * @param id
   *          The unique image id.
   * @param image
   *          The image data itself.
   * @param size
   *          The image size.
   */
  public StoreImage(final long id, BufferedImage image, ImageSize size) {
    if (image == null) {
      log.error(""Supplied image is null."");
      throw new NullPointerException(""Supplied image is null."");
    }

    this.id = id;
    setImage(image);
    setImageSize(size);
  }

  /**
   * Constructor.
   * @param id imageId
   * @param base64 base64 encoded byte array
   * @param size Imagesize object
   */
  public StoreImage(final long id, byte[] base64, ImageSize size) {
    if (base64 == null) {
      log.error(""Supplied base64 encoded byte array is null."");
      throw new NullPointerException(""Supplied base64 encoded byte array is null."");
    }

    this.id = id;
    data = Arrays.copyOf(base64, base64.length);
    setImageSize(size);
  }

  private void setImageSize(ImageSize size) {
    if (size == null) {
      log.error(""Supplied image size is null."");
      throw new NullPointerException(""Supplied image size is null."");
    }
    this.size = size;
  }

  /**
   * Copy constructor for StoreImage.
   * 
   * @param image
   *          Image to copy.
   */
  public StoreImage(StoreImage image) {
    if (image == null) {
      log.error(""Supplied store image is null."");
      throw new NullPointerException(""Store image is null."");
    }

    this.id = image.getId();
    this.data = Arrays.copyOf(image.getByteArray(), image.getByteArray().length);
    this.size = image.getSize();
  }

  /**
   * Returns the unique image identifier.
   * 
   * @return Unique image id.
   */
  public long getId() {
    return id;
  }

  // Converts the Java internal image representation to a byte array and encodes
  // it in base64 for embedding.
  private void setImage(BufferedImage image) {
    ByteArrayOutputStream stream = new ByteArrayOutputStream();
    try {
      ImageIO.write(image, STORE_IMAGE_FORMAT, stream);
    } catch (IOException ioException) {
      log.warn(""An IOException occured while trying to write image to a stream."", ioException);
    }
    data = Base64.getEncoder().encode(stream.toByteArray());
  }

  /**
   * Returns the image as the Java internal representation.
   * 
   * @return The image itself.
   */
  public BufferedImage getImage() {
    BufferedImage image = null;
    ByteArrayInputStream stream = new ByteArrayInputStream(Base64.getDecoder().decode(data));
    try {
      image = ImageIO.read(stream);
    } catch (IOException ioException) {
      log.warn(""An IOException occured while trying to read image from stream."", ioException);
    }
    return image;
  }

  /**
   * Returns the image size.
   * 
   * @return The image size.
   */
  public ImageSize getSize() {
    return size;
  }

  /**
   * Returns the number of bytes stored in the internal data structure.
   * 
   * @return Number of bytes stored for this image.
   */
  @Override
  public long getByteSize() {
    return data.length;
  }

  /**
   * Returns the base64 encoded byte array as string.
   * 
   * @return Base64 encoded data as string.
   */
  public String getBase64() {
    return new String(data);
  }

  /**
   * Getter for bytearray.
   * @return bytearray
   */
  public byte[] getByteArray() {
    return Arrays.copyOf(data, data.length);
  }

  @Override
  public String toString() {
    return STORE_IMAGE_DATA_STRING + getBase64();
  }

  // Auto-generated
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (int) (id ^ (id >>> 32));
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    StoreImage other = (StoreImage) obj;
    if (id != other.getId()) {
      return false;
    }
    return true;
  }
}"
services/tools.descartes.teastore.persistence/src/test/java/tools/descartes/teastore/persistence/repository/EMFManagerInitializer.java,"package tools.descartes.teastore.persistence.repository;

import java.util.HashMap;

/**
 * Class for managing the testing EMF singleton.
 * Replaces the {@link EMFManager} in tests.
 * @author Jakim von Kistowski
 *
 */
public final class EMFManagerInitializer {
	
	private static final String DDL_PROPERTY = ""eclipselink.ddl-generation"";
	private static final String DDL_VALUE = ""drop-and-create-tables"";
	private static final String DDL_OUTPUT_PROPERTY = ""eclipselink.ddl-generation.output-mode"";
	private static final String DDL_OUTPUT_VALUE = ""database"";
	
	private EMFManagerInitializer() {
		
	}
	
	/**
	 * Initialize the testing entity manager factory.
	 */
	public static void initializeEMF() {
			HashMap<String, String> persistenceProperties = createPersistencePropertiesForTesting();
			EMFManager.configureEMFWithProperties(persistenceProperties);
	}
	
	
	private static HashMap<String, String> createPersistencePropertiesForTesting() {
		HashMap<String, String> persistenceProperties = EMFManager.createPersistencePropertieForInMemoryDB();
		persistenceProperties.put(DDL_PROPERTY, DDL_VALUE);
		persistenceProperties.put(DDL_OUTPUT_PROPERTY, DDL_OUTPUT_VALUE);
		return persistenceProperties;
	}
}"
services/tools.descartes.teastore.persistence/src/test/java/tools/descartes/teastore/persistence/DataGeneratorTest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence;

import java.util.regex.Pattern;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import tools.descartes.teastore.persistence.domain.CategoryRepository;
import tools.descartes.teastore.persistence.domain.OrderItemRepository;
import tools.descartes.teastore.persistence.domain.OrderRepository;
import tools.descartes.teastore.persistence.domain.PersistenceCategory;
import tools.descartes.teastore.persistence.domain.ProductRepository;
import tools.descartes.teastore.persistence.domain.UserRepository;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.persistence.repository.EMFManagerInitializer;

/**
 * Test for the DataGenerator.
 * @author Joakim von Kistowski
 *
 */
public class DataGeneratorTest {
	
	private static final int CATEGORIES = 15;
	private static final int PRODUCTS = 30;
	private static final int USERS = 20;
	private static final int MAX_ORDERS = 10;

	/**
	 * Setup the test.
	 * @throws Throwable On failure.
	 */
	@Before
	public void setup() throws Throwable {
		EMFManagerInitializer.initializeEMF();
	}
	
	/**
	 * Run the test.
	 */
	@Test
	public void testRepos() {
		//get initial repo sizes
		int initialCategories = CategoryRepository.REPOSITORY.getAllEntities().size();
		int initialUsers = UserRepository.REPOSITORY.getAllEntities().size();
		
		//generate data
		DataGenerator.GENERATOR.generateDatabaseContent(CATEGORIES, PRODUCTS, USERS, MAX_ORDERS);
		
		//assertions
		Assert.assertEquals(CATEGORIES + initialCategories, CategoryRepository.REPOSITORY.getAllEntities().size());
		CategoryRepository.REPOSITORY.getAllEntities().forEach(c ->
			Assert.assertTrue(c.getName() != null && !c.getName().isEmpty()));
		for (PersistenceCategory category : CategoryRepository.REPOSITORY.getAllEntities()) {
			Assert.assertEquals(PRODUCTS, category.getProducts().size());
			category.getProducts().forEach(p -> Assert.assertTrue(p.getName() != null && !p.getName().isEmpty()));
		}
		Assert.assertEquals(USERS + initialUsers, UserRepository.REPOSITORY.getAllEntities().size());
		Pattern userPattern = Pattern.compile(""user\\d+"");
		UserRepository.REPOSITORY.getAllEntities().forEach(u ->
			Assert.assertTrue(userPattern.matcher(u.getUserName()).matches()));
		Assert.assertTrue(OrderRepository.REPOSITORY.getAllEntities().size() > 0);
		Assert.assertTrue(UserRepository.REPOSITORY.getAllEntities().stream().anyMatch(u -> u.getOrders().size() > 0));
		OrderRepository.REPOSITORY.getAllEntities().forEach(o -> Assert.assertTrue(o.getOrderItems().size() > 0));
		
		//Re-create database
		DataGenerator.GENERATOR.dropAndCreateTables();
		DataGenerator.GENERATOR.generateDatabaseContent(2, 2, 2, 0);
		Assert.assertEquals(2, CategoryRepository.REPOSITORY.getAllEntities().size());
		Assert.assertEquals(2 * 2, ProductRepository.REPOSITORY.getAllEntities().size());
		Assert.assertEquals(2, UserRepository.REPOSITORY.getAllEntities().size());
		Assert.assertTrue(OrderRepository.REPOSITORY.getAllEntities().isEmpty());
		Assert.assertTrue(OrderItemRepository.REPOSITORY.getAllEntities().isEmpty());
	}
	
}"
services/tools.descartes.teastore.persistence/src/test/java/tools/descartes/teastore/persistence/RepositoryTest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence;

import org.junit.Before;
import org.junit.Test;

import java.util.List;

import org.junit.Assert;

import tools.descartes.teastore.persistence.domain.CategoryRepository;
import tools.descartes.teastore.persistence.domain.OrderItemRepository;
import tools.descartes.teastore.persistence.domain.OrderRepository;
import tools.descartes.teastore.persistence.domain.PersistenceCategory;
import tools.descartes.teastore.persistence.domain.PersistenceOrderItem;
import tools.descartes.teastore.persistence.domain.PersistenceProduct;
import tools.descartes.teastore.persistence.domain.ProductRepository;
import tools.descartes.teastore.persistence.domain.UserRepository;
import tools.descartes.teastore.persistence.repository.EMFManagerInitializer;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Test for the ProductEndpoint.
 * @author Joakim von Kistowski
 *
 */
public class RepositoryTest {
	
	private CategoryRepository catRepo;
	private ProductRepository prodRepo;
	private OrderItemRepository orderItemRepo;
	private OrderRepository orderRepo;
	private UserRepository userRepo;
	
	/**
	 * Setup the test.
	 * @throws Throwable Throws uncaught throwables for test to fail.
	 */
	@Before
	public void setup() throws Throwable {
		EMFManagerInitializer.initializeEMF();
		catRepo = CategoryRepository.REPOSITORY;
		prodRepo = ProductRepository.REPOSITORY;
		orderItemRepo = OrderItemRepository.REPOSITORY;
		orderRepo = OrderRepository.REPOSITORY;
		userRepo = UserRepository.REPOSITORY;
	}
	
	/**
	 * Run the test.
	 */
	@Test
	public void testRepos() {
		//get initial repo sizes
		long categorySize = catRepo.getAllEntities().size();
		long productSize = prodRepo.getAllEntities().size();
		long orderItemSize = orderItemRepo.getAllEntities().size();
		long orderSize = orderRepo.getAllEntities().size();
		long userSize = userRepo.getAllEntities().size();
		
		//create two users
		User createUser = new User();
		createUser.setRealName(""Me"");
		createUser.setUserName(""me"");
		createUser.setEmail(""me@descartes.tools"");
		createUser.setPassword(""secret"");
		long uId1 = userRepo.createEntity(createUser);
		Assert.assertTrue(uId1 > 0);
		createUser.setRealName(""You"");
		createUser.setUserName(""you"");
		createUser.setEmail(""you@descartes.tools"");
		long uId2 = userRepo.createEntity(createUser);
		Assert.assertTrue(uId2 > 0);
		
		//create two categories
		Category createCat1 = new Category();
		createCat1.setName(""Category1"");
		createCat1.setDescription(""Category Description1"");
		long cId1 = catRepo.createEntity(createCat1);
		Assert.assertTrue(cId1 >= 0);
		createCat1.setName(""Category2"");
		createCat1.setDescription(""Category Description2"");
		long cId2 = catRepo.createEntity(createCat1);
		Assert.assertTrue(cId2 >= 0);
		
		//list categories
		Assert.assertEquals(catRepo.getAllEntities().size(), 2 + categorySize);
		
		//get and update category
		PersistenceCategory cat1 = catRepo.getEntity(cId1);
		Assert.assertEquals(cat1.getName(), ""Category1"");
		createCat1.setName(""UpdatedCategory1"");
		createCat1.setDescription(cat1.getDescription());
		catRepo.updateEntity(cId1, createCat1);
		cat1 = catRepo.getEntity(cId1);
		Assert.assertEquals(cat1.getName(), ""UpdatedCategory1"");
		
		//Create two products in cat1
		Product product = new Product();
		product.setCategoryId(cId1);
		product.setName(""Prod1"");
		product.setDescription(""pd1"");
		product.setListPriceInCents(1);
		long pId1 = prodRepo.createEntity(product);
		product.setName(""Prod2"");
		product.setDescription(""pd2"");
		product.setListPriceInCents(2);
		long pId2 = prodRepo.createEntity(product);
		Assert.assertTrue(pId1 > 0);
		//create an invalid product
		product.setCategoryId(-1L);
		long invpId = prodRepo.createEntity(product);
		Assert.assertFalse(invpId > 0);
		
		//get and update product
		PersistenceProduct prod1 = prodRepo.getEntity(pId1);
		Assert.assertEquals(prod1.getName(), ""Prod1"");
		product.setCategoryId(cId1);
		product.setName(""UpdatedProd1"");
		product.setDescription(prod1.getDescription());
		product.setListPriceInCents(prod1.getListPriceInCents());
		Assert.assertTrue(prodRepo.updateEntity(pId1, product));
		prod1 = prodRepo.getEntity(pId1);
		Assert.assertEquals(prod1.getName(), ""UpdatedProd1"");
		Assert.assertEquals(prod1.getDescription(), ""pd1"");
		
		//get all products
		Assert.assertEquals(prodRepo.getAllEntities().size(), 2 + productSize);
		
		//create three orders
		Order creationOrder = new Order();
		creationOrder.setTotalPriceInCents(500);
		creationOrder.setUserId(uId1);
		long oId1 = orderRepo.createEntity(creationOrder);
		Assert.assertTrue(oId1 > 0);
		creationOrder.setTotalPriceInCents(600);
		creationOrder.setUserId(uId2);
		long oId2 = orderRepo.createEntity(creationOrder);
		Assert.assertTrue(oId2 > 0);
		creationOrder.setTotalPriceInCents(700);
		creationOrder.setUserId(uId2);
		long oId3 = orderRepo.createEntity(creationOrder);
		Assert.assertTrue(oId3 > 0);
		
		//get and update user; get all users
		User user = userRepo.getEntity(uId1);
		user.setRealName(""Updated"");
		Assert.assertTrue(userRepo.updateEntity(uId1, user));
		user = userRepo.getEntity(uId1);
		Assert.assertEquals(""Updated"", user.getRealName());
		Assert.assertEquals(2 + userSize, userRepo.getAllEntities().size());
		
		//create five order items
		OrderItem coi = new OrderItem();
		coi.setOrderId(oId1);
		coi.setProductId(pId1);
		coi.setQuantity(5);
		coi.setUnitPriceInCents(5);
		long oiId1 = orderItemRepo.createEntity(coi);
		Assert.assertTrue(oiId1 > 0);
		coi.setQuantity(6);
		Assert.assertTrue(orderItemRepo.createEntity(coi) > 0);
		coi.setProductId(pId2);
		coi.setQuantity(7);
		Assert.assertTrue(orderItemRepo.createEntity(coi) > 0);
		coi.setOrderId(oId2);
		coi.setProductId(pId2);
		coi.setQuantity(8);
		Assert.assertTrue(orderItemRepo.createEntity(coi) > 0);
		coi.setOrderId(oId3);
		coi.setProductId(pId2);
		coi.setQuantity(9);
		long oiId5 = orderItemRepo.createEntity(coi);
		Assert.assertTrue(oiId5 > 0);

		//update and get order item
		coi.setProductId(pId1);
		coi.setQuantity(2);
		Assert.assertTrue(orderItemRepo.updateEntity(oiId1, coi));
		PersistenceOrderItem oi1 = orderItemRepo.getEntity(oiId1);
		Assert.assertEquals(oi1.getQuantity(), 2);
		Assert.assertEquals(oi1.getUnitPriceInCents(), 5);
		
		//delete order 3, should delete order item 5
		Assert.assertTrue(orderRepo.removeEntity(oId3));
		Assert.assertNull(orderItemRepo.getEntity(oiId5));
		//delete user two, should delete order 2 and its order item (order item 4)
		Assert.assertTrue(userRepo.removeEntity(uId2));
		Assert.assertEquals(1 + userSize, userRepo.getAllEntities().size());
		Assert.assertNull(orderRepo.getEntity(oId2));
		
		//delete order item
		Assert.assertTrue(orderItemRepo.removeEntity(oiId1));
		
		//get order items with and without product specification
		Assert.assertEquals(orderItemRepo.getAllEntities().size(), 2 + orderItemSize);
		Assert.assertEquals(orderItemRepo.getAllEntities(1, 1).size(), 1);
		Assert.assertEquals(orderItemRepo.getAllEntitiesWithProduct(pId2, -1, -1).size(), 1);
		
		//get orders and users
		Assert.assertEquals(1 + userSize, userRepo.getAllEntities().size());
		Assert.assertEquals(1 + orderSize, orderRepo.getAllEntities().size());
		//get and update order
		Order order = orderRepo.getEntity(oId1);
		Assert.assertEquals(500, order.getTotalPriceInCents());
		order.setTotalPriceInCents(5);
		orderRepo.updateEntity(oId1, order);
		order = orderRepo.getEntity(oId1);
		Assert.assertEquals(5, order.getTotalPriceInCents());
		
		
		//delete product
		prodRepo.removeEntity(pId1);
		Assert.assertEquals(prodRepo.getAllEntities().size(), 1 + productSize);
		//order item for product should also have been deleted
		Assert.assertEquals(orderItemRepo.getAllEntities().size(), 1 + orderItemSize);
		
		//Get Products with Category
		List<PersistenceProduct> c1p = prodRepo.getAllEntities(cId1, -1, -1);
		Assert.assertEquals(c1p.size(), 1);
		Assert.assertEquals(c1p.get(0).getName(), ""Prod2"");
		Assert.assertEquals(prodRepo.getAllEntities(cId2, -1, 2).size(), 0);
		
		//delete category with product
		catRepo.removeEntity(cId1);
		Assert.assertEquals(catRepo.getAllEntities().size(), 1 + categorySize);
		//product for category should also have been deleted
		Assert.assertEquals(prodRepo.getAllEntities().size(), productSize);
		//order item for product in category should also have been deleted
		Assert.assertEquals(orderItemRepo.getAllEntities().size(), 0 + orderItemSize);
	}
	
	
}"
services/tools.descartes.teastore.persistence/src/test/java/tools/descartes/teastore/persistence/RegistrationDaemon.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence;

import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.registryclient.RegistryClient;
import tools.descartes.teastore.registryclient.Service;

/**
 * Application Lifecycle Listener implementation class for data generation.
 * @author Joakim von Kistowski
 *
 */
@WebListener
public class RegistrationDaemon implements ServletContextListener {

	private static final Logger LOG = LoggerFactory.getLogger(RegistrationDaemon.class);
	
    /**
     * Default constructor. 
     */
    public RegistrationDaemon() {
    	
    }

	/**
     * @see ServletContextListener#contextDestroyed(ServletContextEvent)
     * @param event The servlet context event at destruction.
     */
    public void contextDestroyed(ServletContextEvent event)  { 
    	RegistryClient.getClient().unregister(event.getServletContext().getContextPath());
    }

	/**
     * @see ServletContextListener#contextInitialized(ServletContextEvent)
     * @param event The servlet context event at initialization.
     */
    public void contextInitialized(ServletContextEvent event)  {
    	RegistryClient.getClient().register(""/"" + Service.PERSISTENCE.getServiceName());
    	LOG.info(""Persistence started registration daemon"");
    }
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/repository/DatabaseManagementEntity.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.repository;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;

/**
 * Entity for persisting database managenemt information in database.
 * @author Joakim von Kistowski
 *
 */
@Entity
public class DatabaseManagementEntity {

	@Id
	@GeneratedValue
	private long id;
	
	private boolean finishedGenerating;
	
	/**
	 * Create a new management entity.
	 */
	DatabaseManagementEntity() {
		finishedGenerating = false;
	}

	/**
	 * Get the id.
	 * @return the id
	 */
	long getId() {
		return id;
	}

	/**
	 * False if the database is currently being generated.
	 * True, otherwise.
	 * @return Database generation status.
	 */
	public boolean isFinishedGenerating() {
		return finishedGenerating;
	}

	/**
	 * Specify if the database has finished generating.
	 * False if the database is currently being generated, true otherwise.
	 * @param finishedGenerating Database generation status.
	 */
	public void setFinishedGenerating(boolean finishedGenerating) {
		this.finishedGenerating = finishedGenerating;
	}
	
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/repository/AbstractPersistenceRepository.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.repository;

import java.util.ArrayList;
import java.util.List;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.TypedQuery;

/**
 * Abstract Repository for CRUD Operations for persistence Entities.
 * Already provides lookup and delete operations.
 * @author Joakim von Kistowski
 *
 * @param <E> The class type of the Interface entity
 * 		(i.e., the entity type that is parsed and sent out to clients using REST).
 * @param <P> The class type of the Persistence entity
 * 		(i.e., the entity that is stored in the database).
 */
public abstract class AbstractPersistenceRepository<E, P extends E> {
	
	/**
	 * Gets the ID of a persistence entity.
	 * @param p The persistence entity for which the ID is to be retreived.
	 * @return The id of persistence entity p.
	 */
	protected abstract long getId(P p);
	
	/**
	 * Get the Java Class of the persistence entity objects for this repository.
	 * @return The Java Class of the persistence entity objects.
	 */
	protected abstract Class<P> getEntityClass();
	
	/**
	 * Get the entity manager factory of the persistence context.
	 * @return The entity manager factory.
	 */
	public EntityManagerFactory getEMF() {
		return EMFManager.getEMF();
	}
	
	/**
	 * Creates a new entity manager and returns it.
	 * Don't forget to close!
	 * @return A new entity manager.
	 */
	protected EntityManager getEM() {
		return getEMF().createEntityManager();
	}
	
	/**
	 * Create a new persistence entity from an interface entity
	 * (usually received via REST).
	 * @param entity The entity template for the entity to create.
	 * @return The new ID of the newly created entity.
	 */
	public abstract long createEntity(E entity);
	
	/**
	 * Updates the entity with the values from the provided interface
	 * entity (usually received via REST).
	 * @param id The id of the entity to update (ignore the id in the passed entity).
	 * @param entity The values of the entity to update. Ignore the id of the entity.
	 * 		You may also choose to ignore additional values, if you do not support updating them.
	 * @return True, if update succeded. False otherwise.
	 */
	public abstract boolean updateEntity(long id, E entity);
	
	/**
	 * Retrieve the entity with the given ID.
	 * @param id ID of the entity to retrieve.
	 * @return The entity. Null, if none was found.
	 */
	public P getEntity(long id) {
		P instance = null;
		EntityManager em = getEM();
	    try {
	        instance = em.find(getEntityClass(), id);
	    } finally {
	        em.close();
	    }
		return instance;
	}
	
	/**
	 * Get all entities of the generic types of entities managed in this repository.
	 * @return All entities in a list.
	 */
	public List<P> getAllEntities() {
		return getAllEntities(-1, -1);
	}
	
	/**
	 * Get all entities of the generic types of entities managed in this repository.
	 * Starts with the ""start"" entity and returns at maximum ""limit"" entities.
	 * @param start The index of the entity to start with. Set to negative value to start at the beginning.
	 * @param limit The maximum number of entites to return. Set to negative value to return all.
	 * @return List of entities.
	 */
	public List<P> getAllEntities(int start, int limit) {
		EntityManager em = getEM();
		List<P> entities = null;
		try {
			TypedQuery<P> allMatchesQuery =
					em.createQuery(""SELECT u FROM "" + getEntityClass().getName() + "" u"", getEntityClass());
			if (start >= 0) {
				allMatchesQuery = allMatchesQuery.setFirstResult(start);
		    }
			if (limit >= 0) {
				allMatchesQuery = allMatchesQuery.setMaxResults(limit);
			}
			entities = allMatchesQuery.getResultList();
		} finally {
			em.close();
		}
		if (entities == null) {
			entities = new ArrayList<P>();
		}
		return entities;
	}
	
	/**
	 * Removes the entity with the id from database.
	 * @param id The id of the entity to remove.
	 * @return True, if delete succeded. False, if it failed (entity with id not found).
	 */
	public boolean removeEntity(long id) {
		boolean found = false;
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        P entity = em.find(getEntityClass(), id);
	        if (entity != null) {
	        	em.remove(entity);
	        	found = true;
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
	    return found;
	}
	
	/**
	 * Returns the query result for a query with a start and limit parameter.
	 * Negative starts and limits are ignored.
	 * @param em The currently open entity manager.
	 * @param query The query. Parameters must all be bound.
	 * @param start The start index. Negative values are ignored.
	 * @param limit The limit. Negative values are ignored.
	 * @return The query result.
	 */
	protected List<P> resultsWithStartAndLimit(EntityManager em, TypedQuery<P> query, int start, int limit) {
		if (start >= 0) {
			query.setFirstResult(start);
	    }
		if (limit >= 0) {
			query = query.setMaxResults(limit);
		}
		return query.getResultList();
	}
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/repository/CacheManager.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.repository;

import java.util.List;

import jakarta.ws.rs.client.WebTarget;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.persistence.domain.CategoryRepository;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.util.RESTClient;

/**
 * Class for managing (mostly clearing) the persistence cache.
 * Sends cache clears to other persistence contexts for cache coherence.
 * @author Joakim von Kistowski
 *
 */
public final class CacheManager {

	private static final String ENDPOINTURI = ""cache"";
	
	/**
	 * The cache manager singleton.
	 */
	public static final CacheManager MANAGER = new CacheManager();
	
	private CacheManager() {
		
	}
	
	/**
	 * Clears the entire cache in all persistence services,
	 * including this one.
	 */
	public void clearAllCaches() {
		CategoryRepository.REPOSITORY.getEMF().getCache().evictAll();
		try {
			ServiceLoadBalancer.multicastRESTToOtherServiceInstances(ENDPOINTURI, String.class,
					client -> clearRemoteCacheREST(client, null));
		} catch (Exception e) {
			
		}
	}
	
	/**
	 * Clears the cache for the entity class in all
	 * persistence services, including this one.
	 * @param entityClass The class to clear.
	 */
	public void clearCache(Class<?> entityClass) {
		clearLocalCacheOnly(entityClass);
		clearRemoteCache(entityClass);
	}
	
	/**
	 * Clears the cache in all remote persistence services
	 * (all, except the calling one).
	 * 
	 * Example usage scenario: Update on entity is automatically
	 * cached in local cache but remains unknown to remote services.
	 * @param entityClass The class to clear.
	 * @return List of all responses. Contain the class names or ""null"" if errors occured.
	 */
	public List<String> clearRemoteCache(Class<?> entityClass) {
		List<String> responses = null;
		try {
			responses = ServiceLoadBalancer.multicastRESTToOtherServiceInstances(ENDPOINTURI, String.class,
					client -> clearRemoteCacheREST(client, entityClass));
		} catch (Exception e) {
			
		}
		return responses;
	}
	
	/**
	 * Clear only the local Cache for the entity class in question.
	 * @param entityClass The class to clear.
	 */
	public void clearLocalCacheOnly(Class<?> entityClass) {
		CategoryRepository.REPOSITORY.getEMF().getCache().evict(entityClass);
	}
	
	/**
	 * Clear only the entire local Cache for all classes.
	 */
	public void clearLocalCacheOnly() {
		CategoryRepository.REPOSITORY.getEMF().getCache().evictAll();
	}
	
	private String clearRemoteCacheREST(RESTClient<String> client, Class<?> entityClass) {
		WebTarget target = client.getService().path(client.getApplicationURI())
				.path(client.getEndpointURI());
		if (entityClass != null) {
			target = target.path(""class"").path(entityClass.getName());
		} else {
			target = target.path(""cache"");
		}
		Response response = target.request(MediaType.TEXT_PLAIN).delete();
		String message = null;
		if (response.getStatus() == 200) {
			message = response.readEntity(String.class);
		}
		response.close();
		return message;
	}
	
	/**
	 * Reset the local and all remote EMFs.
	 * @return List of all responses. Contain the ""clearedEMF"", or ""null"" if errors occured.
	 */
	public List<String> resetAllEMFs() {
		resetLocalEMF();
		return resetRemoteEMFs();
	}
	
	/**
	 * Reset all remote EMFs.
	 * @return List of all responses. Contain the ""clearedEMF"", or ""null"" if errors occured.
	 */
	public List<String> resetRemoteEMFs() {
		List<String> responses = null;
		try {
			responses = ServiceLoadBalancer.multicastRESTToOtherServiceInstances(ENDPOINTURI, String.class,
					client -> resetRemoteEMF(client));
		} catch (Exception e) {
			
		}
		return responses;
	}
	
	/**
	 * Reset the local EMF.
	 */
	public void resetLocalEMF() {
		EMFManager.clearEMF();
	}
	
	private String resetRemoteEMF(RESTClient<String> client) {
		WebTarget target = client.getEndpointTarget().path(""emf"");
		Response response = target.request(MediaType.TEXT_PLAIN).delete();
		String message = null;
		if (response.getStatus() == 200) {
			message = response.readEntity(String.class);
		}
		response.close();
		return message;
	}
	
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/repository/DataGenerator.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.repository;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Random;
import java.util.stream.IntStream;

import jakarta.persistence.EntityManager;
import jakarta.ws.rs.client.Entity;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import org.eclipse.persistence.sessions.server.ServerSession;
import org.eclipse.persistence.tools.schemaframework.SchemaManager;
import org.mindrot.jbcrypt.BCrypt;

import tools.descartes.teastore.persistence.domain.CategoryRepository;
import tools.descartes.teastore.persistence.domain.OrderItemRepository;
import tools.descartes.teastore.persistence.domain.OrderRepository;
import tools.descartes.teastore.persistence.domain.PersistenceCategory;
import tools.descartes.teastore.persistence.domain.PersistenceOrder;
import tools.descartes.teastore.persistence.domain.ProductRepository;
import tools.descartes.teastore.persistence.domain.UserRepository;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.util.RESTClient;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Class for generating data in the database.
 *
 * @author Joakim von Kistowski
 *
 */
public final class DataGenerator {

	/**
	 * Status code for maintenance mode.
	 */
	public static final int MAINTENANCE_STATUS_CODE = 503;

	/**
	 * Default category count for small database.
	 */
	public static final int SMALL_DB_CATEGORIES = 5;
	/**
	 * Default product count per category for small database.
	 */
	public static final int SMALL_DB_PRODUCTS_PER_CATEGORY = 100;
	/**
	 * Default user count for small database.
	 */
	public static final int SMALL_DB_USERS = 100;
	/**
	 * Default max order per user for small database.
	 */
	public static final int SMALL_DB_MAX_ORDERS_PER_USER = 5;

	/**
	 * Default category count for tiny database.
	 */
	public static final int TINY_DB_CATEGORIES = 2;
	/**
	 * Default product count per category for tiny database.
	 */
	public static final int TINY_DB_PRODUCTS_PER_CATEGORY = 20;
	/**
	 * Default user count for tiny database.
	 */
	public static final int TINY_DB_USERS = 5;
	/**
	 * Default max order per user for tiny database.
	 */
	public static final int TINY_DB_MAX_ORDERS_PER_USER = 2;

	private Random random = new Random(5);

	private static final String PASSWORD = ""password"";
	private static final String[] CATEGORYNAMES = { ""Black Tea"", ""Green Tea"", ""Herbal Tea"", ""Rooibos"", ""White Tea"",
			""Tea Cups"", ""Tea Pots"", ""Filters"", ""Infusers"" };
	private static final String[] CATEGORYDESCRIPTIONS = { ""Pure black tea and blends"", ""From China and Japan"",
			""Helps when you feel sick"", ""In many variations"", ""If green tea doesn't agree with you"",
			""Cups and glasses"", ""Classy and useful"", ""For extremely fine grained tea"",
			""No metal for green tea"" };

	private static final String[][] PRODUCTNAMES = {
			{ ""Earl Grey (loose)"", ""Assam (loose)"", ""Darjeeling (loose)"", ""Frisian Black Tee (loose)"",
				""Anatolian Assam (loose)"", ""Earl Grey (20 bags)"", ""Assam (20 bags)"", ""Darjeeling (20 bags)"",
				""Ceylon (loose)"", ""Ceylon (20 bags)"", ""House blend (20 bags)"", ""Assam with Ginger (20 bags)""},
			{ ""Sencha (loose)"", ""Sencha (15 bags)"", ""Sencha (25 bags)"", ""Earl Grey Green (loose)"",
					""Earl Grey Green (15 bags)"", ""Earl Grey Green (25 bags)"", ""Matcha 30 g"", ""Matcha 50 g"",
					""Matcha 100 g"", ""Gunpowder Tea (loose)"", ""Gunpowder Tea (15 bags)"", ""Gunpowder Tea (25 bags)"" },
			{ ""Camomile (loose)"", ""Camomile (15 bags)"", ""Peepermint (loose)"", ""Peppermint (15 bags)"",
					""Peppermint (15 bags)"", ""Sweet Mint (loose)"", ""Sweet Mint (15 bags)"", ""Sweet Mint (25 bags)"",
					""Lemongrass (loose)"", ""Lemongrass (20 bags)"", ""Chai Mate (15 bags)"", ""Chai Mate (25 bags)"",
					""Stomach Soothing Tea (15 bags)"", ""Headache Soothing Tea (15 bags)"" },
			{ ""Rooibos Pure (loose)"", ""Rooibos Pure (20 bags)"", ""Rooibos Orange (loose)"", ""Rooibos Orange (20 bags)"",
					""Rooibos Coconut (loose)"", ""Rooibos Coconut (20 bags)"", ""Rooibos Vanilla (loose)"",
					""Rooibos Pure (20 bags)"", ""Rooibos Ginger (loose)"", ""Rooibos Pure (20 bags)"",
					""Rooibos Grapefruit (loose)"", ""Rooibos Pure (20 bags)"" },
			{ ""White Tea (loose)"", ""White Tea (15 bags)"", ""White Tea (25 bags)"", ""White Chai (loose)"",
					""White Chai (15 bags)"", ""White Chai (25 bags)"", ""Pai Mu Tan White (loose)"",
					""Pai Mu Tan White (15 bags)"", ""Pai Mu Tan White (25 bags)"", ""White Apricot (loose)"",
					""White Apricot (15 bags)"", ""White Apricot (25 bags)"" },
			{ ""Ceramic Cup White"", ""Ceramic Cup Blue"", ""Ceramic Cup Green"", ""Ceramic Cup Black"",
					""Percelain Cup White"", ""Porcelain Cup with Flowers"", ""Poercelain Cup with Dog Picture"",
					""Small Glass Cup"", ""Large Glass Cup"", ""Small Glass Cup with Glass Infuser"",
					""Large Glass Cup with Glass Infuser"", ""Small Glass Cup with Plastic Infuser"",
					""Large Glass Cup with Plastic Infuser"" },
			{ ""Porcelain Teapot White, 2 Cups"", ""Porcelain Teapot White, 5 Cups"",
					""Porcelain Teapot with Flowers, 2 Cups"", ""Porcelain Teapot with Flowers, 5 Cups"",
					""Persian Teapot, 3 Cups"", ""Large Teapot with Glass Infuser, 7 Cups"",
					""Small Teapot with Glass Infuser, 3 Cups"", ""Medium Teapot with Glass Infuser, 5 Cups"",
					""Large Glass Teapot with Steel Infuser, 7 Cups"", ""Small Glass Teapot with Steel Infuser, 3 Cups"",
					""Medium Glass Teapot with Steel Infuser, 5 Cups"", ""Glass Teapot Warmer"" },
			{ ""Filters with Drawstring, 100 pcs."", ""Filters with Drawstring, 250 pcs."",
					""Filters with Drawstring, 500 pcs."", ""Tea Sack, 50 pcs."", ""Tea Sack, 125 pcs."",
					""Tea Sack, 500 pcs."", ""Reusible Cotton Tea Sack, 10 pcs."", ""Reusible Cotton Tea Sack, 35 pcs."",
					""Reusable Cotton Tea Sack, 50 pcs."", ""Pyramid-shaped Tea Filter, 10 pcs."",
					""Pyramid-shaped Tea Filter, 25 pcs."", ""Mr. Tea Filter, 10 pcs."" },
			{ ""Medium Mesh Ball with Chain"", ""Medium Snap Mesh Ball"", ""Large Ball with Chain"",
						""Small Mesh Ball with Chain"", ""Small Snap Mesh Ball"", ""Large Snap Mesh Ball"",
						""Medium Silicone Ball Infuser"", ""Small Silicone Ball Infuser"",
					""Large Silicone Ball Infuser"", ""Small Mesh Ball with Panda Look"", ""Heart-shaped Infuser"" } };

	private static final String[] FIRSTNAMES = {""James"", ""John"", ""Robert"", ""Michael"", ""William"", ""David"",
			""Richard"", ""Charles"", ""Jospeph"", ""Thomas"", ""Christopher"", ""Daniel"", ""Paul"", ""Mark"", ""Donald"",
			""George"", ""Kenneth"", ""Steven"", ""Edward"", ""Brian"", ""Ronald"", ""Anthony"", ""Kevin"", ""Jason"",
			""Matthew"", ""Gary"", ""Timothy"", ""Jose"", ""Larry"", ""Jeffrey"", ""Frank"", ""Scott"", ""Eric"", ""Stephen"",
			""Andrew"", ""Raymond"", ""Gregory"", ""Joshua"", ""Jerry"", ""Dennis"", ""Walter"", ""Patrick"", ""Peter"",
			""Mary"", ""Patricia"", ""Barbara"", ""Elizabeth"", ""Jennifer"", ""Maria"", ""Susan"", ""Margaret"", ""Dorothy"",
			""Lisa"", ""Nancy"", ""Karen"", ""Betty"", ""Helen"", ""Sandra"", ""Donna"", ""Carol"", ""Ruth"", ""Sharon"",
			""Michelle"", ""Laura"", ""Sarah"", ""Kimberly"", ""Deborah"", ""Jessica"", ""Shirley"", ""Cynthia""};
	private static final String[] LASTNAMES = {""Smith"", ""Johnson"", ""Williams"", ""Jones"", ""Brown"", ""Davis"",
			""Miller"", ""Wilson"", ""Moorse"", ""Taylor"", ""Anderson"", ""Thomas"", ""Jackson"", ""White"", ""Harris"",
			""Martin"", ""Thompson"", ""Garcia"", ""Martinez"", ""Robinson"", ""Clark"", ""Rodriguez"", ""Lewis"", ""Lee"",
			""Walker"", ""Hall"", ""Allen"", ""Young"", ""Hernandez"", ""King"", ""Wright"", ""Lopez"", ""Hill"", ""Scoot""};

	private static final int MAX_ITEMS_PER_ORDER = 10;
	private static final double PREFFERED_CATEGORY_CHANCE = 0.825;


	/**
	 * The data generator singleton.
	 */
	public static final DataGenerator GENERATOR = new DataGenerator();

	private boolean maintenanceMode = false;

	private DataGenerator() {

	}

	/**
	 * Checks if the database is empty.
	 *
	 * @return True if the database is empty.
	 */
	public boolean isDatabaseEmpty() {
		// every other entity requires a valid category or user
		return (CategoryRepository.REPOSITORY.getAllEntities(-1, 1).size() == 0
				&& UserRepository.REPOSITORY.getAllEntities(-1, 1).size() == 0);
	}

	/**
	 * Generates data for the database. Uses a fixed random seed.
	 *
	 * @param categories
	 *            Number of categories.
	 * @param productsPerCategory
	 *            Number of products per category.
	 * @param users
	 *            Number of users. Password is always ""password"".
	 * @param maxOrdersPerUser
	 *            Maximum order per user.
	 */
	public void generateDatabaseContent(int categories, int productsPerCategory,
			int users, int maxOrdersPerUser) {
		setGenerationFinishedFlag(false);
		CacheManager.MANAGER.clearAllCaches();
		random = new Random(5);
		generateCategories(categories);
		generateProducts(productsPerCategory);
		generateUsers(users);
		generateOrders(maxOrdersPerUser, productsPerCategory);
		setGenerationFinishedFlag(true);
		CacheManager.MANAGER.clearAllCaches();
	}

	private void generateCategories(int categories) {
		for (int i = 0; i < categories; i++) {
			Category category = new Category();
			if (i < CATEGORYDESCRIPTIONS.length) {
				category.setDescription(CATEGORYDESCRIPTIONS[i]);
			} else {
				int version = i / CATEGORYDESCRIPTIONS.length;
				category.setDescription(CATEGORYDESCRIPTIONS[i % CATEGORYDESCRIPTIONS.length] + "", v"" + version);
			}
			if (i < CATEGORYNAMES.length) {
				category.setName(CATEGORYNAMES[i]);
			} else {
				int version = i / CATEGORYNAMES.length;
				category.setName(CATEGORYNAMES[i % CATEGORYNAMES.length] + "", v"" + version);
			}
			CategoryRepository.REPOSITORY.createEntity(category);
		}
	}

	private void generateProducts(int productsPerCategory) {
		int categoryIndex = 0;
		for (PersistenceCategory category : CategoryRepository.REPOSITORY.getAllEntities()) {
			int productTypeIndex = categoryIndex % PRODUCTNAMES.length;
			for (int i = 0; i < productsPerCategory; i++) {
				int productIndex = i % PRODUCTNAMES[productTypeIndex].length;
				int version = i / PRODUCTNAMES[productTypeIndex].length;
				Product product = new Product();
				if (version == 0) {
					product.setName(PRODUCTNAMES[productTypeIndex][productIndex]);
				} else {
					product.setName(PRODUCTNAMES[productTypeIndex][productIndex] + "", v"" + version);
				}
				product.setDescription(
						""Great "" + category.getName() + "": "" + PRODUCTNAMES[productTypeIndex][productIndex]);
				product.setListPriceInCents(95 + random.nextInt(12000));
				product.setCategoryId(category.getId());
				ProductRepository.REPOSITORY.createEntity(product);
			}
			categoryIndex++;
		}
	}

	private void generateUsers(int users) {
		IntStream.range(0, users).parallel().forEach(i -> {
			User user = new User();
			user.setUserName(""user"" + i);
			user.setEmail(""user"" + i + ""@teastore.com"");
			user.setRealName(FIRSTNAMES[random.nextInt(FIRSTNAMES.length)]
					+ "" "" + LASTNAMES[random.nextInt(LASTNAMES.length)]);
			user.setPassword(BCrypt.hashpw(PASSWORD, BCrypt.gensalt(6)));
			UserRepository.REPOSITORY.createEntity(user);
		});
	}

	private void generateOrders(int maxOrdersPerUser, int productsPerCategory) {
		UserRepository.REPOSITORY.getAllEntities().parallelStream().forEach(user -> {
			for (int i = 0; i < random.nextInt(maxOrdersPerUser + 1); i++) {
				Order order = new Order();
				order.setAddressName(user.getRealName());
				String eastWest = "" East "";
				if (random.nextDouble() > 0.5) {
					eastWest = "" West "";
				}
				String northSouth = "" North"";
				if (random.nextDouble() > 0.5) {
					northSouth = "" South"";
				}
				order.setAddress1(random.nextInt(9000) + eastWest + random.nextInt(9000) + northSouth);
				order.setAddress2(""District "" + random.nextInt(500) + "", Utopia, "" + (10000 + random.nextInt(40000)));
				order.setCreditCardCompany(""MasterCard"");
				if (random.nextDouble() > 0.5) {
					order.setCreditCardCompany(""Visa"");
				}
				order.setCreditCardExpiryDate(LocalDate.ofYearDay(LocalDateTime.now().getYear()
						+ 1 + random.nextInt(10), 1 + random.nextInt(363)).format(DateTimeFormatter.ISO_LOCAL_DATE));
				order.setTime(LocalDateTime.of(LocalDateTime.now().getYear() - random.nextInt(10),
						1 + random.nextInt(10), 1 + random.nextInt(24), random.nextInt(23), random.nextInt(59))
						.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
				order.setUserId(user.getId());
				order.setCreditCardNumber(fourDigits() + "" "" + fourDigits() + "" "" + fourDigits() + "" "" + fourDigits());
				long orderId = OrderRepository.REPOSITORY.createEntity(order);
				PersistenceOrder createdOrder = OrderRepository.REPOSITORY.getEntity(orderId);
				long price = 0;
				List<PersistenceCategory> categories = CategoryRepository.REPOSITORY.getAllEntities();
				Category preferred = categories.get(random.nextInt(categories.size()));
				for (int j = 0; j < 1 + random.nextInt(MAX_ITEMS_PER_ORDER); j++) {
					OrderItem item = generateOrderItem(createdOrder, preferred, productsPerCategory);
					price += item.getQuantity() * item.getUnitPriceInCents();
					OrderItemRepository.REPOSITORY.createEntity(item);
				}
				createdOrder.setTotalPriceInCents(price);
				OrderRepository.REPOSITORY.updateEntity(orderId, createdOrder);
			}
		});
	}

	//Order and preferred category must have a valid id!
	private OrderItem generateOrderItem(Order order, Category preferred, int productsPerCategory) {
		OrderItem item = new OrderItem();
		item.setOrderId(order.getId());
		item.setQuantity(random.nextInt(7));
		Category itemCategory = preferred;
		if (random.nextDouble() > PREFFERED_CATEGORY_CHANCE) {
			List<PersistenceCategory> categories = CategoryRepository.REPOSITORY.getAllEntities();
			itemCategory = categories.get(random.nextInt(categories.size()));
		}
		Product product = ProductRepository.REPOSITORY.getAllEntities(
				itemCategory.getId(), random.nextInt(productsPerCategory), 1).get(0);
		item.setProductId(product.getId());
		item.setUnitPriceInCents(product.getListPriceInCents());
		return item;
	}

	private String fourDigits() {
		return String.valueOf(1000 + random.nextInt(8999));
	}

	/**
	 * Drops database and recreates all tables.<br/>
	 * Attention: Does not reset foreign persistence contexts.
	 * Best practice is to call CacheManager.MANAGER.resetAllEMFs() after dropping and then recreating the DB.
	 */
	public void dropAndCreateTables() {
		CacheManager.MANAGER.clearLocalCacheOnly();
		ServerSession session = CategoryRepository.REPOSITORY.getEM().unwrap(ServerSession.class);
		SchemaManager schemaManager = new SchemaManager(session);
		schemaManager.replaceDefaultTables(true, true);
		CacheManager.MANAGER.clearLocalCacheOnly();
		CacheManager.MANAGER.resetLocalEMF();
		setGenerationFinishedFlag(false);
		CacheManager.MANAGER.clearAllCaches();
	}

	private void setGenerationFinishedFlag(boolean flag) {
		EntityManager em = CategoryRepository.REPOSITORY.getEM();
		try {
			em.getTransaction().begin();
			List<DatabaseManagementEntity> entities =
					em.createQuery(""SELECT u FROM ""
							+ DatabaseManagementEntity.class.getName()
							+ "" u"", DatabaseManagementEntity.class)
					.getResultList();
			if (entities == null || entities.isEmpty()) {
				DatabaseManagementEntity entity = new DatabaseManagementEntity();
				entity.setFinishedGenerating(flag);
				em.persist(entity);
			} else {
				DatabaseManagementEntity entity = entities.get(0);
				entity.setFinishedGenerating(flag);
			}
			em.getTransaction().commit();
		} finally {
			em.close();
		}
	}

	/**
	 * Returns true if the database has finished generating.
	 * False if it is currently generating.
	 * @return False if the database is generating.
	 */
	public boolean getGenerationFinishedFlag() {
		if (isMaintenanceMode()) {
			return false;
		}
		boolean finishedGenerating = false;
		EntityManager em = CategoryRepository.REPOSITORY.getEM();
		try {
			List<DatabaseManagementEntity> entities =
					em.createQuery(""SELECT u FROM ""
							+ DatabaseManagementEntity.class.getName()
							+ "" u"", DatabaseManagementEntity.class)
					.getResultList();
			if (entities != null && !entities.isEmpty()) {
				finishedGenerating = entities.get(0).isFinishedGenerating();
			}
		} finally {
			em.close();
		}
		return finishedGenerating;
	}

	/**
	 * Returns if the current persistence is in maintenance mode.
	 * Will return 503 on pretty much every external call in this mode.
	 * @return True if in maintenance, false otherwise.
	 */
	public boolean isMaintenanceMode() {
		return maintenanceMode;
	}

	/**
	 * Put the current persistence into maintenance mode.
	 * Will return 503 on pretty much every external call in this mode.
	 * @param maintenanceMode The maintenance flag.
	 */
	public synchronized void setMaintenanceModeInternal(boolean maintenanceMode) {
		this.maintenanceMode = maintenanceMode;
	}

	/**
	 * Puts all persistences into maintenance mode.
	 * Will return 503 on pretty much every external call once in this mode.
	 * @param maintenanceMode The maintenance flag.
	 */
	public void setMaintenanceModeGlobal(boolean maintenanceMode) {
		setMaintenanceModeInternal(maintenanceMode);
		List<Response> rs = ServiceLoadBalancer.multicastRESTToOtherServiceInstances(
				""generatedb"", String.class, client -> setMaintenanceModeExternal(client, maintenanceMode));
		rs.forEach(r -> {
				if (r != null) {
					r.bufferEntity();
					r.close();
				}
			});
	}

	private Response setMaintenanceModeExternal(RESTClient<String> client, final Boolean maintenanceMode) {
		Response r = client.getEndpointTarget().path(""maintenance"")
		.request(MediaType.TEXT_PLAIN).post(Entity.entity(String.valueOf(maintenanceMode), MediaType.TEXT_PLAIN));
		return r;
	}
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/repository/EMFManager.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.repository;

import java.util.HashMap;

import javax.naming.InitialContext;
import javax.naming.NamingException;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.Persistence;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class for managing the EMF singleton.
 * @author Jakim von Kistowski
 *
 */
final class EMFManager {

	private static EntityManagerFactory emf = null; 
	private static HashMap<String, String> persistenceProperties = null;
	
	private static final Logger LOG = LoggerFactory.getLogger(EMFManager.class);
	
	private static final String DRIVER_PROPERTY = ""jakarta.persistence.jdbc.driver"";
	private static final String IN_MEMORY_DRIVER_VALUE = ""org.hsqldb.jdbcDriver"";
	private static final String JDBC_URL_PROPERTY = ""jakarta.persistence.jdbc.url"";
	private static final String IN_MEMORY_JDBC_URL_VALUE = ""jdbc:hsqldb:mem:test"";
	private static final String USER_PROPERTY = ""jakarta.persistence.jdbc.user"";
	private static final String IN_MEMORY_USER_VALUE = ""sa"";
	private static final String PASSWORD_PROPERTY = ""jakarta.persistence.jdbc.password"";
	private static final String IN_MEMORY_PASSWORD_VALUE = """";
	
	private static final String MYSQL_URL_PREFIX = ""jdbc:mysql://"";
	private static final String MYSQL_URL_POSTFIX = ""/teadb"";
	private static final String MYSQL_DEFAULT_HOST = ""localhost"";
	private static final String MYSQL_DEFAULT_PORT = ""3306"";
	
	private EMFManager() {
		
	}
	
	/**
	 * (Re-)configure the entity manager factory using a set of persistence properties.
	 * Use to change database/user at run-time.
	 * Properties are kept, even if the database is reset.
	 * @param persistenceProperties The persistence properties.
	 */
	static void configureEMFWithProperties(HashMap<String, String> persistenceProperties) {
		EMFManager.persistenceProperties = persistenceProperties;
		clearEMF();
	}
	
	/**
	 * Get the entity manager factory.
	 * @return The entity manager factory.
	 */
	static synchronized EntityManagerFactory getEMF() {
		if (emf == null) {
			HashMap<String, String> persistenceProperties = EMFManager.persistenceProperties;
			if (persistenceProperties == null) {
				persistenceProperties = createPersistencePropertiesFromJavaEnv();
			}
			emf = Persistence.createEntityManagerFactory(""tools.descartes.teastore.persistence"",
					persistenceProperties);
			
		}
		return emf;
	}
	
	/**
	 * Closes and deletes EMF to be reinitialized later.
	 */
	static void clearEMF() {
		if (emf != null) {
			emf.close();
		}
		emf = null;
	}
	
	private static HashMap<String, String> createPersistencePropertiesFromJavaEnv() {
		HashMap<String, String> persistenceProperties = new HashMap<String, String>();
		String dbhost = null;
		String dbport = null;
		boolean useInMemoryDB = false;
		String url = MYSQL_URL_PREFIX;
		try {
			useInMemoryDB = Boolean.parseBoolean((String) new InitialContext().lookup(""java:comp/env/inMemoryDB""));
			if (useInMemoryDB) {
				LOG.info(""Using in-memory development database. Set Java env \""inMemoryDB\"" to false to use MariaDB."");
			} else {
				LOG.info(""\""inMemoryDB\"" set to false. Using MariaDB/MySQL."");
			}
		} catch (NamingException e) {
			LOG.info(""Using MySQL/MariaDB database."");
		}
		if (!useInMemoryDB) {
			try {
				dbhost = (String) new InitialContext().lookup(""java:comp/env/databaseHost"");
			} catch (NamingException e) {
				LOG.info(""Database host not set. Falling back to default host at "" + MYSQL_DEFAULT_HOST + ""."");
			}
			try {
				dbport = (String) new InitialContext().lookup(""java:comp/env/databasePort"");
			} catch (NamingException e) {
				LOG.info(""Database port not set. Falling back to default host at "" + MYSQL_DEFAULT_PORT + ""."");
			}
			if (dbhost != null || dbport != null) {
				if (dbhost != null) {
					url += dbhost;
				} else {
					url += MYSQL_DEFAULT_HOST;
				}
				url += "":"";
				if (dbport != null) {
					url += dbport;
				} else {
					url += MYSQL_DEFAULT_PORT;
				}
				url += MYSQL_URL_POSTFIX;
				LOG.info(""Setting jdbc url to \"""" + url + ""\""."");
				persistenceProperties.put(""jakarta.persistence.jdbc.url"", url);
			}
		} else {
			persistenceProperties = createPersistencePropertieForInMemoryDB();
		}
		return persistenceProperties;
	}
	
	/**
	 * Create a persistence property map to configure the EMFManager to use an in-memory database
	 * instead of the usual MySQL/MariaDB database.
	 * @return The configuration. Pass this to {@link #configureEMFWithProperties(HashMap)}.
	 */
	static HashMap<String, String> createPersistencePropertieForInMemoryDB() {
		HashMap<String, String> persistenceProperties = new HashMap<String, String>();
		persistenceProperties.put(DRIVER_PROPERTY, IN_MEMORY_DRIVER_VALUE);
		persistenceProperties.put(JDBC_URL_PROPERTY, IN_MEMORY_JDBC_URL_VALUE);
		persistenceProperties.put(USER_PROPERTY, IN_MEMORY_USER_VALUE);
		persistenceProperties.put(PASSWORD_PROPERTY, IN_MEMORY_PASSWORD_VALUE);
		return persistenceProperties;
	}
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/servlet/IndexServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.servlet;

import java.io.IOException;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Index Servlet for Persistence. Provides some basic debug information for
 * deployers and testers.
 * @author Joakim von Kistowski
 */
@WebServlet(""/index"")
public class IndexServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public IndexServlet() {
        super();
    }

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 * @param request The request.
	 * @param response The response.
	 * @throws ServletException In case of servlet Exception.
	 * @throws IOException In case of IOException.
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.getWriter().println(""This is the persistence module running at ""
	+ request.getProtocol() + ""://"" + request.getLocalAddr() + "":""
				+ request.getLocalPort() + ""/"" + request.getContextPath());
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 * @param request The request.
	 * @param response The response.
	 * @throws ServletException In case of servlet Exception.
	 * @throws IOException In case of IOException.
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}

}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/rest/UserEndpoint.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;

import tools.descartes.teastore.persistence.domain.UserRepository;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.util.AbstractCRUDEndpoint;
import tools.descartes.teastore.entities.User;

/**
 * Persistence endpoint for CRUD operations on Categories.
 * 
 * @author Joakim von Kistowski
 *
 */
@Path(""users"")
public class UserEndpoint extends AbstractCRUDEndpoint<User> {

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long createEntity(final User category) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return -1L;
		}
		try {
			return UserRepository.REPOSITORY.createEntity(category);
		} catch (Exception e) {
			// SQL errors, especially for duplicate user names
			return -1L;
		}

	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected User findEntityById(final long id) {
		User user = UserRepository.REPOSITORY.getEntity(id);
		if (user == null) {
			return null;
		}
		return new User(user);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected List<User> listAllEntities(final int startIndex, final int maxResultCount) {
		List<User> users = new ArrayList<User>();
		for (User u : UserRepository.REPOSITORY.getAllEntities(startIndex, maxResultCount)) {
			users.add(new User(u));
		}
		return users;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean updateEntity(long id, User category) {
		return UserRepository.REPOSITORY.updateEntity(id, category);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean deleteEntity(long id) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return false;
		}
		return UserRepository.REPOSITORY.removeEntity(id);
	}

	/**
	 * Retreive user with the provided name.
	 * 
	 * @param name
	 *            name of the entity to find.
	 * @return A Response containing the entity.
	 */
	@GET
	@Path(""name/{name}"")
	public Response findById(@PathParam(""name"") final String name) {
		if (name == null || name.isEmpty()) {
			return Response.status(Status.NOT_FOUND).build();
		}
		User entity = UserRepository.REPOSITORY.getUserByName(name);
		if (entity == null) {
			return Response.status(Status.NOT_FOUND).build();
		}
		return Response.ok(new User(entity)).build();
	}
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/rest/CacheManagerEndpoint.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import jakarta.ws.rs.DELETE;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;
import tools.descartes.teastore.persistence.repository.CacheManager;

/**
 * REST endpoint for cache clearing.
 * @author Joakim von Kistowski
 */
@Path(""cache"")
@Produces(""text/plain"")
public final class CacheManagerEndpoint {

	/**
	 * Clears the cache for the class.
	 * @param className fully qualified class name.
	 * @return Status Code 200 and cleared class name if clear succeeded, 404 if it didn't.
	 */
	@DELETE
	@Path(""/class/{class}"")
	public Response clearClassCache(@PathParam(""class"") final String className) {
		boolean classfound = true;
		try {
			Class<?> entityClass = Class.forName(className);
			CacheManager.MANAGER.clearLocalCacheOnly(entityClass);
		} catch (Exception e) {
			classfound = false;
		}
		if (classfound) {
			return Response.ok(className).build();
		}
		return Response.status(Status.NOT_FOUND).build();
	}
	
	/**
	 * Clears the entire cache.
	 * @return Status Code 200 and ""cleared"" text if clear succeeded, 404 if it didn't.
	 */
	@DELETE
	@Path(""/cache"")
	public Response clearAllCaches() {
		CacheManager.MANAGER.clearLocalCacheOnly();
		return Response.ok(""cleared"").build();
	}
	
	/**
	 * Closes and resets the EMF.
	 * @return Status Code 200 and ""clearedEMF"" text if reset succeeded, 404 if it didn't.
	 */
	@DELETE
	@Path(""/emf"")
	public Response clearEMF() {
		CacheManager.MANAGER.resetLocalEMF();
		return Response.ok(""clearedEMF"").build();
	}
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/rest/CategoryEndpoint.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.Path;

import tools.descartes.teastore.persistence.domain.CategoryRepository;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.util.AbstractCRUDEndpoint;
import tools.descartes.teastore.entities.Category;

/**
 * Persistence endpoint for CRUD operations on Categories.
 * @author Joakim von Kistowski
 *
 */
@Path(""categories"")
public class CategoryEndpoint extends AbstractCRUDEndpoint<Category> {

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long createEntity(final Category category) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return -1L;
		}
		return CategoryRepository.REPOSITORY.createEntity(category);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected Category findEntityById(final long id) {
		Category category = CategoryRepository.REPOSITORY.getEntity(id);
		if (category == null) {
			return null;
		}
		return new Category(category);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected List<Category> listAllEntities(final int startIndex, final int maxResultCount) {
		List<Category> categories = new ArrayList<Category>();
		for (Category c : CategoryRepository.REPOSITORY.getAllEntities(startIndex, maxResultCount)) {
			categories.add(new Category(c));
		}
		return categories;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean updateEntity(long id, Category category) {
		return CategoryRepository.REPOSITORY.updateEntity(id, category);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean deleteEntity(long id) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return false;
		}
		return CategoryRepository.REPOSITORY.removeEntity(id);
	}
	
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/rest/OrderEndpoint.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.QueryParam;

import tools.descartes.teastore.persistence.domain.OrderRepository;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.util.AbstractCRUDEndpoint;
import tools.descartes.teastore.entities.Order;

/**
 * Persistence endpoint for for CRUD operations on orders.
 * @author Joakim von Kistowski
 *
 */
@Path(""orders"")
public class OrderEndpoint extends AbstractCRUDEndpoint<Order> {

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long createEntity(final Order order) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return -1L;
		}
		return OrderRepository.REPOSITORY.createEntity(order);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected Order findEntityById(final long id) {
		Order order = OrderRepository.REPOSITORY.getEntity(id);
		if (order == null) {
			return null;
		}
		return new Order(order);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected List<Order> listAllEntities(final int startIndex, final int maxResultCount) {
		List<Order> order = new ArrayList<Order>();
		for (Order o : OrderRepository.REPOSITORY.getAllEntities(startIndex, maxResultCount)) {
			order.add(new Order(o));
		}
		return order;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean updateEntity(long id, Order order) {
		return OrderRepository.REPOSITORY.updateEntity(id, order);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean deleteEntity(long id) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return false;
		}
		return OrderRepository.REPOSITORY.removeEntity(id);
	}
	
	/**
	 * Returns all order items with the given product Id (all order items for that product).
	 * @param userId The id of the product.
	 * @param startPosition The index (NOT ID) of the first order item with the product to return.
	 * @param maxResult The max number of order items to return.
	 * @return list of order items with the product.
	 */
	@GET
	@Path(""user/{user:[0-9][0-9]*}"")
	public List<Order> listAllForUser(@PathParam(""user"") final Long userId,
			@QueryParam(""start"") final Integer startPosition,
			@QueryParam(""max"") final Integer maxResult) {
		if (userId == null) {
			return listAll(startPosition, maxResult);
		}
		List<Order> orders = new ArrayList<Order>();
		for (Order o : OrderRepository.REPOSITORY.getAllEntitiesWithUser(userId,
				parseIntQueryParam(startPosition), parseIntQueryParam(maxResult))) {
			orders.add(new Order(o));
		}
		return orders;
	}

}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/rest/ProductEndpoint.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.persistence.domain.ProductRepository;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.util.AbstractCRUDEndpoint;
import tools.descartes.teastore.entities.Product;

/**
 * Persistence endpoint for for CRUD operations on products.
 * @author Joakim von Kistowski
 *
 */
@Path(""products"")
public class ProductEndpoint extends AbstractCRUDEndpoint<Product> {

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long createEntity(final Product product) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return -1L;
		}
		return ProductRepository.REPOSITORY.createEntity(product);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected Product findEntityById(final long id) {
		Product product = ProductRepository.REPOSITORY.getEntity(id);
		if (product == null) {
			return null;
		}
		return new Product(product);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected List<Product> listAllEntities(final int startIndex, final int maxResultCount) {
		List<Product> products = new ArrayList<Product>();
		for (Product p : ProductRepository.REPOSITORY.getAllEntities(startIndex, maxResultCount)) {
			products.add(new Product(p));
		}
		return products;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean updateEntity(long id, Product product) {
		return ProductRepository.REPOSITORY.updateEntity(id, product);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean deleteEntity(long id) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return false;
		}
		return ProductRepository.REPOSITORY.removeEntity(id);
	}
	
	/**
	 * Returns all products with the given category Id (all products in that category).
	 * @param categoryId The id of the Category.
	 * @param startPosition The index (NOT ID) of the first product in the category to return.
	 * @param maxResult The max number of products to return.
	 * @return list of products in the category.
	 */
	@GET
	@Path(""category/{category:[0-9][0-9]*}"")
	public List<Product> listAllForCategory(@PathParam(""category"") final Long categoryId,
			@QueryParam(""start"") final Integer startPosition,
			@QueryParam(""max"") final Integer maxResult) {
		if (categoryId == null) {
			return listAll(startPosition, maxResult);
		}
		List<Product> products = new ArrayList<Product>();
		for (Product p : ProductRepository.REPOSITORY.getAllEntities(categoryId,
				parseIntQueryParam(startPosition), parseIntQueryParam(maxResult))) {
			products.add(new Product(p));
		}
		return products;
	}
	
	/**
	 * Returns the count of produts with the given category Id (products in that category).
	 * @param categoryId The id of the Category.
	 * @return list of products in the category.
	 */
	@GET
	@Path(""count/{category:[0-9][0-9]*}"")
	public Response countForCategory(@PathParam(""category"") final Long categoryId) {
		if (categoryId == null) {
			return Response.status(404).build();
		}
		long count = ProductRepository.REPOSITORY.getProductCount(categoryId);
		if (count >= 0) {
			return Response.ok(String.valueOf(count)).build();
		}
		return Response.status(404).build();
	}
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/rest/DatabaseGenerationEndpoint.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import java.util.concurrent.Executors;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.persistence.repository.CacheManager;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.RegistryClient;

/**
 * Persistence endpoint for generating new database content.
 * @author Joakim von Kistowski
 *
 */
@Path(""generatedb"")
public class DatabaseGenerationEndpoint {

	private static final Logger LOG = LoggerFactory.getLogger(DatabaseGenerationEndpoint.class);

	/**
	 * Drop database and create a new one.
	 * @param categories Number of new categories.
	 * @param products Number of new products per category.
	 * @param users Number of new users.
	 * @param orders Number of max orders per user.
	 * @return Status OK. Returns {@value DataGenerator.MAINTENANCE_STATUS_CODE}
	 * if in maintenance mode.
	 */
	@GET
	public Response generateDataBase(
			@QueryParam(""categories"") final Integer categories,
			@QueryParam(""products"") final Integer products,
			@QueryParam(""users"") final Integer users,
			@QueryParam(""orders"") final Integer orders) {
		LOG.info(""Received database generation command for Persistence at ""
			+ RegistryClient.getClient().getMyServiceInstanceServer() + ""."");
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return Response.status(DataGenerator.MAINTENANCE_STATUS_CODE).build();
		}
		DataGenerator.GENERATOR.setMaintenanceModeGlobal(true);
		LOG.info(""Global maintenance mode enabled."");
		DataGenerator.GENERATOR.dropAndCreateTables();
		LOG.info(""Finished dropping tables and re-initializing database schmema."");
		int categoryCount = parseQuery(categories, DataGenerator.SMALL_DB_CATEGORIES);
		int productCount = parseQuery(products, DataGenerator.SMALL_DB_PRODUCTS_PER_CATEGORY);
		int userCount = parseQuery(users, DataGenerator.SMALL_DB_USERS);
		int maxOrderCount = parseQuery(orders, DataGenerator.SMALL_DB_MAX_ORDERS_PER_USER);
		LOG.info(""Initializing database creation with ""
				+ categoryCount + "" categories, ""
				+ productCount + "" products per category, ""
				+ userCount + "" users, ""
				+ maxOrderCount + "" max orders per user."");
		Executors.newSingleThreadScheduledExecutor().execute(() -> {
			DataGenerator.GENERATOR.generateDatabaseContent(categoryCount,
					productCount, userCount, maxOrderCount);
			LOG.info(""Finished database generation."");
			CacheManager.MANAGER.resetRemoteEMFs();
			LOG.info(""Finished resetting all Persistence service instances."");
			DataGenerator.GENERATOR.setMaintenanceModeGlobal(false);
			LOG.info(""Done. Maintenance mode disabled."");
		});
		String message = ""Creating database with ""
				+ categoryCount + "" categories, ""
				+ productCount + "" products per category, ""
				+ userCount + "" users, ""
				+ maxOrderCount + "" max orders per user."";
		return Response.ok(message).build();
	}

	private int parseQuery(Integer param, int defaultValue) {
		if (param == null) {
			return defaultValue;
		}
		return param;
	}

	/**
	 * Returns the is finished flag for database generation.
	 * Also returns false if the persistence provider is in maintenance mode.
	 * @return True, if generation is finished; false, if in progress.
	 */
	@GET
	@Path(""finished"")
	public Response isFinshed() {
		if (DataGenerator.GENERATOR.getGenerationFinishedFlag()) {
			return Response.ok(true).build();
		} else {
			return Response.serverError().entity(false).build();
		}
	}

	/**
	 * Disables or enables the maintenance mode.
	 * Persistence providers in maintenance mode return 503 on almost anything.
	 * @param maintenanceMode Send true to enable, false to disable.
	 * @return 404 if message body was missing. 200, otherwise.
	 */
	@POST
	@Path(""maintenance"")
	public Response setMaintenanceMode(final Boolean maintenanceMode) {
		if (maintenanceMode == null) {
			return Response.status(Status.NOT_FOUND).build();
		}
		DataGenerator.GENERATOR.setMaintenanceModeInternal(maintenanceMode);
		return Response.ok().build();
	}

	/**
	 * Returns the is maintenance flag. Only to be used by other persistence providers.
	 * @return True, if in maintenance; false, otherwise.
	 */
	@GET
	@Path(""maintenance"")
	public Response isMaintenance() {
		return Response.ok(DataGenerator.GENERATOR.isMaintenanceMode()).build();
	}
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/rest/OrderItemEndpoint.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.QueryParam;

import tools.descartes.teastore.persistence.domain.OrderItemRepository;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.util.AbstractCRUDEndpoint;
import tools.descartes.teastore.entities.OrderItem;

/**
 * Persistence endpoint for for CRUD operations on orders.
 * @author Joakim von Kistowski
 *
 */
@Path(""orderitems"")
public class OrderItemEndpoint extends AbstractCRUDEndpoint<OrderItem> {

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long createEntity(final OrderItem orderItem) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return -1L;
		}
		return OrderItemRepository.REPOSITORY.createEntity(orderItem);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected OrderItem findEntityById(final long id) {
		OrderItem item = OrderItemRepository.REPOSITORY.getEntity(id);
		if (item == null) {
			return null;
		}
		return new OrderItem(item);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected List<OrderItem> listAllEntities(final int startIndex, final int maxResultCount) {
		List<OrderItem> orderItems = new ArrayList<OrderItem>();
		for (OrderItem oi : OrderItemRepository.REPOSITORY.getAllEntities(startIndex, maxResultCount)) {
			orderItems.add(new OrderItem(oi));
		}
		return orderItems;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean updateEntity(long id, OrderItem orderItem) {
		return OrderItemRepository.REPOSITORY.updateEntity(id, orderItem);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean deleteEntity(long id) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return false;
		}
		return OrderItemRepository.REPOSITORY.removeEntity(id);
	}
	
	/**
	 * Returns all order items with the given product Id (all order items for that product).
	 * @param productId The id of the product.
	 * @param startPosition The index (NOT ID) of the first order item with the product to return.
	 * @param maxResult The max number of order items to return.
	 * @return list of order items with the product.
	 */
	@GET
	@Path(""product/{product:[0-9][0-9]*}"")
	public List<OrderItem> listAllForProduct(@PathParam(""product"") final Long productId,
			@QueryParam(""start"") final Integer startPosition,
			@QueryParam(""max"") final Integer maxResult) {
		if (productId == null) {
			return listAll(startPosition, maxResult);
		}
		List<OrderItem> orderItems = new ArrayList<OrderItem>();
		for (OrderItem oi : OrderItemRepository.REPOSITORY.getAllEntitiesWithProduct(productId,
				parseIntQueryParam(startPosition), parseIntQueryParam(maxResult))) {
			orderItems.add(new OrderItem(oi));
		}
		return orderItems;
	}
	
	/**
	 * Returns all order items with the given order Id (all order items for that order).
	 * @param orderId The id of the product.
	 * @param startPosition The index (NOT ID) of the first order item with the product to return.
	 * @param maxResult The max number of order items to return.
	 * @return list of order items with the product.
	 */
	@GET
	@Path(""order/{order:[0-9][0-9]*}"")
	public List<OrderItem> listAllForOrder(@PathParam(""order"") final Long orderId,
			@QueryParam(""start"") final Integer startPosition,
			@QueryParam(""max"") final Integer maxResult) {
		if (orderId == null) {
			return listAll(startPosition, maxResult);
		}
		List<OrderItem> orderItems = new ArrayList<OrderItem>();
		for (OrderItem oi : OrderItemRepository.REPOSITORY.getAllEntitiesWithOrder(orderId,
				parseIntQueryParam(startPosition), parseIntQueryParam(maxResult))) {
			orderItems.add(new OrderItem(oi));
		}
		return orderItems;
	}
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/daemons/InitialDataGenerationDaemon.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.daemons;

import jakarta.persistence.PersistenceException;
import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.opentracing.util.GlobalTracer;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.RegistryClient;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.tracing.Tracing;

/**
 * Application Lifecycle Listener implementation class for data generation.
 *
 * @author Joakim von Kistowski
 *
 */
@WebListener
public class InitialDataGenerationDaemon implements ServletContextListener {

  private static final Logger LOG = LoggerFactory.getLogger(InitialDataGenerationDaemon.class);

  private static final long DATABASE_OFFLINE_WAIT_MS = 2000;

  /**
   * Default constructor.
   */
  public InitialDataGenerationDaemon() {

  }

  /**
   * @see ServletContextListener#contextDestroyed(ServletContextEvent)
   * @param event
   *          The servlet context event at destruction.
   */
  public void contextDestroyed(ServletContextEvent event) {
    RegistryClient.getClient().unregister(event.getServletContext().getContextPath());
  }

  /**
   * @see ServletContextListener#contextInitialized(ServletContextEvent)
   * @param event
   *          The servlet context event at initialization.
   */
  public void contextInitialized(ServletContextEvent event) {
    GlobalTracer.register(Tracing.init(Service.PERSISTENCE.getServiceName()));
    waitForDatabase();
    if (DataGenerator.GENERATOR.isDatabaseEmpty()) {
      LOG.info(""Database is empty. Generating new database content"");
      DataGenerator.GENERATOR.generateDatabaseContent(DataGenerator.SMALL_DB_CATEGORIES,
          DataGenerator.SMALL_DB_PRODUCTS_PER_CATEGORY, DataGenerator.SMALL_DB_USERS,
          DataGenerator.SMALL_DB_MAX_ORDERS_PER_USER);
    } else {
      LOG.info(""Populated database found. Skipping data generation"");
    }
    LOG.info(""Persistence finished initializing database"");
    RegistryClient.getClient().register(event.getServletContext().getContextPath());
    LOG.info(""Persistence started registration daemon"");
  }

  private void waitForDatabase() {
    boolean databaseOffline = true;
    while (databaseOffline) {
      try {
        DataGenerator.GENERATOR.isDatabaseEmpty();
        databaseOffline = false;
      } catch (PersistenceException e) {
        System.out.println(""TEST"");
        LOG.warn(""Exception connecting to database. Is database offline? Wating for ""
            + DATABASE_OFFLINE_WAIT_MS + "" ms."");
        try {
          Thread.sleep(DATABASE_OFFLINE_WAIT_MS);
        } catch (InterruptedException e1) {
          LOG.error(""Exception waiting for database to come online: "" + e1.getMessage());
        }
      }
    }

  }
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/domain/converters/LocalDateAttributeConverter.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.domain.converters;

import java.sql.Date;
import java.time.LocalDate;

import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;

/**
 * Converter for persisting Java8 LocalDate in database.
 * @author Joakim von Kistowski
 *
 */
@Converter(autoApply = true)
public class LocalDateAttributeConverter implements AttributeConverter<LocalDate, Date> {
	
	/**
	 * Converts LocalDate to a supported format.
	 * @param locDate The date to convert.
	 * @return The date in a supported format.
	 */
    @Override
    public Date convertToDatabaseColumn(LocalDate locDate) {
    	if (locDate == null) {
    		return null;
    	}
    	return Date.valueOf(locDate);
    }

    /**
	 * Converts database format to LocalDate.
	 * @param sqlDate The date to convert.
	 * @return The date as LocalDate.
	 */
    @Override
    public LocalDate convertToEntityAttribute(Date sqlDate) {
    	if (sqlDate == null) {
    		return null;
    	}
    	return sqlDate.toLocalDate();
    }
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/domain/converters/LocalDateTimeAttributeConverter.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.domain.converters;

import java.sql.Timestamp;
import java.time.LocalDateTime;

import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;

/**
 * Converter for persisting Java8 LocalDateTime in database.
 * @author Joakim von Kistowski
 *
 */
@Converter(autoApply = true)
public class LocalDateTimeAttributeConverter implements AttributeConverter<LocalDateTime, Timestamp> {
	
	/**
	 * Converts LocalDateTime to a supported format.
	 * @param locDateTime The date time to convert.
	 * @return The date time in a supported format.
	 */
	@Override
	public Timestamp convertToDatabaseColumn(LocalDateTime locDateTime) {
		if (locDateTime == null) {
			return null;
		}
		return Timestamp.valueOf(locDateTime);
	}

	
	/**
	 * Converts database format to LocalDateTime.
	 * @param sqlTimestamp The date time to convert.
	 * @return The date as LocalDateTime.
	 */
	@Override
	public LocalDateTime convertToEntityAttribute(Timestamp sqlTimestamp) {
		if (sqlTimestamp == null) {
			return null;
		}
		return sqlTimestamp.toLocalDateTime();
	}
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/domain/PersistenceProduct.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.domain;

import java.util.ArrayList;
import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import jakarta.persistence.Lob;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.PostRemove;

import tools.descartes.teastore.persistence.repository.CacheManager;
import tools.descartes.teastore.entities.Product;

/**
 * Persistence entity for products.
 * @author Joakim von Kistowski
 *
 */
@Entity
public class PersistenceProduct extends Product {

	@Id
	@GeneratedValue
	private long id;
	
	@Column(length = 100)
	private String name;
	@Lob
	private String description;
	private long listPriceInCents;
	
	@ManyToOne
	private PersistenceCategory category;
	
	@OneToMany(mappedBy = ""product"", orphanRemoval = true, cascade = {CascadeType.ALL})
	private List<PersistenceOrderItem> orderItems;
	
	/**
	 * Clear categories and order items from cache post remove.
	 */
	@PostRemove
	private void clearCaches() {
		CacheManager.MANAGER.clearCache(PersistenceCategory.class);
		CacheManager.MANAGER.clearRemoteCache(PersistenceProduct.class);
	}
	
	/**
	 * Create a new and empty product.
	 */
	PersistenceProduct() {
		super();
		orderItems = new ArrayList<PersistenceOrderItem>();
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setId(long id) {
		this.id = id;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getId() {
		return id;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getCategoryId() {
		return category.getId();
	}
	
	/**
	 * Unsupported operation. Does nothing.
	 * @param categoryId Unsupported parameter.
	 */
	@Override
	public void setCategoryId(long categoryId) {
		// unsupported operation
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getName() {
		return name;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setName(String name) {
		this.name = name;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getDescription() {
		return description;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setDescription(String description) {
		this.description = description;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getListPriceInCents() {
		return listPriceInCents;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setListPriceInCents(long listPriceInCents) {
		this.listPriceInCents = listPriceInCents;
	}

	/**
	 * {@inheritDoc}
	 */
	public PersistenceCategory getCategory() {
		return category;
	}

	/**
	 * {@inheritDoc}
	 */
	public void setCategory(PersistenceCategory category) {
		this.category = category;
	}

	/**
	 * @return the orderItems
	 */
	public List<PersistenceOrderItem> getOrderItems() {
		return orderItems;
	}
	
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/domain/OrderRepository.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.domain;

import java.util.ArrayList;
import java.util.List;

import jakarta.persistence.EntityManager;
import jakarta.persistence.TypedQuery;

import tools.descartes.teastore.persistence.repository.AbstractPersistenceRepository;
import tools.descartes.teastore.entities.Order;

/**
 * Repository that performs transactional CRUD operations for orders on database.
 * @author Joakim von Kistowski
 *
 */
public final class OrderRepository extends AbstractPersistenceRepository<Order, PersistenceOrder> {

	/**
	 * Singleton for the ProductRepository.
	 */
	public static final OrderRepository REPOSITORY = new OrderRepository();
	
	//Private constructor.
	private OrderRepository() {
		
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public long createEntity(Order entity) {
		PersistenceOrder order = new PersistenceOrder();
		order.setTime(entity.getTime());
		order.setTotalPriceInCents(entity.getTotalPriceInCents());
		order.setAddressName(entity.getAddressName());
		order.setAddress1(entity.getAddress1());
		order.setAddress2(entity.getAddress2());
		order.setCreditCardCompany(entity.getCreditCardCompany());
		order.setCreditCardNumber(entity.getCreditCardNumber());
		order.setCreditCardExpiryDate(entity.getCreditCardExpiryDate());
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceUser user = em.find(PersistenceUser.class, entity.getUserId());
	        if (user != null) {
	        	order.setUser(user);
	        	em.persist(order);
	        } else {
	        	order.setId(-1L);
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
	    return order.getId();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean updateEntity(long id, Order entity) {
		boolean found = false;
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceOrder order = em.find(getEntityClass(), id);
	        if (order != null) {
	        	order.setTime(entity.getTime());
	    		order.setTotalPriceInCents(entity.getTotalPriceInCents());
	    		order.setAddressName(entity.getAddressName());
	    		order.setAddress1(entity.getAddress1());
	    		order.setAddress2(entity.getAddress2());
	    		order.setCreditCardCompany(entity.getCreditCardCompany());
	    		order.setCreditCardNumber(entity.getCreditCardNumber());
	    		order.setCreditCardExpiryDate(entity.getCreditCardExpiryDate());
	        	found = true;
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
	    return found;
	}
	
	/**
	 * Gets all Orders for the user with the specified userId.
	 * @param userId The id of the ordering user.
	 * @param start The index of the first order to return. Negative value to start at the beginning.
	 * @param limit The maximum number of order to return. Negative value to return all.
	 * @return List of orders with the specified user.
	 */
	public List<PersistenceOrder> getAllEntitiesWithUser(long userId, int start, int limit) {
		List<PersistenceOrder> entities = null;
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceUser user = em.find(PersistenceUser.class, userId);
	        if (user != null) {
	        	TypedQuery<PersistenceOrder> allMatchesQuery =
	        			em.createQuery(""SELECT u FROM "" + getEntityClass().getName()
	        					+ "" u WHERE u.user = :user"", getEntityClass());
	        	allMatchesQuery.setParameter(""user"", user);
	    		entities = resultsWithStartAndLimit(em, allMatchesQuery, start, limit);
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
		if (entities == null) {
			return new ArrayList<PersistenceOrder>();
		}
		return entities;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long getId(PersistenceOrder v) {
		return v.getId();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected Class<PersistenceOrder> getEntityClass() {
		return PersistenceOrder.class;
	}
	
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/domain/ProductRepository.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.domain;

import java.util.ArrayList;
import java.util.List;

import jakarta.persistence.EntityManager;
import jakarta.persistence.TypedQuery;

import tools.descartes.teastore.persistence.repository.AbstractPersistenceRepository;
import tools.descartes.teastore.entities.Product;

/**
 * Repository that performs transactional CRUD operations for Products on database.
 * @author Joakim von Kistowski
 *
 */
public final class ProductRepository extends AbstractPersistenceRepository<Product, PersistenceProduct> {

	/**
	 * Singleton for the ProductRepository.
	 */
	public static final ProductRepository REPOSITORY = new ProductRepository();
	
	//Private constructor.
	private ProductRepository() {
		
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public long createEntity(Product entity) {
		PersistenceProduct product = new PersistenceProduct();
		product.setName(entity.getName());
		product.setDescription(entity.getDescription());
		product.setListPriceInCents(entity.getListPriceInCents());
		
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceCategory cat = em.find(PersistenceCategory.class, entity.getCategoryId());
	        if (cat != null) {
	        	product.setCategory(cat);
	        	em.persist(product);
	        } else {
	        	product.setId(-1L);
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
	    return product.getId();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean updateEntity(long id, Product entity) {
		boolean found = false;
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceProduct product = em.find(getEntityClass(), id);
	        if (product != null) {
	        	product.setName(entity.getName());
	        	product.setDescription(entity.getDescription());
	        	product.setListPriceInCents(entity.getListPriceInCents());
	        	found = true;
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
	    return found;
	}
	
	/**
	 * Gets all Products in the Category of the given categoryId.
	 * @param categoryId The id of the Category containing the Products.
	 * @param start The index of the first Product to return. Negative value to start at the beginning.
	 * @param limit The maximum number of Products to return. Negative value to return all.
	 * @return List of Products with the specified Category.
	 */
	public List<PersistenceProduct> getAllEntities(long categoryId, int start, int limit) {
		List<PersistenceProduct> entities = null;
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceCategory cat = em.find(PersistenceCategory.class, categoryId);
	        if (cat != null) {
	        	TypedQuery<PersistenceProduct> allMatchesQuery =
	        			em.createQuery(""SELECT u FROM "" + getEntityClass().getName()
	        					+ "" u WHERE u.category = :cat"", getEntityClass());
	        	allMatchesQuery.setParameter(""cat"", cat);
	        	entities = resultsWithStartAndLimit(em, allMatchesQuery, start, limit);
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
		if (entities == null) {
			return new ArrayList<PersistenceProduct>();
		}
		return entities;
	}

	/**
	 * Gets the count of all Products in the Category of the given categoryId.
	 * @param categoryId The id of the Category containing the Products.
	 * @return Count of Products with the specified Category.
	 */
	public long getProductCount(long categoryId) {
		long count = -1;
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceCategory cat = em.find(PersistenceCategory.class, categoryId);
	        if (cat != null) {
	        	TypedQuery<Long> allMatchesQuery =
	        			em.createQuery(""SELECT COUNT(u) FROM "" + getEntityClass().getName()
	        					+ "" u WHERE u.category = :cat"", Long.class);
	        	allMatchesQuery.setParameter(""cat"", cat);
	        	Long countResult = allMatchesQuery.getSingleResult();
	        	if (countResult != null) {
	        		count = countResult;
	        	}
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
		return count;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long getId(PersistenceProduct v) {
		return v.getId();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected Class<PersistenceProduct> getEntityClass() {
		return PersistenceProduct.class;
	}
	
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/domain/PersistenceCategory.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.domain;

import java.util.ArrayList;
import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import jakarta.persistence.Lob;
import jakarta.persistence.OneToMany;
import jakarta.persistence.PostRemove;

import tools.descartes.teastore.persistence.repository.CacheManager;
import tools.descartes.teastore.entities.Category;

/**
 * Entity for persisting Categories in database.
 * @author Joakim von Kistowski
 *
 */
@Entity
public class PersistenceCategory extends Category {

	@Id
	@GeneratedValue
	private long id;
	
	@Column(length = 100)
	private String name;
	@Lob
	private String description;
	
	@OneToMany(mappedBy = ""category"", orphanRemoval = true, cascade = {CascadeType.ALL})
	private List<PersistenceProduct> products;
	
	/**
	 * Creates a new and empty category.
	 */
	PersistenceCategory() {
		super();
		products = new ArrayList<>();
	}
	
	/**
	 * Clear products from cache to update relationships.
	 */
	@PostRemove
	private void clearCaches() {
		CacheManager.MANAGER.clearCache(PersistenceProduct.class);
		CacheManager.MANAGER.clearRemoteCache(PersistenceCategory.class);
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getId() {
		return id;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setId(long id) {
		this.id = id;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getName() {
		return name;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setName(String name) {
		this.name = name;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getDescription() {
		return description;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setDescription(String description) {
		this.description = description;
	}
	
	/**
	 * Get all products in this category.
	 * @return All products in the category.
	 */
	public List<PersistenceProduct> getProducts() {
		return products;
	}
	
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/domain/PersistenceOrderItem.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PostRemove;

import tools.descartes.teastore.persistence.repository.CacheManager;
import tools.descartes.teastore.entities.OrderItem;

/**
 * Persistence entity Class for OrderItems (item with quantity in shopping cart or order).
 * @author Joakim von Kistowski
 *
 */
@Entity
public class PersistenceOrderItem extends OrderItem {

	@Id
	@GeneratedValue
	private long id;
	
	private int quantity;
	private long unitPriceInCents;

	@ManyToOne(optional = false)
	private PersistenceProduct product;

	@ManyToOne(optional = false)
	private PersistenceOrder order;
	
	/**
	 * Create a new and empty order item.
	 */
	PersistenceOrderItem() {
		super();
	}
	
	/**
	 * Clear products and orders from cache post remove.
	 */
	@PostRemove
	private void clearCaches() {
		CacheManager.MANAGER.clearCache(PersistenceProduct.class);
		CacheManager.MANAGER.clearCache(PersistenceOrder.class);
		CacheManager.MANAGER.clearRemoteCache(PersistenceOrderItem.class);
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getId() {
		return id;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setId(long id) {
		this.id = id;
	}
	
	 /**
	 * {@inheritDoc}
	 */
	@Override
	public long getProductId() {
		return product.getId();
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setProductId(long productId) {
		//unsupported
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getQuantity() {
		return quantity;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getUnitPriceInCents() {
		return unitPriceInCents;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setUnitPriceInCents(long unitPriceInCents) {
		this.unitPriceInCents = unitPriceInCents;
	}

	/**
	 * Gets the product.
	 * @return the product to get.
	 */
	public PersistenceProduct getProduct() {
		return product;
	}

	/**
	 * Sets the product.
	 * @param product the product to set.
	 */
	void setProduct(PersistenceProduct product) {
		this.product = product;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getOrderId() {
		return getOrder().getId();
	}

	/**
	 * Unsupported operation.
	 * @param orderId unsupported parameter.
	 */
	public void setOrderId(long orderId) {
		//unsupported operation
	}
	
	/**
	 * Gets the order.
	 * @return The order to get.
	 */
	public PersistenceOrder getOrder() {
		return order;
	}

	/**
	 * Sets the order.
	 * @param order the order to set.
	 */
	void setOrder(PersistenceOrder order) {
		this.order = order;
	}
	
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/domain/UserRepository.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.domain;

import java.util.List;

import jakarta.persistence.EntityManager;
import jakarta.persistence.TypedQuery;

import tools.descartes.teastore.persistence.repository.AbstractPersistenceRepository;
import tools.descartes.teastore.entities.User;

/**
 * Repository that performs transactional CRUD operations for users on database.
 * @author Joakim von Kistowski
 *
 */
public final class UserRepository extends AbstractPersistenceRepository<User, PersistenceUser> {

	/**
	 * Singleton for the ProductRepository.
	 */
	public static final UserRepository REPOSITORY = new UserRepository();
	
	//Private constructor.
	private UserRepository() {
		
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public long createEntity(User entity) {
		PersistenceUser user = new PersistenceUser();
		user.setUserName(entity.getUserName());
		user.setPassword(entity.getPassword());
		user.setRealName(entity.getRealName());
		user.setEmail(entity.getEmail());
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceUser existing = getUserByName(entity.getUserName());
	        if (existing == null) {
	        	em.persist(user);
	        } else {
	        	user.setId(-1L);
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
	    return user.getId();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean updateEntity(long id, User entity) {
		boolean found = false;
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceUser user = em.find(getEntityClass(), id);
	        if (user != null) {
	        	user.setUserName(entity.getUserName());
	    		user.setPassword(entity.getPassword());
	    		user.setRealName(entity.getRealName());
	    		user.setEmail(entity.getEmail());
	        	found = true;
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
	    return found;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long getId(PersistenceUser v) {
		return v.getId();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected Class<PersistenceUser> getEntityClass() {
		return PersistenceUser.class;
	}
	
	/**
	 * Return the user with the name.
	 * @param userName The user name.
	 * @return User or null if the user doesn't exist.
	 */
	public PersistenceUser getUserByName(String userName) {
		EntityManager em = getEM();
		TypedQuery<PersistenceUser> allMatchesQuery =
				em.createQuery(""SELECT u FROM "" + getEntityClass().getName()
						+ "" u WHERE u.userName = :name"", getEntityClass())
				.setMaxResults(1);
		allMatchesQuery.setParameter(""name"", userName);
		List<PersistenceUser> entities = allMatchesQuery.getResultList();
		if (entities == null || entities.isEmpty()) {
			return null;
		}
		return entities.get(0);
	}
	
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/domain/CategoryRepository.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.domain;

import jakarta.persistence.EntityManager;

import tools.descartes.teastore.persistence.repository.AbstractPersistenceRepository;
import tools.descartes.teastore.entities.Category;

/**
 * Repository that performs transactional CRUD operations cor Categories on database.
 * @author Joakim von Kistowski
 *
 */
public final class CategoryRepository extends AbstractPersistenceRepository<Category, PersistenceCategory> {

	/**
	 * Singleton for the CategoryRepository.
	 */
	public static final CategoryRepository REPOSITORY = new CategoryRepository();
	
	//Private constructor.
	private CategoryRepository() {
		
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public long createEntity(Category entity) {
		PersistenceCategory category = new PersistenceCategory();
		category.setName(entity.getName());
		category.setDescription(entity.getDescription());
		
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
        	em.persist(category);
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
	    return category.getId();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean updateEntity(long id, Category entity) {
		boolean found = false;
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceCategory category = em.find(getEntityClass(), id);
	        if (category != null) {
	        	category.setName(entity.getName());
	        	category.setDescription(entity.getDescription());
	        	found = true;
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
	    return found;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long getId(PersistenceCategory v) {
		return v.getId();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected Class<PersistenceCategory> getEntityClass() {
		return PersistenceCategory.class;
	}
	
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/domain/PersistenceOrder.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.domain;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityManager;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.PostRemove;
import jakarta.persistence.PreRemove;

import tools.descartes.teastore.persistence.repository.CacheManager;
import tools.descartes.teastore.entities.Order;

/**
 * Entity for persisting Orders in database.
 * @author Joakim von Kistowski
 *
 */
@Entity
public class PersistenceOrder extends Order {

	@Id
	@GeneratedValue
	private long id;
	private LocalDateTime orderTime;
	
	private long totalPriceInCents;
	private String addressName;
	private String address1;
	private String address2;
	
	private String creditCardCompany;
	private String creditCardNumber;
	private LocalDate creditCardExpiryLocalDate;
	
	@OneToMany(mappedBy = ""order"", cascade = {CascadeType.ALL})
	private List<PersistenceOrderItem> orderItems;
	
	@ManyToOne(optional = false)
	private PersistenceUser user;

	/**
	 * Create a new and empty order.
	 */
	PersistenceOrder() {
		super();
		orderItems = new ArrayList<PersistenceOrderItem>();
		orderTime = LocalDateTime.now();
		creditCardExpiryLocalDate = LocalDate.now();
	}
	
	/**
	 * Delete orders and order items.
	 */
	@PreRemove
	private void deleteOrders() {
		EntityManager em = OrderRepository.REPOSITORY.getEMF().createEntityManager();
		try {
			em.getTransaction().begin();
			em.createQuery(""DELETE FROM PersistenceOrderItem oi WHERE oi.order = :order"")
			.setParameter(""order"", this).executeUpdate();
			em.getTransaction().commit();
		} finally {
	        em.close();
	    }
	}
	
	/**
	 * Clear users and order items from cache post remove.
	 */
	@PostRemove
	private void clearCaches() {
		CacheManager.MANAGER.clearCache(PersistenceUser.class);
		CacheManager.MANAGER.clearCache(PersistenceOrderItem.class);
		CacheManager.MANAGER.clearRemoteCache(PersistenceOrder.class);
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getId() {
		return id;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setId(long id) {
		this.id = id;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getUserId() {
		return user.getId();
	}

	/**
	 * Unsupported operation in persistence.
	 * @param userId unsupported parameter.
	 */
	@Override
	public void setUserId(long userId) {
		//unsupported operation
	}

	/**
	 * Get the order's time.
	 * @return The time.
	 */
	public LocalDateTime getOrderTime() {
		return orderTime;
	}

	/**
	 * Sets the order's time.
	 * @param orderTime The time to set.
	 */
	public void setOrderTime(LocalDateTime orderTime) {
		this.orderTime = orderTime;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getTime() {
		return getOrderTime().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setTime(String time) {
		if (time != null && !time.isEmpty()) {
			setOrderTime(LocalDateTime.parse(time, DateTimeFormatter.ISO_LOCAL_DATE_TIME));
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getTotalPriceInCents() {
		return totalPriceInCents;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setTotalPriceInCents(long totalPriceInCents) {
		this.totalPriceInCents = totalPriceInCents;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getAddressName() {
		return addressName;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setAddressName(String addressName) {
		this.addressName = addressName;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getAddress1() {
		return address1;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setAddress1(String address1) {
		this.address1 = address1;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getAddress2() {
		return address2;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setAddress2(String address2) {
		this.address2 = address2;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getCreditCardCompany() {
		return creditCardCompany;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setCreditCardCompany(String creditCardCompany) {
		this.creditCardCompany = creditCardCompany;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getCreditCardNumber() {
		return creditCardNumber;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setCreditCardNumber(String creditCardNumber) {
		this.creditCardNumber = creditCardNumber;
	}

	/**
	 * Get the credit card expiry date.
	 * @return The date.
	 */
	public LocalDate getCreditCardExpiryLocalDate() {
		return creditCardExpiryLocalDate;
	}

	/**
	 * Set the credit card expiry date.
	 * @param creditCardExpiryLocalDate the date to set.
	 */
	public void setCreditCardExpiryLocalDate(LocalDate creditCardExpiryLocalDate) {
		this.creditCardExpiryLocalDate = creditCardExpiryLocalDate;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getCreditCardExpiryDate() {
		return getCreditCardExpiryLocalDate().format(DateTimeFormatter.ISO_LOCAL_DATE);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setCreditCardExpiryDate(String creditCardExpiryDate) {
		if (creditCardExpiryDate != null && !creditCardExpiryDate.isEmpty()) {
			setCreditCardExpiryLocalDate(LocalDate.parse(creditCardExpiryDate, DateTimeFormatter.ISO_LOCAL_DATE));
		}
	}

	/**
	 * Get the order items for the order.
	 * @return The order items.
	 */
	public List<PersistenceOrderItem> getOrderItems() {
		return orderItems;
	}

	/**
	 * Set the order items.
	 * @param orderItems The order items.
	 */
	public void setOrderItems(List<PersistenceOrderItem> orderItems) {
		this.orderItems = orderItems;
	}

	/**
	 * Get the ordering user.
	 * @return The user.
	 */
	public PersistenceUser getUser() {
		return user;
	}

	/**
	 * Set the ordering user.
	 * @param user The user.
	 */
	public void setUser(PersistenceUser user) {
		this.user = user;
	}
	
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/domain/PersistenceUser.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.domain;

import java.util.ArrayList;
import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityManager;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.PostRemove;
import jakarta.persistence.PreRemove;

import tools.descartes.teastore.persistence.repository.CacheManager;
import tools.descartes.teastore.entities.User;

/**
 * Persistence entity for user.
 * @author Joakim von Kistowski
 *
 */
@Entity
public class PersistenceUser extends User {

	@Id
	@GeneratedValue
	private long id;
	
	private String userName;
	
	private String password;
	private String realName;
	private String email;
	
	@OneToMany(mappedBy = ""user"", cascade = {CascadeType.ALL})
	private List<PersistenceOrder> orders;
	
	/**
	 * Delete orders and order items.
	 */
	@PreRemove
	private void deleteOrders() {
		EntityManager em = UserRepository.REPOSITORY.getEMF().createEntityManager();
		try {
			em.getTransaction().begin();
			em.createQuery(""DELETE FROM PersistenceOrderItem oi WHERE oi.order.user = :user"")
			.setParameter(""user"", this).executeUpdate();
			em.createQuery(""DELETE FROM PersistenceOrder o WHERE o.user = :user"")
			.setParameter(""user"", this).executeUpdate();
			em.getTransaction().commit();
		} finally {
	        em.close();
	    }
	}
	
	/**
	 * Clear users and order items from cache post remove.
	 */
	@PostRemove
	private void clearCaches() {
		CacheManager.MANAGER.clearCache(PersistenceOrder.class);
		CacheManager.MANAGER.clearRemoteCache(PersistenceUser.class);
	}
	
	/**
	 * Create a new and empty user.
	 */
	PersistenceUser() {
		super();
		orders = new ArrayList<>();
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getId() {
		return id;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setId(long id) {
		this.id = id;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getUserName() {
		return userName;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setUserName(String userName) {
		this.userName = userName;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getPassword() {
		return password;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setPassword(String password) {
		this.password = password;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getRealName() {
		return realName;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setRealName(String realName) {
		this.realName = realName;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getEmail() {
		return email;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setEmail(String email) {
		this.email = email;
	}

	/**
	 * Get the user's orders.
	 * @return the orders.
	 */
	public List<PersistenceOrder> getOrders() {
		return orders;
	}	
}"
services/tools.descartes.teastore.persistence/src/main/java/tools/descartes/teastore/persistence/domain/OrderItemRepository.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.domain;

import java.util.ArrayList;
import java.util.List;

import jakarta.persistence.EntityManager;
import jakarta.persistence.TypedQuery;

import tools.descartes.teastore.persistence.repository.AbstractPersistenceRepository;
import tools.descartes.teastore.entities.OrderItem;

/**
 * Repository that performs transactional CRUD operations for order items on database.
 * @author Joakim von Kistowski
 *
 */
public final class OrderItemRepository extends AbstractPersistenceRepository<OrderItem, PersistenceOrderItem> {

	/**
	 * Singleton for the ProductRepository.
	 */
	public static final OrderItemRepository REPOSITORY = new OrderItemRepository();
	
	//Private constructor.
	private OrderItemRepository() {
		
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public long createEntity(OrderItem entity) {
		PersistenceOrderItem item = new PersistenceOrderItem();
		item.setQuantity(entity.getQuantity());
		item.setUnitPriceInCents(entity.getUnitPriceInCents());
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceProduct prod = em.find(PersistenceProduct.class, entity.getProductId());
	        PersistenceOrder order = em.find(PersistenceOrder.class, entity.getOrderId());
	        if (prod != null && order != null) {
	        	item.setProduct(prod);
	        	item.setOrder(order);
	        	em.persist(item);
	        } else {
	        	item.setId(-1L);
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
	    return item.getId();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean updateEntity(long id, OrderItem entity) {
		boolean found = false;
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceOrderItem item = em.find(getEntityClass(), id);
	        if (item != null) {
	        	item.setQuantity(entity.getQuantity());
	    		item.setUnitPriceInCents(entity.getUnitPriceInCents());
	        	found = true;
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
	    return found;
	}
	
	/**
	 * Gets all order items for the given productId.
	 * @param productId The id of the product ordered.
	 * @param start The index of the first orderItem to return. Negative value to start at the beginning.
	 * @param limit The maximum number of orderItem to return. Negative value to return all.
	 * @return List of order items with the specified product.
	 */
	public List<PersistenceOrderItem> getAllEntitiesWithProduct(long productId, int start, int limit) {
		List<PersistenceOrderItem> entities = null;
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceProduct prod = em.find(PersistenceProduct.class, productId);
	        if (prod != null) {
	        	TypedQuery<PersistenceOrderItem> allMatchesQuery =
	        			em.createQuery(""SELECT u FROM "" + getEntityClass().getName()
	        					+ "" u WHERE u.product = :prod"", getEntityClass());
	        	allMatchesQuery.setParameter(""prod"", prod);
	    		entities = resultsWithStartAndLimit(em, allMatchesQuery, start, limit);
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
		if (entities == null) {
			return new ArrayList<PersistenceOrderItem>();
		}
		return entities;
	}

	/**
	 * Gets all order items in the specified order.
	 * @param orderId The id of the order.
	 * @param start The index of the first orderItem to return. Negative value to start at the beginning.
	 * @param limit The maximum number of orderItem to return. Negative value to return all.
	 * @return List of order items in the specified order.
	 */
	public List<PersistenceOrderItem> getAllEntitiesWithOrder(long orderId, int start, int limit) {
		List<PersistenceOrderItem> entities = null;
		EntityManager em = getEM();
	    try {
	        em.getTransaction().begin();
	        PersistenceOrder order = em.find(PersistenceOrder.class, orderId);
	        if (order != null) {
	        	TypedQuery<PersistenceOrderItem> allMatchesQuery =
	        			em.createQuery(""SELECT u FROM "" + getEntityClass().getName()
	        					+ "" u WHERE u.order = :order"", getEntityClass());
	        	allMatchesQuery.setParameter(""order"", order);
	        	entities = resultsWithStartAndLimit(em, allMatchesQuery, start, limit);
	        }
	        em.getTransaction().commit();
	    } finally {
	        em.close();
	    }
		if (entities == null) {
			return new ArrayList<PersistenceOrderItem>();
		}
		return entities;
	}
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long getId(PersistenceOrderItem v) {
		return v.getId();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected Class<PersistenceOrderItem> getEntityClass() {
		return PersistenceOrderItem.class;
	}
	
}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/LoginServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.rest.LoadBalancedCRUDOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedImageOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedStoreOperations;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.ImageSizePreset;

/**
 * Servlet implementation for the web view of ""Login"".
 * 
 * @author Andre Bauer
 */
@WebServlet(""/login"")
public class LoginServlet extends AbstractUIServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * @see HttpServlet#HttpServlet()
	 */
	public LoginServlet() {
		super();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException, LoadBalancerTimeoutException {
		checkforCookie(request, response);
		request.setAttribute(""CategoryList"",
				LoadBalancedCRUDOperations.getEntities(Service.PERSISTENCE, ""categories"", Category.class, -1, -1));
		request.setAttribute(""storeIcon"",
				LoadBalancedImageOperations.getWebImage(""icon"", ImageSizePreset.ICON.getSize()));
		request.setAttribute(""title"", ""TeaStore Login"");
		request.setAttribute(""login"", LoadBalancedStoreOperations.isLoggedIn(getSessionBlob(request)));

		request.setAttribute(""referer"", request.getHeader(""Referer""));

		request.getRequestDispatcher(""WEB-INF/pages/login.jsp"").forward(request, response);
	}

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/IndexServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.rest.LoadBalancedCRUDOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedImageOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedStoreOperations;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.ImageSizePreset;

/**
 * Servlet implementation for the web view of ""Index"".
 * 
 * @author Andre Bauer
 */
@WebServlet(""/index"")
public class IndexServlet extends AbstractUIServlet {

	private static final long serialVersionUID = 1L;

	/**
	 * @see HttpServlet#HttpServlet()
	 */
	public IndexServlet() {
		super();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException, LoadBalancerTimeoutException {
		checkforCookie(request, response);
		request.setAttribute(""CategoryList"",
				LoadBalancedCRUDOperations.getEntities(Service.PERSISTENCE, ""categories"", Category.class, -1, -1));
		request.setAttribute(""title"", ""TeaStore Home"");
		request.setAttribute(""login"", LoadBalancedStoreOperations.isLoggedIn(getSessionBlob(request)));
		request.setAttribute(""storeIcon"",
				LoadBalancedImageOperations.getWebImage(""icon"", ImageSizePreset.ICON.getSize()));

		request.getRequestDispatcher(""WEB-INF/pages/index.jsp"").forward(request, response);
	}

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/LoginActionServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.rest.LoadBalancedStoreOperations;
import tools.descartes.teastore.entities.message.SessionBlob;

/**
 * Servlet for handling the login actions.
 * 
 * @author Andre Bauer
 */
@WebServlet(""/loginAction"")
public class LoginActionServlet extends AbstractUIServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * @see HttpServlet#HttpServlet()
	 */
	public LoginActionServlet() {
		super();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException, LoadBalancerTimeoutException {

		redirect(""/"", response);

	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void handlePOSTRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException, LoadBalancerTimeoutException {
		boolean login = false;
		if (request.getParameter(""username"") != null && request.getParameter(""password"") != null) {
			SessionBlob blob = LoadBalancedStoreOperations.login(getSessionBlob(request),
					request.getParameter(""username""), request.getParameter(""password""));
			login = (blob != null && blob.getSID() != null);

			if (login) {
				saveSessionBlob(blob, response);
				if (request.getParameter(""referer"") != null
						&& request.getParameter(""referer"").contains(""tools.descartes.teastore.webui/cart"")) {
					redirect(""/cart"", response, MESSAGECOOKIE, SUCESSLOGIN);
				} else {
					redirect(""/"", response, MESSAGECOOKIE, SUCESSLOGIN);
				}

			} else {
				redirect(""/login"", response, ERRORMESSAGECOOKIE, WRONGCREDENTIALS);
			}

		} else if (request.getParameter(""logout"") != null) {
			SessionBlob blob = LoadBalancedStoreOperations.logout(getSessionBlob(request));
			saveSessionBlob(blob, response);
			destroySessionBlob(blob, response);
			redirect(""/"", response, MESSAGECOOKIE, SUCESSLOGOUT);

		} else {
			handleGETRequest(request, response);
		}

	}

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/DataBaseActionServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import java.util.List;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.rest.LoadBalancedImageOperations;

/**
 * Servlet implementation for handling the data base action.
 * @author Andre
 */
@WebServlet(""/dataBaseAction"")
public class DataBaseActionServlet extends AbstractUIServlet {
	private static final long serialVersionUID = 1L;
	private static final String[] PARAMETERS = new String[] { ""categories"", ""products"", ""users"", ""orders"" };
	private static final Logger LOG = LoggerFactory.getLogger(DataBaseActionServlet.class);

	/**
	 * @see HttpServlet#HttpServlet()
	 */
	public DataBaseActionServlet() {
		super();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException, LoadBalancerTimeoutException {

		if (request.getParameter(""confirm"") != null) {

			String[] infos = extractOrderInformation(request);
			if (infos.length == 0) {
				redirect(""/database"", response);
			} else {
				destroySessionBlob(getSessionBlob(request), response);
				Response resp = ServiceLoadBalancer.loadBalanceRESTOperation(Service.PERSISTENCE, ""generatedb"",
						String.class,
						client -> client.getService().path(client.getApplicationURI()).path(client.getEndpointURI())
								.queryParam(PARAMETERS[0], infos[0]).queryParam(PARAMETERS[1], infos[1])
								.queryParam(PARAMETERS[2], infos[2]).queryParam(PARAMETERS[3], infos[3])
								.request(MediaType.TEXT_PLAIN).get());
				//buffer entity to release connections
				resp.bufferEntity();
				if (resp.getStatus() == 200) {
					LOG.info(""DB is re-generating."");
				}

				// Regenerate images
				List<Integer> status = LoadBalancedImageOperations.regenerateImages();
				status.stream().filter(r -> r != 200).forEach(
						r -> LOG.warn(""An image provider service responded with "" + r + "" when regenerating images.""));
				// Retrain recommender
				List<Response> recResp = ServiceLoadBalancer.multicastRESTOperation(Service.RECOMMENDER, ""train"",
						String.class,
						client -> client.getEndpointTarget().path(""async"").request(MediaType.TEXT_PLAIN).get());
				recResp.stream().filter(r -> r.getStatus() != 200).forEach(
						r -> LOG.warn(""A recommender service responded with "" + r.getStatus() + "" when retraining.""));
				//buffer entity to release connections
				recResp.stream().forEach(r -> r.bufferEntity());
				redirect(""/status"", response);
			}

		} else {
			redirect(""/"", response);
		}
	}

	/**
	 * Extracts the information from the input fields.
	 * 
	 * @param request
	 * @return String[] with the info for the database generation
	 */
	private String[] extractOrderInformation(HttpServletRequest request) {

		String[] infos = new String[PARAMETERS.length];
		for (int i = 0; i < PARAMETERS.length; i++) {
			if (request.getParameter(PARAMETERS[i]) == null) {
				return new String[0];
			} else {
				infos[i] = request.getParameter(PARAMETERS[i]);
			}
		}
		return infos;
	}

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/AbstractUIServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.ArrayList;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.util.NotFoundException;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.message.SessionBlob;

/**
 * Abstract servlet for the webUI.
 * 
 * @author Andre Bauer
 * @author Simon Eismann
 */
public abstract class AbstractUIServlet extends HttpServlet {

	private static final long serialVersionUID = 1L;
	/**
	 * Text for message cookie.
	 */
	protected static final String MESSAGECOOKIE = ""teastoreMessageCookie"";
	/**
	 * Text for error message cookie.
	 */
	protected static final String ERRORMESSAGECOOKIE = ""teastoreErrorMessageCookie"";
	/**
	 * Text for successful login. 
	 */
	protected static final String SUCESSLOGIN = ""You are logged in!"";
	/**
	 * Text for logout.
	 */
	protected static final String SUCESSLOGOUT = ""You are logged out!"";
	/**
	 * Text for wrong credentials.
	 */
	protected static final String WRONGCREDENTIALS = ""You used wrong credentials!"";
	/**
	 * Text for number products cookie.
	 */
	protected static final String PRODUCTCOOKIE = ""teastorenumberProductsCookie"";
	/**
	 * Text for session blob.
	 */
	protected static final String BLOB = ""sessionBlob"";
	/**
	 * Text for confirmed order.
	 */
	protected static final String ORDERCONFIRMED = ""Your order is confirmed!"";
	/**
	 * Text for updated cart.
	 */
	protected static final String CARTUPDATED = ""Your cart is updated!"";
	/**
	 * Text for added product.
	 */
	protected static final String ADDPRODUCT = ""Product %s is added to cart!"";
	/**
	 * Text for removed product.
	 */
	protected static final String REMOVEPRODUCT = ""Product %s is removed from cart!"";

	/**
	 * Try to read the SessionBlob from the cookie. If no SessioBlob exist, a new
	 * SessionBlob is created. If the SessionBlob is corrupted, an
	 * IlligalStateException is thrown.
	 * 
	 * @param request servlet request
	 * @return SessionBlob
	 */
	protected SessionBlob getSessionBlob(HttpServletRequest request) {
		if (request.getCookies() != null) {
			for (Cookie cook : request.getCookies()) {
				if (cook.getName().equals(BLOB)) {
					ObjectMapper o = new ObjectMapper();
					try {
						SessionBlob blob = o.readValue(URLDecoder.decode(cook.getValue(), ""UTF-8""), SessionBlob.class);
						if (blob != null) {
						return blob;
						} 
					} catch (IOException e) {
						throw new IllegalStateException(""Cookie corrupted!"");
					}
				}
			}
		}
		return new SessionBlob();
	}

	/**
	 * Saves the SessionBlob as Cookie. Throws an IllegalStateException if the
	 * SessionBlob is corrupted.
	 * 
	 * @param blob session blob
	 * @param response servlet response
	 */
	protected void saveSessionBlob(SessionBlob blob, HttpServletResponse response) {
		ObjectMapper o = new ObjectMapper();
		try {
			Cookie cookie = new Cookie(BLOB, URLEncoder.encode(o.writeValueAsString(blob), ""UTF-8""));
			response.addCookie(cookie);
		} catch (JsonProcessingException | UnsupportedEncodingException e) {
			throw new IllegalStateException(""Could not save blob!"");
		}
	}

	/**
	 * Destroys the SessionBlob. Throws an IllegalStateException if the SessionBlob
	 * is corrupted.
	 * 
	 * @param blob session blob
	 * @param response servlet response
	 */
	protected void destroySessionBlob(SessionBlob blob, HttpServletResponse response) {
		ObjectMapper o = new ObjectMapper();
		try {
			Cookie cookie = new Cookie(BLOB, URLEncoder.encode(o.writeValueAsString(blob), ""UTF-8""));
			cookie.setMaxAge(0);
			response.addCookie(cookie);
		} catch (JsonProcessingException | UnsupportedEncodingException e) {
			throw new IllegalStateException(""Could not destroy blob!"");
		}
	}

	/**
	 * Redirects to the target and creates an Cookie.
	 * 
	 * @param target webtarget
	 * @param response servlet response
	 * @param cookiename name of cookie
	 * @param value cookie value
	 * @throws IOException cookie exception
	 */
	protected void redirect(String target, HttpServletResponse response, String cookiename, String value)
			throws IOException {
		if (!cookiename.equals("""")) {
			Cookie cookie = new Cookie(cookiename, value.replace("" "", ""_""));
			response.addCookie(cookie);
		}

		redirect(target, response);
	}

	/**
	 * Redirects to the target.
	 * 
	 * @param target webtarget
	 * @param response servlet response
	 * @throws IOException redirect exception
	 */
	protected void redirect(String target, HttpServletResponse response) throws IOException {
		if (!target.startsWith(""/"")) {
			target = ""/"" + target;
		}
		response.sendRedirect(getServletContext().getContextPath() + target);

	}

	/**
	 * Checks if specific cookies exist and save their value as message.
	 * 
	 * @param request servlet request
	 * @param response servlet response
	 */
	protected void checkforCookie(HttpServletRequest request, HttpServletResponse response) {
		if (request.getCookies() != null) {
			for (Cookie cook : request.getCookies()) {
				if (cook.getName().equals(MESSAGECOOKIE)) {
					request.setAttribute(""message"", cook.getValue().replaceAll(""_"", "" ""));
					cook.setMaxAge(0);
					response.addCookie(cook);
				} else if (cook.getName().equals(PRODUCTCOOKIE)) {
					request.setAttribute(""numberProducts"", cook.getValue());
				} else if (cook.getName().equals(ERRORMESSAGECOOKIE)) {
					request.setAttribute(""errormessage"", cook.getValue().replaceAll(""_"", "" ""));
					cook.setMaxAge(0);
					response.addCookie(cook);
				}
			}
		}
	}

	/**
   * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse
   *      response)
	 * @param request servlet request
	 * @param response servlet response
	 * @throws IOException external call exception
	 * @throws ServletException exception servlet exception     
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			handleGETRequest(request, response);
		} catch (LoadBalancerTimeoutException e) {
			serveTimoutResponse(request, response, e.getTargetService());
		} catch (NotFoundException e) {
			serveNotFoundException(request, response, e);
		} catch (Exception e) {
			serveExceptionResponse(request, response, e);
		}

	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse
	 *      response)
   * @param request servlet request
   * @param response servlet response
   * @throws IOException external call exception
   * @throws ServletException exception servlet exception    
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {

			handlePOSTRequest(request, response);
		} catch (LoadBalancerTimeoutException e) {
			serveTimoutResponse(request, response, e.getTargetService());
		} catch (NotFoundException e) {
			serveNotFoundException(request, response, e);
		} catch (Exception e) {
			serveExceptionResponse(request, response, e);
		}
	}

	/**
	 * Handles a http POST request internally.
	 * 
	 * @param request
	 *            The request.
	 * @param response
	 *            The response to write to.
	 * @throws ServletException
	 *             ServletException on error.
	 * @throws IOException
	 *             IOException on error.
	 * @throws LoadBalancerTimeoutException
	 *             Exception on timeouts and load balancer errors.
	 */
	protected void handlePOSTRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException, LoadBalancerTimeoutException {
		handleGETRequest(request, response);
	}

	/**
	 * Handles a http GET request internally.
	 * 
	 * @param request
	 *            The request.
	 * @param response
	 *            The response to write to.
	 * @throws ServletException
	 *             ServletException on error.
	 * @throws IOException
	 *             IOException on error.
	 * @throws LoadBalancerTimeoutException
	 *             Exception on timeouts and load balancer errors.
	 */
	protected abstract void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException, LoadBalancerTimeoutException;

	private void serveTimoutResponse(HttpServletRequest request, HttpServletResponse response, Service service)
			throws ServletException, IOException {
		response.setStatus(408);
		request.setAttribute(""CategoryList"", new ArrayList<Category>());
		request.setAttribute(""storeIcon"", """");
		request.setAttribute(""errorImage"", """");
		request.setAttribute(""title"", ""TeaStore Timeout"");
		request.setAttribute(""messagetitle"", ""408: Timout waiting for Service: "" + service.getServiceName());
		request.setAttribute(""messageparagraph"", ""WebUI got a timeout waiting for service \"""" + service.getServiceName()
				+ ""\"" to respond. Note the that service may itself have been waiting for another service."");
		request.setAttribute(""login"", false);
		request.getRequestDispatcher(""WEB-INF/pages/error.jsp"").forward(request, response);
	}

	private void serveExceptionResponse(HttpServletRequest request, HttpServletResponse response, Exception e)
			throws ServletException, IOException {
		StringWriter sw = new StringWriter();
		e.printStackTrace(new PrintWriter(sw));
		String exceptionAsString = sw.toString();
		response.setStatus(500);
		request.setAttribute(""CategoryList"", new ArrayList<Category>());
		request.setAttribute(""storeIcon"", """");
		request.setAttribute(""errorImage"", """");
		request.setAttribute(""title"", ""TeaStore Timeout"");
		request.setAttribute(""messagetitle"", ""500: Internal Exception: "" + e.getMessage());
		request.setAttribute(""messageparagraph"", exceptionAsString);
		request.setAttribute(""login"", false);
		request.getRequestDispatcher(""WEB-INF/pages/error.jsp"").forward(request, response);
	}

	private void serveNotFoundException(HttpServletRequest request, HttpServletResponse response, Exception e)
			throws ServletException, IOException {
		StringWriter sw = new StringWriter();
		e.printStackTrace(new PrintWriter(sw));
		String exceptionAsString = sw.toString();
		response.setStatus(404);
		request.setAttribute(""CategoryList"", new ArrayList<Category>());
		request.setAttribute(""storeIcon"", """");
		request.setAttribute(""errorImage"", """");
		request.setAttribute(""title"", ""TeaStore Timeout"");
		request.setAttribute(""messagetitle"", ""404: Not Found Exception: "" + e.getMessage());
		request.setAttribute(""messageparagraph"", exceptionAsString);
		request.setAttribute(""login"", false);
		request.getRequestDispatcher(""WEB-INF/pages/error.jsp"").forward(request, response);
	}
}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/CartActionServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import java.time.YearMonth;
import java.time.format.DateTimeFormatter;
import java.util.List;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.rest.LoadBalancedStoreOperations;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.message.SessionBlob;

/**
 * Servlet for handling all cart actions.
 * 
 * @author Andre Bauer
 */
@WebServlet(""/cartAction"")
public class CartActionServlet extends AbstractUIServlet {
	private static final long serialVersionUID = 1L;
	private static final DateTimeFormatter DTF = DateTimeFormatter.ofPattern(""MM/yyyy"");

	/**
	 * @see HttpServlet#HttpServlet()
	 */
	public CartActionServlet() {
		super();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException, LoadBalancerTimeoutException {
		for (Object paramo : request.getParameterMap().keySet()) {
			String param = (String) paramo;
			if (param.contains(""addToCart"")) {
				long productID = Long.parseLong(request.getParameter(""productid""));
				SessionBlob blob = LoadBalancedStoreOperations.addProductToCart(getSessionBlob(request), productID);
				saveSessionBlob(blob, response);
				redirect(""/cart"", response, MESSAGECOOKIE, String.format(ADDPRODUCT, productID));
				break;
			} else if (param.contains(""removeProduct"")) {
				long productID = Long.parseLong(param.substring(""removeProduct_"".length()));
				SessionBlob blob = LoadBalancedStoreOperations.removeProductFromCart(getSessionBlob(request),
						productID);
				saveSessionBlob(blob, response);
				redirect(""/cart"", response, MESSAGECOOKIE, String.format(REMOVEPRODUCT, productID));
				break;
			} else if (param.contains(""updateCartQuantities"")) {
				List<OrderItem> orderItems = getSessionBlob(request).getOrderItems();
				updateOrder(request, orderItems, response);
				redirect(""/cart"", response, MESSAGECOOKIE, CARTUPDATED);
				break;
			} else if (param.contains(""proceedtoCheckout"")) {
				if (LoadBalancedStoreOperations.isLoggedIn(getSessionBlob(request))) {
					List<OrderItem> orderItems = getSessionBlob(request).getOrderItems();
					updateOrder(request, orderItems, response);
					redirect(""/order"", response);
				} else {
					redirect(""/login"", response);
				}
				break;
			} else if (param.contains(""confirm"")) {
				confirmOrder(request, response);
				break;
			}

		}

	}

	/**
	 * Handles the confirm order action. Saves the order into the sessionBlob
	 * 
	 * @param request
	 * @param response
	 * @throws IOException
	 */
	private void confirmOrder(HttpServletRequest request, HttpServletResponse response) throws IOException {

		String[] infos = extractOrderInformation(request);
		if (infos.length == 0) {
			redirect(""/order"", response);
		} else {

			SessionBlob blob = getSessionBlob(request);
			long price = 0;
			for (OrderItem item : blob.getOrderItems()) {
				price += item.getQuantity() * item.getUnitPriceInCents();
			}
			blob = LoadBalancedStoreOperations.placeOrder(getSessionBlob(request), infos[0] + "" "" + infos[1], infos[2],
					infos[3], infos[4],
					YearMonth.parse(infos[6], DTF).atDay(1).format(DateTimeFormatter.ISO_LOCAL_DATE), price, infos[5]);
			saveSessionBlob(blob, response);
			redirect(""/"", response, MESSAGECOOKIE, ORDERCONFIRMED);
		}

	}

	/**
	 * Extracts the user information from the input fields.
	 * 
	 * @param request
	 * @return String[] with user infos.
	 * 
	 */
	private String[] extractOrderInformation(HttpServletRequest request) {

		String[] parameters = new String[] { ""firstname"", ""lastname"", ""address1"", ""address2"", ""cardtype"", ""cardnumber"",
				""expirydate"" };
		String[] infos = new String[parameters.length];
		for (int i = 0; i < parameters.length; i++) {
			if (request.getParameter(parameters[i]) == null) {
				return new String[0];
			} else {
				infos[i] = request.getParameter(parameters[i]);
			}
		}
		return infos;
	}

	/**
	 * Updates the items in the cart.
	 * 
	 * @param request
	 * @param orderItems
	 * @param response
	 */
	private void updateOrder(HttpServletRequest request, List<OrderItem> orderItems, HttpServletResponse response) {
		SessionBlob blob = getSessionBlob(request);
		for (OrderItem orderItem : orderItems) {
			if (request.getParameter(""orderitem_"" + orderItem.getProductId()) != null) {
				blob = LoadBalancedStoreOperations.updateQuantity(blob, orderItem.getProductId(),
						Integer.parseInt(request.getParameter(""orderitem_"" + orderItem.getProductId())));
			}
		}
		saveSessionBlob(blob, response);
	}

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/DataBaseServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.rest.LoadBalancedImageOperations;
import tools.descartes.teastore.entities.ImageSizePreset;

/**
 * Servlet implementation for the web view of ""Database"".
 * 
 * @author Andre Bauer
 */
@WebServlet(""/database"")
public class DataBaseServlet extends AbstractUIServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * @see HttpServlet#HttpServlet()
	 */
	public DataBaseServlet() {
		super();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException, LoadBalancerTimeoutException {
		checkforCookie(request, response);
		request.setAttribute(""storeIcon"", 
				LoadBalancedImageOperations.getWebImage(""icon"", ImageSizePreset.ICON.getSize()));
		request.setAttribute(""title"", ""TeaStore Database"");
		request.getRequestDispatcher(""WEB-INF/pages/database.jsp"").forward(request, response);
	}


}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/StatusServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import java.util.List;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.ws.rs.core.MediaType;

import tools.descartes.teastore.registryclient.RegistryClient;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.rest.LoadBalancedImageOperations;
import tools.descartes.teastore.entities.ImageSizePreset;

/**
 * Servlet to show database and other service status.
 *
 * @author Joakim von Kistowski
 */
@WebServlet(""/status"")
public class StatusServlet extends AbstractUIServlet {
  private static final long serialVersionUID = 1L;

  /**
   * @see HttpServlet#HttpServlet()
   */
  public StatusServlet() {
    super();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException, LoadBalancerTimeoutException {
    checkforCookie(request, response);
    String iconImage = null;
    try {
      iconImage = LoadBalancedImageOperations.getWebImage(""icon"", ImageSizePreset.ICON.getSize());
    } catch (NullPointerException e) {

    }
    request.setAttribute(""storeIcon"", iconImage);
    request.setAttribute(""title"", ""TeaStore Status"");

    boolean noregistry = false;
    try {
      request.setAttribute(""webuiservers"",
          RegistryClient.getClient().getServersForService(Service.WEBUI));
      request.setAttribute(""authenticationservers"",
          RegistryClient.getClient().getServersForService(Service.AUTH));
      request.setAttribute(""persistenceservers"",
          RegistryClient.getClient().getServersForService(Service.PERSISTENCE));
      request.setAttribute(""imageservers"",
          RegistryClient.getClient().getServersForService(Service.IMAGE));
      request.setAttribute(""recommenderservers"",
          RegistryClient.getClient().getServersForService(Service.RECOMMENDER));
      request.setAttribute(""dbfinished"", isDatabaseFinished());
      request.setAttribute(""imagefinished"", isImageFinished());
      request.setAttribute(""recommenderfinished"", isRecommenderFinished());
    } catch (NullPointerException e) {
      noregistry = true;
    }
    request.setAttribute(""noregistry"", noregistry);

    request.getRequestDispatcher(""WEB-INF/pages/status.jsp"").forward(request, response);
  }

  /**
   * Checks if Database is created.
   *
   * @return status
   */
  private boolean isDatabaseFinished() {
    String finished = ServiceLoadBalancer.loadBalanceRESTOperation(Service.PERSISTENCE,
        ""generatedb"", String.class, client -> client.getEndpointTarget().path(""finished"")
            .request(MediaType.TEXT_PLAIN).get().readEntity(String.class));
    if (finished != null) {
      return Boolean.parseBoolean(finished);
    }
    return false;
  }

  /**
   * Checks if ImageProvider is ready.
   *
   * @return status
   */
  private boolean isImageFinished() {
    List<String> finishedMessages = ServiceLoadBalancer.multicastRESTOperation(Service.IMAGE,
        ""image"", String.class, client -> client.getEndpointTarget().path(""finished"")
            .request(MediaType.APPLICATION_JSON).get().readEntity(String.class));
    if (finishedMessages != null && !finishedMessages.isEmpty()) {
      boolean finished = true;
      for (String finishedMessage : finishedMessages) {
        finished = finished && Boolean.parseBoolean(finishedMessage);
      }
      return finished;
    }
    return false;
  }

  /**
   * Checks if Recommender has finished training.
   *
   * @return status
   */
  private boolean isRecommenderFinished() {
    List<String> finishedMessages = ServiceLoadBalancer.multicastRESTOperation(Service.RECOMMENDER,
        ""train"", String.class, client -> client.getEndpointTarget().path(""isready"")
            .request(MediaType.TEXT_PLAIN).get().readEntity(String.class));
    if (finishedMessages != null && !finishedMessages.isEmpty()) {
      return finishedMessages.stream().map(b -> Boolean.parseBoolean(b)).reduce(Boolean.TRUE,
          (a, b) -> a && b);
    }
    return false;
  }

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/elhelper/ELHelperUtils.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.webui.servlet.elhelper;

import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * Helper functions to call from JSP.
 * @author Joakim von Kistowski
 *
 */
public final class ELHelperUtils {

	/**
	 * The helper singleton to pass to EL.
	 */
	public static final ELHelperUtils  UTILS = new ELHelperUtils();

	private static final NumberFormat PRICE_FORMAT = new DecimalFormat(""#0.00"");
	
	private ELHelperUtils() {
		
	}
	
	/**
	 * Formats date.
	 * @param isoFormattedDate string containing date
	 * @return pretty formatted date
	 */
	public String formatToPrettyDate(String isoFormattedDate) {
		return LocalDateTime.parse(isoFormattedDate, DateTimeFormatter.ISO_LOCAL_DATE_TIME)
				.format(DateTimeFormatter.ofPattern(""yyyy MM dd - HH:mm:ss""));
	}
	
	/**
	 * Format price.
	 * @param price price to be formatted
	 * @return formatted price
	 */
	public String formatPriceInCents(long price) {
		return ""&#36; "" + PRICE_FORMAT.format((double) price / 100.0);
	}
	
}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/ProductServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import java.util.LinkedList;
import java.util.List;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.rest.LoadBalancedCRUDOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedImageOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedRecommenderOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedStoreOperations;
import tools.descartes.teastore.webui.servlet.elhelper.ELHelperUtils;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.ImageSizePreset;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.message.SessionBlob;

/**
 * Servlet implementation for the web view of ""Product"".
 * 
 * @author Andre Bauer
 */
@WebServlet(""/product"")
public class ProductServlet extends AbstractUIServlet {
  private static final long serialVersionUID = 1L;

  /**
   * @see HttpServlet#HttpServlet()
   */
  public ProductServlet() {
    super();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException, LoadBalancerTimeoutException {
    checkforCookie(request, response);
    if (request.getParameter(""id"") != null) {
      Long id = Long.valueOf(request.getParameter(""id""));
      request.setAttribute(""CategoryList"", LoadBalancedCRUDOperations
          .getEntities(Service.PERSISTENCE, ""categories"", Category.class, -1, -1));
      request.setAttribute(""title"", ""TeaStore Product"");
      SessionBlob blob = getSessionBlob(request);
      request.setAttribute(""login"", LoadBalancedStoreOperations.isLoggedIn(blob));
      Product p = LoadBalancedCRUDOperations.getEntity(Service.PERSISTENCE, ""products"",
          Product.class, id);
      request.setAttribute(""product"", p);

      List<OrderItem> items = new LinkedList<>();
      OrderItem oi = new OrderItem();
      oi.setProductId(id);
      oi.setQuantity(1);
      items.add(oi);
      items.addAll(getSessionBlob(request).getOrderItems());
      List<Long> productIds = LoadBalancedRecommenderOperations.getRecommendations(items,
          getSessionBlob(request).getUID());
      List<Product> ads = new LinkedList<Product>();
      for (Long productId : productIds) {
        ads.add(LoadBalancedCRUDOperations.getEntity(Service.PERSISTENCE, ""products"", Product.class,
            productId));
      }

      if (ads.size() > 3) {
        ads.subList(3, ads.size()).clear();
      }
      request.setAttribute(""Advertisment"", ads);

      request.setAttribute(""productImages"", LoadBalancedImageOperations.getProductImages(ads,
          ImageSizePreset.RECOMMENDATION.getSize()));
      request.setAttribute(""productImage"", LoadBalancedImageOperations.getProductImage(p));
      request.setAttribute(""storeIcon"",
          LoadBalancedImageOperations.getWebImage(""icon"", ImageSizePreset.ICON.getSize()));
      request.setAttribute(""helper"", ELHelperUtils.UTILS);

      request.getRequestDispatcher(""WEB-INF/pages/product.jsp"").forward(request, response);
    } else {
      redirect(""/"", response);
    }
  }

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/ProfileServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.webui.servlet;

import java.io.IOException;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.rest.LoadBalancedCRUDOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedImageOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedStoreOperations;
import tools.descartes.teastore.webui.servlet.elhelper.ELHelperUtils;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.ImageSizePreset;
import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.User;

/**
 * Servlet implementation for the web view of ""Profile"".
 * 
 * @author Andre Bauer
 */
@WebServlet(""/profile"")
public class ProfileServlet extends AbstractUIServlet {

  private static final long serialVersionUID = 1L;

  /**
   * @see HttpServlet#HttpServlet()
   */
  public ProfileServlet() {
    super();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException, LoadBalancerTimeoutException {
    checkforCookie(request, response);
    if (!LoadBalancedStoreOperations.isLoggedIn(getSessionBlob(request))) {
      redirect(""/"", response);
    } else {

      request.setAttribute(""storeIcon"",
          LoadBalancedImageOperations.getWebImage(""icon"", ImageSizePreset.ICON.getSize()));
      request.setAttribute(""CategoryList"", LoadBalancedCRUDOperations
          .getEntities(Service.PERSISTENCE, ""categories"", Category.class, -1, -1));
      request.setAttribute(""title"", ""TeaStore Home"");
      request.setAttribute(""User"", LoadBalancedCRUDOperations.getEntity(Service.PERSISTENCE,
          ""users"", User.class, getSessionBlob(request).getUID()));
      request.setAttribute(""Orders"", LoadBalancedCRUDOperations.getEntities(Service.PERSISTENCE,
          ""orders"", Order.class, ""user"", getSessionBlob(request).getUID(), -1, -1));
      request.setAttribute(""login"",
          LoadBalancedStoreOperations.isLoggedIn(getSessionBlob(request)));
      request.setAttribute(""helper"", ELHelperUtils.UTILS);

      request.getRequestDispatcher(""WEB-INF/pages/profile.jsp"").forward(request, response);
    }
  }

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/OrderServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.rest.LoadBalancedCRUDOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedImageOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedStoreOperations;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.ImageSizePreset;

/**
 * Servlet implementation for the web view of ""Order"".
 * 
 * @author Andre Bauer
 */
@WebServlet(""/order"")
public class OrderServlet extends AbstractUIServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * @see HttpServlet#HttpServlet()
	 */
	public OrderServlet() {
		super();

	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException, LoadBalancerTimeoutException {
		checkforCookie(request, response);
		if (getSessionBlob(request).getOrderItems().size() == 0) {
			redirect(""/"", response);
		} else {
			doPost(request, response);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void handlePOSTRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException, LoadBalancerTimeoutException {
		request.setAttribute(""CategoryList"",
				LoadBalancedCRUDOperations.getEntities(Service.PERSISTENCE, ""categories"", Category.class, -1, -1));
		request.setAttribute(""storeIcon"",
				LoadBalancedImageOperations.getWebImage(""icon"", ImageSizePreset.ICON.getSize()));
		request.setAttribute(""title"", ""TeaStore Order"");
		request.setAttribute(""login"", LoadBalancedStoreOperations.isLoggedIn(getSessionBlob(request)));
		request.getRequestDispatcher(""WEB-INF/pages/order.jsp"").forward(request, response);
	}

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/CategoryServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.rest.HttpWrapper;
import tools.descartes.teastore.registryclient.rest.LoadBalancedCRUDOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedImageOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedStoreOperations;
import tools.descartes.teastore.registryclient.rest.ResponseWrapper;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.ImageSizePreset;
import tools.descartes.teastore.entities.Product;

/**
 * Servlet implementation for the web view of ""Category"".
 * 
 * @author Andre Bauer
 */
@WebServlet(""/category"")
public class CategoryServlet extends AbstractUIServlet {
  private static final long serialVersionUID = 1L;

  private static final int INITIAL_PRODUCT_DISPLAY_COUNT = 20;
  private static final List<Integer> PRODUCT_DISPLAY_COUNT_OPTIONS = Arrays.asList(5, 10, 20, 30,
      50);

  /**
   * @see HttpServlet#HttpServlet()
   */
  public CategoryServlet() {
    super();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException, LoadBalancerTimeoutException {
    if (request.getParameter(""category"") != null) {
      checkforCookie(request, response);
      long categoryID = Long.parseLong(request.getParameter(""category""));

      Category category = LoadBalancedCRUDOperations.getEntity(Service.PERSISTENCE, ""categories"",
          Category.class, categoryID);

      int products = Integer.parseInt(ServiceLoadBalancer.loadBalanceRESTOperation(
          Service.PERSISTENCE, ""products"", Product.class,
          client -> ResponseWrapper.wrap(HttpWrapper
              .wrap(client.getEndpointTarget().path(""count"").path(String.valueOf(categoryID)))
              .get()).readEntity(String.class)));

      int numberProducts = INITIAL_PRODUCT_DISPLAY_COUNT;
      if (request.getAttribute(""numberProducts"") != null) {
        numberProducts = Integer.parseInt(request.getAttribute(""numberProducts"").toString());
      }

      int page = 1;
      if (request.getParameter(""page"") != null) {
        int pagenumber = Integer.parseInt(request.getParameter(""page""));
        int maxpages = (int) Math.ceil(((double) products) / numberProducts);
        if (pagenumber <= maxpages) {
          page = pagenumber;
        }
      }

      ArrayList<String> navigation = createNavigation(products, page, numberProducts);

      List<Product> productlist = LoadBalancedCRUDOperations.getEntities(Service.PERSISTENCE,
          ""products"", Product.class, ""category"", categoryID, (page - 1) * numberProducts,
          numberProducts);
      request.setAttribute(""productImages"",
          LoadBalancedImageOperations.getProductPreviewImages(productlist));
      request.setAttribute(""storeIcon"",
          LoadBalancedImageOperations.getWebImage(""icon"", ImageSizePreset.ICON.getSize()));
      request.setAttribute(""CategoryList"", LoadBalancedCRUDOperations
          .getEntities(Service.PERSISTENCE, ""categories"", Category.class, -1, -1));
      request.setAttribute(""title"", ""TeaStore Categorie "" + category.getName());

      request.setAttribute(""Productslist"", productlist);

      request.setAttribute(""category"", category.getName());
      request.setAttribute(""login"",
          LoadBalancedStoreOperations.isLoggedIn(getSessionBlob(request)));
      request.setAttribute(""categoryID"", categoryID);
      request.setAttribute(""currentnumber"", numberProducts);
      request.setAttribute(""pagination"", navigation);
      request.setAttribute(""pagenumber"", page);
      request.setAttribute(""productdisplaycountoptions"", PRODUCT_DISPLAY_COUNT_OPTIONS);
      request.getRequestDispatcher(""WEB-INF/pages/category.jsp"").forward(request, response);
    } else {
      redirect(""/"", response);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  protected void handlePOSTRequest(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException, LoadBalancerTimeoutException {
    if (request.getParameter(""number"") != null && request.getParameter(""page"") != null
        && request.getParameter(""category"") != null) {
      redirect(
          ""/category?category="" + request.getParameter(""category"") + ""&page=""
              + request.getParameter(""page""),
          response, PRODUCTCOOKIE, request.getParameter(""number""));
    } else {
      handleGETRequest(request, response);
    }
  }

  /**
   * Creates the entries for the pagination.
   * @param products
   * @param page
   * @param numberProducts
   * @return Arraylist<String> pagination
   */
  private ArrayList<String> createNavigation(int products, int page, int numberProducts) {

    ArrayList<String> navigation = new ArrayList<String>();

    int numberpagination = 5;

    int maxpages = (int) Math.ceil(((double) products) / numberProducts);

    if (maxpages < page) {
      return navigation;
    }

    if (page == 1) {
      if (maxpages == 1) {
        navigation.add(""1"");
        return navigation;
      }
      int min = Math.min(maxpages, numberpagination + 1);
      for (int i = 1; i <= min; i++) {
        navigation.add(String.valueOf(i));
      }

    } else {
      navigation.add(""previous"");
      if (page == maxpages) {
        int max = Math.max(maxpages - numberpagination, 1);
        for (int i = max; i <= maxpages; i++) {
          navigation.add(String.valueOf(i));
        }
        return navigation;

      } else {
        int lowerbound = (int) Math.ceil(((double) numberpagination - 1.0) / 2.0);
        int upperbound = (int) Math.floor(((double) numberpagination - 1.0) / 2.0);
        int up = Math.min(page + upperbound, maxpages);
        int down = Math.max(page - lowerbound, 1);
        for (int i = down; i <= up; i++) {
          navigation.add(String.valueOf(i));
        }
      }
    }
    navigation.add(""next"");

    return navigation;
  }

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/ErrorServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.rest.LoadBalancedCRUDOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedImageOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedStoreOperations;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.ImageSizePreset;

/**
 * Servlet implementation for the web view of ""Error page"".
 * 
 * @author Andre Bauer
 */
@WebServlet(""/error"")
public class ErrorServlet extends AbstractUIServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * @see HttpServlet#HttpServlet()
	 */
	public ErrorServlet() {
		super();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException, LoadBalancerTimeoutException {

		Integer statusCode = (Integer) request.getAttribute(""javax.servlet.error.status_code"");

		if (statusCode == null) {
			redirect(""/"", response);
		} else {
			request.setAttribute(""CategoryList"",
					LoadBalancedCRUDOperations.getEntities(Service.PERSISTENCE, ""categories"", Category.class, -1, -1));
			request.setAttribute(""storeIcon"",
					LoadBalancedImageOperations.getWebImage(""icon"", ImageSizePreset.ICON.getSize()));
			request.setAttribute(""errorImage"",
					LoadBalancedImageOperations.getWebImage(""error"", ImageSizePreset.ERROR.getSize()));
			request.setAttribute(""title"", ""TeaStore Error "");
			request.setAttribute(""login"", LoadBalancedStoreOperations.isLoggedIn(getSessionBlob(request)));
			request.getRequestDispatcher(""WEB-INF/pages/error.jsp"").forward(request, response);

		}
	}

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/AboutUsServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.rest.LoadBalancedImageOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedStoreOperations;
import tools.descartes.teastore.entities.ImageSizePreset;

/**
 * Servlet implementation for the web view of ""About us"".
 * 
 * @author Andre Bauer
 */
@WebServlet(""/about"")
public class AboutUsServlet extends AbstractUIServlet {
  private static final long serialVersionUID = 1L;

  /**
   * @see HttpServlet#HttpServlet()
   */
  public AboutUsServlet() {
    super();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException, LoadBalancerTimeoutException {
    checkforCookie(request, response);
    HashMap<String, String> portraits = LoadBalancedImageOperations
        .getWebImages(Arrays.asList(""andreBauer"", ""johannesGrohmann"", ""joakimKistowski"",
            ""simonEismann"", ""norbertSchmitt"", ""samuelKounev""), ImageSizePreset.PORTRAIT.getSize());
    request.setAttribute(""portraitAndre"", portraits.get(""andreBauer""));
    request.setAttribute(""portraitJohannes"", portraits.get(""johannesGrohmann""));
    request.setAttribute(""portraitJoakim"", portraits.get(""joakimKistowski""));
    request.setAttribute(""portraitSimon"", portraits.get(""simonEismann""));
    request.setAttribute(""portraitNorbert"", portraits.get(""norbertSchmitt""));
    request.setAttribute(""portraitKounev"", portraits.get(""samuelKounev""));
    request.setAttribute(""descartesLogo"",
        LoadBalancedImageOperations.getWebImage(""descartesLogo"", ImageSizePreset.LOGO.getSize()));
    request.setAttribute(""storeIcon"",
        LoadBalancedImageOperations.getWebImage(""icon"", ImageSizePreset.ICON.getSize()));
    request.setAttribute(""title"", ""TeaStore About Us"");
    request.setAttribute(""login"", LoadBalancedStoreOperations.isLoggedIn(getSessionBlob(request)));

    request.getRequestDispatcher(""WEB-INF/pages/about.jsp"").forward(request, response);
  }

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/servlet/CartServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.webui.servlet;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.rest.LoadBalancedCRUDOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedImageOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedRecommenderOperations;
import tools.descartes.teastore.registryclient.rest.LoadBalancedStoreOperations;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.ImageSizePreset;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.message.SessionBlob;

/**
 * Servlet implementation for the web view of ""Cart"".
 * 
 * @author Andre Bauer
 */
@WebServlet(""/cart"")
public class CartServlet extends AbstractUIServlet {
  private static final long serialVersionUID = 1L;

  /**
   * @see HttpServlet#HttpServlet()
   */
  public CartServlet() {
    super();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  protected void handleGETRequest(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException, LoadBalancerTimeoutException {
    checkforCookie(request, response);
    SessionBlob blob = getSessionBlob(request);

    List<OrderItem> orderItems = blob.getOrderItems();
    ArrayList<Long> ids = new ArrayList<Long>();
    for (OrderItem orderItem : orderItems) {
      ids.add(orderItem.getProductId());
    }

    HashMap<Long, Product> products = new HashMap<Long, Product>();
    for (Long id : ids) {
      Product product = LoadBalancedCRUDOperations.getEntity(Service.PERSISTENCE, ""products"",
          Product.class, id);
      products.put(product.getId(), product);
    }

    request.setAttribute(""storeIcon"",
        LoadBalancedImageOperations.getWebImage(""icon"", ImageSizePreset.ICON.getSize()));
    request.setAttribute(""title"", ""TeaStore Cart"");
    request.setAttribute(""CategoryList"", LoadBalancedCRUDOperations.getEntities(Service.PERSISTENCE,
        ""categories"", Category.class, -1, -1));
    request.setAttribute(""OrderItems"", orderItems);
    request.setAttribute(""Products"", products);
    request.setAttribute(""login"", LoadBalancedStoreOperations.isLoggedIn(getSessionBlob(request)));

    List<Long> productIds = LoadBalancedRecommenderOperations
        .getRecommendations(blob.getOrderItems(), blob.getUID());
    List<Product> ads = new LinkedList<Product>();
    for (Long productId : productIds) {
      ads.add(LoadBalancedCRUDOperations.getEntity(Service.PERSISTENCE, ""products"", Product.class,
          productId));
    }

    if (ads.size() > 3) {
      ads.subList(3, ads.size()).clear();
    }
    request.setAttribute(""Advertisment"", ads);

    request.setAttribute(""productImages"", LoadBalancedImageOperations.getProductPreviewImages(ads));

    request.getRequestDispatcher(""WEB-INF/pages/cart.jsp"").forward(request, response);

  }

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/startup/WebuiStartup.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.webui.startup;

import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

import io.opentracing.util.GlobalTracer;
import tools.descartes.teastore.registryclient.RegistryClient;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.tracing.Tracing;

/**
 * Application Lifecycle Listener implementation class Registry Client Startup.
 * @author Simon Eismann
 *
 */
@WebListener
public class WebuiStartup implements ServletContextListener {
	/**
	 * Empty constructor.
	 */
    public WebuiStartup() {

    }

	/**
     * @see ServletContextListener#contextDestroyed(ServletContextEvent)
     * @param event The servlet context event at destruction.
     */
    public void contextDestroyed(ServletContextEvent event)  {
    	RegistryClient.getClient().unregister(event.getServletContext().getContextPath());
    }

	/**
     * @see ServletContextListener#contextInitialized(ServletContextEvent)
     * @param event The servlet context event at initialization.
     */
    public void contextInitialized(ServletContextEvent event) {
        GlobalTracer.register(Tracing.init(Service.WEBUI.getServiceName()));
    	ServiceLoadBalancer.preInitializeServiceLoadBalancers(Service.AUTH, Service.IMAGE,
    			Service.PERSISTENCE, Service.RECOMMENDER);
    	RegistryClient.getClient().register(event.getServletContext().getContextPath());
    }

}"
services/tools.descartes.teastore.webui/src/main/java/tools/descartes/teastore/webui/rest/ReadyRest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tools.descartes.teastore.webui.rest;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.Response;

/**
 * Rest endpoint for the store cart.
 *
 * @author Simon
 */
@Path(""ready"")
@Produces({ ""application/json"" })
public class ReadyRest {


  /**
   * This methods checks, if the service is ready.
   *
   * @return True, if recommender is ready; false, if not.
   */
  @GET
  @Path(""isready"")
  public Response isReady() {
    return Response.ok(true).build();
  }

}"
services/tools.descartes.teastore.recommender/src/test/java/tools/descartes/teastore/recommender/algorithm/OrderBasedRecommenderTest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import java.util.ArrayList;
import java.util.List;

import org.junit.Assert;

import tools.descartes.teastore.recommender.algorithm.impl.UseFallBackException;
import tools.descartes.teastore.recommender.algorithm.impl.orderbased.OrderBasedRecommender;
import tools.descartes.teastore.entities.OrderItem;

/**
 * Test for the Dummy Recommender.
 * 
 * @author Johannes Grohmann
 *
 */
public class OrderBasedRecommenderTest extends AbstractRecommenderFunctionalityTest {

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * setupAlgo()
	 */
	@Override
	protected void setupAlgo() {
		setAlgo(new OrderBasedRecommender());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * testResults()
	 */
	@Override
	public void testSingleResults() {
		// test single
		evaluateForItemNo2(getAlgo().recommendProducts(100L, getRecommendSingle()));
		// test single with different order
		evaluateForItemNo2(getAlgo().recommendProducts(102L, getRecommendSingle()));
		// test single with null user
		evaluateForItemNo2(getAlgo().recommendProducts(null, getRecommendSingle()));

		// try other item with id 1
		List<OrderItem> recommend = new ArrayList<>();
		OrderItem o = new OrderItem();
		o.setProductId(1);
		recommend.add(o);
		List<Long> result = getAlgo().recommendProducts(100L, recommend);
		Assert.assertEquals(3L, result.get(0).longValue());
		try {
			Assert.assertEquals(2L, result.get(1).longValue());
			Assert.assertEquals(4L, result.get(2).longValue());
		} catch (AssertionError e) {
			// Result should contain 2 or 4 on position 2
			Assert.assertEquals(4L, result.get(1).longValue());
			Assert.assertEquals(2L, result.get(2).longValue());
		}
		Assert.assertEquals(3, result.size());

		recommend = new ArrayList<>();
		o = new OrderItem();
		o.setProductId(6);
		recommend.add(o);

		try {
			getAlgo().recommendProducts(100L, recommend);
			Assert.fail(""Exception expected"");
		} catch (UseFallBackException e) {
			// expected
		}
	}

	private void evaluateForItemNo2(List<Long> result) {
		try {
			Assert.assertEquals(3L, result.get(0).longValue());
			Assert.assertEquals(4L, result.get(1).longValue());
		} catch (AssertionError e) {
			// Result should contain 3 or 4 on position 1
			Assert.assertEquals(4L, result.get(0).longValue());
			Assert.assertEquals(3L, result.get(1).longValue());
		}
		try {
			Assert.assertEquals(1L, result.get(2).longValue());
			Assert.assertEquals(5L, result.get(3).longValue());
		} catch (AssertionError e) {
			// Result should contain 5 or 1 on position 3
			Assert.assertEquals(5L, result.get(2).longValue());
			Assert.assertEquals(1L, result.get(3).longValue());
		}
		Assert.assertEquals(4, result.size());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * testResults()
	 */
	@Override
	public void testMultiResults() {
		// test multi
		evaluateForItemNo356(getAlgo().recommendProducts(100L, getRecommendMulti()));
		// test multi with different user
		evaluateForItemNo356(getAlgo().recommendProducts(102L, getRecommendMulti()));

		// test multi with null user
		evaluateForItemNo356(getAlgo().recommendProducts(null, getRecommendMulti()));

		// test multi with different user
		evaluateForItemNo356(getAlgo().recommendProducts(104L, getRecommendMulti()));

		// test multi with different user
		evaluateForItemNo356(getAlgo().recommendProducts(105L, getRecommendMulti()));

		// test multi with different user
		evaluateForItemNo356(getAlgo().recommendProducts(101L, getRecommendMulti()));

	}

	private void evaluateForItemNo356(List<Long> result) {
		try {
			Assert.assertEquals(2L, result.get(0).longValue());
			Assert.assertEquals(4L, result.get(1).longValue());
		} catch (AssertionError e) {
			// Result should contain 2 or 4 on position 1
			Assert.assertEquals(4L, result.get(0).longValue());
			Assert.assertEquals(2L, result.get(1).longValue());
		}
		Assert.assertEquals(1L, result.get(2).longValue());
		Assert.assertEquals(3, result.size());
	}

}"
services/tools.descartes.teastore.recommender/src/test/java/tools/descartes/teastore/recommender/algorithm/DummyRecommenderTest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import java.util.ArrayList;
import java.util.List;

import org.junit.Assert;

import tools.descartes.teastore.recommender.algorithm.impl.DummyRecommender;

/**
 * Test for the Dummy Recommender.
 * 
 * @author Johannes Grohmann
 *
 */
public class DummyRecommenderTest extends AbstractRecommenderFunctionalityTest {

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * setupAlgo()
	 */
	@Override
	protected void setupAlgo() {
		setAlgo(new DummyRecommender());

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * testResults()
	 */
	@Override
	public void testSingleResults() {
		// compare
		List<Long> recommended = new ArrayList<Long>();
		recommended.add(-1L);
		Assert.assertEquals(recommended,
				getAlgo().recommendProducts(getAllUsers().get(0).getId(), getRecommendSingle()));
	}
	
	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * testResults()
	 */
	@Override
	public void testMultiResults() {
		// compare
		List<Long> recommended = new ArrayList<Long>();
		recommended.add(-1L);

		Assert.assertEquals(recommended,
				getAlgo().recommendProducts(getAllUsers().get(0).getId(), getRecommendMulti()));
		Assert.assertEquals(recommended,
				getAlgo().recommendProducts(getAllUsers().get(1).getId(), getRecommendMulti()));
		Assert.assertEquals(recommended,
				getAlgo().recommendProducts(getAllUsers().get(4).getId(), getRecommendMulti()));
	}

}"
services/tools.descartes.teastore.recommender/src/test/java/tools/descartes/teastore/recommender/algorithm/AbstractRecommenderTest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import java.util.ArrayList;
import java.util.List;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.User;

/**
 * Abstract Recommender Test.
 * 
 * @author Johannes Grohmann
 *
 */
public abstract class AbstractRecommenderTest {

	private List<OrderItem> trainOrderItems;

	private List<Order> trainOrders;

	private List<User> allUsers;

	private List<OrderItem> recommendSingle;

	private List<OrderItem> recommendMulti;

	private AbstractRecommender algo;

	/**
	 * Run the setup.
	 * 
	 * trainOrders = [{10, user100}, {11, user101}, {12, user103}, {13, user104},
	 * {14, user101}, {15, user101}, {16, user105}, {17, user106}] <br>
	 * orderItems: 10 = {1, 2, 3}; 11 = {2^5,4^2}; 12 = {1, 3, 4}; 13 = {2^2}; 14 =
	 * {2^2}; 15 = {2}; 16 = {2, 3, 4, 5}; 17 = {3};
	 */
	@Before
	public void setup() {
		setupAlgo();
		// create users
		allUsers = new ArrayList<>();

		User u = new User();
		u.setId(100);
		u.setEmail(""u100@testemail.com"");
		u.setRealName(""User 100"");
		u.setUserName(""u100"");
		u.setPassword(""Bad password"");
		allUsers.add(u);

		u.setId(101);
		u.setEmail(""u101@testemail.com"");
		u.setRealName(""User 101"");
		u.setUserName(""u101"");
		u.setPassword(""Bad password"");
		allUsers.add(u);

		u.setId(102);
		u.setEmail(""u102@testemail.com"");
		u.setRealName(""User 102"");
		u.setUserName(""u102"");
		u.setPassword(""Bad password"");
		allUsers.add(u);

		u.setId(103);
		u.setEmail(""u100@testemail.com"");
		u.setRealName(""User 103"");
		u.setUserName(""u103"");
		u.setPassword(""Bad password"");
		allUsers.add(u);

		u.setId(104);
		u.setEmail(""u104@testemail.com"");
		u.setRealName(""User 104"");
		u.setUserName(""u104"");
		u.setPassword(""Bad password"");
		allUsers.add(u);

		u.setId(105);
		u.setEmail(""u105@testemail.com"");
		u.setRealName(""User 105"");
		u.setUserName(""u105"");
		u.setPassword(""Bad password"");
		allUsers.add(u);

		u.setId(106);
		u.setEmail(""u106@testemail.com"");
		u.setRealName(""User 106"");
		u.setUserName(""u106"");
		u.setPassword(""Bad password"");
		allUsers.add(u);

		// train orders
		trainOrders = new ArrayList<>();

		Order or = new Order();
		or.setUserId(100);
		or.setId(10);
		trainOrders.add(or);

		or = new Order();
		or.setUserId(101);
		or.setId(11);
		trainOrders.add(or);

		or = new Order();
		or.setUserId(103);
		or.setId(12);
		trainOrders.add(or);

		or = new Order();
		or.setUserId(104);
		or.setId(13);
		trainOrders.add(or);

		or = new Order();
		or.setUserId(101);
		or.setId(14);
		trainOrders.add(or);

		or = new Order();
		or.setUserId(101);
		or.setId(15);
		trainOrders.add(or);

		or = new Order();
		or.setUserId(105);
		or.setId(16);
		trainOrders.add(or);

		or = new Order();
		or.setUserId(106);
		or.setId(17);
		trainOrders.add(or);

		// train items
		trainOrderItems = new ArrayList<OrderItem>();

		OrderItem o = new OrderItem();
		o.setProductId(1);
		o.setQuantity(1);
		o.setOrderId(10);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(2);
		o.setQuantity(1);
		o.setOrderId(10);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(3);
		o.setQuantity(1);
		o.setOrderId(10);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(4);
		o.setQuantity(2);
		o.setOrderId(11);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(2);
		o.setQuantity(5);
		o.setOrderId(11);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(3);
		o.setQuantity(1);
		o.setOrderId(12);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(4);
		o.setQuantity(1);
		o.setOrderId(12);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(1);
		o.setQuantity(1);
		o.setOrderId(12);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(2);
		o.setQuantity(2);
		o.setOrderId(13);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(2);
		o.setQuantity(2);
		o.setOrderId(14);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(2);
		o.setQuantity(1);
		o.setOrderId(15);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(2);
		o.setQuantity(1);
		o.setOrderId(16);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(3);
		o.setQuantity(1);
		o.setOrderId(16);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(4);
		o.setQuantity(1);
		o.setOrderId(16);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(5);
		o.setQuantity(1);
		o.setOrderId(16);
		trainOrderItems.add(o);

		o = new OrderItem();
		o.setProductId(3);
		o.setQuantity(1);
		o.setOrderId(17);
		trainOrderItems.add(o);

		// recommend Single
		recommendSingle = new ArrayList<>();
		o = new OrderItem();
		o.setProductId(2);
		recommendSingle.add(o);

		// recommend Multi
		recommendMulti = new ArrayList<>();
		o = new OrderItem();
		o.setProductId(3);
		recommendMulti.add(o);
		o = new OrderItem();
		o.setProductId(5);
		recommendMulti.add(o);
		o = new OrderItem();
		o.setProductId(6);
		recommendMulti.add(o);
	}

	/**
	 * Iniialize the algo.
	 */
	protected abstract void setupAlgo();

	/**
	 * Test for interface conformity.
	 */
	@Test
	public void testInterface() {
		try {
			getAlgo().recommendProducts(allUsers.get(2).getId(), recommendMulti);
			Assert.fail(""Recommender is supposed to throw an exception before being trained."");
		} catch (UnsupportedOperationException e) {
			// expected
		}

		getAlgo().train(trainOrderItems, trainOrders);

		// compare type
		List<Long> recommended = new ArrayList<Long>();
		recommended.add(-1L);

		Assert.assertEquals(recommended.getClass(),
				getAlgo().recommendProducts(allUsers.get(2).getId(), recommendMulti).getClass());

		Assert.assertEquals(new ArrayList<Long>(),
				getAlgo().recommendProducts(allUsers.get(1).getId(), new ArrayList<>()));
	}

	/**
	 * Test the results.
	 */
	@Test
	public void testResults() {
		getAlgo().train(getTrainOrderItems(), getTrainOrders());
		testSingleResults();
		testMultiResults();
	}

	/**
	 * Test the results of the single recommender interface.
	 */
	public abstract void testSingleResults();

	/**
	 * Test the results of the multi recommender interface.
	 */
	public abstract void testMultiResults();

	/**
	 * @return the trainOrderItems
	 */
	public List<OrderItem> getTrainOrderItems() {
		return trainOrderItems;
	}

	/**
	 * @param trainOrderItems
	 *            the trainOrderItems to set
	 */
	public void setTrainOrderItems(List<OrderItem> trainOrderItems) {
		this.trainOrderItems = trainOrderItems;
	}

	/**
	 * @return the trainOrders
	 */
	public List<Order> getTrainOrders() {
		return trainOrders;
	}

	/**
	 * @param trainOrders
	 *            the trainOrders to set
	 */
	public void setTrainOrders(List<Order> trainOrders) {
		this.trainOrders = trainOrders;
	}

	/**
	 * @return the recommendSingle
	 */
	public List<OrderItem> getRecommendSingle() {
		return recommendSingle;
	}

	/**
	 * @param recommendSingle
	 *            the recommendSingle to set
	 */
	public void setRecommendSingle(List<OrderItem> recommendSingle) {
		this.recommendSingle = recommendSingle;
	}

	/**
	 * @return the recommendMulti
	 */
	public List<OrderItem> getRecommendMulti() {
		return recommendMulti;
	}

	/**
	 * @param recommendMulti
	 *            the recommendMulti to set
	 */
	public void setRecommendMulti(List<OrderItem> recommendMulti) {
		this.recommendMulti = recommendMulti;
	}

	/**
	 * @return the algo
	 */
	public AbstractRecommender getAlgo() {
		return algo;
	}

	/**
	 * @param algo
	 *            the algo to set
	 */
	public void setAlgo(AbstractRecommender algo) {
		this.algo = algo;
	}

	/**
	 * @return the allUsers
	 */
	public List<User> getAllUsers() {
		return allUsers;
	}

	/**
	 * @param allUsers
	 *            the allUsers to set
	 */
	public void setAllUsers(List<User> allUsers) {
		this.allUsers = allUsers;
	}

}"
services/tools.descartes.teastore.recommender/src/test/java/tools/descartes/teastore/recommender/algorithm/PreprocessedSlopeOneRecommenderTest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import static org.junit.Assert.assertEquals;

import java.util.HashMap;
import java.util.Map;

import tools.descartes.teastore.recommender.algorithm.impl.cf.PreprocessedSlopeOneRecommender;

/**
 * Test for the Dummy Recommender.
 * 
 * @author Johannes Grohmann
 *
 */
public class PreprocessedSlopeOneRecommenderTest extends SlopeOneRecommenderTest {

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * setupAlgo()
	 */
	@Override
	protected void setupAlgo() {
		setAlgo(new PreprocessedSlopeOneRecommender());
	}

	@Override
	public void testSingleResults() {
		super.testSingleResults();
		checkUserPredictionMatrix();
	}
	
	@Override
	public void testMultiResults() {
		super.testMultiResults();
		checkUserPredictionMatrix();
	}

	private void checkUserPredictionMatrix() {
		Map<Long, Map<Long, Double>> ratings = new HashMap<>();

		// user 100 {1=1.0, 2=1.0, 3=1.0, 4=2.2, 5=-1.0}
		Map<Long, Double> entry = new HashMap<>();
		entry.put(1L, 1.0);
		entry.put(2L, 1.0);
		entry.put(3L, 1.0);
		entry.put(4L, 2.2);
		entry.put(5L, -1.0);
		ratings.put(100L, entry);
		// user 101 {1=5.0, 2=8.0, 3=5.0, 4=2.0, 5=5.0}
		entry = new HashMap<>();
		entry.put(1L, 5.0);
		entry.put(2L, 8.0);
		entry.put(3L, 5.0);
		entry.put(4L, 2.0);
		entry.put(5L, 5.0);
		ratings.put(101L, entry);
		// user 103 {1=1.0, 2=-0.2, 3=1.0, 4=1.0, 5=-1.0}
		entry = new HashMap<>();
		entry.put(1L, 1.0);
		entry.put(2L, -0.2);
		entry.put(3L, 1.0);
		entry.put(4L, 1.0);
		entry.put(5L, -1.0);
		ratings.put(103L, entry);
		// user 104 {1=2.0, 2=2.0, 3=2.0, 4=5.0, 5=2.0}
		entry = new HashMap<>();
		entry.put(1L, 2.0);
		entry.put(2L, 2.0);
		entry.put(3L, 2.0);
		entry.put(4L, 5.0);
		entry.put(5L, 2.0);
		ratings.put(104L, entry);
		// user 105 {1=-1.0, 2=1.0, 3=1.0, 4=1.0, 5=1.0}
		entry = new HashMap<>();
		entry.put(1L, -1.0);
		entry.put(2L, 1.0);
		entry.put(3L, 1.0);
		entry.put(4L, 1.0);
		entry.put(5L, 1.0);
		ratings.put(105L, entry);
		// user 106 {1=1.0, 2=1.0, 3=1.0, 4=1.0, 5=1.0}
		entry = new HashMap<>();
		entry.put(1L, 1.0);
		entry.put(2L, 1.0);
		entry.put(3L, 1.0);
		entry.put(4L, 1.0);
		entry.put(5L, 1.0);
		ratings.put(106L, entry);

		assertEquals(ratings, ((PreprocessedSlopeOneRecommender) getAlgo()).getPredictedRatings());

	}

}"
services/tools.descartes.teastore.recommender/src/test/java/tools/descartes/teastore/recommender/algorithm/PopularityBasedRecommenderTest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import java.util.List;

import org.junit.Assert;
import tools.descartes.teastore.recommender.algorithm.impl.pop.PopularityBasedRecommender;

/**
 * Test for the Dummy Recommender.
 * 
 * @author Johannes Grohmann
 *
 */
public class PopularityBasedRecommenderTest extends AbstractRecommenderFunctionalityTest {

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * setupAlgo()
	 */
	@Override
	protected void setupAlgo() {
		setAlgo(new PopularityBasedRecommender());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * testResults()
	 */
	@Override
	public void testSingleResults() {
		// test single
		List<Long> result = getAlgo().recommendProducts(getAllUsers().get(0).getId(), getRecommendSingle());
		Assert.assertEquals(3L, result.get(0).longValue());
		Assert.assertEquals(4L, result.get(1).longValue());
		Assert.assertEquals(1L, result.get(2).longValue());
		Assert.assertEquals(5L, result.get(3).longValue());
		Assert.assertEquals(4, result.size());

		// test single with different user
		result = getAlgo().recommendProducts(getAllUsers().get(2).getId(), getRecommendSingle());
		Assert.assertEquals(3L, result.get(0).longValue());
		Assert.assertEquals(4L, result.get(1).longValue());
		Assert.assertEquals(1L, result.get(2).longValue());
		Assert.assertEquals(5L, result.get(3).longValue());
		Assert.assertEquals(4, result.size());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * testResults()
	 */
	@Override
	public void testMultiResults() {
		// test multi
		List<Long> result = getAlgo().recommendProducts(getAllUsers().get(0).getId(), getRecommendMulti());
		Assert.assertEquals(2L, result.get(0).longValue());
		Assert.assertEquals(4L, result.get(1).longValue());
		Assert.assertEquals(1L, result.get(2).longValue());
		Assert.assertEquals(3, result.size());

		// test multi with different user
		result = getAlgo().recommendProducts(getAllUsers().get(2).getId(), getRecommendMulti());
		Assert.assertEquals(2L, result.get(0).longValue());
		Assert.assertEquals(4L, result.get(1).longValue());
		Assert.assertEquals(1L, result.get(2).longValue());
		Assert.assertEquals(3, result.size());

		// test multi with different user
		result = getAlgo().recommendProducts(getAllUsers().get(4).getId(), getRecommendMulti());
		Assert.assertEquals(2L, result.get(0).longValue());
		Assert.assertEquals(4L, result.get(1).longValue());
		Assert.assertEquals(1L, result.get(2).longValue());
		Assert.assertEquals(3, result.size());
	}

}"
services/tools.descartes.teastore.recommender/src/test/java/tools/descartes/teastore/recommender/algorithm/AbstractRecommenderFunctionalityTest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import static org.junit.Assert.assertEquals;

import java.util.HashMap;
import java.util.Map;

import org.junit.Test;

/**
 * Abstract Recommender Test.
 * 
 * @author Johannes Grohmann
 *
 */
public abstract class AbstractRecommenderFunctionalityTest extends AbstractRecommenderTest {
	/**
	 * Tests the common functions which should usually be the same for all abstract
	 * recommender implementations.
	 */
	@Test
	public void testAbstractFunctions() {
		// train
		getAlgo().train(getTrainOrderItems(), getTrainOrders());

		Map<Long, Map<Long, Double>> newmatrix = new HashMap<>();

		// user100
		Map<Long, Double> entry = new HashMap<>();
		entry.put(1L, 1.0);
		entry.put(2L, 1.0);
		entry.put(3L, 1.0);
		newmatrix.put(100L, entry);
		// user101
		entry = new HashMap<>();
		entry.put(2L, 8.0);
		entry.put(4L, 2.0);
		newmatrix.put(101L, entry);
		// user103
		entry = new HashMap<>();
		entry.put(1L, 1.0);
		entry.put(3L, 1.0);
		entry.put(4L, 1.0);
		newmatrix.put(103L, entry);
		// user104
		entry = new HashMap<>();
		entry.put(2L, 2.0);
		newmatrix.put(104L, entry);
		// user105
		entry = new HashMap<>();
		entry.put(2L, 1.0);
		entry.put(3L, 1.0);
		entry.put(4L, 1.0);
		entry.put(5L, 1.0);
		newmatrix.put(105L, entry);
		// user106
		entry = new HashMap<>();
		entry.put(3L, 1.0);
		newmatrix.put(106L, entry);

		assertEquals(newmatrix, getAlgo().getUserBuyingMatrix());
	}
}"
services/tools.descartes.teastore.recommender/src/test/java/tools/descartes/teastore/recommender/algorithm/SlopeOneRecommenderTest.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import static org.junit.Assert.assertEquals;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.junit.Assert;

import tools.descartes.teastore.recommender.algorithm.impl.UseFallBackException;
import tools.descartes.teastore.recommender.algorithm.impl.cf.SlopeOneRecommender;

/**
 * Test for the Dummy Recommender.
 * 
 * @author Johannes Grohmann
 *
 */
public class SlopeOneRecommenderTest extends AbstractRecommenderFunctionalityTest {

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * setupAlgo()
	 */
	@Override
	protected void setupAlgo() {
		setAlgo(new SlopeOneRecommender());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * testResults()
	 */
	@Override
	public void testSingleResults() {
		// check resulting matrices
		checkDiffMatrix();
		checkFreqMatrix();
		// test single
		List<Long> result = getAlgo().recommendProducts(100L, getRecommendSingle());
		Assert.assertEquals(4L, result.get(0).longValue());
		try {
			Assert.assertEquals(3L, result.get(1).longValue());
			Assert.assertEquals(1L, result.get(2).longValue());
		} catch (AssertionError e) {
			// Result should contain 3 or 1 on position 1
			Assert.assertEquals(1L, result.get(1).longValue());
			Assert.assertEquals(3L, result.get(2).longValue());
		}
		Assert.assertEquals(5L, result.get(3).longValue());
		Assert.assertEquals(4, result.size());

		// test single with different user
		try {
			result = getAlgo().recommendProducts(102L, getRecommendSingle());
			Assert.fail(""Exception expected"");
		} catch (UseFallBackException e) {
			// expected
		}
		// test single with null user
		try {
			result = getAlgo().recommendProducts(null, getRecommendSingle());
			Assert.fail(""Exception expected"");
		} catch (UseFallBackException e) {
			// expected
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommenderTest#
	 * testResults()
	 */
	@Override
	public void testMultiResults() {
		// check that matrices did not change
		checkDiffMatrix();
		checkFreqMatrix();
		// test multi
		List<Long> result = getAlgo().recommendProducts(100L, getRecommendMulti());
		Assert.assertEquals(4L, result.get(0).longValue());
		try {
			Assert.assertEquals(2L, result.get(1).longValue());
			Assert.assertEquals(1L, result.get(2).longValue());
		} catch (AssertionError e) {
			// Result should contain 2 or 1 on position 1
			Assert.assertEquals(1L, result.get(1).longValue());
			Assert.assertEquals(2L, result.get(2).longValue());
		}
		Assert.assertEquals(3, result.size());

		// test multi with different user
		try {
			result = getAlgo().recommendProducts(102L, getRecommendMulti());
			Assert.fail(""Exception expected"");
		} catch (UseFallBackException e) {
			// expected
		}
		
		// test multi with null user
		try {
			result = getAlgo().recommendProducts(null, getRecommendMulti());
			Assert.fail(""Exception expected"");
		} catch (UseFallBackException e) {
			// expected
		}

		// test multi with different user
		result = getAlgo().recommendProducts(104L, getRecommendMulti());
		Assert.assertEquals(4L, result.get(0).longValue());
		try {
			Assert.assertEquals(2L, result.get(1).longValue());
			Assert.assertEquals(1L, result.get(2).longValue());
		} catch (AssertionError e) {
			// Result should contain 2 or 1 on position 1
			Assert.assertEquals(1L, result.get(1).longValue());
			Assert.assertEquals(2L, result.get(2).longValue());
		}
		Assert.assertEquals(3, result.size());

		// test multi with different user
		result = getAlgo().recommendProducts(105L, getRecommendMulti());
		try {
			Assert.assertEquals(4L, result.get(0).longValue());
			Assert.assertEquals(2L, result.get(1).longValue());
		}  catch (AssertionError e) {
			// Result should contain 2 or 1 on position 1
			Assert.assertEquals(2L, result.get(0).longValue());
			Assert.assertEquals(4L, result.get(1).longValue());
		}
		Assert.assertEquals(1L, result.get(2).longValue());
		Assert.assertEquals(3, result.size());

		// test multi with different user
		result = getAlgo().recommendProducts(101L, getRecommendMulti());
		Assert.assertEquals(2L, result.get(0).longValue());
		Assert.assertEquals(1L, result.get(1).longValue());
		Assert.assertEquals(4L, result.get(2).longValue());
		Assert.assertEquals(3, result.size());

		// check that matrices still not changed
		checkDiffMatrix();
		checkFreqMatrix();
	}

	private void checkDiffMatrix() {
		Map<Long, Map<Long, Double>> differences = new HashMap<>();

		// item 1
		Map<Long, Double> entry = new HashMap<>();
		entry.put(1L, 0.0);
		entry.put(2L, 0.0);
		entry.put(3L, 0.0);
		entry.put(4L, 0.0);
		differences.put(1L, entry);
		// item 2
		entry = new HashMap<>();
		entry.put(1L, 0.0);
		entry.put(2L, 0.0);
		entry.put(3L, 0.0);
		entry.put(4L, 3.0);
		entry.put(5L, 0.0);
		differences.put(2L, entry);
		// item 3
		entry = new HashMap<>();
		entry.put(1L, 0.0);
		entry.put(2L, 0.0);
		entry.put(3L, 0.0);
		entry.put(4L, 0.0);
		entry.put(5L, 0.0);
		differences.put(3L, entry);
		// item 4
		entry = new HashMap<>();
		entry.put(1L, 0.0);
		entry.put(2L, -3.0);
		entry.put(3L, 0.0);
		entry.put(4L, 0.0);
		entry.put(5L, 0.0);
		differences.put(4L, entry);
		// item 5
		entry = new HashMap<>();
		entry.put(2L, 0.0);
		entry.put(3L, 0.0);
		entry.put(4L, 0.0);
		entry.put(5L, 0.0);
		differences.put(5L, entry);

		assertEquals(differences, ((SlopeOneRecommender) getAlgo()).getDifferences());
	}

	private void checkFreqMatrix() {
		Map<Long, Map<Long, Integer>> frequencies = new HashMap<>();

		// item 1
		Map<Long, Integer> entry = new HashMap<>();
		entry.put(1L, 2);
		entry.put(2L, 1);
		entry.put(3L, 2);
		entry.put(4L, 1);
		frequencies.put(1L, entry);
		// item 2
		entry = new HashMap<>();
		entry.put(1L, 1);
		entry.put(2L, 4);
		entry.put(3L, 2);
		entry.put(4L, 2);
		entry.put(5L, 1);
		frequencies.put(2L, entry);
		// item 3
		entry = new HashMap<>();
		entry.put(1L, 2);
		entry.put(2L, 2);
		entry.put(3L, 4);
		entry.put(4L, 2);
		entry.put(5L, 1);
		frequencies.put(3L, entry);
		// item 4
		entry = new HashMap<>();
		entry.put(1L, 1);
		entry.put(2L, 2);
		entry.put(3L, 2);
		entry.put(4L, 3);
		entry.put(5L, 1);
		frequencies.put(4L, entry);
		// item 5
		entry = new HashMap<>();
		entry.put(2L, 1);
		entry.put(3L, 1);
		entry.put(4L, 1);
		entry.put(5L, 1);
		frequencies.put(5L, entry);

		assertEquals(frequencies, ((SlopeOneRecommender) getAlgo()).getFrequencies());
	}

}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/algorithm/AbstractRecommender.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.Map.Entry;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Abstract class for basic recommendation functionality.
 * 
 * @author Johannes Grohmann
 *
 */
public abstract class AbstractRecommender implements IRecommender {

	private boolean trainingFinished = false;

	/**
	 * Defines the maximum number of recommendations different implementations
	 * should return. Is NOT mandatory for any of the algorithms.
	 */
	public static final int MAX_NUMBER_OF_RECOMMENDATIONS = 10;

	private static final Logger LOG = LoggerFactory.getLogger(AbstractRecommender.class);

	/**
	 * This represents the matrix assigning each user a frequency for each product
	 * ID. The frequency resembles the number of times, a user has bought that item.
	 */
	private Map<Long, Map<Long, Double>> userBuyingMatrix;

	/**
	 * This set maps a userId to a set, containing the corresponding OrderItemSets,
	 * i.e. all orders that were done by the user.
	 */
	private Map<Long, Set<OrderItemSet>> userItemSets;

	/**
	 * This is an enumeration of all available products seen during the training
	 * phase.
	 */
	private Set<Long> totalProducts;

	@Override
	public void train(List<OrderItem> orderItems, List<Order> orders) {
		long tic = System.currentTimeMillis();
		totalProducts = new HashSet<>();
		// first create order mapping unorderized
		Map<Long, OrderItemSet> unOrderizeditemSets = new HashMap<>();
		for (OrderItem orderItem : orderItems) {
			if (!unOrderizeditemSets.containsKey(orderItem.getOrderId())) {
				unOrderizeditemSets.put(orderItem.getOrderId(), new OrderItemSet());
				unOrderizeditemSets.get(orderItem.getOrderId()).setOrderId(orderItem.getOrderId());
			}
			unOrderizeditemSets.get(orderItem.getOrderId()).getOrderset().put(orderItem.getProductId(),
					orderItem.getQuantity());
			// see, if we already have our item
			if (!totalProducts.contains(orderItem.getProductId())) {
				// if not known yet -> add
				totalProducts.add(orderItem.getProductId());
			}
		}
		// now map each id with the corresponding order
		Map<Order, OrderItemSet> itemSets = new HashMap<>();
		for (Long orderid : unOrderizeditemSets.keySet()) {
			Order realOrder = findOrder(orders, orderid);
			itemSets.put(realOrder, unOrderizeditemSets.get(orderid));
		}
		userItemSets = new HashMap<>();
		for (Order order : itemSets.keySet()) {
			if (!userItemSets.containsKey(order.getUserId())) {
				userItemSets.put(order.getUserId(), new HashSet<OrderItemSet>());
			}
			itemSets.get(order).setUserId(order.getUserId());
			userItemSets.get(order.getUserId()).add(itemSets.get(order));
		}
		userBuyingMatrix = createUserBuyingMatrix(userItemSets);
		executePreprocessing();
		LOG.info(""Training recommender finished. Training took: "" + (System.currentTimeMillis() - tic) + ""ms."");
		trainingFinished = true;
	}

	/**
	 * Triggers implementing classes if they want to execute a pre-processing step
	 * during {@link AbstractRecommender#train(List, List)}.
	 */
	protected void executePreprocessing() {
		// do nothing
	}

	@Override
	public List<Long> recommendProducts(Long userid, List<OrderItem> currentItems)
			throws UnsupportedOperationException {
		if (!trainingFinished) {
			throw new UnsupportedOperationException(""This instance is not fully trained yet."");
		}
		if (currentItems.isEmpty()) {
			// if input is empty return empty list
			return new LinkedList<>();
		}
		List<Long> items = new ArrayList<>(currentItems.size());
		for (OrderItem item : currentItems) {
			items.add(item.getProductId());
		}
		return execute(userid, items);
	}

	/**
	 * Filters the given ranking of recommendations and deletes items that already
	 * are in the cart. Furthermore caps the recommendations and only uses the
	 * {@link AbstractRecommender#MAX_NUMBER_OF_RECOMMENDATIONS} highest rated
	 * recommendations.
	 * 
	 * @param priorityList
	 *            The unfiltered ranking assigning each recommended product ID a
	 *            score or an importance. Does not need to be sorted.
	 * @param currentItems
	 *            The list of item IDs that must NOT be contained in the returned
	 *            list.
	 * @return A sorted list of recommendations with a size not greater than
	 *         {@link AbstractRecommender#MAX_NUMBER_OF_RECOMMENDATIONS}
	 */
	protected List<Long> filterRecommendations(Map<Long, Double> priorityList, List<Long> currentItems) {
		TreeMap<Double, List<Long>> ranking = createRanking(priorityList);
		List<Long> reco = new ArrayList<>(MAX_NUMBER_OF_RECOMMENDATIONS);
		for (Double score : ranking.descendingKeySet()) {
			List<Long> productIds = ranking.get(score);
			for (long productId : productIds) {
				if (reco.size() < MAX_NUMBER_OF_RECOMMENDATIONS) {
					if (!currentItems.contains(productId)) {
						reco.add(productId);
					}
				} else {
					return reco;
				}
			}
		}
		return reco;
	}

	private TreeMap<Double, List<Long>> createRanking(Map<Long, Double> map) {
		// transforming the map into a treemap (for efficient access)
		TreeMap<Double, List<Long>> ranking = new TreeMap<Double, List<Long>>();
		for (Entry<Long, Double> entry : map.entrySet()) {
			List<Long> productIds = ranking.get(entry.getValue());
			if (productIds == null) {
				productIds = new ArrayList<>();
				ranking.put(entry.getValue(), productIds);
			}
			productIds.add(entry.getKey());
		}
		return ranking;
	}

	/**
	 * Has to be implemented by subclasses in order to perform actual
	 * recommendation.
	 * 
	 * @param userid
	 *            The id of the {@link User} to recommend for. May be null.
	 * @param currentItems
	 *            A list containing all ids of {@link OrderItem}s.
	 * @return List of all IDs of the {@link Product} entities that are recommended
	 *         to add to the cart. Does not contain any {@link Product} that is
	 *         already part of the given list of {@link OrderItem}s. Might be empty.
	 */
	protected abstract List<Long> execute(Long userid, List<Long> currentItems);

	private Order findOrder(List<Order> orders, long orderid) {
		for (Order order : orders) {
			if (order.getId() == orderid) {
				return order;
			}
		}
		return null;
	}

	/**
	 * @return the userBuyingMatrix
	 */
	public Map<Long, Map<Long, Double>> getUserBuyingMatrix() {
		return userBuyingMatrix;
	}

	/**
	 * @param userBuyingMatrix
	 *            the userBuyingMatrix to set
	 */
	public void setUserBuyingMatrix(Map<Long, Map<Long, Double>> userBuyingMatrix) {
		this.userBuyingMatrix = userBuyingMatrix;
	}

	/**
	 * @return the totalProducts
	 */
	public Set<Long> getTotalProducts() {
		return totalProducts;
	}

	/**
	 * @param totalProducts
	 *            the totalProducts to set
	 */
	public void setTotalProducts(Set<Long> totalProducts) {
		this.totalProducts = totalProducts;
	}

	/**
	 * @return the userItemSets
	 */
	public Map<Long, Set<OrderItemSet>> getUserItemSets() {
		return userItemSets;
	}

	/**
	 * @param userItemSets
	 *            the userItemSets to set
	 */
	public void setUserItemSets(Map<Long, Set<OrderItemSet>> userItemSets) {
		this.userItemSets = userItemSets;
	}

	/**
	 * Transforms the list of orders into one matrix containing all user-IDs and
	 * their number of buys (i.e., their rating) of all product-IDs. A
	 * quantity/rating of a user is null, if the user did not buy that item. If the
	 * user bought one item at least once, the contained value (rating) is the
	 * number of times, he bought one given item.
	 * 
	 * @param useritemsets
	 *            A map assigning each user-ID all its OrderItemSets
	 * @return A Map representing a matrix of each user-ID assigning each item-ID
	 *         its number of buys (as double value)
	 */
	private static Map<Long, Map<Long, Double>> createUserBuyingMatrix(Map<Long, Set<OrderItemSet>> useritemsets) {
		Map<Long, Map<Long, Double>> matrix = new HashMap<>();
		// for each user
		for (Entry<Long, Set<OrderItemSet>> entry : useritemsets.entrySet()) {
			// create a new line for this user-ID
			Map<Long, Double> line = new HashMap<>();
			// for all orders of that user
			for (OrderItemSet orderset : entry.getValue()) {
				// for all orderitems of that orderset
				for (Entry<Long, Integer> product : orderset.getOrderset().entrySet()) {
					// if key was not known before -> first occurence
					if (!line.containsKey(product.getKey())) {
						line.put(product.getKey(), Double.valueOf(product.getValue()));
					} else {
						// if key was known before -> increase counter
						line.put(product.getKey(), Double.valueOf(line.get(product.getKey()) + product.getValue()));
					}
				}
			}
			// add this user-ID to the matrix
			matrix.put(entry.getKey(), line);
		}
		return matrix;
	}

}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/algorithm/RecommenderSelector.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.naming.InitialContext;
import javax.naming.NamingException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.recommender.algorithm.impl.UseFallBackException;
import tools.descartes.teastore.recommender.algorithm.impl.cf.PreprocessedSlopeOneRecommender;
import tools.descartes.teastore.recommender.algorithm.impl.cf.SlopeOneRecommender;
import tools.descartes.teastore.recommender.algorithm.impl.orderbased.OrderBasedRecommender;
import tools.descartes.teastore.recommender.algorithm.impl.pop.PopularityBasedRecommender;
import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;

/**
 * A strategy selector for the Recommender functionality.
 * 
 * @author Johannes Grohmann
 *
 */
public final class RecommenderSelector implements IRecommender {

	/**
	 * This map lists all currently available recommending approaches and assigns
	 * them their ""name"" for the environment variable.
	 */
	private static Map<String, Class<? extends IRecommender>> recommenders = new HashMap<>();

	static {
		recommenders = new HashMap<String, Class<? extends IRecommender>>();
		recommenders.put(""Popularity"", PopularityBasedRecommender.class);
		recommenders.put(""SlopeOne"", SlopeOneRecommender.class);
		recommenders.put(""PreprocessedSlopeOne"", PreprocessedSlopeOneRecommender.class);
		recommenders.put(""OrderBased"", OrderBasedRecommender.class);
	}

	/**
	 * The default recommender to choose, if no other recommender was set.
	 */
	private static final Class<? extends IRecommender> DEFAULT_RECOMMENDER = SlopeOneRecommender.class;

	private static final Logger LOG = LoggerFactory.getLogger(RecommenderSelector.class);

	private static RecommenderSelector instance;

	private IRecommender fallbackrecommender;

	private IRecommender recommender;

	/**
	 * Private Constructor.
	 */
	private RecommenderSelector() {
		fallbackrecommender = new PopularityBasedRecommender();
		try {
			String recommendername = (String) new InitialContext().lookup(""java:comp/env/recommenderAlgorithm"");
			// if a specific algorithm is set, we can use that algorithm
			if (recommenders.containsKey(recommendername)) {
				try {
					recommender = recommenders.get(recommendername).getDeclaredConstructor().newInstance();
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (InvocationTargetException e) {
					e.printStackTrace();
				} catch (NoSuchMethodException e) {
					e.printStackTrace();
				} catch (SecurityException e) {
					e.printStackTrace();
				}
			} else {
				LOG.warn(""Recommendername: "" + recommendername
						+ "" was not found. Using default recommender (SlopeOneRecommeder)."");
				try {
					recommender = DEFAULT_RECOMMENDER.getDeclaredConstructor().newInstance();
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (InvocationTargetException e) {
					e.printStackTrace();
				} catch (NoSuchMethodException e) {
					e.printStackTrace();
				} catch (SecurityException e) {
					e.printStackTrace();
				}
			}
		} catch (InstantiationException | IllegalAccessException e) {
			// if creating a new instance fails
			e.printStackTrace();
			LOG.warn(""Could not create an instance of the requested recommender. Using fallback."");
			recommender = fallbackrecommender;
		} catch (NamingException e) {
			// if nothing was set
			LOG.info(""Recommender not set. Using default recommender (SlopeOneRecommeder)."");
			try {
				try {
					recommender = DEFAULT_RECOMMENDER.getDeclaredConstructor().newInstance();
				} catch (IllegalArgumentException e1) {
					e1.printStackTrace();
				} catch (InvocationTargetException e1) {
					e1.printStackTrace();
				} catch (NoSuchMethodException e1) {
					e1.printStackTrace();
				} catch (SecurityException e1) {
					e1.printStackTrace();
				}
			} catch (InstantiationException | IllegalAccessException e1) {
				// also the default algorithm could fail
				e1.printStackTrace();
				LOG.warn(""Could not create an instance of DEFAULT_RECOMMENDER "" + DEFAULT_RECOMMENDER.getName() + ""."");
				recommender = fallbackrecommender;
			}
		}
	}

	@Override
	public List<Long> recommendProducts(Long userid, List<OrderItem> currentItems)
			throws UnsupportedOperationException {
		try {
			return recommender.recommendProducts(userid, currentItems);
		} catch (UseFallBackException e) {
			// a UseFallBackException is usually ignored (as it is conceptual and might
			// occur quite often)
			LOG.trace(""Executing "" + recommender.getClass().getName()
					+ "" as recommender failed. Using fallback recommender. Reason:\n"" + e.getMessage());
			return fallbackrecommender.recommendProducts(userid, currentItems);
		} catch (UnsupportedOperationException e) {
			// if algorithm is not yet trained, we throw the error
			LOG.error(""Executing "" + recommender.getClass().getName()
					+ "" threw an UnsupportedOperationException. The recommender was not finished with training."");
			throw e;
		} catch (Exception e) {
			// any other exception is just reported
			LOG.warn(""Executing "" + recommender.getClass().getName()
					+ "" threw an unexpected error. Using fallback recommender. Reason:\n"" + e.getMessage());
			return fallbackrecommender.recommendProducts(userid, currentItems);
		}
	}

	/**
	 * Returns the instance of this Singleton or creates a new one, if this is the
	 * first call of this method.
	 * 
	 * @return The instance of this class.
	 */
	public static synchronized RecommenderSelector getInstance() {
		if (instance == null) {
			 instance = new RecommenderSelector();
		}
		return instance;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.IRecommender#train(java.util.List,
	 * java.util.List)
	 */
	@Override
	public void train(List<OrderItem> orderItems, List<Order> orders) {
		recommender.train(orderItems, orders);
		fallbackrecommender.train(orderItems, orders);
	}

}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/algorithm/IRecommender.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import java.util.List;

import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Interface providing the recommender functionality.
 * 
 * @author Johannes Grohmann
 *
 */
public interface IRecommender {

	/**
	 * Trains this recommender with the given list of historical {@link OrderItems}s
	 * and {@link Order}s. This list is used as knowledge basis for the recommending
	 * in {@link IRecommender#recommendProducts(List)}.<br>
	 * The mapping of the different {@link OrderItem}s to their corresponding
	 * {@link Order}s is done via {@link OrderItem#getOrderId()}.<br>
	 * Calling this method twice will trigger a retraining.
	 * 
	 * @param orderItems
	 *            A list of {@link OrderItem}s that were placed by users.
	 * @param orders
	 *            A list of {@link Order}s that were placed by users.
	 */
	public void train(List<OrderItem> orderItems, List<Order> orders);

	/**
	 * Return a list of all {@link Product}s, which are recommended for the given
	 * {@link User} buying the given list of {@link OrderItem}s. <br>
	 * {@link IRecommender#train(List)} must be called before any recommendations
	 * can be executed.
	 * 
	 * @param currentItems
	 *            A list containing all {@link OrderItem}s in the current cart.
	 *            Might be empty.
	 * @param userid
	 *            The id of the {@link User} to recommend for. May be null.
	 * @return List of all IDs of the {@link Product} entities that are recommended
	 *         to add to the cart. Does not contain any {@link Product} that is
	 *         already part of the given list of {@link OrderItem}s. Might be empty.
	 * 
	 * @throws UnsupportedOperationException
	 *             If this instance is not ready to recommend, i.e.,
	 *             {@link IRecommender#train(List)} has not been invoked or
	 *             terminated yet.
	 */
	public List<Long> recommendProducts(Long userid, List<OrderItem> currentItems) throws UnsupportedOperationException;

}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/algorithm/OrderItemSet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import java.util.HashMap;
import java.util.Map;

import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Objects of this class holds a mapping of {@link Product} IDs to quantities
 * that were bought in the same {@link Order} by one {@link User}. Non-present
 * {@link Product} IDs imply a quantity of 0.
 * 
 * @author Johannes Grohmann
 *
 */
public class OrderItemSet {

	/**
	 * Standard constructor.
	 */
	public OrderItemSet() {
		orderset = new HashMap<>();
	}

	/**
	 * The user that made this order.
	 */
	private long userId;

	/**
	 * The orderId that the Items were bought in.
	 */
	private long orderId;

	/**
	 * The productIds that were bought together with the given quantity.
	 */
	private Map<Long, Integer> orderset;

	/**
	 * @return the orderset
	 */
	public Map<Long, Integer> getOrderset() {
		return orderset;
	}

	/**
	 * @param orderset
	 *            the orderset to set
	 */
	public void setOrderset(Map<Long, Integer> orderset) {
		this.orderset = orderset;
	}

	/**
	 * @return the orderId
	 */
	public long getOrderId() {
		return orderId;
	}

	/**
	 * @param orderId
	 *            the orderId to set
	 */
	public void setOrderId(long orderId) {
		this.orderId = orderId;
	}

	/**
	 * @return the userId
	 */
	public long getUserId() {
		return userId;
	}

	/**
	 * @param userId the userId to set
	 */
	public void setUserId(long userId) {
		this.userId = userId;
	}
}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/algorithm/impl/pop/PopularityBasedRecommender.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm.impl.pop;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import tools.descartes.teastore.recommender.algorithm.AbstractRecommender;

/**
 * A simple Recommender that makes recommendations based on general popularity.
 * 
 * @author Johannes Grohmann
 *
 */
public class PopularityBasedRecommender extends AbstractRecommender {

	/**
	 * Map with all product IDs and their corresponding total purchase counts.
	 */
	private HashMap<Long, Double> counts;

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommender#
	 * execute( java.util.List)
	 */
	@Override
	protected List<Long> execute(Long userid, List<Long> currentItems) {
		return filterRecommendations(counts, currentItems);
	}

	@Override
	protected void executePreprocessing() {
		// assigns each product a quantity
		counts = new HashMap<>();
		// calculate product frequencies
		for (Map<Long, Double> usermap : getUserBuyingMatrix().values()) {
			for (Entry<Long, Double> product : usermap.entrySet()) {
				if (!counts.containsKey(product.getKey())) {
					counts.put(product.getKey(), product.getValue());
				} else {
					counts.put(product.getKey(), counts.get(product.getKey()) + product.getValue());
				}
			}
		}

	}
}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/algorithm/impl/cf/PreprocessedSlopeOneRecommender.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm.impl.cf;

import java.util.HashMap;
import java.util.Map;

/**
 * Recommender based on item-based collaborative filtering with the slope one
 * algorithm.
 * 
 * @author Johannes Grohmann
 *
 */
public class PreprocessedSlopeOneRecommender extends SlopeOneRecommender {

	/**
	 * Represents a matrix, assigning each user a calculated score for each item.
	 * This score can be used to recommend items.
	 */
	private Map<Long, Map<Long, Double>> predictedRatings;

	/**
	 * @return the predictedRatings
	 */
	public Map<Long, Map<Long, Double>> getPredictedRatings() {
		return predictedRatings;
	}

	/**
	 * @param predictedRatings
	 *            the predictedRatings to set
	 */
	public void setPredictedRatings(Map<Long, Map<Long, Double>> predictedRatings) {
		this.predictedRatings = predictedRatings;
	}

	@Override
	protected Map<Long, Double> getUserVector(Long userid) {
		// improve performance by preprocessing and storing userids
		return predictedRatings.get(userid);
	}

	@Override
	protected void executePreprocessing() {
		super.executePreprocessing();
		predictedRatings = new HashMap<>();
		// Moving the matrix calculation to the preprocessing to optimize runtime
		// behavior
		for (Long userid : getUserBuyingMatrix().keySet()) {
			// for all known users
			Map<Long, Double> pred = super.getUserVector(userid);
			predictedRatings.put(userid, pred);
		}
	}
}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/algorithm/impl/cf/SlopeOneRecommender.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm.impl.cf;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import tools.descartes.teastore.recommender.algorithm.AbstractRecommender;
import tools.descartes.teastore.recommender.algorithm.impl.UseFallBackException;

/**
 * Recommender based on item-based collaborative filtering with the slope one
 * algorithm.
 * 
 * @author Johannes Grohmann
 *
 */
public class SlopeOneRecommender extends AbstractRecommender {

	/**
	 * Represents a matrix, assigning each itemid an average difference (in
	 * rating/buying) to any other itemid.
	 */
	private Map<Long, Map<Long, Double>> differences = new HashMap<>();

	/**
	 * Represents a matrix, counting the frequencies of each combination (i.e. users
	 * rating/buying both items).
	 */
	private Map<Long, Map<Long, Integer>> frequencies = new HashMap<>();

	/**
	 * @return the differences
	 */
	public Map<Long, Map<Long, Double>> getDifferences() {
		return differences;
	}

	/**
	 * @param differences
	 *            the differences to set
	 */
	public void setDifferences(Map<Long, Map<Long, Double>> differences) {
		this.differences = differences;
	}

	/**
	 * @return the frequencies
	 */
	public Map<Long, Map<Long, Integer>> getFrequencies() {
		return frequencies;
	}

	/**
	 * @param frequencies
	 *            the frequencies to set
	 */
	public void setFrequencies(Map<Long, Map<Long, Integer>> frequencies) {
		this.frequencies = frequencies;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommender#
	 * execute(java.util.List)
	 */
	@Override
	protected List<Long> execute(Long userid, List<Long> currentItems) {
		if (userid == null) {
			throw new UseFallBackException(this.getClass().getName()
					+ "" does not support null userids. Use a pseudouser or switch to another approach."");
		}
		if (getUserBuyingMatrix().get(userid) == null) {
			// this user has not bought anything yet, so we do not have any information
			throw new UseFallBackException(""No user information."");
		}
		Map<Long, Double> importances = getUserVector(userid);
		return filterRecommendations(importances, currentItems);

	}

	/**
	 * Generates one row of the matrix for the given user. (Predicts the user score
	 * for each product ID.)
	 * 
	 * @param userid
	 *            The user to predict for
	 * @return A Map assigning each product ID a (predicted) score (for the given
	 *         user)
	 */
	protected Map<Long, Double> getUserVector(Long userid) {
		// This could be further optimized by moving this part into the pre-processing
		// step, but we want to have nicer performance behavior
		HashMap<Long, Double> importances = new HashMap<>();
		for (Long productid : getTotalProducts()) {
			try {
				importances.put(productid, calculateScoreForItem(userid, productid));
			} catch (NullPointerException e) {
				// this exception can be thrown if we have not enough information
				importances.put(productid, -1.0);
			}
		}
		return importances;
	}

	private double calculateScoreForItem(long userid, long itemid) {
		double score = 0;
		double cumWeights = 0;
		for (Entry<Long, Double> useritem : getUserBuyingMatrix().get(userid).entrySet()) {
			// if we find that the user actually bought this item before, we can return this
			// value
			// (considering it is his rating, we can directly return this rating)
			if (useritem.getKey() == itemid) {
				return useritem.getValue();
			}
			// if not, we can calculate the (expected) rating for that user based on item i
			int frequency = frequencies.get(useritem.getKey()).get(itemid);
			score += useritem.getValue() * frequency;
			score += differences.get(useritem.getKey()).get(itemid) * frequency;
			cumWeights += frequency;
		}
		// normalize
		return score / cumWeights;
	}

	@Override
	protected void executePreprocessing() {
		// The buying matrix is considered to be the rating
		// i.e. the more buys, the higher the rating
		buildDifferencesMatrices(getUserBuyingMatrix());
	}

	/**
	 * Based on the available data, calculate the relationships between the items
	 * and number of occurrences. Fill the difference and frequencies matrix.
	 * 
	 * @param data
	 *            The user rating matrix
	 */
	private void buildDifferencesMatrices(Map<Long, Map<Long, Double>> userRatingMatrix) {
		for (Map<Long, Double> uservalues : userRatingMatrix.values()) {
			for (Entry<Long, Double> singleRating : uservalues.entrySet()) {
				// if not present -> create
				if (!frequencies.containsKey(singleRating.getKey())) {
					frequencies.put(singleRating.getKey(), new HashMap<Long, Integer>());
					differences.put(singleRating.getKey(), new HashMap<Long, Double>());
				}
				// for all other ratings of that user
				for (Entry<Long, Double> otherRating : uservalues.entrySet()) {
					int currCount = 0;
					Integer count = frequencies.get(singleRating.getKey()).get(otherRating.getKey());
					if (count != null) {
						// count is != null, if the key is actually found
						// if so, we use the known count value as count, otherwise the count until now
						// is 0
						currCount = count.intValue();
					}

					double currDiff = 0;
					Double diff = differences.get(singleRating.getKey()).get(otherRating.getKey());
					if (diff != null) {
						// diff is != null, if the key is actually found
						// if so, we use the known difference value as currDiff, otherwise the diff
						// until now is 0.0
						currDiff = diff.doubleValue();
					}

					// get the diff value of this user
					double userdiff = singleRating.getValue() - otherRating.getValue();
					frequencies.get(singleRating.getKey()).put(otherRating.getKey(), currCount + 1);
					differences.get(singleRating.getKey()).put(otherRating.getKey(), currDiff + userdiff);
				}
			}
		}

		// now, transform the differences matrix into real differences (not just the sum
		// of all found differences)
		for (Long i : differences.keySet()) {
			for (Long j : differences.get(i).keySet()) {
				// for all matrix entries divide the differences by the sum of occurences
				double diffval = differences.get(i).get(j);
				double freq = frequencies.get(i).get(j);
				differences.get(i).put(j, diffval / freq);
			}
		}
	}
}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/algorithm/impl/UseFallBackException.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm.impl;

/**
 * This exception signals a (mostly) conceptual error or lack of information,
 * why the current recommending approach can not be applied. Therefore the
 * calling instance should go for the robust fall-back solution in this case.
 * 
 * @author Johannes
 *
 */
public class UseFallBackException extends RuntimeException {

	/**
	 * @param string
	 *            The error message.
	 */
	public UseFallBackException(String string) {
		super(string);
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 2503876420753158905L;

}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/algorithm/impl/DummyRecommender.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm.impl;

import java.util.ArrayList;
import java.util.List;

import tools.descartes.teastore.recommender.algorithm.AbstractRecommender;

/**
 * Temporary class to be replaced by something actually useful.
 * 
 * @author Johannes Grohmann
 *
 */
public class DummyRecommender extends AbstractRecommender {
	
	/* (non-Javadoc)
	 * @see tools.descartes.teastore.recommender.algorithm.AbstractRecommender#execute(java.util.List)
	 */
	@Override
	protected List<Long> execute(Long userid, List<Long> currentItems) {
		List<Long> recommended = new ArrayList<Long>();
		recommended.add(-1L);
		return recommended;
	}

}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/algorithm/impl/orderbased/OrderBasedRecommender.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm.impl.orderbased;

import java.util.HashMap;
import java.util.List;
import java.util.Set;

import tools.descartes.teastore.recommender.algorithm.AbstractRecommender;
import tools.descartes.teastore.recommender.algorithm.OrderItemSet;
import tools.descartes.teastore.recommender.algorithm.impl.UseFallBackException;

/**
 * A simple Recommender that makes recommendations based on an order-based
 * nearest-neighbor heuristic.
 * 
 * @author Johannes Grohmann
 *
 */
public class OrderBasedRecommender extends AbstractRecommender {

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommender#
	 * execute( java.util.List)
	 */
	@Override
	protected List<Long> execute(Long userid, List<Long> currentItems) {
		// Map with all product IDs and how often they have been bought in the same cart
		// with one of the items in the current cart
		HashMap<Long, Double> counts = new HashMap<>();
		// treat all products in the current cart equally, and sum all the occurrences
		for (Long product : currentItems) {
			addAllCountsOfProduct(counts, product);
		}

		if (counts.isEmpty()) {
			throw new UseFallBackException(
					""No item was bought together with the current cart. Therefore, all counts are 0."");
		}

		// the count list contains all items in the current cart
		// however, this is fine, as it is filtered
		return filterRecommendations(counts, currentItems);
	}

	/**
	 * Adds the counts of the given product to the given count list.
	 * 
	 * @param counts
	 *            The count list, assinging each product id, how often it was bought
	 *            with the given product.
	 * @param product
	 *            The product id of the specific product.
	 */
	private void addAllCountsOfProduct(HashMap<Long, Double> counts, Long product) {
		for (Set<OrderItemSet> set : getUserItemSets().values()) {
			// ignore which user bought which set
			for (OrderItemSet orderset : set) {
				// look through all orders bought
				if (orderset.getOrderset().keySet().contains(product)) {
					for (Long o : orderset.getOrderset().keySet()) {
						// we count all order of the set (including the product we are currently looking
						// at)
						if (counts.containsKey(o)) {
							// we do not count the NUMBER of items, just if the item occurred in the order
							counts.put(o, counts.get(o) + 1);
						} else {
							counts.put(o, 1.0);
						}
					}
				}
			}
		}
	}
}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/servlet/RecommenderStartup.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.servlet;

import javax.naming.InitialContext;
import javax.naming.NamingException;
import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.opentracing.util.GlobalTracer;
import tools.descartes.teastore.registryclient.RegistryClient;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.tracing.Tracing;
import tools.descartes.teastore.registryclient.util.RESTClient;

/**
 * Startup Handler for the Recommender Service.
 *
 * @author Simon Eismann, Johannes Grohmann
 *
 */
@WebListener
public class RecommenderStartup implements ServletContextListener {

	private static final int REST_READ_TIMOUT = 1750;

	private static final Logger LOG = LoggerFactory.getLogger(RecommenderStartup.class);

	/**
	 * Also set this accordingly in RegistryClientStartup.
	 */

	/**
	 * Empty constructor.
	 */
	public RecommenderStartup() {

	}

	/**
	 * @see ServletContextListener#contextDestroyed(ServletContextEvent)
	 * @param event
	 *            The servlet context event at destruction.
	 */
	public void contextDestroyed(ServletContextEvent event) {
		RegistryClient.getClient().unregister(event.getServletContext().getContextPath());
	}

	/**
	 * @see ServletContextListener#contextInitialized(ServletContextEvent)
	 * @param event
	 *            The servlet context event at initialization.
	 */
	public void contextInitialized(ServletContextEvent event) {
		GlobalTracer.register(Tracing.init(Service.RECOMMENDER.getServiceName()));
		RESTClient.setGlobalReadTimeout(REST_READ_TIMOUT);
		ServiceLoadBalancer.preInitializeServiceLoadBalancers(Service.PERSISTENCE);
		RegistryClient.getClient().runAfterServiceIsAvailable(Service.PERSISTENCE, () -> {
			TrainingSynchronizer.getInstance().retrieveDataAndRetrain();
			RegistryClient.getClient().register(event.getServletContext().getContextPath());
		}, Service.RECOMMENDER);
		try {
			long looptime = (Long) new InitialContext().lookup(""java:comp/env/recommenderLoopTime"");
			// if a looptime is specified, a retraining daemon is started
			if (looptime > 0) {
				new RetrainDaemon(looptime).start();
				LOG.info(""Periodic retraining every "" + looptime + "" milliseconds"");
			} else {
				LOG.info(""Recommender loop time not set. Disabling periodic retraining."");
			}
		} catch (NamingException e) {
			LOG.info(""Recommender loop time not set. Disabling periodic retraining."");
		}

	}

}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/servlet/IndexServlet.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.servlet;

import java.io.IOException;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Index Servlet for the Recommender Component. Provides some basic debug
 * information for deployers and testers.
 * 
 * @author Johannes Grohmann
 */
@WebServlet(""/index"")
public class IndexServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * @see HttpServlet#HttpServlet()
	 */
	public IndexServlet() {
		super();
	}

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse
	 *      response)
	 * @param request
	 *            The request.
	 * @param response
	 *            The response.
	 * @throws ServletException
	 *             In case of servlet Exception.
	 * @throws IOException
	 *             In case of IOException.
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.getWriter().println(""This is the recommender module running at "" + request.getProtocol() + ""://""
				+ request.getLocalAddr() + "":"" + request.getLocalPort() + ""/"" + request.getContextPath());
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse
	 *      response)
	 * @param request
	 *            The request.
	 * @param response
	 *            The response.
	 * @throws ServletException
	 *             In case of servlet Exception.
	 * @throws IOException
	 *             In case of IOException.
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}

}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/servlet/RetrainDaemon.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.servlet;

import tools.descartes.teastore.registryclient.RegistryClient;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.StartupCallback;

/**
 * DaemonThread for periodic retraining if required.
 * 
 * @author Johannes Grohmann
 */
public class RetrainDaemon extends Thread {

	/**
	 * The time between retraining in milliseconds.
	 */
	private long looptime;

	/**
	 * Constructor.
	 * 
	 * @param looptime
	 *            The time between retraining in milliseconds
	 */
	public RetrainDaemon(long looptime) {
		super();
		// set as daemon thread
		setDaemon(true);
		this.looptime = looptime;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Runnable#run()
	 */
	@Override
	public void run() {
		super.run();
		// repeat until stopped
		while (true) {
			try {
				Thread.sleep(looptime);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			// wait for the persistance service and then retrain
			RegistryClient.getClient().runAfterServiceIsAvailable(Service.PERSISTENCE, new StartupCallback() {
				@Override
				public void callback() {
					TrainingSynchronizer.getInstance().retrieveDataAndRetrain();
				}
			}, Service.RECOMMENDER);
		}

	}

}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/servlet/TrainingSynchronizer.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.servlet;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.TemporalAccessor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.recommender.algorithm.RecommenderSelector;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.rest.LoadBalancedCRUDOperations;
import tools.descartes.teastore.registryclient.util.NotFoundException;
import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;

/**
 * This class organizes the communication with the other services and
 * synchronizes on startup and training.
 *
 * @author Johannes Grohmann
 *
 */
public final class TrainingSynchronizer {

	/**
	 * This value signals that the maximum training time is not known.
	 */
	public static final long DEFAULT_MAX_TIME_VALUE = Long.MIN_VALUE;

	// Longest wait period before querying the persistence again if it is finished
	// creating entries
	private static final int PERSISTENCE_CREATION_MAX_WAIT_TIME = 120000;
	// Wait time in ms before checking again for an existing persistence service
	private static final List<Integer> PERSISTENCE_CREATION_WAIT_TIME = Arrays.asList(1000, 2000, 5000, 10000, 30000,
			60000);

	private static TrainingSynchronizer instance;

	private boolean isReady = false;

	/**
	 * @return the isReady
	 */
	public boolean isReady() {
		return isReady;
	}

	/**
	 * @param isReady
	 *            the isReady to set
	 */
	public void setReady(boolean isReady) {
		this.isReady = isReady;
	}

	private TrainingSynchronizer() {

	}

	/**
	 * Returns the instance for this singleton.
	 *
	 * @return An instance of {@link TrainingSynchronizer}
	 */
	public static synchronized TrainingSynchronizer getInstance() {
		if (instance == null) {
			instance = new TrainingSynchronizer();
		}
		return instance;
	}

	private static final Logger LOG = LoggerFactory.getLogger(TrainingSynchronizer.class);

	/**
	 * The maximum considered time in milliseconds. DEFAULT_MAX_TIME_VALUE signals
	 * no entry, e.g. all orders are used for training.
	 */
	private long maxTime = DEFAULT_MAX_TIME_VALUE;

	/**
	 * @return the maxTime
	 */
	public long getMaxTime() {
		return maxTime;
	}

	/**
	 * @param maxTime
	 *            the maxTime to set
	 */
	public void setMaxTime(String maxTime) {
		setMaxTime(toMillis(maxTime));
	}

	/**
	 * @param maxTime
	 *            the maxTime to set
	 */
	public void setMaxTime(long maxTime) {
		this.maxTime = maxTime;
	}

	private void waitForPersistence() {
		// We have to wait for the database that all entries are created before
		// generating images (which queries persistence). Yes we want to wait forever in
		// case the persistence is
		// not answering.
		Iterator<Integer> waitTimes = PERSISTENCE_CREATION_WAIT_TIME.iterator();
		while (true) {
			Response result = null;
			try {
				result = ServiceLoadBalancer.loadBalanceRESTOperation(Service.PERSISTENCE, ""generatedb"", String.class,
						client -> client.getService().path(client.getApplicationURI()).path(client.getEndpointURI())
								.path(""finished"").request().get());

								if (result != null && Boolean.parseBoolean(result.readEntity(String.class))) {
									break;
				}
			} catch (NullPointerException | NotFoundException | LoadBalancerTimeoutException e) {
				// continue waiting as usual
			} finally {
				if (result != null) {
					result.close();
				}
			}
			try {
				int nextWaitTime;
				if (waitTimes.hasNext()) {
					nextWaitTime = waitTimes.next();
				} else {
					nextWaitTime = PERSISTENCE_CREATION_MAX_WAIT_TIME;
				}
				LOG.info(""Persistence not reachable. Waiting for {}ms."", nextWaitTime);
				Thread.sleep(nextWaitTime);
			} catch (InterruptedException interrupted) {
				LOG.warn(""Thread interrupted while waiting for persistence to be available."", interrupted);
			}
		}
	}

	/**
	 * Connects via REST to the database and retrieves all {@link OrderItem}s and
	 * all {@link Order}s. Then, it triggers the training of the recommender.
	 *
	 * @return The number of elements retrieved from the database or -1 if the
	 *         process failed.
	 */
	public long retrieveDataAndRetrain() {
		setReady(false);
		LOG.trace(""Retrieving data objects from database..."");

		waitForPersistence();

		List<OrderItem> items = null;
		List<Order> orders = null;
		// retrieve
		try {
			items = LoadBalancedCRUDOperations.getEntities(Service.PERSISTENCE, ""orderitems"", OrderItem.class, -1, -1);
			long noItems = items.size();
			LOG.trace(""Retrieved "" + noItems + "" orderItems, starting retrieving of orders now."");
		} catch (NotFoundException | LoadBalancerTimeoutException e) {
			// set ready anyway to avoid deadlocks
			setReady(true);
			LOG.error(""Database retrieving failed."");
			return -1;
		}
		try {
			orders = LoadBalancedCRUDOperations.getEntities(Service.PERSISTENCE, ""orders"", Order.class, -1, -1);
			long noOrders = orders.size();
			LOG.trace(""Retrieved "" + noOrders + "" orders, starting training now."");
		} catch (NotFoundException | LoadBalancerTimeoutException e) {
			// set ready anyway to avoid deadlocks
			setReady(true);
			LOG.error(""Database retrieving failed."");
			return -1;
		}
		// filter lists
		filterLists(items, orders);
		// train instance
		RecommenderSelector.getInstance().train(items, orders);
		LOG.trace(""Finished training, ready for recommendation."");
		setReady(true);
		return items.size() + orders.size();
	}

	private void filterLists(List<OrderItem> orderItems, List<Order> orders) {
		// since we are not registered ourselves, we can multicast to all services
		List<Response> maxTimeResponses = ServiceLoadBalancer.multicastRESTOperation(Service.RECOMMENDER,
				""train/timestamp"", Response.class,
				client -> client.getService().path(client.getApplicationURI()).path(client.getEndpointURI())
						.request(MediaType.TEXT_PLAIN).accept(MediaType.TEXT_PLAIN).get());
		for (Response response : maxTimeResponses) {
			if (response == null) {
				LOG.warn(""One service response was null and is therefore not available for time-check."");
			} else if (response.getStatus() == Response.Status.OK.getStatusCode()) {
				// only consider if status was fine
				long milliTS = response.readEntity(Long.class);
				if (maxTime != TrainingSynchronizer.DEFAULT_MAX_TIME_VALUE && maxTime != milliTS) {
					LOG.warn(""Services disagree about timestamp: "" + maxTime + "" vs "" + milliTS
							+ "". Therfore using the minimum."");
				}
				maxTime = Math.min(maxTime, milliTS);
			} else {
				// release connection by buffering entity
				response.bufferEntity();
				LOG.warn(""Service "" + response + ""was not available for time-check."");
			}
		}
		if (maxTime == Long.MIN_VALUE) {
			// we are the only known service
			// therefore we find max and set it
			for (Order or : orders) {
				maxTime = Math.max(maxTime, toMillis(or.getTime()));
			}
		}
		filterForMaxtimeStamp(orderItems, orders);
	}

	private void filterForMaxtimeStamp(List<OrderItem> orderItems, List<Order> orders) {
		// filter orderItems and orders and ignore newer entries.
		List<Order> remove = new ArrayList<>();
		for (Order or : orders) {
			if (toMillis(or.getTime()) > maxTime) {
				remove.add(or);
			}
		}
		orders.removeAll(remove);

		List<OrderItem> removeItems = new ArrayList<>();
		for (OrderItem orderItem : orderItems) {
			boolean contained = false;
			for (Order or : orders) {
				if (or.getId() == orderItem.getOrderId()) {
					contained = true;
				}
			}
			if (!contained) {
				removeItems.add(orderItem);
			}
		}
		orderItems.removeAll(removeItems);
	}

	private long toMillis(String date) {
		TemporalAccessor temporalAccessor = DateTimeFormatter.ISO_LOCAL_DATE_TIME.parse(date);
		LocalDateTime localDateTime = LocalDateTime.from(temporalAccessor);
		ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, ZoneId.systemDefault());
		Instant instant = Instant.from(zonedDateTime);
		return instant.toEpochMilli();
	}

}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/rest/TrainEndpoint.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.rest;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.recommender.algorithm.IRecommender;
import tools.descartes.teastore.recommender.servlet.TrainingSynchronizer;
import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;

/**
 * REST endpoint to trigger the (re)training of the Recommender.
 *
 * @author Johannes Grohmann
 *
 */
@Path(""train"")
@Produces({ ""text/plain"", ""application/json"" })
public class TrainEndpoint {

	/**
	 * Triggers the training of the recommendation algorithm. It retrieves all data
	 * {@link OrderItem}s and all {@link Order}s from the database entity and is
	 * therefore both very network and computation time intensive. <br>
	 * This method must be called before the {@link RecommendEndpoint} is usable, as
	 * the {@link IRecommender} will throw an
	 * {@link UnsupportedOperationException}.<br>
	 * Calling this method a second time initiates a new training process from scratch.
	 *
	 * @return Returns a {@link Response} with
	 *         {@link jakarta.servlet.http.HttpServletResponse#SC_OK} or with
	 *         {@link jakarta.servlet.http.HttpServletResponse#SC_INTERNAL_SERVER_ERROR},
	 *         if the operation failed.
	 */
	@GET
	public Response train() {
		try {
			long start = System.currentTimeMillis();
			long number = TrainingSynchronizer.getInstance().retrieveDataAndRetrain();
			long time = System.currentTimeMillis() - start;
			if (number != -1) {
				return Response.ok(""The (re)train was succesfully done. It took "" + time + ""ms and "" + number
						+ "" of Orderitems were retrieved from the database."").build();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		// set ready to true anyway to avoid being stuck
		return Response.status(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode())
				.entity(""The (re)trainprocess failed."").build();
	}

	/**
	 * Returns the last time stamp, which was considered at the training of this
	 * instance.
	 *
	 * @return Returns a {@link Response} with
	 *         {@link jakarta.servlet.http.HttpServletResponse#SC_OK} containing the
	 *         maximum considered time as String or with
	 *         {@link jakarta.servlet.http.HttpServletResponse#SC_INTERNAL_SERVER_ERROR},
	 *         if the operation failed.
	 */
	@GET
	@Path(""timestamp"")
	public Response getTimeStamp() {
		if (TrainingSynchronizer.getInstance().getMaxTime() == TrainingSynchronizer.DEFAULT_MAX_TIME_VALUE) {
			return Response.status(Response.Status.PRECONDITION_FAILED.getStatusCode())
					.entity(""The collection of the current maxTime was not possible."").build();
		}
		return Response.ok(TrainingSynchronizer.getInstance().getMaxTime()).build();
	}

	/**
	 * This methods checks, if the service is ready to serve recommendation
	 * requests, i.e., if the algorithm has finished training and no retraining process
	 * is running. However, this does not imply that issuing a recommendation will
	 * fail, if this method returns false. For example, if a retraining is issued,
	 * the old trained instance might still answer issued requests until the new
	 * instance is fully trained. However, performance behavior is probably
	 * influenced.
	 *
	 * @return True, if recommender is ready; false, if not.
	 */
	@GET
	@Path(""isready"")
	public Response isReady() {
		if (TrainingSynchronizer.getInstance().isReady()) {
			return Response.ok(true).build();
		} else {
			return Response.serverError().entity(false).build();
		}
	}
}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/rest/RecommendEndpoint.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.rest;

import java.util.List;

import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.recommender.algorithm.RecommenderSelector;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Recommender REST endpoint.
 * 
 * @author Johannes Grohmann
 *
 */
@Path(""recommend"")
@Produces({ ""application/json"" })
@Consumes({ ""application/json"" })
public class RecommendEndpoint {

	/**
	 * Return a list of all {@link Product}s, that are recommended for the given
	 * {@link User} buying the given list of {@link OrderItem}s. <br>
	 * 
	 * The returning list does not contain any {@link Product} that is already part
	 * of the given list of {@link OrderItem}s. It might be empty, however.
	 * 
	 * @param currentItems
	 *            A list, containing all {@link OrderItem}s in the current cart.
	 *            Might be empty.
	 * @param uid
	 *            The id of the {@link User} to recommend for. May be null.
	 * @return List of {@link Long} objects, containing all {@link Product} IDs that
	 *         are recommended to add to the cart, or an INTERNALSERVERERROR, if the
	 *         recommendation failed.
	 */
	@POST
	public Response recommend(List<OrderItem> currentItems, @QueryParam(""uid"") final Long uid) {
		List<Long> recommended = RecommenderSelector.getInstance().recommendProducts(uid, currentItems);
		return Response.ok().entity(recommended).build();
	}
}"
services/tools.descartes.teastore.recommender/src/main/java/tools/descartes/teastore/recommender/rest/RecommendSingleEndpoint.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.rest;

import java.util.LinkedList;
import java.util.List;

import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.recommender.algorithm.RecommenderSelector;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Recommender REST endpoint for single recommendation.
 * 
 * @author Johannes Grohmann
 *
 */
@Path(""recommendsingle"")
@Produces({ ""application/json"" })
@Consumes({ ""application/json"" })
public class RecommendSingleEndpoint {

	/**
	 * Return a list of all {@link Product}s, that are recommended for the given
	 * {@link User} buying the given {@link OrderItem}. <br>
	 * 
	 * The returning list does not contain the {@link Product} of the respective
	 * {@link OrderItem}. It might be empty, however.
	 * 
	 * @param item
	 *            An {@link OrderItem} to use as recommender. Must not be null.
	 * @param uid
	 *            The id of the {@link User} to recommend for. May be null.
	 * @return List of {@link Long} objects, containing all {@link Product} IDs that
	 *         are recommended to add to the cart, or an INTERNALSERVERERROR, if the
	 *         recommendation failed.
	 */
	@POST
	public Response recommend(OrderItem item, @QueryParam(""uid"") final Long uid) {
		if (item == null) {
			throw new NullPointerException(""OrderItem must not be null."");
		}
		LinkedList<OrderItem> list = new LinkedList<OrderItem>();
		list.add(item);
		List<Long> recommended = RecommenderSelector.getInstance().recommendProducts(uid, list);
		return Response.ok().entity(recommended).build();
	}
}"
utilities/tools.descartes.teastore.kieker.probes/src/main/java/tools/descartes/teastore/kieker/probes/AbstractOperationExecutionWithParameterAspect.java,"package tools.descartes.teastore.kieker.probes;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import kieker.common.record.controlflow.OperationExecutionRecord;
import kieker.monitoring.core.controller.IMonitoringController;
import kieker.monitoring.core.controller.MonitoringController;
import kieker.monitoring.core.registry.ControlFlowRegistry;
import kieker.monitoring.core.registry.SessionRegistry;
import kieker.monitoring.probe.aspectj.AbstractAspectJProbe;
import kieker.monitoring.timer.ITimeSource;
import tools.descartes.teastore.entities.ImageSize;
import tools.descartes.teastore.entities.message.SessionBlob;
import tools.descartes.teastore.kieker.probes.records.OperationExecutionWithParametersRecord;

/**
 * Probe to log execution times plus parameter values with Kieker.
 *
 * @author Johannes Grohmann
 *
 */
@Aspect
public abstract class AbstractOperationExecutionWithParameterAspect extends AbstractAspectJProbe {
  private static final Logger LOG = LoggerFactory
      .getLogger(AbstractOperationExecutionWithParameterAspect.class);

  private static final IMonitoringController CTRLINST = MonitoringController.getInstance();
  private static final ITimeSource TIME = CTRLINST.getTimeSource();
  private static final String VMNAME = CTRLINST.getHostname();
  private static final ControlFlowRegistry CFREGISTRY = ControlFlowRegistry.INSTANCE;
  private static final SessionRegistry SESSIONREGISTRY = SessionRegistry.INSTANCE;

  /**
   * The pointcut for the monitored operations. Inheriting classes should extend
   * the pointcut in order to find the correct executions of the methods (e.g. all
   * methods or only methods with specific annotations).
   */
  @Pointcut
  public abstract void monitoredOperation();

  /**
   * actual pointcut.
   * @param thisJoinPoint joinpoint
   * @return result of joinpoint
   * @throws Throwable possible errors
   */
  @Around(""monitoredOperation() && notWithinKieker()"")
  public Object operation(final ProceedingJoinPoint thisJoinPoint) throws Throwable { // NOCS
                                                                                      // (Throwable)
    if (!CTRLINST.isMonitoringEnabled()) {
      return thisJoinPoint.proceed();
    }
    final String signature = this.signatureToLongString(thisJoinPoint.getSignature());
    if (!CTRLINST.isProbeActivated(signature)) {
      return thisJoinPoint.proceed();
    }
    // collect data
    final boolean entrypoint;
    final String hostname = VMNAME;
    final String sessionId = SESSIONREGISTRY.recallThreadLocalSessionId();
    final int eoi; // this is executionOrderIndex-th execution in this trace
    final int ess; // this is the height in the dynamic call tree of this execution
    long traceId = CFREGISTRY.recallThreadLocalTraceId(); // traceId, -1 if entry point
    if (traceId == -1) {
      entrypoint = true;
      traceId = CFREGISTRY.getAndStoreUniqueThreadLocalTraceId();
      CFREGISTRY.storeThreadLocalEOI(0);
      CFREGISTRY.storeThreadLocalESS(1); // next operation is ess + 1
      eoi = 0;
      ess = 0;
    } else {
      entrypoint = false;
      eoi = CFREGISTRY.incrementAndRecallThreadLocalEOI(); // ess > 1
      ess = CFREGISTRY.recallAndIncrementThreadLocalESS(); // ess >= 0
      if ((eoi == -1) || (ess == -1)) {
        LOG.error(""eoi and/or ess have invalid values:"" + "" eoi == "" + eoi + "" ess == "" + ess);
        CTRLINST.terminateMonitoring();
      }
    }
    // measure before
    final long tin = TIME.getTime();
    // execution of the called method
    Object retval = null;
    try {
      retval = thisJoinPoint.proceed();
    } finally {
      // measure after
      final long tout = TIME.getTime();
      // get parameters

      String flag = System.getenv(""LOG_PARAMETERS"");
      if (flag != null && (flag.equals(""true"") || flag.equals(""TRUE""))) {
        logWithParameter(thisJoinPoint, signature, sessionId, traceId, tin, tout, hostname, eoi,
            ess, retval);
      } else {
        logWithoutParameters(thisJoinPoint, signature, sessionId, traceId, tin, tout, hostname, eoi,
            ess, retval);
      }

      // cleanup
      if (entrypoint) {
        CFREGISTRY.unsetThreadLocalTraceId();
        CFREGISTRY.unsetThreadLocalEOI();
        CFREGISTRY.unsetThreadLocalESS();
      } else {
        CFREGISTRY.storeThreadLocalESS(ess); // next operation is ess
      }
    }
    return retval;
  }

  private void logWithParameter(final ProceedingJoinPoint thisJoinPoint, String signature,
      String sessionId, long traceId, long tin, long tout, String hostname, int eoi, int ess,
      Object retval) {
    /** extension over the original routine. */
    final String[] names = ((MethodSignature) thisJoinPoint.getSignature()).getParameterNames();

    final Object[] arguments = thisJoinPoint.getArgs();
    final String[] values = new String[arguments.length];

    int i = 0;
    for (final Object argument : arguments) {
      values[i] = parseObjectToString(argument);
      if (argument instanceof java.util.Collection && !names[i].endsWith("".size()"")) {
        names[i] = names[i] + "".size()"";
      }
      i++;
    }
    // get return type
    Class<?> returnClass = ((MethodSignature) thisJoinPoint.getSignature()).getReturnType();
    final String returnType;
    final String returnValue;
    if (returnClass.equals(Void.TYPE)) {
      // return type is void
      returnType = ""void"";
      returnValue = """";
    } else {
      // we have a return type
      returnType = returnClass.getName();
      returnValue = parseObjectToString(retval);
    }

    CTRLINST.newMonitoringRecord(new OperationExecutionWithParametersRecord(signature, sessionId,
        traceId, tin, tout, hostname, eoi, ess, names, values, returnType, returnValue));

  }

  private String parseObjectToString(Object argument) {
    if (argument == null) {
      return ""null"";
    }
    if (argument instanceof java.util.Collection) {
      // log collection size
      return String.valueOf(((java.util.Collection<?>) argument).size());
    }
    if (argument instanceof SessionBlob) {
      SessionBlob sb = (SessionBlob) argument;
      return String.valueOf(sb.getOrderItems().size());
    }

    if (argument instanceof ImageSize) {
      return String.valueOf(((ImageSize) argument).getPixelCount());
    }

    // all others are just to string
    String stringRepresentation = argument.toString();
    int stringLength = stringRepresentation.length();
    if (stringLength < 500) {
      return argument.toString();
    }
    return String.valueOf(stringLength);
  }

  private void logWithoutParameters(final ProceedingJoinPoint thisJoinPoint, String signature,
      String sessionId, long traceId, long tin, long tout, String hostname, int eoi, int ess,
      Object retval) {
    CTRLINST.newMonitoringRecord(
        new OperationExecutionRecord(signature, sessionId, traceId, tin, tout, hostname, eoi, ess));

  }
}"
utilities/tools.descartes.teastore.kieker.probes/src/main/java/tools/descartes/teastore/kieker/probes/records/OperationExecutionWithParametersRecord.java,"package tools.descartes.teastore.kieker.probes.records;

import java.nio.BufferOverflowException;

import kieker.common.record.controlflow.OperationExecutionRecord;
import kieker.common.record.io.IValueDeserializer;
import kieker.common.record.io.IValueSerializer;

/**
 * Class for storing the Monitored execution recrods with parameters.
 *
 * @author Johannes Grohmann
 *
 *         API compatibility: Kieker 1.13.0
 *
 */
public class OperationExecutionWithParametersRecord extends OperationExecutionRecord
    implements IPayloadCharacterization {

  private static final long serialVersionUID = 5027368663979062260L;

  /** Descriptive definition of the serialization size of the record. */
  private static final int SIZE = TYPE_SIZE_STRING // OperationExecutionRecord.operationSignature
      + TYPE_SIZE_STRING // OperationExecutionRecord.sessionId
      + TYPE_SIZE_LONG // OperationExecutionRecord.traceId
      + TYPE_SIZE_LONG // OperationExecutionRecord.tin
      + TYPE_SIZE_LONG // OperationExecutionRecord.tout
      + TYPE_SIZE_STRING // OperationExecutionRecord.hostname
      + TYPE_SIZE_INT // OperationExecutionRecord.eoi
      + TYPE_SIZE_INT // OperationExecutionRecord.ess
      + TYPE_SIZE_STRING // IPayloadCharacterization.parameterTypes
      + TYPE_SIZE_STRING // IPayloadCharacterization.parameterValues
      + TYPE_SIZE_STRING // IPayloadCharacterization.returnType
      + TYPE_SIZE_STRING; // IPayloadCharacterization.returnVal

  private static final Class<?>[] TYPES = { String.class, // OperationExecutionRecord.operationSignature
      String.class, // OperationExecutionRecord.sessionId
      long.class, // OperationExecutionRecord.traceId
      long.class, // OperationExecutionRecord.tin
      long.class, // OperationExecutionRecord.tout
      String.class, // OperationExecutionRecord.hostname
      int.class, // OperationExecutionRecord.eoi
      int.class, // OperationExecutionRecord.ess
      String[].class, // IPayloadCharacterization.parameterTypes
      String[].class, // IPayloadCharacterization.parameterValues
      String.class, // IPayloadCharacterization.returnType
      String.class, // IPayloadCharacterization.returnVal
  };

  /** property name array. */
  private static final String[] PROPERTY_NAMES = { ""operationSignature"", ""sessionId"", ""traceId"",
      ""tin"", ""tout"", ""hostname"", ""eoi"", ""ess"", ""parameterTypes"", ""parameterValues"", ""returnType"",
      ""returnValue"", };

  /** property declarations. */
  private final String[] parameterTypes;
  private final String[] parameterValues;
  private final String returnType;
  private final String returnValue;

  /**
   * Creates a new instance of this class using the given parameters.
   *
   * @param operationSignature string representation of operation signature
   * @param sessionId sessionid
   * @param traceId traceid
   * @param tin time in
   * @param tout time out
   * @param hostname hostname
   * @param eoi eoi
   * @param ess ess
   * @param parameterTypes array of parameter types
   * @param parameterValues array of parameter values
   * @param returnType return type
   * @param returnValue return value
   */
  public OperationExecutionWithParametersRecord(final String operationSignature,
      final String sessionId, final long traceId, final long tin, final long tout,
      final String hostname, final int eoi, final int ess, final String[] parameterTypes,
      final String[] parameterValues, final String returnType, final String returnValue) {
    super(operationSignature, sessionId, traceId, tin, tout, hostname, eoi, ess);
    this.parameterTypes = parameterTypes;
    this.parameterValues = parameterValues;
    this.returnType = returnType;
    this.returnValue = returnValue;
  }

  /**
   * Constructor.
   * @param deserializer
   *          The deserializer to use
   */
  public OperationExecutionWithParametersRecord(final IValueDeserializer deserializer) {
    super(deserializer);
    // load array sizes
    int parametersSize0 = deserializer.getInt();
    this.parameterTypes = new String[parametersSize0];
    for (int i0 = 0; i0 < parametersSize0; i0++) {
      this.parameterTypes[i0] = deserializer.getString();
  }
    // load array sizes
    int valuesSize0 = deserializer.getInt();
    this.parameterValues = new String[valuesSize0];
    for (int i0 = 0; i0 < valuesSize0; i0++) {
      this.parameterValues[i0] = deserializer.getString();
    }

    this.returnType = deserializer.getString();
    this.returnValue = deserializer.getString();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void serialize(final IValueSerializer serializer) throws BufferOverflowException {
    super.serialize(serializer);
    // store array sizes
    int parametersSize0 = this.getParameterTypes().length;
    serializer.putInt(parametersSize0);
    for (int i0 = 0; i0 < parametersSize0; i0++) {
      serializer.putString(this.getParameterTypes()[i0]);
  }
    // store array sizes
    int valuesSize0 = this.getParameterValues().length;
    serializer.putInt(valuesSize0);
    for (int i0 = 0; i0 < valuesSize0; i0++) {
      serializer.putString(this.getParameterValues()[i0]);
    }

    serializer.putString(this.getReturnType());
    serializer.putString(this.getReturnValue());
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Class<?>[] getValueTypes() {
    return TYPES; // NOPMD
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public String[] getValueNames() {
    return PROPERTY_NAMES; // NOPMD
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public int getSize() {
    return SIZE;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean equals(final Object obj) {
    if (obj == null) {
      return false;
    }
    if (obj == this) {
      return true;
    }
    if (obj.getClass() != this.getClass()) {
      return false;
    }

    final OperationExecutionWithParametersRecord castedRecord = (OperationExecutionWithParametersRecord) obj;
    if (this.getLoggingTimestamp() != castedRecord.getLoggingTimestamp()) {
      return false;
    }
    if (!this.getOperationSignature().equals(castedRecord.getOperationSignature())) {
      return false;
    }
    if (!this.getSessionId().equals(castedRecord.getSessionId())) {
      return false;
    }
    if (this.getTraceId() != castedRecord.getTraceId()) {
      return false;
    }
    if (this.getTin() != castedRecord.getTin()) {
      return false;
    }
    if (this.getTout() != castedRecord.getTout()) {
      return false;
    }
    if (!this.getHostname().equals(castedRecord.getHostname())) {
      return false;
    }
    if (this.getEoi() != castedRecord.getEoi()) {
      return false;
    }
    if (this.getEss() != castedRecord.getEss()) {
      return false;
    }
    if (!this.getReturnType().equals(castedRecord.getReturnType())) {
      return false;
    }
    if (!this.getReturnValue().equals(castedRecord.getReturnValue())) {
      return false;
    }
    // get array length
    int parametersSize0 = this.getParameterTypes().length;
    if (parametersSize0 != castedRecord.getParameterTypes().length) {
      return false;
    }
    for (int i0 = 0; i0 < parametersSize0; i0++) {
      if (!this.getParameterTypes()[i0].equals(castedRecord.getParameterTypes()[i0])) {
        return false;
      }
    }
    // get array length
    int valuesSize0 = this.getParameterValues().length;
    if (valuesSize0 != castedRecord.getParameterValues().length) {
      return false;
    }
    for (int i0 = 0; i0 < valuesSize0; i0++) {
      if (!this.getParameterValues()[i0].equals(castedRecord.getParameterValues()[i0])) {
        return false;
      }
    }
    return true;
  }

  /**
   * Getter for parameter types.
   * @return parameter types
   */
  public final String[] getParameterTypes() {
    return this.parameterTypes;
  }

  /**
   * Getter for parameter values.
   * @return parameter values
   */
  public final String[] getParameterValues() {
    return this.parameterValues;
  }

  /**
   * Getter for return type.
   * @return return type
   */
  public String getReturnType() {
    return this.returnType;
  }

  /**
   * Getter for return value.
   * @return return value
   */
  public String getReturnValue() {
    return this.returnValue;
  }

}"
utilities/tools.descartes.teastore.kieker.probes/src/main/java/tools/descartes/teastore/kieker/probes/records/IPayloadCharacterization.java,"package tools.descartes.teastore.kieker.probes.records;

import kieker.common.record.IMonitoringRecord;

/**
 * Interface in order to realize parameter logging with Kieker.
 * 
 * @author Johannes Grohmann, Reiner Jung
 * 
 * 
 */
public interface IPayloadCharacterization extends IMonitoringRecord {
	
  /**
   * Getter for parameter types.
   * @return parameter types
   */
  public String[] getParameterTypes();

  /**
   * Getter for parameter values.
   * @return parameter values
   */
	public String[] getParameterValues();

	/**
	 * Getter for return type.
	 * @return return type
	 */
	public String getReturnType();

	/**
	 * Getter for return value.
	 * @return return value
	 */
	public String getReturnValue();

}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/RegistryClient.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import javax.naming.InitialContext;
import javax.naming.NamingException;
import jakarta.ws.rs.ProcessingException;
import jakarta.ws.rs.client.Client;
import jakarta.ws.rs.client.ClientBuilder;
import jakarta.ws.rs.client.Entity;
import jakarta.ws.rs.core.GenericType;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import org.glassfish.jersey.client.ClientConfig;
import org.glassfish.jersey.client.ClientProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.netflix.loadbalancer.Server;

import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerUpdaterDaemon;

/**
 * Client with common functionality for registering with the registry.
 *
 * @author Simon Eismann
 *
 */
public class RegistryClient {

  private static final Logger LOG = LoggerFactory.getLogger(RegistryClient.class);

  /**
   * The registry client.
   */
  private static RegistryClient client = new RegistryClient();
  private String registryRESTURL;
  private String hostName = null;
  private Integer port = null;

  private Server myServiceInstanceServer = null;
  private Service myService = null;

  private static final int LOAD_BALANCER_REFRESH_INTERVAL_MS = 2500;
  private static final int HEARTBEAT_INTERVAL_MS = 2500;

  private ScheduledExecutorService loadBalancerUpdateScheduler = Executors
      .newSingleThreadScheduledExecutor();
  private ScheduledExecutorService heartbeatScheduler = Executors
      .newSingleThreadScheduledExecutor();
  private ScheduledExecutorService availabilityScheduler = Executors
      .newSingleThreadScheduledExecutor();

  /**
   * Constructor.
   */
  protected RegistryClient() {
    System.setProperty(""org.slf4j.simpleLogger.logFile"", ""System.out"");
    String useHostIP = ""false"";
    try {
      useHostIP = (String) new InitialContext().lookup(""java:comp/env/useHostIP"");
    } catch (NamingException e) {
      LOG.warn(""useHostIP not set. Not using host ip as hostname."");
    }
    try {
      if (useHostIP.equalsIgnoreCase(""true"")) {
        hostName = InetAddress.getLocalHost().getHostAddress();
      } else {
        hostName = (String) new InitialContext().lookup(""java:comp/env/hostName"");
      }
    } catch (NamingException e) {
      LOG.warn(""hostName not set. Using default OS-provided hostname."");
    } catch (UnknownHostException e) {
      LOG.error(""could not resolve host IP. Using default OS-provided hostname: "" + e.getMessage());
    }
    try {
      port = Integer.parseInt((String) new InitialContext().lookup(""java:comp/env/servicePort""));
    } catch (NamingException | NumberFormatException e) {
      LOG.warn(""Could not read servicePort! Using port 8080 as fallback."");
      port = 8080;
    }
    try {
      registryRESTURL = (String) new InitialContext().lookup(""java:comp/env/registryURL"");
    } catch (NamingException e) {
      LOG.warn(""registryURL not set. Falling back to default registry URL (localhost, port "" + port
          + "")."");
      registryRESTURL = ""http://localhost:"" + port
          + ""/tools.descartes.teastore.registry/rest/services/"";
    }
  }

  /**
   * Getter.
   *
   * @return registry client
   */
  public static RegistryClient getClient() {
    return client;
  }

  /**
   * Handles full registration.
   *
   * @param contextPath
   *          contextPath private String getContextPath(ServletContextEvent event)
   *          { return event.getServletContext().getContextPath(); }
   */
  public void unregister(String contextPath) {
    Service service = getService(contextPath);
    Server host = getServer();
    LOG.info(""Shutting down "" + service.getServiceName() + ""@"" + host);
    heartbeatScheduler.shutdownNow();
    loadBalancerUpdateScheduler.shutdownNow();
    availabilityScheduler.shutdownNow();
    try {
      loadBalancerUpdateScheduler.awaitTermination(20, TimeUnit.SECONDS);
      heartbeatScheduler.awaitTermination(20, TimeUnit.SECONDS);
      availabilityScheduler.awaitTermination(20, TimeUnit.SECONDS);
      RegistryClient.client.unregisterOnce(service, host);
    } catch (ProcessingException e) {
      LOG.warn(""Could not unregister "" + service.getServiceName() + "" when it was shutting ""
          + ""down, since it could not reach the registry. This can be caused by shutting ""
          + ""down the registry before other services, but is in it self not a problem."");
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  /**
   * Handles full unregistration.
   *
   * @param contextPath
   *          contextPath private String getContextPath(ServletContextEvent event)
   *          { return event.getServletContext().getContextPath(); }
   */
  public void register(String contextPath) {
    Service service = getService(contextPath);
    Server host = getServer();
    heartbeatScheduler.scheduleAtFixedRate(new RegistryClientHeartbeatDaemon(service, host), 0,
        HEARTBEAT_INTERVAL_MS, TimeUnit.MILLISECONDS);
    loadBalancerUpdateScheduler.scheduleAtFixedRate(new LoadBalancerUpdaterDaemon(), 1000,
        LOAD_BALANCER_REFRESH_INTERVAL_MS, TimeUnit.MILLISECONDS);
  }

  /**
   * Calls the StartupCallback after the service is available.
   *
   * @param requestedService
   *          service to check for
   * @param myService
   *          The Service enum for the waiting service (the service calling this).
   * @param callback
   *          StartupCallback to call
   */
  public void runAfterServiceIsAvailable(Service requestedService, StartupCallback callback,
      Service myService) {
    availabilityScheduler.schedule(new StartupCallbackTask(requestedService, callback, myService),
        0, TimeUnit.NANOSECONDS);
    availabilityScheduler.shutdown();
  }

  /**
   * Get all servers for a service in the {@link Service} enum from the registry.
   *
   * @param targetService
   *          The service for which to get the servers.
   * @return List of servers.
   */
  public List<Server> getServersForService(Service targetService) {
    List<String> list = null;
    List<Server> serverList = new ArrayList<Server>();
    try {
      Response response = getRESTClient(5000).target(registryRESTURL)
          .path(""/"" + targetService.getServiceName() + ""/"").request(MediaType.APPLICATION_JSON)
          .get();
      list = response.readEntity(new GenericType<List<String>>() {
      });
    } catch (ProcessingException e) {
      return null;
    }

    if (list != null) {
      for (String string : list) {
        serverList.add(new Server(string));
      }
    }

    return serverList;
  }

  /**
   * Get the server for this service. Returns null if the service is not
   * registered yet.
   *
   * @return The server for this service. Null, if not registered.
   */
  public Server getMyServiceInstanceServer() {
    return myServiceInstanceServer;
  }

  /**
   * Get the service of this application. Returns null if the service is not
   * registered yet.
   *
   * @return The service for this application. Null, if not registered.
   */
  public Service getMyService() {
    return myService;
  }

  /**
   * Register a new server for a service in the registry.
   *
   * @param service
   *          The service for which to register.
   * @param server
   *          The server address.
   * @return True, if registration succeeded.
   */
  protected boolean registerOnce(Service service, Server server) {
    myService = service;
    myServiceInstanceServer = server;
    try {
      Response response = getRESTClient(5000).target(registryRESTURL).path(service.getServiceName())
          .path(server.toString()).request(MediaType.APPLICATION_JSON).put(Entity.text(""""));
      return (response.getStatus() == Response.Status.OK.getStatusCode());
    } catch (ProcessingException e) {
      e.printStackTrace();
      return false;
    }
  }

  /**
   * Unregister a server for a service in the registry.
   *
   * @param service
   *          The service for which to unregister.
   * @param server
   *          The server address to remove.
   * @return True, if unregistration succeeded.
   */
  private boolean unregisterOnce(Service service, Server server) {
    try {
      Response response = getRESTClient(1000).target(registryRESTURL).path(service.getServiceName())
          .path(server.toString()).request(MediaType.APPLICATION_JSON).delete();
      return (response.getStatus() == Response.Status.OK.getStatusCode());
    } catch (ProcessingException e) {
      return false;
    }
  }

  private Client getRESTClient(int timeout) {
    ClientConfig configuration = new ClientConfig();
    configuration.property(ClientProperties.CONNECT_TIMEOUT, timeout);
    configuration.property(ClientProperties.READ_TIMEOUT, timeout);
    return ClientBuilder.newClient(configuration);
  }

  private Service getService(String serviceName) {
    serviceName = cleanupServiceName(serviceName);
    for (Service service : Service.values()) {
      if (service.getServiceName().equals(serviceName)) {
        return service;
      }
    }
    throw new IllegalStateException(
        ""The service "" + serviceName + "" is not registered in the Services enum"");
  }

  private Server getServer() {
    return new Server(getHostName(), getPort());
  }

  private String getHostName() {
    if (hostName != null && !hostName.isEmpty()) {
      return hostName;
    }
    try {
      return InetAddress.getLocalHost().getCanonicalHostName();
    } catch (UnknownHostException e) {
      throw new IllegalStateException(""could not load hostname from OS."");
    }
  };

  private int getPort() {
    if (port != null) {
      return port;
    } else {
      throw new IllegalStateException(""Could not read servicePort!"");
    }
  }

  /**
   * Protected for testing.
   *
   * @param serviceName
   *          name of service
   * @return cleaned service name
   */
  protected String cleanupServiceName(String serviceName) {
    return serviceName.replace(""/"", """");
  }

  /**
   * Protected for test.
   *
   * @return scheduler
   */
  protected ScheduledExecutorService getHeartbeatScheduler() {
    return heartbeatScheduler;
  }

  /**
   * Protected for test.
   *
   * @return scheduler
   */
  protected ScheduledExecutorService getLoadBalancerUpdateScheduler() {
    return loadBalancerUpdateScheduler;
  }
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/util/TimeoutException.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient.util;


/**
 * Exception thrown if a 408 response was received.
 * @author Joakim von Kistowski
 *
 */
public class TimeoutException extends RuntimeException {


	private static final long serialVersionUID = -7025097849696056898L;
	/**
	 * The corresponding HTTP error code.
	 */
	public static final int ERROR_CODE = 408;
	

	/**
	 * Creates a new NotFoundException.
	 */
	public TimeoutException() {
		super();
	}
	
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/util/RESTClient.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient.util;

import org.glassfish.jersey.client.ClientConfig;
import org.glassfish.jersey.client.ClientProperties;
import org.glassfish.jersey.grizzly.connector.GrizzlyConnectorProvider;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.HostnameVerifier;
import jakarta.ws.rs.client.Client;
import jakarta.ws.rs.client.ClientBuilder;
import jakarta.ws.rs.client.WebTarget;
import jakarta.ws.rs.core.GenericType;
import jakarta.ws.rs.core.UriBuilder;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.util.List;

/**
 * Default Client that transfers Entities to/from a service that has a standard conforming REST-API.
 * @author Joakim von Kistowski
 * @param <T> Entity type for the client to handle.
 */
public class RESTClient<T> {

	/**
	 * Default and max size for connection pools. We estimate a good size by using the available processor count.
	 */

	private static final int DEFAULT_CONNECT_TIMEOUT = 600;
	private static final int DEFAULT_READ_TIMEOUT = 6000;

	/**
	 * Default REST application path.
	 */
	public static final String DEFAULT_REST_APPLICATION = ""rest"";

	private static int readTimeout = DEFAULT_READ_TIMEOUT;
	private static int connectTimeout = DEFAULT_CONNECT_TIMEOUT;

	private String applicationURI;
	private String endpointURI;

	private Client client;
	private WebTarget service;
	private Class<T> entityClass;

	private ParameterizedType parameterizedGenericType;
	private GenericType<List<T>> genericListType;

	/**
	 * Creates a new REST Client for an entity of Type T. The client interacts with a Server providing
	 * CRUD functionalities
	 * @param hostURL The url of the host. Common Pattern: ""http://[hostname]:[port]/servicename/""
	 * @param application The name of the rest application, usually {@link #DEFAULT_REST_APPLICATION} ""rest"" (no ""/""!)
	 * @param endpoint The name of the rest endpoint, typically the all lower case name of the entity in a plural form.
	 * E.g., ""products"" for the entity ""Product"" (no ""/""!)
	 * @param entityClass Classtype of the Entitiy to send/receive. Note that the use of this Class type is
	 * 			open for interpretation by the inheriting REST clients.
	 */
	public RESTClient(String hostURL, String application, String endpoint, final Class<T> entityClass) {
		boolean useHTTPS = ""true"".equals(System.getenv(""USE_HTTPS""));

		if (!hostURL.endsWith(""/"")) {
			hostURL += ""/"";
		}
		if (!hostURL.contains(""://"")) {
			if (useHTTPS) {
				hostURL = ""https://"" + hostURL;
			} else {
				hostURL = ""http://"" + hostURL;
			}
		}
		ClientConfig config = new ClientConfig();
		config.property(ClientProperties.CONNECT_TIMEOUT, connectTimeout);
		config.property(ClientProperties.READ_TIMEOUT, readTimeout);
		config.connectorProvider(new GrizzlyConnectorProvider());

		if (useHTTPS) {
			try {
				TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
					@Override
					public void checkClientTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) {
					}

					@Override
					public void checkServerTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) {
					}

					public java.security.cert.X509Certificate[] getAcceptedIssuers() {
						return null;
					}
				}
				};
				SSLContext sslContext = SSLContext.getInstance(""SSL"");
				sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
				HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
				HostnameVerifier allHostsValid = (hostname, session) -> true;
				HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

				ClientBuilder builder = ClientBuilder.newBuilder().withConfig(config);
				builder.sslContext(sslContext);
				client = builder.build();
			} catch (NoSuchAlgorithmException | KeyManagementException e) {
				e.printStackTrace();
			}
		} else {
			client = ClientBuilder.newClient(config);
		}

		service = client.target(UriBuilder.fromUri(hostURL).build());
		applicationURI = application;
		endpointURI = endpoint;
		this.entityClass = entityClass;

		parameterizedGenericType = new ParameterizedType() {
		        public Type[] getActualTypeArguments() {
		            return new Type[] { entityClass };
		        }

		        public Type getRawType() {
		            return List.class;
		        }

		        public Type getOwnerType() {
		            return List.class;
		        }
		    };
		    genericListType = new GenericType<List<T>>(parameterizedGenericType) { };
	}

	/**
	 * Sets the global read timeout for all REST clients of this service.
	 * @param readTimeout The read timeout in ms.
	 */
	public static void setGlobalReadTimeout(int readTimeout) {
		RESTClient.readTimeout = readTimeout;
	}

	/**
	 * Sets the global connect timeout for all REST clients of this service.
	 * @param connectTimeout The read timeout in ms.
	 */
	public static void setGlobalConnectTimeout(int connectTimeout) {
		RESTClient.connectTimeout = connectTimeout;
	}

	/**
	 * Generic type of return lists.
	 * @return Generic List type.
	 */
	public GenericType<List<T>> getGenericListType() {
		return genericListType;
	}

	/**
	 * Class of entities to handle in REST Client.
	 * @return Entity class.
	 */
	public Class<T> getEntityClass() {
		return entityClass;
	}

	/**
	 * The service to use.
	 * @return The web service.
	 */
	public WebTarget getService() {
		return service;
	}

	/**
	 * Get the web target for sending requests directly to the endpoint.
	 * @return The web target for the endpoint.
	 */
	public WebTarget getEndpointTarget() {
		return service.path(applicationURI).path(endpointURI);
	}

	/**
	 * URI of the REST Endpoint within the application.
	 * @return The enpoint URI.
	 */
	public String getEndpointURI() {
		return endpointURI;
	}

	/**
	 * URI of the rest application (usually ""rest"").
	 * @return The application URI.
	 */
	public String getApplicationURI() {
		return applicationURI;
	}

}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/util/NotFoundException.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient.util;


/**
 * Exception thrown if a 404 response was received.
 * @author Joakim von Kistowski
 *
 */
public class NotFoundException extends RuntimeException {


	/**
	 * The corresponding HTTP error code.
	 */
	public static final int ERROR_CODE = 404;
	
	private static final long serialVersionUID = -6617660221762786650L;

	/**
	 * Creates a new NotFoundException.
	 */
	public NotFoundException() {
		super();
	}
	
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/util/AbstractCRUDEndpoint.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient.util;

import java.util.List;

import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.DELETE;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.PUT;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;
import jakarta.ws.rs.core.UriBuilder;

/**
 * Abstract endpoint for providing entities as resources using REST.
 * @author Joakim von Kistowski
 *
 * @param <T> The entity type.
 */
@Path(""abstract"") //This is overwritten by inheritance
@Produces({ ""application/json"" })
@Consumes({ ""application/json"" })
public abstract class AbstractCRUDEndpoint<T> {
	
	/**
	 * Create a new entity by copying the passed entity. Any passed IDs are always ignored.
	 * A new ID will be created.
	 * @param entity Template for the new entity.
	 * @return A new entity with the initial values of the passed template.
	 */
	@POST
	public Response create(final T entity) {
		long id = createEntity(entity);
		return Response.created(UriBuilder.fromResource(AbstractCRUDEndpoint.class).
				path(String.valueOf(id)).build()).entity(id).build();
	}
	
	/**
	 * Create a new entity (usually by passing this on to persistence).
	 * Copy the values of all Attributes of entity to the new Entity, EXEPT the ID.
	 * Create a new ID, write it to the new entity and return it.
	 * @param entity Entity to copy and create as new with a new ID.
	 * @return The new ID. Also write this new ID to the new entity.
	 */
	protected abstract long createEntity(final T entity);

	/**
	 * Retreive and entity with the provided ID.
	 * @param id ID of the entity to find.
	 * @return A Response containing the entity.
	 */
	@GET
	@Path(""/{id:[0-9][0-9]*}"")
	public Response findById(@PathParam(""id"") final Long id) {
		if (id == null) {
			return Response.status(Status.NOT_FOUND).build();
		}
		T entity = findEntityById(id);
		if (entity == null) {
			return Response.status(Status.NOT_FOUND).build();
		}
		return Response.ok(entity).build();
	}
	
	/**
	 * Find the entity with the given ID and return it. Return null if none was found.
	 * @param id The ID of the Entity to find.
	 * @return The retreived Entity. null, if no entity was found.
	 */
	protected abstract T findEntityById(final long id);

	/**
	 * Return a list of all entities starting at the startIndex_th entity.
	 * Return maxResultCount entities or fewer if fewer exist.
	 * Negative or 0 startIndexes should result in the startIndex being ignored.
	 * @param startPosition The index to start. Negative or null startIndex starts returning at the beginning.
	 * @param maxResult Max amount of entities to return. Negative or null maxResultCount: return all.
	 * @return List of all entities within the provided range. Returns an empty list for no matches
	 */
	@GET
	public List<T> listAll(@QueryParam(""start"") final Integer startPosition,
			@QueryParam(""max"") final Integer maxResult) {
		final List<T> entities = listAllEntities(parseIntQueryParam(startPosition), parseIntQueryParam(maxResult));
		return entities;
	}

	/**
	 * Return a list of all entities starting at the startIndex_th entity.
	 * Return maxResultCount entities or fewer if fewer exist.
	 * Negative or 0 startIndexes should result in the startIndex being ignored.
	 * Negative maxResultCounts should result in all results from startIndex being returned.
	 * @param startIndex The index to start. Negative startIndex starts returning at the beginning.
	 * @param maxResultCount Max amount of entities to return. Negative maxResultCount: return all.
	 * @return List of all entities within the provided range. Return an empty list for no matches.
	 */
	protected abstract List<T> listAllEntities(final int startIndex, final int maxResultCount);
	
	/**
	 * Update the entity with ID id with the attributes of the passed entity.
	 * You are free to choose for which attributes you allow updates and which attributes to ignore.
	 * Will always ignore the ID in the passed entity and use the separate ID instead.
	 * @param id The id of the entity to update.
	 * @param entity The values of the entity to update.
	 * @return Status Code 200 if update succeeded, 404 if it didn't.
	 */
	@PUT
	@Path(""/{id:[0-9][0-9]*}"")
	public Response update(@PathParam(""id"") Long id, final T entity) {
		boolean updated = false;
		if (id != null && entity != null) {
			updated = updateEntity(id, entity);
		}
		if (updated) {
			return Response.ok().build();
		} else {
			return Response.status(Status.NOT_FOUND).build();
		}
	}
	
	/**
	 * Update the entity with ID id with the attributes of the passed entity.
	 * You are free to choose for which attributes you allow updates and which attributes to ignore.
	 * Note the the ID passed in the entity itself must ALWAYS be ignored.
	 * @param id The id of the entity to update.
	 * @param entity The values of the entity to update.
	 * @return True, if a matching entity was found and updated. False, if the update failed.
	 */
	protected abstract boolean updateEntity(long id, final T entity);

	/**
	 * Delete the entity with ID id.
	 * @param id The id of the entity to delete.
	 * @return Status Code 200 if delete succeeded, 404 if it didn't.
	 */
	@DELETE
	@Path(""/{id:[0-9][0-9]*}"")
	public Response deleteById(@PathParam(""id"") final Long id) {
		boolean deleted = deleteEntity(id);
		if (deleted) {
			return Response.ok().build();
		} else {
			return Response.status(Status.NOT_FOUND).build();
		}
	}

	/**
	 * Delete the entity with ID id.
	 * @param id The id of the entity to delete.
	 * @return True, if a matching entity was found and deleted. False, if no entity was found or if no delte occured.
	 */
	protected abstract boolean deleteEntity(long id);
	
	/**
	 * Parses an int query param and catches errors. Returns -1 on errors or missing params.
	 * @param queryArg The query param to parse.
	 * @return -1 on errors. The query param otherwise.
	 */
	protected int parseIntQueryParam(Integer queryArg) {
		if (queryArg != null) {
			return queryArg;
		}
		return -1;
	}
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/tracing/Tracing.java,"package tools.descartes.teastore.registryclient.tracing;

import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.ws.rs.client.Invocation;
import jakarta.ws.rs.core.HttpHeaders;

import io.jaegertracing.internal.JaegerTracer;
import io.jaegertracing.internal.propagation.B3TextMapCodec;
import io.jaegertracing.internal.samplers.ConstSampler;
import io.opentracing.Scope;
import io.opentracing.Span;
import io.opentracing.SpanContext;
import io.opentracing.Tracer;
import io.opentracing.propagation.Format;
import io.opentracing.propagation.TextMap;
import io.opentracing.propagation.TextMapExtractAdapter;
import io.opentracing.tag.Tags;
import io.opentracing.util.GlobalTracer;

/**
 * Utility functions for OpenTracing integration.
 *
 * @author Long Bui
 */
public final class Tracing {
  private Tracing() {
  }

  /**
   * This function is used to create an Tracer instance to be used as the
   * GlobalTracer.
   *
   * @param service is usually the name of the service
   * @return Tracer intended to be used as GlobalTracer
   */
  public static Tracer init(String service) {
    return new JaegerTracer.Builder(service).withSampler(new ConstSampler(true)).withZipkinSharedRpcSpan()
        .registerInjector(Format.Builtin.HTTP_HEADERS, new B3TextMapCodec.Builder().build())
        .registerExtractor(Format.Builtin.HTTP_HEADERS, new B3TextMapCodec.Builder().build()).build();
  }

  /**
   * This function is used to inject the current span context into the request to
   * be made.
   *
   * @param requestBuilder The requestBuilder object that gets injected
   */
  public static void inject(Invocation.Builder requestBuilder) {
    Span activeSpan = GlobalTracer.get().activeSpan();
    if (activeSpan != null) {
      GlobalTracer.get().inject(activeSpan.context(), Format.Builtin.HTTP_HEADERS,
          Tracing.requestBuilderCarrier(requestBuilder));
    }
  }

  /**
   * Overloaded function used to extract span information out of an
   * HttpServletRequest instance.
   *
   * @param request is the HttpServletRequest isntance with the potential span
   *                informations
   * @return Scope containing the extracted span marked as active. Can be used
   *         with try-with-resource construct
   */
  public static Scope extractCurrentSpan(HttpServletRequest request) {
    Map<String, String> headers = new HashMap<>();
    for (String headerName : Collections.list(request.getHeaderNames())) {
      headers.put(headerName, request.getHeader(headerName));
    }
    return buildSpanFromHeaders(headers);
  }

  /**
   * Overloaded function used to extract span information out of an HttpHeaders
   * instance.
   *
   * @param httpHeaders is the HttpHeaders instance with the potential span
   *                    informations
   * @return Scope containing the extracted span marked as active. Can be used
   *         with try-with-resource construct
   */
  public static Scope extractCurrentSpan(HttpHeaders httpHeaders) {
    Map<String, String> headers = new HashMap<>();
    for (String headerName : httpHeaders.getRequestHeaders().keySet()) {
      headers.put(headerName, httpHeaders.getRequestHeader(headerName).get(0));
    }
    return buildSpanFromHeaders(headers);
  }

  /**
   * Helper method to extract and build the active span out of Map containing the
   * processed headers.
   *
   * @param headers is the Map of the processed headers
   * @return Scope containing the extracted span marked as active. Can be used
   *         with try-with-resource construct
   */
  private static Scope buildSpanFromHeaders(Map<String, String> headers) {
    Tracer.SpanBuilder spanBuilder = GlobalTracer.get().buildSpan(""op"");
    try {
      SpanContext parentSpanCtx = GlobalTracer.get().extract(Format.Builtin.HTTP_HEADERS,
          new TextMapExtractAdapter(headers));
      if (parentSpanCtx != null) {
        spanBuilder = spanBuilder.asChildOf(parentSpanCtx);
      }
    } catch (IllegalArgumentException e) {
      e.printStackTrace();
    }
    return spanBuilder.withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT).startActive(true);
  }

  /**
   * Returns a TextMap Adapter for Invocation.Builder instance.
   *
   * @param builder is the construct where the span information should be injected
   *                to
   * @return the TextMap adapter which can be used for injection
   */
  public static TextMap requestBuilderCarrier(final Invocation.Builder builder) {
    return new TextMap() {
      @Override
      public Iterator<Map.Entry<String, String>> iterator() {
        throw new UnsupportedOperationException(""carrier is write-only"");
      }

      @Override
      public void put(String key, String value) {
        builder.header(key, value);
      }
    };
  }
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/Service.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient;

/**
 * Enum of all services in the pet supply store.
 * @author Joakim von Kistowski
 *
 */
public enum Service {
	/**
	 * Persistence service.
	 */
	PERSISTENCE(""tools.descartes.teastore.persistence""),
	/**
	 * Recommender service.
	 */
	RECOMMENDER(""tools.descartes.teastore.recommender""),
	/**
	 * Store service.
	 */
	AUTH(""tools.descartes.teastore.auth""),
	/**
	 * WebUi service.
	 */
	WEBUI(""tools.descartes.teastore.webui""),
	/**
	 * Image Provider service.
	 */
	IMAGE(""tools.descartes.teastore.image"");
	
	private String serviceName;
	
	/**
	 * Service enums have service names. Names are also contexts.
	 * @param serviceName The name of the service.
	 */
	Service(String serviceName) {
		this.serviceName = serviceName;
	}
	
	/**
	 * Gets the service name; name is also context.
	 * @return The service name.
	 */
	public String getServiceName() {
		return serviceName;
	}
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/StartupCallbackTask.java,"package tools.descartes.teastore.registryclient;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.netflix.loadbalancer.Server;

/**
 * Runnable to get callback once service is online.
 * @author Simon
 *
 */
public class StartupCallbackTask implements Runnable {
	private static final Logger LOG = LoggerFactory.getLogger(RegistryClient.class);
	
	private Service requestedService;
	private StartupCallback callback;
	private Service myService;
	
	/**
	 * Constructor.
	 * @param requestedService service
	 * @param callback callback object
	 * @param myService service
	 */
	public StartupCallbackTask(Service requestedService, StartupCallback callback, Service myService) {
		this.requestedService = requestedService;
		this.callback = callback;
		this.myService = myService;
	}
	
	@Override
	public void run() {
		try {
	    	List<Server> servers;
	    	boolean msgLogged = false;
	    	do {
	    		servers = RegistryClient.getClient().getServersForService(requestedService);
	    		if (servers == null || servers.isEmpty()) {
	    			try {
	    				if (!msgLogged) {
		    				if (servers == null) {
		    					LOG.info(""Registry not online. "" + myService + "" is waiting for it to come online"");
		    				} else {
		    					LOG.info(requestedService.getServiceName() + "" not online. ""
		    							+ myService + "" is waiting for it to come online"");
		    				}
		    				msgLogged = true;
	    				}
						Thread.sleep(1000);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
	    		}
	    	} while (servers == null || servers.isEmpty());
	    	
	    	callback.callback();
	    		
		} catch (Exception e) {
			e.printStackTrace();
			throw(e);
		}
	}

}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/StartupCallback.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient;

/**
 * Interface for callback at startup.
 * @author Simon Eismann
 *
 */
public interface StartupCallback {
	/**
	 * This function is called to trigger callback.
	 */
	public void callback();

}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/rest/CharResponseWrapper.java,"package tools.descartes.teastore.registryclient.rest;

import java.io.CharArrayWriter;
import java.io.IOException;
import java.io.PrintWriter;

import jakarta.servlet.ServletOutputStream;
import jakarta.servlet.WriteListener;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpServletResponseWrapper;

/**
 * Warper for responses.
 * 
 * @author Simon
 *
 */
public class CharResponseWrapper extends HttpServletResponseWrapper {
  private CharArrayWriter output;

  /**
   * Returns string content.
   * 
   * @return string
   */
  public String toString() {
    return output.toString();
  }

  /**
   * Constructor using a response.
   * 
   * @param response
   *          response to wrap
   */
  public CharResponseWrapper(HttpServletResponse response) {
    super(response);
    output = new CharArrayWriter();
  }

  /**
   * Getter for print writer.
   * 
   * @return print writer
   */
  public PrintWriter getWriter() {
    return new PrintWriter(output);
  }

  /**
   * Getter for output stream.
   * 
   * @return ServletOutputStream
   */
  @Override
  public ServletOutputStream getOutputStream() throws IOException {
    // This is the magic to prevent closing stream, create a ""virtual"" stream that
    // does nothing..
    return new ServletOutputStream() {
      @Override
      public void write(int b) throws IOException {
        output.write(b);
      }

      @Override
      public void setWriteListener(WriteListener writeListener) {
      }

      @Override
      public boolean isReady() {
        return true;
      }
    };
  }
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/rest/HttpWrapper.java,"package tools.descartes.teastore.registryclient.rest;

import jakarta.ws.rs.client.Invocation.Builder;
import jakarta.ws.rs.core.MediaType;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import kieker.monitoring.core.controller.IMonitoringController;
import kieker.monitoring.core.controller.MonitoringController;
import kieker.monitoring.core.registry.ControlFlowRegistry;
import kieker.monitoring.core.registry.SessionRegistry;
import tools.descartes.teastore.registryclient.tracing.Tracing;

import jakarta.ws.rs.client.WebTarget;

/**
 * Wrapper for http calls.
 *
 * @author Simon
 *
 */
public final class HttpWrapper {
  private static final IMonitoringController CTRLINST = MonitoringController.getInstance();
  private static final Logger LOG = LoggerFactory.getLogger(HttpWrapper.class);
  private static final ControlFlowRegistry CF_REGISTRY = ControlFlowRegistry.INSTANCE;
  private static final SessionRegistry SESSION_REGISTRY = SessionRegistry.INSTANCE;
  private static final String HEADER_FIELD = ""KiekerTracingInfo"";

  /**
   * Hide default constructor.
   */
  private HttpWrapper() {

  }

  /**
   * Wrap webtarget.
   *
   * @param target webtarget to wrap
   * @return wrapped wentarget
   */
  public static Builder wrap(WebTarget target) {
    Builder builder = target.request(MediaType.APPLICATION_JSON).accept(MediaType.APPLICATION_JSON);
    Tracing.inject(builder);
    if (CTRLINST.isMonitoringEnabled()) {
      final String sessionId = SESSION_REGISTRY.recallThreadLocalSessionId();
      final int eoi; // this is executionOrderIndex-th execution in this trace
      final int ess; // this is the height in the dynamic call tree of this execution
      final int nextESS;
      long traceId = CF_REGISTRY.recallThreadLocalTraceId(); // traceId, -1 if entry point
      if (traceId == -1) {
        // entrypoint = true;
        traceId = CF_REGISTRY.getAndStoreUniqueThreadLocalTraceId();
        CF_REGISTRY.storeThreadLocalEOI(0);
        CF_REGISTRY.storeThreadLocalESS(1); // next operation is ess + 1
        eoi = 0;
        ess = 0;
        nextESS = 1;
      } else {
        // entrypoint = false;
        eoi = CF_REGISTRY.recallThreadLocalEOI();
        ess = CF_REGISTRY.recallThreadLocalESS();
        nextESS = ess;
        if ((eoi == -1) || (ess == -1)) {
          LOG.error(""eoi and/or ess have invalid values:"" + "" eoi == "" + eoi + "" ess == "" + ess);
          // CTRLINST.terminateMonitoring();
        }
      }
      // Get request header
      return builder.header(HEADER_FIELD,
          Long.toString(traceId) + "","" + sessionId + "","" + Integer.toString(eoi) + "","" + Integer.toString(nextESS));
    }
    return builder;
  }
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/rest/LoadBalancedImageOperations.java,"package tools.descartes.teastore.registryclient.rest;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import jakarta.ws.rs.client.Entity;
import jakarta.ws.rs.core.GenericType;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.util.NotFoundException;
import tools.descartes.teastore.entities.ImageSize;
import tools.descartes.teastore.entities.ImageSizePreset;
import tools.descartes.teastore.entities.Product;

/**
 * Wrapper for rest operations.
 * 
 * @author mediocre comments --> Simon, good code --> Norbert
 *
 */
public final class LoadBalancedImageOperations {

	private LoadBalancedImageOperations() {

	}

	/**
	 * Retrieves image for a product.
	 * 
	 * @param product
	 *            product.
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return image for product
	 */
	public static String getProductImage(Product product) throws NotFoundException, LoadBalancerTimeoutException {
		return getProductImage(product, ImageSizePreset.FULL.getSize());
	}

	/**
	 * Gets product image.
	 * 
	 * @param product
	 *            product.
	 * @param size
	 *            target size
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return image for product with target size
	 */
	public static String getProductImage(Product product, ImageSize size)
			throws NotFoundException, LoadBalancerTimeoutException {
		return getProductImages(Stream.of(product).collect(Collectors.toList()), size).getOrDefault(product.getId(),
				"""");
	}

	/**
	 * Gets preview images for a series of products.
	 * 
	 * @param products
	 *            List of products
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return HashMap containing all preview images
	 */
	public static HashMap<Long, String> getProductPreviewImages(List<Product> products)
			throws NotFoundException, LoadBalancerTimeoutException {
		return getProductImages(products, ImageSizePreset.PREVIEW.getSize());
	}

	/**
	 * Gets preview images for a series of products with target image size.
	 * 
	 * @param products
	 *            list of products
	 * @param size
	 *            target size
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return HashMap containing all preview images
	 */
	public static HashMap<Long, String> getProductImages(List<Product> products, ImageSize size)
			throws NotFoundException, LoadBalancerTimeoutException {
		HashMap<Long, String> img = new HashMap<>();
		for (Product p : products) {
			img.put(p.getId(), size.toString());
		}

		Response r = ServiceLoadBalancer.loadBalanceRESTOperation(Service.IMAGE, ""image"", HashMap.class,
				client -> ResponseWrapper.wrap(HttpWrapper.wrap(client.getEndpointTarget().path(""getProductImages""))
						.post(Entity.entity(img, MediaType.APPLICATION_JSON))));

		if (r == null) {
			return new HashMap<Long, String>();
		}

		HashMap<Long, String> result = null;
		if (r.getStatus() < 400) {
			result = r.readEntity(new GenericType<HashMap<Long, String>>() {
			});
		} else {
			// buffer all entities so that the connections are released to the connection
			// pool
			r.bufferEntity();
		}
		if (result == null) {
			return new HashMap<Long, String>();
		}
		return result;
	}

	/**
	 * Retrieves web image.
	 * 
	 * @param name
	 *            name of image.
	 * @param size
	 *            target size
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return image
	 */
	public static String getWebImage(String name, ImageSize size)
			throws NotFoundException, LoadBalancerTimeoutException {
		return getWebImages(Stream.of(name).collect(Collectors.toList()), size).getOrDefault(name, """");
	}

	/**
	 * Retrieves a series of web image.
	 * 
	 * @param names
	 *            list of name of image.
	 * @param size
	 *            target size
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return HashMap containing requested images.
	 */
	public static HashMap<String, String> getWebImages(List<String> names, ImageSize size)
			throws NotFoundException, LoadBalancerTimeoutException {
		HashMap<String, String> img = new HashMap<>();
		for (String name : names) {
			img.put(name, size.toString());
		}

		Response r = ServiceLoadBalancer.loadBalanceRESTOperation(Service.IMAGE, ""image"", HashMap.class,
				client -> ResponseWrapper.wrap(HttpWrapper.wrap(client.getEndpointTarget().path(""getWebImages""))
						.post(Entity.entity(img, MediaType.APPLICATION_JSON))));

		if (r == null) {
			return new HashMap<String, String>();
		}

		HashMap<String, String> result = null;
		if (r.getStatus() < 400) {
			result = r.readEntity(new GenericType<HashMap<String, String>>() {
			});
		} else {
			// buffer all entities so that the connections are released to the connection
			// pool
			r.bufferEntity();
		}
		if (result == null) {
			return new HashMap<String, String>();
		}
		return result;
	}

	/**
	 * Regenerates images.
	 * 
	 * @return List of status codes.
	 */
	public static List<Integer> regenerateImages() {
		List<Response> r = ServiceLoadBalancer.multicastRESTOperation(Service.IMAGE, ""image"", null,
				client -> client.getEndpointTarget().path(""regenerateImages"").request().get());
		if (r == null) {
			return new ArrayList<Integer>();
		}
		List<Integer> statuses = r.stream().filter(response -> response != null).map(response -> response.getStatus())
				.collect(Collectors.toList());
		// buffer all entities so that the connections are released to the connection
		// pool
		r.stream().filter(response -> response != null).forEach(response -> response.bufferEntity());
		return statuses;
	}
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/rest/NonBalancedCRUDOperations.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.ProcessingException;
import jakarta.ws.rs.client.Entity;
import jakarta.ws.rs.client.WebTarget;
import jakarta.ws.rs.core.GenericType;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.registryclient.util.NotFoundException;
import tools.descartes.teastore.registryclient.util.RESTClient;
import tools.descartes.teastore.registryclient.util.TimeoutException;

/**
 * Default REST operations that transfer Entities to/from a service that has a
 * standard conforming REST-API. Do not utilize any load balancers. Use the
 * LoadBalancedCRUDOperations instead for all normal use cases.
 * 
 * @author Joakim von Kistowski
 */
public final class NonBalancedCRUDOperations {
  private static final Logger LOG = LoggerFactory.getLogger(NonBalancedCRUDOperations.class);

  private NonBalancedCRUDOperations() {

  }

  /**
   * Sends an Entity to be created ""as new"" by the receiving service.
   * 
   * @param entity
   *          The new entity to create. ID may remain unset, it will be ignored by
   *          target service.
   * @param client
   *          The REST client to use.
   * @param <T>
   *          Type of entity to handle.
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws TimeoutException
   *           If 408 was returned.
   * @return The new ID of the created entity. Target service creates a new ID,
   *         any passed ID is ignored. Returns -1L if creation failed. Returns 0
   *         if creation worked, but ID remains unkown.
   */
  public static <T> long sendEntityForCreation(RESTClient<T> client, T entity)
      throws NotFoundException, TimeoutException {
    Response response = ResponseWrapper.wrap(HttpWrapper.wrap(client.getEndpointTarget())
        .post(Entity.entity(entity, MediaType.APPLICATION_JSON), Response.class));
    long id = -1L;
    // If resource was created successfully
    if (response != null && response.getStatus() == 201) {
      id = 0L;
      // check if response an Id; if yes: return the id
      try {
        id = response.readEntity(Long.class);
      } catch (ProcessingException e) {
        LOG.warn(""Response did not conform to expected message type. Expected a Long ID."");
      }
    } else if (response != null) {
      response.bufferEntity();
    }
    if (response != null && response.getStatus() == Status.NOT_FOUND.getStatusCode()) {
      throw new NotFoundException();
    } else if (response != null && response.getStatus() == Status.REQUEST_TIMEOUT.getStatusCode()) {
      throw new TimeoutException();
    }
    return id;
  }

  /**
   * Sends an Entity to be updated using the values of the provided entity. Note
   * that not all values may be used by the receiving service. The values used
   * depend on which changes are allowed in the domain model.
   * 
   * @param id
   *          The id of the entity to update. Ids stored within the entity are
   *          ignored.
   * @param entity
   *          The entity to be updated. Entity is matched using its ID.
   * @param client
   *          The REST client to use.
   * @param <T>
   *          Type of entity to handle.
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws TimeoutException
   *           If 408 was returned.
   * @return True, if update succeeded. False, otherwise.
   */
  public static <T> boolean sendEntityForUpdate(RESTClient<T> client, long id, T entity)
      throws NotFoundException, TimeoutException {
    Response response = ResponseWrapper
        .wrap(HttpWrapper.wrap(client.getEndpointTarget().path(String.valueOf(id)))
            .put(Entity.entity(entity, MediaType.APPLICATION_JSON), Response.class));
    if (response != null) {
      response.bufferEntity();
    }
    if (response != null && response.getStatus() == Status.NOT_FOUND.getStatusCode()) {
      throw new NotFoundException();
    } else if (response != null && response.getStatus() == Status.REQUEST_TIMEOUT.getStatusCode()) {
      throw new TimeoutException();
    }
    if (response != null && response.getStatus() == 200) {
      return true;
    }
    return false;
  }

  /**
   * Deletes the entity at the target id.
   * 
   * @param id
   *          The ID of the entity to delete.
   * @param client
   *          The REST client to use.
   * @param <T>
   *          Type of entity to handle.
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws TimeoutException
   *           If 408 was returned.
   * @return True, if deletion succeeded; false otherwise.
   */
  public static <T> boolean deleteEntity(RESTClient<T> client, long id)
      throws NotFoundException, TimeoutException {
    Response response = ResponseWrapper
        .wrap(HttpWrapper.wrap(client.getEndpointTarget().path(String.valueOf(id))).delete());

    if (response != null) {
      response.bufferEntity();
    }
    if (response != null && response.getStatus() == 200) {
      return true;
    }
    if (response != null && response.getStatus() == Status.NOT_FOUND.getStatusCode()) {
      throw new NotFoundException();
    } else if (response != null && response.getStatus() == Status.REQUEST_TIMEOUT.getStatusCode()) {
      throw new TimeoutException();
    }
    return false;
  }

  /**
   * Returns the entity with the specified id. Returns null if it does not exist.
   * 
   * @param id
   *          Id of the entity to find.
   * @param client
   *          The REST client to use.
   * @param <T>
   *          Type of entity to handle.
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws TimeoutException
   *           If 408 was returned.
   * @return The entity; null if it does not exist.
   */
  public static <T> T getEntity(RESTClient<T> client, long id)
      throws NotFoundException, TimeoutException {
    Response response = ResponseWrapper
        .wrap(HttpWrapper.wrap(client.getEndpointTarget().path(String.valueOf(id))).get());
    T entity = null;
    if (response != null && response.getStatus() < 400) {
      try {
        entity = response.readEntity(client.getEntityClass());
      } catch (NullPointerException | ProcessingException e) {
        LOG.warn(""Response did not conform to expected entity type."");
      }
    } else if (response != null) {
      response.bufferEntity();
    }
    if (response != null && response.getStatus() == Status.NOT_FOUND.getStatusCode()) {
      throw new NotFoundException();
    } else if (response != null && response.getStatus() == Status.REQUEST_TIMEOUT.getStatusCode()) {
      throw new TimeoutException();
    }
    return entity;
  }

  /**
   * Returns a list of Entities of the relevant type.
   * 
   * @param client
   *          The REST client to use.
   * @param startIndex
   *          The index of the first entity to return (index, not ID!). -1, if you
   *          don't want to set an index.
   * @param limit
   *          Maximum amount of entities to return. -1, for no max.
   * @param <T>
   *          Type of entity to handle.
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws TimeoutException
   *           If 408 was returned.
   * @return List of entities; empty list if non were found.
   */
  public static <T> List<T> getEntities(RESTClient<T> client, int startIndex, int limit)
      throws NotFoundException, TimeoutException {
    WebTarget target = client.getEndpointTarget();
    if (startIndex >= 0) {
      target = target.queryParam(""start"", startIndex);
    }
    if (limit >= 0) {
      target = target.queryParam(""max"", limit);
    }

    GenericType<List<T>> listType = client.getGenericListType();
    Response response = ResponseWrapper.wrap(HttpWrapper.wrap(target).get());
    List<T> entities = new ArrayList<T>();
    
    if (response != null && response.getStatus() == 200) {
      try {
        entities = response.readEntity(listType);
      } catch (ProcessingException e) {
        LOG.warn(""Response did not conform to expected entity type. List expected."");
      }
    } else if (response != null) {
      response.bufferEntity();
    }
    if (response != null && response.getStatus() == Status.NOT_FOUND.getStatusCode()) {
      throw new NotFoundException();
    } else if (response != null && response.getStatus() == Status.REQUEST_TIMEOUT.getStatusCode()) {
      throw new TimeoutException();
    }
    return entities;
  }

  /**
   * Returns a list of Entities of the relevant type after filtering using a path
   * param query. Example: ""category"", 2, 1, 3 will return 3 items in Category
   * with ID 2, beginning from item with index 1 (skipping item 0). Note that the
   * AbstractCRUDEndpoint does not offer this feature by default.
   * 
   * @param client
   *          The REST client to use.
   * @param filterURI
   *          Name of the objects to filter for. E.g., ""category"".
   * @param filterId
   *          Id of the Object to filter for. E.g, 2
   * @param startIndex
   *          The index of the first entity to return (index, not ID!). -1, if you
   *          don't want to set an index.
   * @param limit
   *          Maximum amount of entities to return. -1, for no max.
   * @param <T>
   *          Type of entity to handle.
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws TimeoutException
   *           If 408 was returned.
   * @return List of entities; empty list if non were found.
   */
  public static <T> List<T> getEntities(RESTClient<T> client, String filterURI, long filterId,
      int startIndex, int limit) throws NotFoundException, TimeoutException {
    WebTarget target = client.getEndpointTarget().path(filterURI).path(String.valueOf(filterId));
    if (startIndex >= 0) {
      target = target.queryParam(""start"", startIndex);
    }
    if (limit >= 0) {
      target = target.queryParam(""max"", limit);
    }
    Response response = ResponseWrapper.wrap(HttpWrapper.wrap(target).get());
    List<T> entities = new ArrayList<T>();
    if (response != null && response.getStatus() == 200) {
      try {
        entities = response.readEntity(client.getGenericListType());
      } catch (ProcessingException e) {
        e.printStackTrace();
        LOG.warn(""Response did not conform to expected entity type. List expected."");
      }
    } else if (response != null) {
      response.bufferEntity();
    }
    if (response != null && response.getStatus() == Status.NOT_FOUND.getStatusCode()) {
      throw new NotFoundException();
    } else if (response != null && response.getStatus() == Status.REQUEST_TIMEOUT.getStatusCode()) {
      throw new TimeoutException();
    }
    return entities;
  }

  /**
   * Returns an Entity of the relevant type by using a unique non-primary-key
   * property. Example: Get user with user name. Note that the
   * AbstractCRUDEndpoint does not offer this feature by default.
   * 
   * @param client
   *          The REST client to use.
   * @param propertyURI
   *          Name of the property. E.g., ""name"".
   * @param propertyValue
   *          Value of the property, e.g., ""user1"".
   * @param <T>
   *          Type of entity to handle.
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws TimeoutException
   *           If 408 was returned.
   * @return The entity; null if it does not exist.
   */
  public static <T> T getEntityWithProperty(RESTClient<T> client, String propertyURI,
      String propertyValue) throws NotFoundException, TimeoutException {
    WebTarget target = client.getEndpointTarget().path(propertyURI).path(propertyValue);
    Response response = ResponseWrapper.wrap(HttpWrapper.wrap(target).get());
    T entity = null;
    if (response != null && response.getStatus() < 400) {
      try {
        entity = response.readEntity(client.getEntityClass());
      } catch (NullPointerException | ProcessingException e) {
        // This happens if no entity was found
      }
    } else if (response != null) {
      response.bufferEntity();
    }
    if (response != null && response.getStatus() == Status.NOT_FOUND.getStatusCode()) {
      throw new NotFoundException();
    } else if (response != null && response.getStatus() == Status.REQUEST_TIMEOUT.getStatusCode()) {
      throw new TimeoutException();
    }
    return entity;
  }

}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/rest/LoadBalancedCRUDOperations.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient.rest;

import java.util.List;
import java.util.Optional;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.util.NotFoundException;

/**
 * Default REST operations that transfer Entities to/from a service that has a
 * standard conforming REST-API. Uses load balancing to find the target
 * services.
 * 
 * @author Joakim von Kistowski
 */
public final class LoadBalancedCRUDOperations {

	private LoadBalancedCRUDOperations() {

	}

	/**
	 * Sends an Entity to be created ""as new"" by the receiving service.
	 * 
	 * @param entity
	 *            The new entity to create. ID may remain unset, it will be ignored
	 *            by target service.
	 * @param service
	 *            The service to load balance.
	 * @param endpointURI
	 *            The endpoint URI (e.g., ""products"").
	 * @param entityClass
	 *            The class of entities to send/receive.
	 * @param <T>
	 *            Type of entity to handle.
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return The new ID of the created entity. Target service creates a new ID,
	 *         any passed ID is ignored. Returns -1L if creation failed. Returns 0
	 *         if creation worked, but ID remains unkown.
	 */
	public static <T> long sendEntityForCreation(Service service, String endpointURI, Class<T> entityClass, T entity)
			throws NotFoundException, LoadBalancerTimeoutException {
		return Optional.ofNullable(ServiceLoadBalancer.loadBalanceRESTOperation(service, endpointURI, entityClass,
				client -> NonBalancedCRUDOperations.sendEntityForCreation(client, entity))).orElse(-1L);
	}

	/**
	 * Sends an Entity to be updated using the values of the provided entity. Note
	 * that not all values may be used by the receiving service. The values used
	 * depend on which changes are allowed in the domain model.
	 * 
	 * @param id
	 *            The id of the entity to update. Ids stored within the entity are
	 *            ignored.
	 * @param entity
	 *            The entity to be updated. Entity is matched using its ID.
	 * @param service
	 *            The service to load balance.
	 * @param endpointURI
	 *            The endpoint URI (e.g., ""products"").
	 * @param entityClass
	 *            The class of entities to send/receive.
	 * @param <T>
	 *            Type of entity to handle.
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return True, if update succeeded. False, otherwise.
	 */
	public static <T> boolean sendEntityForUpdate(Service service, String endpointURI, Class<T> entityClass, long id,
			T entity) throws NotFoundException, LoadBalancerTimeoutException {
		return Optional.ofNullable(ServiceLoadBalancer.loadBalanceRESTOperation(service, endpointURI, entityClass,
				client -> NonBalancedCRUDOperations.sendEntityForUpdate(client, id, entity))).orElse(false);
	}

	/**
	 * Deletes the entity at the target id.
	 * 
	 * @param id
	 *            The ID of the entity to delete.
	 * @param service
	 *            The service to load balance.
	 * @param endpointURI
	 *            The endpoint URI (e.g., ""products"").
	 * @param entityClass
	 *            The class of entities to send/receive.
	 * @param <T>
	 *            Type of entity to handle.
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return True, if deletion succeeded; false otherwise.
	 */
	public static <T> boolean deleteEntity(Service service, String endpointURI, Class<T> entityClass, long id)
			throws NotFoundException, LoadBalancerTimeoutException {
		return Optional.ofNullable(ServiceLoadBalancer.loadBalanceRESTOperation(service, endpointURI, entityClass,
				client -> NonBalancedCRUDOperations.deleteEntity(client, id))).orElse(false);
	}

	/**
	 * Returns the entity with the specified id. Returns null if it does not exist.
	 * 
	 * @param id
	 *            Id of the entity to find.
	 * @param service
	 *            The service to load balance.
	 * @param endpointURI
	 *            The endpoint URI (e.g., ""products"").
	 * @param entityClass
	 *            The class of entities to send/receive.
	 * @param <T>
	 *            Type of entity to handle.
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return The entity; null if it does not exist.
	 */
	public static <T> T getEntity(Service service, String endpointURI, Class<T> entityClass, long id)
			throws NotFoundException, LoadBalancerTimeoutException {
		return ServiceLoadBalancer.loadBalanceRESTOperation(service, endpointURI, entityClass,
				client -> NonBalancedCRUDOperations.getEntity(client, id));
	}

	/**
	 * Returns a list of Entities of the relevant type.
	 * 
	 * @param service
	 *            The service to load balance.
	 * @param endpointURI
	 *            The endpoint URI (e.g., ""products"").
	 * @param entityClass
	 *            The class of entities to send/receive.
	 * @param propertyName
	 *            name of filter property
	 * @param propertyValue
	 *            value of filter property
	 * @param <T>
	 *            Type of entity to handle.
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return List of entities; empty list if non were found.
	 */
	public static <T> T getEntityWithProperties(Service service, String endpointURI, Class<T> entityClass,
			String propertyName, String propertyValue) throws NotFoundException, LoadBalancerTimeoutException {
		return ServiceLoadBalancer.loadBalanceRESTOperation(service, endpointURI, entityClass,
				client -> NonBalancedCRUDOperations.getEntityWithProperty(client, propertyName, propertyValue));
	}

	/**
	 * Returns a list of Entities of the relevant type.
	 * 
	 * @param service
	 *            The service to load balance.
	 * @param endpointURI
	 *            The endpoint URI (e.g., ""products"").
	 * @param entityClass
	 *            The class of entities to send/receive.
	 * @param startIndex
	 *            The index of the first entity to return (index, not ID!). -1, if
	 *            you don't want to set an index.
	 * @param limit
	 *            Maximum amount of entities to return. -1, for no max.
	 * @param <T>
	 *            Type of entity to handle.
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return List of entities; empty list if non were found.
	 */
	public static <T> List<T> getEntities(Service service, String endpointURI, Class<T> entityClass, int startIndex,
			int limit) throws NotFoundException, LoadBalancerTimeoutException {
		return ServiceLoadBalancer.loadBalanceRESTOperation(service, endpointURI, entityClass,
				client -> NonBalancedCRUDOperations.getEntities(client, startIndex, limit));
	}

	/**
	 * Returns a list of Entities of the relevant type after filtering using a path
	 * param query. Example: ""category"", 2, 1, 3 will return 3 items in Category
	 * with ID 2, beginning from item with index 1 (skipping item 0). Note that the
	 * AbstractCRUDEndpoint does not offer this feature by default.
	 * 
	 * @param service
	 *            The service to load balance.
	 * @param endpointURI
	 *            The endpoint URI (e.g., ""products"").
	 * @param entityClass
	 *            The class of entities to send/receive.
	 * @param filterURI
	 *            Name of the objects to filter for. E.g., ""category"".
	 * @param filterId
	 *            Id of the Object to filter for. E.g, 2
	 * @param startIndex
	 *            The index of the first entity to return (index, not ID!). -1, if
	 *            you don't want to set an index.
	 * @param limit
	 *            Maximum amount of entities to return. -1, for no max.
	 * @param <T>
	 *            Type of entity to handle.
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return List of entities; empty list if non were found.
	 */
	public static <T> List<T> getEntities(Service service, String endpointURI, Class<T> entityClass, String filterURI,
			long filterId, int startIndex, int limit) throws NotFoundException, LoadBalancerTimeoutException {
		return ServiceLoadBalancer.loadBalanceRESTOperation(service, endpointURI, entityClass,
				client -> NonBalancedCRUDOperations.getEntities(client, filterURI, filterId, startIndex, limit));
	}

}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/rest/ResponseWrapper.java,"package tools.descartes.teastore.registryclient.rest;

import jakarta.ws.rs.core.Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import kieker.common.record.controlflow.OperationExecutionRecord;
import kieker.monitoring.core.controller.IMonitoringController;
import kieker.monitoring.core.controller.MonitoringController;
import kieker.monitoring.core.registry.ControlFlowRegistry;
import kieker.monitoring.core.registry.SessionRegistry;

/**
 * Wrapper for http responses.
 *
 * @author Simon
 *
 */
public final class ResponseWrapper {

  private static final IMonitoringController CTRLINST = MonitoringController.getInstance();
  private static final ControlFlowRegistry CF_REGISTRY = ControlFlowRegistry.INSTANCE;
  private static final SessionRegistry SESSION_REGISTRY = SessionRegistry.INSTANCE;
  private static final String HEADER_FIELD = ""KiekerTracingInfo"";
  private static final Logger LOG = LoggerFactory.getLogger(ResponseWrapper.class);
  private static final String SESSION_ID_ASYNC_TRACE = ""NOSESSION-ASYNCIN"";

  /**
   * Hide default constructor.
   */
  private ResponseWrapper() {

  }

  /**
   * Hook for monitoring.
   *
   * @param response
   *          response
   * @return response response
   */
  public static Response wrap(Response response) {
    if (CTRLINST.isMonitoringEnabled()) {
      long traceId = -1L;
      int eoi;
      int ess;
      String sessionId;

      final String operationExecutionHeader = response.getHeaderString(HEADER_FIELD);
      if ((operationExecutionHeader == null) || (operationExecutionHeader.equals(""""))) {
        LOG.warn(""Response without tracking id was found"");
      } else {

        final String[] headerArray = operationExecutionHeader.split("","");

        // Extract session id
        sessionId = headerArray[1];
        if (""null"".equals(sessionId)) {
          sessionId = OperationExecutionRecord.NO_SESSION_ID;
        }

        // Extract EOI
        final String eoiStr = headerArray[2];
        eoi = -1;
        try {
          eoi = Integer.parseInt(eoiStr);
        } catch (final NumberFormatException exc) {
          LOG.warn(""Invalid eoi"", exc);
        }

        // Extract ESS
        final String essStr = headerArray[3];
        ess = -1;
        try {
          ess = Integer.parseInt(essStr);
        } catch (final NumberFormatException exc) {
          LOG.warn(""Invalid ess"", exc);
        }

        // Extract trace id
        final String traceIdStr = headerArray[0];
        if (traceIdStr != null) {
          try {
            traceId = Long.parseLong(traceIdStr);
          } catch (final NumberFormatException exc) {
            LOG.warn(""Invalid trace id"", exc);
          }
        } else {
          traceId = CF_REGISTRY.getUniqueTraceId();
          sessionId = SESSION_ID_ASYNC_TRACE;
          eoi = 0; // EOI of this execution
          ess = 0; // ESS of this execution
        }

        // Store thread-local values
        CF_REGISTRY.storeThreadLocalTraceId(traceId);
        CF_REGISTRY.storeThreadLocalEOI(eoi); // this execution has EOI=eoi; next execution will get
                                              // eoi with incrementAndRecall
        CF_REGISTRY.storeThreadLocalESS(ess); // this execution has ESS=ess
        SESSION_REGISTRY.storeThreadLocalSessionId(sessionId);
      }
    }
    return response;
  }

}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/rest/LoadBalancedStoreOperations.java,"package tools.descartes.teastore.registryclient.rest;

import jakarta.ws.rs.client.Entity;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.util.NotFoundException;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.message.SessionBlob;

/**
 * Container class for the static calls to the Store service.
 * 
 * @author Simon
 *
 */
public final class LoadBalancedStoreOperations {

  private LoadBalancedStoreOperations() {

  }

  /**
   * Persists order in database.
   * 
   * @param blob
   *          Sessionblob
   * @param addressName
   *          adress
   * @param address1
   *          adress
   * @param address2
   *          adress
   * @param creditCardCompany
   *          creditcard
   * @param creditCardExpiryDate
   *          creditcard
   * @param creditCardNumber
   *          creditcard
   * @param totalPriceInCents
   *          totalPrice
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws LoadBalancerTimeoutException
   *           On receiving the 408 status code and on repeated load balancer
   *           socket timeouts.
   * @return empty SessionBlob
   */
  public static SessionBlob placeOrder(SessionBlob blob, String addressName, String address1,
      String address2, String creditCardCompany, String creditCardExpiryDate,
      long totalPriceInCents, String creditCardNumber)
      throws NotFoundException, LoadBalancerTimeoutException {
    Response r = ServiceLoadBalancer.loadBalanceRESTOperation(Service.AUTH, ""useractions"",
        Product.class,
        client -> ResponseWrapper.wrap(HttpWrapper
            .wrap(client.getEndpointTarget().path(""placeorder"")
                .queryParam(""addressName"", addressName).queryParam(""address1"", address1)
                .queryParam(""address2"", address2).queryParam(""creditCardCompany"", creditCardCompany)
                .queryParam(""creditCardNumber"", creditCardNumber)
                .queryParam(""creditCardExpiryDate"", creditCardExpiryDate)
                .queryParam(""totalPriceInCents"", totalPriceInCents))
            .post(Entity.entity(blob, MediaType.APPLICATION_JSON), Response.class)));
    return RestUtil.readThrowAndOrClose(r, SessionBlob.class);
  }

  /**
   * Login if name and pw are correct.
   * 
   * @param blob
   *          SessionBlob
   * @param name
   *          username
   * @param password
   *          user password
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws LoadBalancerTimeoutException
   *           On receiving the 408 status code and on repeated load balancer
   *           socket timeouts.
   * @return SessionBlob with login information if login was successful
   */
  public static SessionBlob login(SessionBlob blob, String name, String password)
      throws NotFoundException, LoadBalancerTimeoutException {
    Response r = ServiceLoadBalancer.loadBalanceRESTOperation(Service.AUTH, ""useractions"",
        Product.class,
        client -> ResponseWrapper.wrap(HttpWrapper
            .wrap(client.getEndpointTarget().path(""login"").queryParam(""name"", name)
                .queryParam(""password"", password))
            .post(Entity.entity(blob, MediaType.APPLICATION_JSON), Response.class)));
    return RestUtil.readThrowAndOrClose(r, SessionBlob.class);
  }

  /**
   * Logs user out.
   * 
   * @param blob
   *          SessionBlob
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws LoadBalancerTimeoutException
   *           On receiving the 408 status code and on repeated load balancer
   *           socket timeouts.
   * @return SessionBlob without user information
   */
  public static SessionBlob logout(SessionBlob blob)
      throws NotFoundException, LoadBalancerTimeoutException {
    Response r = ServiceLoadBalancer.loadBalanceRESTOperation(Service.AUTH, ""useractions"",
        Product.class,
        client -> ResponseWrapper.wrap(HttpWrapper.wrap(client.getEndpointTarget().path(""logout""))
            .post(Entity.entity(blob, MediaType.APPLICATION_JSON), Response.class)));
    return RestUtil.readThrowAndOrClose(r, SessionBlob.class);
  }

  /**
   * Checks if user is logged in.
   * 
   * @param blob
   *          SessionBlob
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws LoadBalancerTimeoutException
   *           On receiving the 408 status code and on repeated load balancer
   *           socket timeouts.
   * @return true if user is logged in
   */
  public static boolean isLoggedIn(SessionBlob blob)
      throws NotFoundException, LoadBalancerTimeoutException {
    Response r = ServiceLoadBalancer.loadBalanceRESTOperation(Service.AUTH, ""useractions"",
        Product.class,
        client -> ResponseWrapper
            .wrap(HttpWrapper.wrap(client.getEndpointTarget().path(""isloggedin""))
                .post(Entity.entity(blob, MediaType.APPLICATION_JSON), Response.class)));
    return RestUtil.readThrowAndOrClose(r, SessionBlob.class) != null;
  }

  /**
   * Adds product to cart. if the item is already in the cart, the quantity is
   * increased.
   * 
   * @param blob
   *          SessionBlob
   * @param pid
   *          ProductId
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws LoadBalancerTimeoutException
   *           On receiving the 408 status code and on repeated load balancer
   *           socket timeouts.
   * @return Sessionblob containing product
   */
  public static SessionBlob addProductToCart(SessionBlob blob, long pid)
      throws NotFoundException, LoadBalancerTimeoutException {
    Response r = ServiceLoadBalancer.loadBalanceRESTOperation(Service.AUTH, ""cart"", Product.class,
        client -> ResponseWrapper
            .wrap(HttpWrapper.wrap(client.getEndpointTarget().path(""add"").path("""" + pid))
                .post(Entity.entity(blob, MediaType.APPLICATION_JSON), Response.class)));
    return RestUtil.readThrowAndOrClose(r, SessionBlob.class);
  }

  /**
   * Removes product from cart.
   * 
   * @param blob
   *          Sessionblob
   * @param pid
   *          productid
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws LoadBalancerTimeoutException
   *           On receiving the 408 status code and on repeated load balancer
   *           socket timeouts.
   * @return Sessionblob without product
   */
  public static SessionBlob removeProductFromCart(SessionBlob blob, long pid)
      throws NotFoundException, LoadBalancerTimeoutException {
    Response r = ServiceLoadBalancer.loadBalanceRESTOperation(Service.AUTH, ""cart"", Product.class,
        client -> ResponseWrapper
            .wrap(HttpWrapper.wrap(client.getEndpointTarget().path(""remove"").path("""" + pid))
                .post(Entity.entity(blob, MediaType.APPLICATION_JSON), Response.class)));
    return RestUtil.readThrowAndOrClose(r, SessionBlob.class);
  }

  /**
   * Updates quantity of item in cart.
   * 
   * @param blob
   *          Sessionblob
   * @param pid
   *          productid of item
   * @param quantity
   *          target quantity
   * @throws NotFoundException
   *           If 404 was returned.
   * @throws LoadBalancerTimeoutException
   *           On receiving the 408 status code and on repeated load balancer
   *           socket timeouts.
   * @return Sessionblob with updated quantity
   */
  public static SessionBlob updateQuantity(SessionBlob blob, long pid, int quantity)
      throws NotFoundException, LoadBalancerTimeoutException {
    if (quantity < 1) {
      throw new IllegalArgumentException(""Quantity has to be larger than 1"");
    }
    Response r = ServiceLoadBalancer.loadBalanceRESTOperation(Service.AUTH, ""cart"", Product.class,
        client -> ResponseWrapper.wrap(HttpWrapper
            .wrap(client.getEndpointTarget().path("""" + pid).queryParam(""quantity"", quantity))
            .put(Entity.entity(blob, MediaType.APPLICATION_JSON), Response.class)));
    return RestUtil.readThrowAndOrClose(r, SessionBlob.class);
  }

}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/rest/RestUtil.java,"package tools.descartes.teastore.registryclient.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.core.GenericType;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.util.NotFoundException;
import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.Product;

/**
 * Utilities.
 * @author Simon
 *
 */
public final class RestUtil {
	
  /**
   * hides constructor.
   */
  private RestUtil() {
    
  }
  
  /**
   * Throw common exceptions.
   * @param responseWithStatus response
   * @throws NotFoundException error 404
   * @throws LoadBalancerTimeoutException timeout error
   */
	public static void throwCommonExceptions(Response responseWithStatus)
			throws NotFoundException, LoadBalancerTimeoutException {
		if (responseWithStatus.getStatus() == Status.NOT_FOUND.getStatusCode()) {
			throw new NotFoundException();
		} else if (responseWithStatus.getStatus() == Status.REQUEST_TIMEOUT.getStatusCode()) {
			throw new LoadBalancerTimeoutException(""Timout waiting for Store."", Service.AUTH);
		}
	}
	
	/**
	 * Read entity or return null-.
	 * @param r external call response
	 * @param entityClass class of object to load
   * @param <T> class of object to be loaded
	 * @return entity or null
	 */
	public static <T> T readEntityOrNull(Response r, Class<T> entityClass) {
		if (r != null) {
			if (r.getStatus() == 200) {
				return r.readEntity(entityClass);
			} else {
				r.bufferEntity();
			}
		}
		return null;
	}
	
	/**
	 * reads entity, throws potential errors and closes the response.
	 * @param responseWithStatus response 
	 * @param entityClass class of object to be loaded
	 * @param <T> class of object to be loaded
	 * @return entity
	 */
	public static <T> T readThrowAndOrClose(Response responseWithStatus, Class<T> entityClass) {
		T entity = null;
		entity = readEntityOrNull(responseWithStatus, entityClass);
		throwCommonExceptions(responseWithStatus);
		return entity;
	}

  /**
   * Special case for orders.
   * @param r response 
   * @return List of orders
   */
	public static List<Order> readListThrowAndOrCloseOrder(Response r) {
		List<Order> entity = null;
		if (r != null) {
			if (r.getStatus() == 200) {
				entity = r.readEntity(new GenericType<List<Order>>() { });
			} else {
				r.bufferEntity();
			}
		}
		if (r == null || entity == null) {
			entity = new ArrayList<Order>();
		}
		throwCommonExceptions(r);
		return entity;
	}
	
	/**
	 * Special case for products.
	 * @param r response
	 * @return List of products
	 */
	public static List<Product> readListThrowAndOrCloseProduct(Response r) {
		List<Product> entity = null;
		if (r != null) {
			if (r.getStatus() == 200) {
				entity = r.readEntity(new GenericType<List<Product>>() { });
			} else {
				r.bufferEntity();
			}
		}
		if (r == null || entity == null) {
			entity = new ArrayList<Product>();
		}
		throwCommonExceptions(r);
		return entity;
	}
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/rest/LoadBalancedRecommenderOperations.java,"package tools.descartes.teastore.registryclient.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.client.Entity;
import jakarta.ws.rs.core.GenericType;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.LoadBalancerTimeoutException;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.util.NotFoundException;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.OrderItem;

/**
 * Container class for the static calls to the Store service.
 * 
 * @author Simon
 *
 */
public final class LoadBalancedRecommenderOperations {

	private LoadBalancedRecommenderOperations() {

	}

	/**
	 * Gets recommendations.
	 * 
	 * @param order
	 *            list of order items
	 * @param uid userId
	 * @throws NotFoundException
	 *             If 404 was returned.
	 * @throws LoadBalancerTimeoutException
	 *             On receiving the 408 status code and on repeated load balancer
	 *             socket timeouts.
	 * @return List of recommended order ids
	 */
	public static List<Long> getRecommendations(List<OrderItem> order, Long uid)
			throws NotFoundException, LoadBalancerTimeoutException {
		Response r = ServiceLoadBalancer.loadBalanceRESTOperation(Service.RECOMMENDER, ""recommend"", Category.class,
				client -> ResponseWrapper.wrap(HttpWrapper.wrap(client.getEndpointTarget().queryParam(""uid"", uid))
						.post(Entity.entity(order, MediaType.APPLICATION_JSON))));
		if (r != null) {
			if (r.getStatus() < 400) {
				return r.readEntity(new GenericType<List<Long>>() {
				});
			} else {
				r.bufferEntity();
			}
		}
		return new ArrayList<>();
	}
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/rest/TrackingFilter.java,"package tools.descartes.teastore.registryclient.rest;

import java.io.IOException;
import java.io.PrintWriter;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import io.opentracing.Scope;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import kieker.common.record.controlflow.OperationExecutionRecord;
import kieker.monitoring.core.controller.IMonitoringController;
import kieker.monitoring.core.controller.MonitoringController;
import kieker.monitoring.core.registry.ControlFlowRegistry;
import kieker.monitoring.core.registry.SessionRegistry;
import tools.descartes.teastore.registryclient.tracing.Tracing;

/**
 * Servlet filter for request tracking.
 *
 * @author Simon
 *
 */
public class TrackingFilter implements Filter {

  private static final Logger LOG = LoggerFactory.getLogger(TrackingFilter.class);

  private static final IMonitoringController CTRLINST = MonitoringController.getInstance();
  private static final String SESSION_ID_ASYNC_TRACE = ""NOSESSION-ASYNCIN"";
  private static final ControlFlowRegistry CF_REGISTRY = ControlFlowRegistry.INSTANCE;
  private static final SessionRegistry SESSION_REGISTRY = SessionRegistry.INSTANCE;
  private static final String HEADER_FIELD = ""KiekerTracingInfo"";

  /**
   * empty initialization method.
   *
   * @param filterConfig configuration of filter
   * @throws ServletException servletException
   */
  public void init(FilterConfig filterConfig) throws ServletException {

  }

  /**
   * Filter method that appends tracking id.
   *
   * @param request  request
   * @param response response
   * @param chain    filter chain
   * @throws IOException      ioException
   * @throws ServletException servletException
   */
  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
      throws IOException, ServletException {
    try (Scope scope = Tracing.extractCurrentSpan((HttpServletRequest) request)) {
      if (!CTRLINST.isMonitoringEnabled()) {
        chain.doFilter(request, response);
        return;
      }
      if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {
        String url = ((HttpServletRequest) request).getRequestURL().toString();
        if (url.contains(""webui"")) {
          chain.doFilter(request, response);
          return;
        }
        HttpServletRequest req = (HttpServletRequest) request;
        String sessionId = SESSION_REGISTRY.recallThreadLocalSessionId();
        long traceId = -1L;
        int eoi;
        int ess;

        final String operationExecutionHeader = req.getHeader(HEADER_FIELD);

        if ((operationExecutionHeader == null) || (operationExecutionHeader.equals(""""))) {
          LOG.debug(""No monitoring data found in the incoming request header"");
          // LOG.info(""Will continue without sending back reponse header"");
          traceId = CF_REGISTRY.getAndStoreUniqueThreadLocalTraceId();
          CF_REGISTRY.storeThreadLocalEOI(0);
          CF_REGISTRY.storeThreadLocalESS(1); // next operation is ess + 1
          eoi = 0;
          ess = 0;
        } else {
          if (LOG.isDebugEnabled()) {
            LOG.debug(""Received request: "" + req.getMethod() + ""with header = "" + operationExecutionHeader);
          }
          final String[] headerArray = operationExecutionHeader.split("","");

          // Extract session id
          sessionId = headerArray[1];
          if (""null"".equals(sessionId)) {
            sessionId = OperationExecutionRecord.NO_SESSION_ID;
          }

          // Extract EOI
          final String eoiStr = headerArray[2];
          eoi = -1;
          try {
            eoi = Integer.parseInt(eoiStr);
          } catch (final NumberFormatException exc) {
            LOG.warn(""Invalid eoi"", exc);
          }

          // Extract ESS
          final String essStr = headerArray[3];
          ess = -1;
          try {
            ess = Integer.parseInt(essStr);
          } catch (final NumberFormatException exc) {
            LOG.warn(""Invalid ess"", exc);
          }

          // Extract trace id
          final String traceIdStr = headerArray[0];
          if (traceIdStr != null) {
            try {
              traceId = Long.parseLong(traceIdStr);
            } catch (final NumberFormatException exc) {
              LOG.warn(""Invalid trace id"", exc);
            }
          } else {
            traceId = CF_REGISTRY.getUniqueTraceId();
            sessionId = SESSION_ID_ASYNC_TRACE;
            eoi = 0; // EOI of this execution
            ess = 0; // ESS of this execution
          }

          // Store thread-local values
          CF_REGISTRY.storeThreadLocalTraceId(traceId);
          CF_REGISTRY.storeThreadLocalEOI(eoi);
          CF_REGISTRY.storeThreadLocalESS(ess);
          SESSION_REGISTRY.storeThreadLocalSessionId(sessionId);
        }

      } else {
        LOG.error(""Something went wrong"");
      }
      CharResponseWrapper wrappedResponse = new CharResponseWrapper((HttpServletResponse) response);
      PrintWriter out = response.getWriter();

      chain.doFilter(request, wrappedResponse);

      String sessionId = SESSION_REGISTRY.recallThreadLocalSessionId();
      long traceId = CF_REGISTRY.recallThreadLocalTraceId();
      int eoi = CF_REGISTRY.recallThreadLocalEOI();
      wrappedResponse.addHeader(HEADER_FIELD,
          traceId + "","" + sessionId + "","" + (eoi) + "","" + Integer.toString(CF_REGISTRY.recallThreadLocalESS()));
      out.write(wrappedResponse.toString());
    }
  }

  /**
   * Teardown method.
   */
  public void destroy() {
    CF_REGISTRY.unsetThreadLocalTraceId();
    CF_REGISTRY.unsetThreadLocalEOI();
    CF_REGISTRY.unsetThreadLocalESS();
  }
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/loadbalancers/LoadBalancerTimeoutException.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient.loadbalancers;

import tools.descartes.teastore.registryclient.Service;

/**
 * Exception thrown for too many load balancer retries.
 * @author Joakim von Kistowski
 *
 */
public class LoadBalancerTimeoutException extends RuntimeException {

	private static final long serialVersionUID = 5101941775644953394L;

	private Service targetService;

	/**
	 * Creates a new LoadBalancerTimoutException.
	 * @param message The the timeout message.
	 * @param targetService The service for which the load balancer failed.
	 */
	public LoadBalancerTimeoutException(String message, Service targetService) {
		super(message);
		this.targetService = targetService;
	}
	
	/**
	 * Returns the service for which the timeout occurred.
	 * @return The service for which the timeout occurred.
	 */
	public Service getTargetService() {
		return targetService;
	}
	
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/loadbalancers/EndpointClientCollection.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient.loadbalancers;

import java.util.Collection;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import com.netflix.loadbalancer.Server;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.util.RESTClient;

/**
 * Load balancer for a REST endpoint. Balances between the different servers.
 * @author Joakim von Kistowski
 * @param <T> Type of the entity class returned by the endpoint.
 */
public class EndpointClientCollection<T> {
	
	 //load balancer for each endpoint has REST clients for each server
    private ConcurrentHashMap<Server, RESTClient<T>> clients = new ConcurrentHashMap<>();
    
    
    private final Class<T> entityClass;
	private final Service targetService;
	private final String endpointURI;
    
	/**
	 * Create a new endpoint client collection.
	 * @param targetService The service to address.
	 * @param endpointURI The endpoint URI (e.g., ""products"").
	 * @param entityClass The class of the entities to pass around.
	 */
	EndpointClientCollection(Service targetService, String endpointURI, final Class<T> entityClass) {
		this.endpointURI = endpointURI;
		this.targetService = targetService;
		this.entityClass = entityClass;
	}
	
	/**
	 * Checks for updates in the list of relevant servers.
	 * Rebuilds the load balancer if server list changed.
	 * @param newServers The newly received list from the registry.
	 */
	void updateServers(Collection<Server> newServers) {
		Set<Server> oldServers = clients.keySet();
		//don't do anything if nothing changed
		if (oldServers.size() == newServers.size() && newServers.containsAll(oldServers)) {
			return;
		}
		updateClients(newServers);
	}
	
	/**
	 * Get the endpoint URI.
	 * @return The REST enpoint URI (e.g., ""products"").
	 */
	public String getEndpointURI() {
		return endpointURI;
	}
	
	private void updateClients(Collection<Server> newServers) {
    	//remove outdated clients
    	for (Server s : clients.keySet()) {
    		if (!newServers.contains(s)) {
    			clients.remove(s);
    		}
    	}
    	//add new clients
    	for (Server s : newServers) {
    		clients.putIfAbsent(s, new RESTClient<T>(s.getHost() + "":""
    					+ s.getPort() + ""/"" + targetService.getServiceName(),
					RESTClient.DEFAULT_REST_APPLICATION, endpointURI, entityClass));
    	}
    }
	
	/**
	 * Gets the rest client for a server. Returns null if it doesnt exist.
	 * @param server The server for which to get the client.
	 * @return The server.
	 */
	RESTClient<T> getRESTClient(Server server) {
		return clients.get(server);
	}
	
//	public <R> R loadBalanceRESTOperation(Function<AbstractRESTClient<T>, R> operation) {
//		return LoadBalancerCommand.<R>builder()
//                .withLoadBalancer(loadBalancer)
//                .withRetryHandler(retryHandler)
//                .build()
//                .submit(server -> Observable.just(operation.apply(clients.get(server))))
//                .toBlocking().first();
//	}
	
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/loadbalancers/ServiceLoadBalancerResult.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient.loadbalancers;

import java.util.function.Function;

import tools.descartes.teastore.registryclient.util.NotFoundException;
import tools.descartes.teastore.registryclient.util.RESTClient;
import tools.descartes.teastore.registryclient.util.TimeoutException;

/**
 * Wrapper for results from service load balancer calls.
 * @param <R> Entity Type to wrap.
 * @author Joakim von Kistowski
 *
 */
final class ServiceLoadBalancerResult<R> {

	private int statusCode = 200;
	private R entity = null;
	
	private ServiceLoadBalancerResult() {
		
	}
	
	/**
	 * Create a load balancer result by performing a REST operation.
	 * @param client The rest client to perform the operation with (determined by load balancer).
	 * @param operation The operation to perform (passed from the user).
	 * @param <T> REST client type.
	 * @param <R> Entity type.
	 * @throws TimeoutException On receiving the 408 status code.
	 * @throws NotFoundException On receiving the 404 status code.
	 * @return The result. Entity is always null on failure.
	 */
	static <T, R> ServiceLoadBalancerResult<R> fromRESTOperation(
			RESTClient<T> client, Function<RESTClient<T>, R> operation)
			throws NotFoundException, TimeoutException {
		ServiceLoadBalancerResult<R> result = new ServiceLoadBalancerResult<>();
		try {
			result.setEntity(operation.apply(client));
		} catch (NotFoundException e) {
			result.setStatusCode(NotFoundException.ERROR_CODE);
		} catch (TimeoutException e) {
			result.setStatusCode(TimeoutException.ERROR_CODE);
		}
		return result;
	}

	/**
	 * Get the status code for the returned response.
	 * @return The status code.
	 */
	public int getStatusCode() {
		return statusCode;
	}

	/**
	 * Set the status code for the returned response.
	 * @param statusCode The status code.
	 */
	private void setStatusCode(int statusCode) {
		this.statusCode = statusCode;
	}

	/**
	 * Get the entity from the returned response.
	 * @return The entity.
	 */
	public R getEntity() {
		return entity;
	}

	/**
	 * Set the entity from the returned response.
	 * @param entity The entity.
	 */
	private void setEntity(R entity) {
		this.entity = entity;
	}
	
	
	
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/loadbalancers/LoadBalancerUpdaterDaemon.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient.loadbalancers;

/**
 * Daemon for updating load balancers using the registry.
 * 
 * @author Joakim von Kistowski
 *
 */
public class LoadBalancerUpdaterDaemon implements Runnable {

	/**
	 * Run the daemon.
	 */
	@Override
	public void run() {
		try {
			ServiceLoadBalancer.updateLoadBalancersForKnownServicesUsingRegistry();
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e);
		}
	}

}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/loadbalancers/ServiceLoadBalancer.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient.loadbalancers;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.Function;
import java.util.stream.Collectors;

import jakarta.ws.rs.core.Response.Status;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.netflix.client.DefaultLoadBalancerRetryHandler;
import com.netflix.client.RetryHandler;
import com.netflix.loadbalancer.BaseLoadBalancer;
import com.netflix.loadbalancer.LoadBalancerBuilder;
import com.netflix.loadbalancer.Server;
import com.netflix.loadbalancer.reactive.LoadBalancerCommand;

import rx.Observable;
import tools.descartes.teastore.registryclient.RegistryClient;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.util.NotFoundException;
import tools.descartes.teastore.registryclient.util.RESTClient;

/**
 * The load balancer for services.
 * @author Joakim von Kistowski
 *
 */
public final class ServiceLoadBalancer {

	private static final Logger LOG = LoggerFactory.getLogger(ServiceLoadBalancer.class);

	//Loadbalancers for each service name
	private static ConcurrentHashMap<String, ServiceLoadBalancer> serviceMap = new ConcurrentHashMap<>();

	//clients for each endpoint (for a fixed service)
	private ConcurrentHashMap<String, EndpointClientCollection<?>> endpointMap = new ConcurrentHashMap<>();
	private final Service targetService;
	private Set<Server> serviceServers = new HashSet<Server>();

	private BaseLoadBalancer loadBalancer;
    // retry handler that does not retry on same server, but on a different server
    private final RetryHandler retryHandler = new DefaultLoadBalancerRetryHandler(0, 2, true);

    private ReadWriteLock loadBalancerModificationLock = new ReentrantReadWriteLock();

    //private constructor
    private ServiceLoadBalancer(final Service targetService) {
    	this.targetService = targetService;
    }

    /**
     * Initializes load balancers for the target services.
     * Queries target service instances from the registry.
     * @param targetServices The services to pre-initialize.
     */
    public static void preInitializeServiceLoadBalancers(Service... targetServices) {
    	for (Service service : targetServices) {
    		//initialize before logging in case the compiler optimizes it away when log-level info is not set
    		getServiceLoadBalancer(service);
    		//log the state to prevent the compiler from optimizing the initialization away
    		LOG.info(""Pre-initializing client-side load balancer for target: ""
			 + getServiceLoadBalancer(service).targetService.getServiceName());
    	}
    }

	private static ServiceLoadBalancer getServiceLoadBalancer(Service targetService) {
		ServiceLoadBalancer serviceBalancer = serviceMap.get(targetService.getServiceName());
    	if (serviceBalancer == null
    			|| serviceBalancer.serviceServers == null
    			|| serviceBalancer.serviceServers.isEmpty()) {
    		serviceMap.putIfAbsent(targetService.getServiceName(), new ServiceLoadBalancer(targetService));
    		updateLoadBalancersForServiceUsingRegistry(targetService);
    	}
    	return serviceMap.get(targetService.getServiceName());
    }

	/**
	 * Gets the load balancer for a service. Initializes it with a list of know servers,
	 * if the service is not known exists.
	 * @param targetService The service for which to get the balancer
	 * @param knownServers The list of know servers.
	 * @return The load balancer.
	 */
	static ServiceLoadBalancer getServiceLoadBalancer(Service targetService, List<Server> knownServers) {
		ServiceLoadBalancer serviceBalancer = ServiceLoadBalancer.serviceMap.get(targetService.getServiceName());
    	if (serviceBalancer == null
    			|| serviceBalancer.serviceServers == null
    			|| serviceBalancer.serviceServers.isEmpty()) {
    		serviceMap.putIfAbsent(targetService.getServiceName(), new ServiceLoadBalancer(targetService));
    		updateLoadBalancersForService(targetService, knownServers);
    	}
    	return serviceMap.get(targetService.getServiceName());
    }

	@SuppressWarnings(""unchecked"")
	private <T> EndpointClientCollection<T> getEndpointClientCollection(String endpointURI, Class<T> entityClass) {
		EndpointClientCollection<?> endpointCollection = endpointMap.get(endpointURI);
    	if (endpointCollection == null) {
    		endpointMap.putIfAbsent(endpointURI,
    				new EndpointClientCollection<T>(targetService, endpointURI, entityClass));
    		endpointMap.get(endpointURI).updateServers(serviceServers);
    	}
    	endpointCollection = endpointMap.get(endpointURI);
    	return (EndpointClientCollection<T>) endpointCollection;
	}

	/**
	 * Update all load balancers for a service. Triggers Registry client to ask registry for updates.
	 */
	static void updateLoadBalancersForKnownServicesUsingRegistry() {
		serviceMap.values().forEach(balancer -> updateLoadBalancersForServiceUsingRegistry(balancer.targetService));
    }

	/**
	 * Update all load balancers for a service with servers. Triggers Registry client to ask registry for updates.
	 * @param targetService The service for which to update.
	 */
    private static void updateLoadBalancersForServiceUsingRegistry(Service targetService) {
    	List<Server> servers = RegistryClient.getClient().getServersForService(targetService);
    	updateLoadBalancersForService(targetService, servers);
    }

	/**
	 * Update all load balancers for a service. Call if server list has changed.
	 * @param newServers New servers with which to update the load balancers.
	 * @param targetService The service for which to update.
	 */
    static void updateLoadBalancersForService(Service targetService, List<Server> newServers) {
    	ServiceLoadBalancer serviceBalancer = serviceMap.get(targetService.getServiceName());
    	if (serviceBalancer == null) {
    		return;
    	}
    	serviceBalancer.updateLoadBalancer(newServers);
    }

    private void updateLoadBalancer(List<Server> newServers) {
    	if (serviceServers == null) {
    		serviceServers = new HashSet<Server>();
    	}
    	if (newServers == null) {
    		newServers = new ArrayList<Server>();
    	}
    	//return if nothing changed
    	if ((serviceServers.isEmpty() && newServers.isEmpty())
    		|| (newServers.size() == serviceServers.size() && serviceServers.containsAll(newServers))) {
    		return;
    	}
    	serviceServers = new HashSet<Server>(newServers);
    	loadBalancerModificationLock.writeLock().lock();
    	try {
	    	if (loadBalancer != null) {
	    		loadBalancer.shutdown();
	    	}
	    	loadBalancer = LoadBalancerBuilder.newBuilder().buildFixedServerListLoadBalancer(newServers);
	    	for (EndpointClientCollection<?> lb : endpointMap.values()) {
	    		lb.updateServers(newServers);
	    	}
    	} finally {
    		loadBalancerModificationLock.writeLock().unlock();
    	}
    }

    /**
     * Load balances a REST operation. Automatically creates the needed load balancers, clients, etc. if needed.
     * @param targetService The service to load balance.
     * @param endpointURI The endpoint URI (e.g., ""products"").
     * @param entityClass The class of entities to send/receive.
     * @param operation The operation to load balance as Java8 lambda.
     * 				E.g.: ""client -> CRUDOperations.getEntity(client, id)"".
     * @param <R> The expected return type.
     * @param <T> The entity type of the entity to send/receive.
     * @throws LoadBalancerTimeoutException On receiving the 408 status code
     * and on repeated load balancer socket timeouts.
	 * @throws NotFoundException On receiving the 404 status code.
     * @return Returns the return value of the load balanced operation.
     */
    public static <T, R> R loadBalanceRESTOperation(Service targetService,
    		String endpointURI, Class<T> entityClass,
    		Function<RESTClient<T>, R> operation) throws NotFoundException, LoadBalancerTimeoutException {
    	return getServiceLoadBalancer(targetService).loadBalanceRESTOperation(endpointURI, entityClass, operation);
	}

    private <T, R> R loadBalanceRESTOperation(String endpointURI,
    		Class<T> entityClass, Function<RESTClient<T>, R> operation)
    				throws NotFoundException, LoadBalancerTimeoutException {
    	R r = null;
    	loadBalancerModificationLock.readLock().lock();
    	try {
    		if (loadBalancer == null) {
        		LOG.warn(""Load Balancer was not initialized for service: "" + targetService.getServiceName()
        			+ "". Is Registry up?"");
        		updateLoadBalancersForServiceUsingRegistry(targetService);
        	}
        	if (loadBalancer == null || loadBalancer.getAllServers().isEmpty()) {
        		LOG.warn(""No Server registered for Service: "" + targetService.getServiceName());
        	} else {
        		ServiceLoadBalancerResult<R> slbr = LoadBalancerCommand.<ServiceLoadBalancerResult<R>>builder()
                        .withLoadBalancer(loadBalancer)
                        .withRetryHandler(retryHandler)
                        .build()
                        .submit(server -> Observable.just(
                        		ServiceLoadBalancerResult.fromRESTOperation(
                        				(RESTClient<T>) getEndpointClientCollection(endpointURI, entityClass)
                				.getRESTClient(server), operation)
                        		))
						.onErrorReturn((Throwable e) -> {
							e.printStackTrace();
							return null;
						}).toBlocking().first();
        		if (slbr == null) {
        			throw new NullPointerException(""ServiceLoadBalancerResult was null!"");
        		}
        		if (slbr.getStatusCode() == Status.REQUEST_TIMEOUT.getStatusCode()) {
        			throw new LoadBalancerTimeoutException(""Timout at endpoint: ""
        					+ endpointURI + "", with target service: "" + targetService.getServiceName(),
        					targetService);
        		} else if (slbr.getStatusCode() == Status.NOT_FOUND.getStatusCode() || slbr.getEntity() == null) {
        			throw new NotFoundException();
        		}
        		r = slbr.getEntity();
        	}
    	} finally {
    		loadBalancerModificationLock.readLock().unlock();
    	}
		return r;
	}

    /**
     * Sends a multicast to all known instances of the service.
     * Does not repeat failed sends.
     * @param targetService The service to send to.
     * @param endpointURI The endpoint URI (e.g., ""cache"").
     * @param entityClass The class of entities to send/receive.
     * @param operation The operation to load balance as Java8 lambda.
     * 				E.g.: ""client -> CRUDOperations.getEntity(client, id)"".
     * @param <R> The expected return type.
     * @param <T> The entity type of the entity to send/receive.
     * @return List of all responses. Contains null for each unreachable server.
     */
    public static <T, R> List<R> multicastRESTOperation(Service targetService,
    		String endpointURI, Class<T> entityClass,
    		Function<RESTClient<T>, R> operation) {
    	return getServiceLoadBalancer(targetService).multicastRESTOperation(endpointURI, entityClass, operation, null);
    }

    /**
     * Sends a multicast to all known instances of this service, except for the
     * one actually sending (this instance).
     * Does not repeat failed sends.
     * @param endpointURI The endpoint URI (e.g., ""cache"").
     * @param entityClass The class of entities to send/receive.
     * @param operation The operation to load balance as Java8 lambda.
     * 				E.g.: ""client -> CRUDOperations.getEntity(client, id)"".
     * @param <R> The expected return type.
     * @param <T> The entity type of the entity to send/receive.
     * @return List of all responses. Contains null for each unreachable server.
     */
    public static <T, R> List<R> multicastRESTToOtherServiceInstances(String endpointURI, Class<T> entityClass,
    		Function<RESTClient<T>, R> operation) {
    	return getServiceLoadBalancer(RegistryClient.getClient().getMyService())
    			.multicastRESTOperation(endpointURI, entityClass, operation,
    					RegistryClient.getClient().getMyServiceInstanceServer());
    }

    //exception can be null
    private <T, R> List<R> multicastRESTOperation(String endpointURI, Class<T> entityClass,
    		Function<RESTClient<T>, R> operation, Server exception) {
    	List<R> responses = new ArrayList<>();
    	List<Server> servers = null;
    	loadBalancerModificationLock.readLock().lock();
    	try {
	    	if (loadBalancer != null) {
	    		servers = new ArrayList<>(loadBalancer.getAllServers());
	    	}
	    	if (servers != null) {
	    		if (exception != null) {
	        		servers.remove(exception);
	        	}
	        	responses = servers.parallelStream().map(
	        		server -> {
	        			try {
	        				return operation.apply((RESTClient<T>) getEndpointClientCollection(endpointURI, entityClass)
	                				.getRESTClient(server));
	        			} catch (Exception e) {
	        				return null;
	        			}
	        		}).collect(Collectors.toList());
	    	}
    	} finally {
    		loadBalancerModificationLock.readLock().unlock();
    	}
    	return responses;
    }
}"
utilities/tools.descartes.teastore.registryclient/src/main/java/tools/descartes/teastore/registryclient/RegistryClientHeartbeatDaemon.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.registryclient;

import com.netflix.loadbalancer.Server;

/**
 * Daemon which sends out heartbeats to the registry.
 * @author Simon
 */
public class RegistryClientHeartbeatDaemon implements Runnable {

	private Service service;
	private Server server;
	
	/**
	 * Constructor.
	 * @param service Service enum
	 * @param server Service location
	 */
	public RegistryClientHeartbeatDaemon(Service service, Server server) {
		this.server = server;
		this.service = service;
	}
	
	@Override
	public void run() {
		try {
			RegistryClient.getClient().registerOnce(service, server);
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e);
		}
	}

}"
utilities/tools.descartes.teastore.dockermemoryconfigurator/src/main/java/tools/descartes/teastore/dockermemoryconfigurator/Configurator.java,"package tools.descartes.teastore.dockermemoryconfigurator;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

/**
 * Configures the Tomcat heap space inside a docker container. Implemented in
 * Java to compensate for potentially missing GNU/Linux tools inside the
 * container when running this using bash.
 * 
 * @author Joakim von Kistowski
 *
 */
public final class Configurator {

  private static final long DEFAULT_PERCENTAGE = 80;

  private Configurator() {

  }

  /**
   * Runs the configurator.
   * 
   * @param args
   *          Percentage of total memory to be used for heap as the only
   *          parameter.
   */
  public static void main(String[] args) {
    long percentage = readPercentage(args);
    long totalkb = readTotalMemoryInKB();
    long cgroupkb = readCGroupMemoryInKB();

    // System.out.println(""Total Host Memory = "" + totalkb + "" KiB"");
    // System.out.println(""Container CGroup Limit = "" + cgroupkb + "" KiB"");

    if (cgroupkb != 0 && totalkb != 0 && cgroupkb < totalkb) {
      long heapkb = (cgroupkb * percentage) / 100L;
      System.out.println(""Setting heap space to "" + heapkb + "" KiB"");
      writeSetEnvFile(heapkb);

    }
  }

  private static long readPercentage(String[] args) {
    long percentage = DEFAULT_PERCENTAGE;
    if (args.length > 0) {
      String arg0 = args[0].trim();
      if (!arg0.isEmpty()) {
        try {
          percentage = Long.parseLong(arg0);
        } catch (NumberFormatException e) {
          percentage = DEFAULT_PERCENTAGE;
        }
      }
    }
    return percentage;
  }

  /**
   * Reads the total memory from /proc/meminfo.
   * 
   * @return 0 on error.
   */
  private static long readTotalMemoryInKB() {
    File meminfo = new File(""/proc/meminfo"");
    if (!meminfo.exists()) {
      return 0;
    }

    try (Scanner scan = new Scanner(meminfo)) {
      while (scan.hasNextLine()) {
        String line = scan.nextLine().trim();
        if (line.startsWith(""MemTotal:"")) {
          String[] tokens = line.split("" "");
          String kbs = tokens[tokens.length - 2].trim();
          try {
            return Long.parseLong(kbs);
          } catch (NumberFormatException e) {
            return 0;
          }
        }
      }
    } catch (IOException e) {
      return 0;
    }

    return 0;
  }

  /**
   * Reads the cgroup memory from /sys/fs/cgroup/memory/memory.limit_in_bytes and
   * converts to KiB.
   * 
   * @return 0 on error.
   */
  private static long readCGroupMemoryInKB() {
    File cgroupbytes = new File(""/sys/fs/cgroup/memory/memory.limit_in_bytes"");
    if (!cgroupbytes.exists()) {
      return 0;
    }

    try (BufferedReader br = new BufferedReader(new FileReader(cgroupbytes))) {
      try {
        // use double, number may be too large
        double bytes = Double.parseDouble(br.readLine().trim());
        return (long) (bytes / 1024.0);
      } catch (NumberFormatException e) {
        return 0;
      }
    } catch (IOException e) {
      return 0;
    }
  }

  private static void writeSetEnvFile(long heapkb) {
    try {
      new File(""/usr/local/tomcat/bin/setenv.sh"").createNewFile();
      PrintWriter out = new PrintWriter(""/usr/local/tomcat/bin/setenv.sh"");
      out.println(""export CATALINA_OPTS=\""$CATALINA_OPTS -Xmx"" + heapkb + ""k\"""");
      out.close();
    } catch (IOException e) {
      throw new IllegalStateException(""Could not create setenv.sh file"");
    }
  }
}"
utilities/tools.descartes.teastore.dockerbase/start.sh,"#!/bin/bash
# DANGER! MAKE SURE THIS FILE HAS UNIX-STYLE LINE-ENDINGS OR THE DOCKER CONTAINER WILL NOT START!
sed -i ""s/<Environment name=\""servicePort\"" value=.*/<Environment name=\""servicePort\"" value=\""${SERVICE_PORT}\""/g"" /usr/local/tomcat/conf/context.xml
if [ ""$USE_HTTPS"" == ""true"" ]
then
  sed -i ""s|<Environment name=\""registryURL\"" value=.*|<Environment name=\""registryURL\"" value=\""https://${REGISTRY_HOST}:${REGISTRY_PORT}/tools.descartes.teastore.registry/rest/services/\""|g"" /usr/local/tomcat/conf/context.xml
  sed -i 's|<Connector port=""8009"" protocol=""AJP/1.3"" redirectPort=""8443"" secretRequired=""false"" />|<Connector port=""8009"" protocol=""AJP/1.3"" redirectPort=""8443"" secretRequired=""false"" />\n\n    <Connector port=""8443"" protocol=""org.apache.coyote.http11.Http11AprProtocol"" maxThreads=""150"" SSLEnabled=""true"" defaultSSLHostConfigName=""hostname.unset"">\n        <UpgradeProtocol className=""org.apache.coyote.http2.Http2Protocol"" />\n        <SSLHostConfig hostName=""hostname.unset"">\n            <Certificate certificateKeyFile=""ssl/key.pem""\n                         certificateFile=""ssl/cert.pem""/>\n        </SSLHostConfig>\n    </Connector>|g' /usr/local/tomcat/conf/server.xml
else
  sed -i ""s|<Environment name=\""registryURL\"" value=.*|<Environment name=\""registryURL\"" value=\""http://${REGISTRY_HOST}:${REGISTRY_PORT}/tools.descartes.teastore.registry/rest/services/\""|g"" /usr/local/tomcat/conf/context.xml
fi
if [ ""$HOST_NAME"" != ""unset"" ]
then
	sed -i ""s|<Environment name=\""hostName\"" value=.*|<Environment name=\""hostName\"" value=\""${HOST_NAME}\"" type=\""java.lang.String\"" override=\""false\""/>|g"" /usr/local/tomcat/conf/context.xml
	if [ ""$USE_HTTPS"" == ""true"" ]
  then
	  sed -i ""s|<Connector port=\""8443\"" protocol=\""org.apache.coyote.http11.Http11AprProtocol\"".*|<Connector port=\""8443\"" protocol=\""org.apache.coyote.http11.Http11AprProtocol\"" maxThreads=\""150\"" SSLEnabled=\""true\"" defaultSSLHostConfigName=\""${HOST_NAME}\"">|g"" /usr/local/tomcat/conf/server.xml
	  sed -i ""s|<SSLHostConfig hostName=.*|<SSLHostConfig hostName=\""${HOST_NAME}\"">|g"" /usr/local/tomcat/conf/server.xml
	fi
else
	sed -i ""/Environment name=\""hostName\""/d"" /usr/local/tomcat/conf/context.xml
fi
sed -i ""s|<Environment name=\""useHostIP\"" value=.*|<Environment name=\""useHostIP\"" value=\""${USE_POD_IP}\""|g"" /usr/local/tomcat/conf/context.xml
sed -i ""s/<Environment name=\""databaseHost\"" value=.*/<Environment name=\""databaseHost\"" value=\""${DB_HOST}\""/g"" /usr/local/tomcat/conf/context.xml
sed -i ""s/<Environment name=\""databasePort\"" value=.*/<Environment name=\""databasePort\"" value=\""${DB_PORT}\""/g"" /usr/local/tomcat/conf/context.xml
sed -i ""s/<Environment name=\""recommenderLoopTime\"" value=.*/<Environment name=\""recommenderLoopTime\"" value=\""${RECOMMENDER_RETRAIN_LOOP_TIME}\""/g"" /usr/local/tomcat/conf/context.xml
sed -i ""s/<Environment name=\""recommenderAlgorithm\"" value=.*/<Environment name=\""recommenderAlgorithm\"" value=\""${RECOMMENDER_ALGORITHM}\""/g"" /usr/local/tomcat/conf/context.xml
if [ ""$PROXY_NAME"" != ""unset"" ] && [ ""$PROXY_PORT"" != ""unset"" ]
then
	sed -i ""s/<Connector port=\""8080\"" protocol=\""HTTP\/1.1\"".*/<Connector port=\""8080\"" protocol=\""HTTP\/1.1\"" proxyName=\""${PROXY_NAME}\"" proxyPort=\""${PROXY_PORT}\""/g"" /usr/local/tomcat/conf/server.xml
fi
sed -i 's/securerandom.source=file:\/dev.*/securerandom.source=file:\/dev\/urandom/g'  ${JAVA_HOME}/conf/security/java.security

if [ ""$RABBITMQ_HOST"" != ""unset"" ]
then
  sed -i ""s/kieker.monitoring.writer=kieker.monitoring.writer.filesystem.FileWriter/kieker.monitoring.writer=kieker.monitoring.writer.collector.ChunkingCollector/g"" /kieker/config/kieker.monitoring.properties
  sed -i ""s/kieker.monitoring.writer.amqp.ChunkingAmqpWriter.uri=amqp:\/\/admin:nimda@RABBITMQ_PORT_PLACEHOLDER/kieker.monitoring.writer.amqp.ChunkingAmqpWriter.uri=amqp:\/\/admin:nimda@${RABBITMQ_HOST}/g"" /kieker/config/kieker.monitoring.properties
fi

if [ ""$LOG_TO_FILE"" != ""true"" ] && [ ""$RABBITMQ_HOST"" == ""unset"" ]
then
  sed -i 's/kieker.monitoring.enabled=true/kieker.monitoring.enabled=false/g' /kieker/config/kieker.monitoring.properties
fi

touch /usr/local/tomcat/bin/setenv.sh
chmod +x /usr/local/tomcat/bin/setenv.sh
echo 'export JAVA_OPTS=""-javaagent:/kieker/agent/agent.jar --add-opens=java.base/java.lang=ALL-UNNAMED -Dkieker.monitoring.configuration=/kieker/config/kieker.monitoring.properties -Daj.weaving.verbose=false -Dorg.aspectj.weaver.loadtime.configuration=aop.xml -Dkieker.monitoring.skipDefaultAOPConfiguration=true -Daj.weaving.loadersToSkip=java.net.URLClassLoader -Dcom.sun.jndi.ldap.object.disableEndpointIdentification=true""' > /usr/local/tomcat/bin/setenv.sh
echo 'export CLASSPATH=$CLASSPATH:/usr/local/slf4j-simple-1.7.21.jar' >> /usr/local/tomcat/bin/setenv.sh
"
utilities/tools.descartes.teastore.dockerbase/ssl/generate_cert.sh,"#!/bin/bash

openssl genrsa -out key.pem 2048

cat > config.conf<< EOF
[req]
distinguished_name=req
[SAN]
subjectAltName=DNS:teastore-registry, DNS:teastore-webui, DNS:teastore-auth, DNS:teastore-recommender, DNS:teastore-persistence, DNS:teastore-image, DNS:teastore-webui, DNS: localhost
EOF

openssl req -new -x509 -key key.pem -out cert.pem -days 3650 -subj /CN=teastore-registry -extensions SAN -config 'config.conf'

openssl x509 -in cert.pem -text -noout"
utilities/tools.descartes.teastore.kieker.rabbitmq/src/main/java/tools/descartes/teastore/kieker/rabbitmq/IndexServlet.java,"package tools.descartes.teastore.kieker.rabbitmq;

import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet that shows logs currently stored in memory.
 * 
 * @author Simon
 *
 */
@WebServlet(""/index"")
public class IndexServlet extends HttpServlet {
  private static final long serialVersionUID = 1L;

  /**
   * {@inheritDoc}
   * 
   * @throws IOException
   */
  @Override
  protected void doGet(HttpServletRequest request, HttpServletResponse response)
      throws IOException {
    PrintWriter writer = response.getWriter();
    response.setCharacterEncoding(""utf8"");
    writer.println(""<h1>Kieker logs</h1>"");
    writer.println(""<ul>"");
    writer.println(""<li><a href=\""/logs/\"">Get log files</a></li>"");
    writer.println(""<li><a href=\""/logs/displaylogs\"">Display logs currently stored in memory</a></li>"");
    writer.println(""<li><a href=\""/logs/reset\"">Reset logs</a></li>"");
    writer.println(""</ul>"");
  }
}"
utilities/tools.descartes.teastore.kieker.rabbitmq/src/main/java/tools/descartes/teastore/kieker/rabbitmq/FileWriterDaemon.java,"package tools.descartes.teastore.kieker.rabbitmq;

import java.io.File;
import java.io.IOException;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;

import kieker.common.configuration.Configuration;
import kieker.common.record.IMonitoringRecord;
import kieker.monitoring.writer.filesystem.FileWriter;

/**
 * Daemon that writes the logs to HDD.
 * @author Simon
 *
 */
public class FileWriterDaemon implements Runnable {

	@Override
	public void run() {
		Logger logger = Logger.getLogger(""FileWriterDaemon"");
		logger.setLevel(Level.INFO);
		new File(""apache-tomcat-8.5.24/webapps/logs"").mkdir();
		new File(""apache-tomcat-8.5.24/webapps/logs"").mkdirs();
		Configuration configuration = new Configuration();

		configuration.setProperty(FileWriter.CONFIG_PATH, ""apache-tomcat-8.5.24/webapps/logs"");
		configuration.setProperty(FileWriter.CONFIG_MAXENTRIESINFILE, ""-1"");
		configuration.setProperty(FileWriter.CONFIG_MAXLOGSIZE, ""-1"");
		configuration.setProperty(FileWriter.CONFIG_MAXLOGFILES, ""-1"");
		configuration.setProperty(FileWriter.CONFIG_FLUSH, ""true"");

		FileWriter writer;
		try {
			writer = new FileWriter(configuration);
		} catch (IOException e1) {
			throw new IllegalStateException(e1.getMessage());
		}
		while (true) {
			for (IMonitoringRecord record : MemoryLogStorage.getRecords()) {
				writer.writeMonitoringRecord(record);
			}
			MemoryLogStorage.clearMemoryStorage();
			try {
				Thread.sleep(5000);
			} catch (InterruptedException e) {
				break;
			}
		}
	}
}"
utilities/tools.descartes.teastore.kieker.rabbitmq/src/main/java/tools/descartes/teastore/kieker/rabbitmq/LogReaderStartup.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.kieker.rabbitmq;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;

import org.apache.log4j.BasicConfigurator;

/**
 * Application Lifecycle Listener implementation class Registry Client Startup.
 * 
 * @author Simon Eismann
 *
 */
@WebListener
public class LogReaderStartup implements ServletContextListener {
  private static ScheduledExecutorService logReaderStarter;
  private static ScheduledExecutorService fileWriterStarter;

  /**
   * Also set this accordingly in RegistryClientStartup.
   */

  /**
   * Empty constructor.
   */
  public LogReaderStartup() {

  }

  /**
   * @see ServletContextListener#contextDestroyed(ServletContextEvent)
   * @param event
   *          The servlet context event at destruction.
   */
  public void contextDestroyed(ServletContextEvent event) {
    stopFileWriter();
    logReaderStarter.shutdownNow();
    try {
      logReaderStarter.awaitTermination(10, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  /**
   * stops the filewriter.
   */
  public static void stopFileWriter() {
    fileWriterStarter.shutdownNow();
    try {
      fileWriterStarter.awaitTermination(10, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  /**
   * @see ServletContextListener#contextInitialized(ServletContextEvent)
   * @param event
   *          The servlet context event at initialization.
   */
  public void contextInitialized(ServletContextEvent event) {
    startFileWriter();
    logReaderStarter = Executors.newSingleThreadScheduledExecutor();
    BasicConfigurator.configure();
    logReaderStarter.schedule(new LogReaderDaemon(), 10, TimeUnit.SECONDS);
  }

  /**
   * Starts the filewriter.
   */
  public static void startFileWriter() {
    fileWriterStarter = Executors.newSingleThreadScheduledExecutor();
    fileWriterStarter.schedule(new FileWriterDaemon(), 10, TimeUnit.SECONDS);
  }

}"
utilities/tools.descartes.teastore.kieker.rabbitmq/src/main/java/tools/descartes/teastore/kieker/rabbitmq/LogReaderDaemon.java,"package tools.descartes.teastore.kieker.rabbitmq;

import kieker.analysis.AnalysisController;
import kieker.analysis.IAnalysisController;
import kieker.analysis.plugin.reader.amqp.AmqpReader;
import kieker.analysis.plugin.reader.amqp.ChunkingAmqpReader;
import kieker.analysis.plugin.reader.newio.RawDataReaderPlugin;
import kieker.common.configuration.Configuration;

/**
 * daemon that retireves the logs.
 * @author Simon
 *
 */
public class LogReaderDaemon implements Runnable {

  private static final String URI = ""amqp://admin:nimda@127.0.0.1"";
  private static final String QUEUENAME = ""kieker"";

  @Override
  public void run() {
    final IAnalysisController analysisInstance = new AnalysisController();
    try {
      Configuration configuration = new Configuration();

      configuration.setProperty(RawDataReaderPlugin.CONFIG_PROPERTY_READER,
          ""kieker.analysis.plugin.reader.amqp.ChunkingAmqpReader"");
      configuration.setProperty(RawDataReaderPlugin.CONFIG_PROPERTY_DESERIALIZER,
          ""kieker.analysis.plugin.reader.newio.deserializer.BinaryDeserializer"");

      configuration.setProperty(ChunkingAmqpReader.CONFIG_PROPERTY_URI, URI);
      configuration.setProperty(ChunkingAmqpReader.CONFIG_PROPERTY_HEARTBEAT, 0);
      configuration.setProperty(ChunkingAmqpReader.CONFIG_PROPERTY_QUEUENAME, QUEUENAME);

      RawDataReaderPlugin reader = new RawDataReaderPlugin(configuration, analysisInstance);
      final LogConsumer consumer = new LogConsumer(new Configuration(), analysisInstance);

      analysisInstance.connect(reader, AmqpReader.OUTPUT_PORT_NAME_RECORDS, consumer,
          LogConsumer.INPUT_PORT_NAME);
      analysisInstance.run();
    } catch (Exception e) {
      System.out.println(""AMQP Reader was interupted, probably due to reset"");
    } finally {
      analysisInstance.terminate();
    }
  }

}"
utilities/tools.descartes.teastore.kieker.rabbitmq/src/main/java/tools/descartes/teastore/kieker/rabbitmq/DisplayLogs.java,"package tools.descartes.teastore.kieker.rabbitmq;

import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import kieker.common.record.IMonitoringRecord;

/**
 * Servlet that shows logs currently stored in memory.
 * 
 * @author Simon
 *
 */
@WebServlet(""/displaylogs"")
public class DisplayLogs extends HttpServlet {
  private static final long serialVersionUID = 1L;

  /**
   * {@inheritDoc}
   * 
   * @throws IOException
   */
  @Override
  protected void doGet(HttpServletRequest request, HttpServletResponse response)
      throws IOException {
    PrintWriter writer = response.getWriter();
    response.setCharacterEncoding(""utf8"");
    for (IMonitoringRecord record : MemoryLogStorage.getRecords()) {
      writer.println(record);
    }
  }
}"
utilities/tools.descartes.teastore.kieker.rabbitmq/src/main/java/tools/descartes/teastore/kieker/rabbitmq/LogConsumer.java,"package tools.descartes.teastore.kieker.rabbitmq;

import kieker.analysis.IProjectContext;
import kieker.analysis.plugin.annotation.InputPort;
import kieker.analysis.plugin.filter.AbstractFilterPlugin;
import kieker.common.configuration.Configuration;
import kieker.common.record.IMonitoringRecord;
import kieker.common.record.system.CPUUtilizationRecord;

/**
 * Consumes the logs from the rabbitmq.
 * @author Simon
 *
 */
public class LogConsumer extends AbstractFilterPlugin {

  /**
   * Name of kieker input port used.
   */
	public static final String INPUT_PORT_NAME = ""newMonitoringRecord"";

	/**
	 * Constructor that delegates to AbstractFilterPlugin.
	 * @param configuration configuration
	 * @param projectContext copntext
	 */
	public LogConsumer(final Configuration configuration, final IProjectContext projectContext) {
		super(configuration, projectContext);
	}
	
	/**
	 * process new monitoring record.
	 * @param record record.
	 */
	@InputPort(name = LogConsumer.INPUT_PORT_NAME, eventTypes = { IMonitoringRecord.class })
	public void newMonitoringRecord(final Object record) {
		if (record instanceof IMonitoringRecord) {
			if (record instanceof CPUUtilizationRecord) {
				CPUUtilizationRecord cpu = (CPUUtilizationRecord) record;
				System.out.println(cpu.getHostname() + cpu.getTotalUtilization());
			}
			IMonitoringRecord monitoringRecord = (IMonitoringRecord) record;
			MemoryLogStorage.storeRecord(monitoringRecord);
		} else {
			throw new IllegalStateException(""Unknown monitoring result type"");
		}
	}

	/**
	 * Getter for configuration.
	 * @return configuration
	 */
	@Override
	public Configuration getCurrentConfiguration() {
		return new Configuration();
	}

}"
utilities/tools.descartes.teastore.kieker.rabbitmq/src/main/java/tools/descartes/teastore/kieker/rabbitmq/MemoryLogStorage.java,"package tools.descartes.teastore.kieker.rabbitmq;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

import kieker.common.record.IMonitoringRecord;

/**
 * Memory storage for kieker logs.
 * @author Simon
 *
 */
public final class MemoryLogStorage {
	private static Queue<IMonitoringRecord> records = new ConcurrentLinkedQueue<IMonitoringRecord>();

  /**
   * Hide default constructor.
   */
  private MemoryLogStorage() {

  }
  
  /**
   * Stores a new record.
   * @param record record that should be stored
   */
	public static void storeRecord(IMonitoringRecord record) {
		records.add(record);
	}
	
	/**
	 * Get current records.
	 * @return queue containing current records
	 */
	public static Queue<IMonitoringRecord> getRecords() {
		return records;
	}
	
	/**
	 * Clears memory storage.
	 */
	public static void clearMemoryStorage() {
		records.clear();
	}
}"
utilities/tools.descartes.teastore.kieker.rabbitmq/src/main/java/tools/descartes/teastore/kieker/rabbitmq/Reset.java,"package tools.descartes.teastore.kieker.rabbitmq;

import java.io.File;
import java.io.IOException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet to reset the logs.
 * @author Simon
 *
 */
@WebServlet(""/reset"")
public class Reset extends HttpServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * {@inheritDoc}
	 * 
	 * @throws IOException
	 */
	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
		LogReaderStartup.stopFileWriter();

		MemoryLogStorage.clearMemoryStorage();
		deleteFolder(new File(""apache-tomcat-8.5.24/webapps/logs""), ""kieker"");

		LogReaderStartup.startFileWriter();
	}

	private void deleteFolder(File folder, String prefix) {
		File[] files = folder.listFiles();
		if (files != null) { // some JVMs return null for empty dirs
			for (File f : files) {
				if (f.getPath().contains(prefix)) {
					if (f.isDirectory()) {
						deleteFolder(f);
					} else {
						f.delete();
					}
				}
			}
		}
	}

	private void deleteFolder(File folder) {
		File[] files = folder.listFiles();
		if (files != null) { // some JVMs return null for empty dirs
			for (File f : files) {
				if (f.isDirectory()) {
					deleteFolder(f);
				} else {
					f.delete();
				}
			}
		}
		folder.delete();
	}
}"
interfaces/tools.descartes.teastore.entities/src/test/java/tools/descartes/teastore/entities/InterfaceTests.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.entities;

/**
 * Tests.
 * @author Joakim von Kistowski
 *
 */
public class InterfaceTests {

}"
interfaces/tools.descartes.teastore.entities/src/main/java/tools/descartes/teastore/entities/ImageSize.java,"package tools.descartes.teastore.entities;

/**
 * Available store image sizes.
 * 
 * @author Norbert Schmitt
 *
 */
public class ImageSize {

  /**
   * Divider string.
   */
  public static final String IMAGE_SIZE_DIVIDER = ""x"";

  /**
   * Image width.
   */
  private int width;

  /**
   * Image height.
   */
  private int height;

  /**
   * Default constructor.
   */
  public ImageSize() {
  }

  /**
   * Constructor with variable width and height.
   * 
   * @param width
   *          imageWidth
   * @param height
   *          imageHeight
   */
  public ImageSize(int width, int height) {
    setWidth(width);
    setHeight(height);
  }

  /**
   * Constructor with ImageSize object.
   * 
   * @param size
   *          ImageSize object
   */
  public ImageSize(ImageSize size) {
    setWidth(size.getWidth());
    setHeight(size.getHeight());
  }

  /**
   * Getter for image width.
   * @return image width
   */
  public int getWidth() {
    return width;
  }

  /**
   * Setter for image width.
   * @param width image width
   */
  public void setWidth(int width) {
    if (width <= 0) {
      throw new IllegalArgumentException(""Image width cannot be zero or negative."");
    }
    this.width = width;
  }

  /**
   * Getter for image height.
   * @return image height.
   */
  public int getHeight() {
    return height;
  }

  /**
   * Setter for image height.
   * @param height image height
   */
  public void setHeight(int height) {
    if (height <= 0) {
      throw new IllegalArgumentException(""Image height cannot be zero or negative."");
    }
    this.height = height;
  }

  /**
   * Calculates number of pixels of an image.
   * @return number of pixels
   */
  public int getPixelCount() {
    return width * height;
  }

  /**
   * Parses from String.
   * @param str String to pars from
   * @return ImageSize object
   */
  public static ImageSize parseImageSize(String str) {
    if (str == null) {
      throw new NullPointerException(""Supplied string is null."");
    }
    if (str.isEmpty()) {
      throw new IllegalArgumentException(""Supplied string is empty."");
    }

    String[] tmp = str.trim().split(IMAGE_SIZE_DIVIDER);
    if (tmp.length != 2) {
      throw new IllegalArgumentException(""Malformed string supplied. Does not contain exactly two size ""
          + ""values divided by \"""" + IMAGE_SIZE_DIVIDER + ""\""."");
    }

    int width = 0;
    int height = 0;

    try {
      width = Integer.parseInt(tmp[0].trim());
      height = Integer.parseInt(tmp[1].trim());
    } catch (NumberFormatException parseException) {
      throw new IllegalArgumentException(""Malformed string supplied. Cannot parse size values."");
    }

    return new ImageSize(width, height);
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + height;
    result = prime * result + width;
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }

    ImageSize other = (ImageSize) obj;
    if (height != other.height) {
      return false;
    }
    if (width != other.width) {
      return false;
    }
    return true;
  }

  @Override
  public String toString() {
    return String.valueOf(width) + IMAGE_SIZE_DIVIDER + String.valueOf(height);
  }
}"
interfaces/tools.descartes.teastore.entities/src/main/java/tools/descartes/teastore/entities/Product.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.entities;

/**
 * Entity for Products.
 * 
 * @author Joakim von Kistowski
 *
 */
public class Product {

  private long id;

  private long categoryId;
  private String name;
  private String description;
  private long listPriceInCents;

  /**
   * Create a new and empty Product.
   */
  public Product() {
    // always use the setters when setting variables here
    // do not access the attributes directly
  }

  /**
   * Every Entity needs a Copy-Constructor!
   * 
   * @param product
   *          The entity to Copy.
   */
  public Product(Product product) {
    setId(product.getId());
    setCategoryId(product.getCategoryId());
    setName(product.getName());
    setDescription(product.getDescription());
    setListPriceInCents(product.getListPriceInCents());
  }

  /**
   * Get the id (remember that this ID may be incorrect, especially if a separate id was passed).
   * 
   * @return The id.
   */
  public long getId() {
    return id;
  }

  /**
   * For REST use only. Sets the product ID. Ignored by persistence.
   * 
   * @param id
   *          Product ID, as passed by the REST API.
   */
  public void setId(long id) {
    this.id = id;
  }

  /**
   * Set the ID of the product's category.
   * 
   * @return The category id.
   */
  public long getCategoryId() {
    return categoryId;
  }

  /**
   * For REST use only. Sets the category ID. Ignored by persistence.
   * 
   * @param categoryId
   *          Category ID, as passed by the REST API.
   */
  public void setCategoryId(long categoryId) {
    this.categoryId = categoryId;
  }

  /**
   * Get the name.
   * 
   * @return The product name.
   */
  public String getName() {
    return name;
  }

  /**
   * Set the name.
   * 
   * @param name
   *          The product name.
   */
  public void setName(String name) {
    this.name = name;
  }

  /**
   * Get the description.
   * 
   * @return The product description.
   */
  public String getDescription() {
    return description;
  }

  /**
   * Set the description.
   * 
   * @param description
   *          The product description.
   */
  public void setDescription(String description) {
    this.description = description;
  }

  /**
   * Get the product list price (recommended price per unit) in cents.
   * 
   * @return The list price in cents.
   */
  public long getListPriceInCents() {
    return listPriceInCents;
  }

  /**
   * For REST use only. Sets the product price in cents. Ignored by persistence.
   * 
   * @param listPriceInCents
   *          The price in cents, as passed by the REST API.
   */
  public void setListPriceInCents(long listPriceInCents) {
    this.listPriceInCents = listPriceInCents;
  }

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Object#hashCode()
   */
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (int) (categoryId ^ (categoryId >>> 32));
    result = prime * result + (int) (id ^ (id >>> 32));
    return result;
  }

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Object#equals(java.lang.Object)
   */
  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    Product other = (Product) obj;
    if (categoryId != other.categoryId) {
      return false;
    }
    if (id != other.id) {
      return false;
    }
    return true;
  }

}"
interfaces/tools.descartes.teastore.entities/src/main/java/tools/descartes/teastore/entities/message/SessionBlob.java,"package tools.descartes.teastore.entities.message;

import java.util.LinkedList;
import java.util.List;

import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;

/**
 * Blob containing all information about the user session.
 * @author Simon
 */
public class SessionBlob {

	private Long uid;
	private String sid;
	private String token;
	private Order order;
	private List<OrderItem> orderItems = new LinkedList<OrderItem>();
	private String message;
	
	/**
	 * Constructor, creates an empty order.
	 */
	public SessionBlob() {
		this.setOrder(new Order());
	}

	/**
	 * Getter for the userid.
	 * @return userid
	 */
	public Long getUID() {
		return uid;
	}

	/**
	 * Setter for the userid.
	 * @param uID userid
	 */
	public void setUID(Long uID) {
		uid = uID;
	}

	/**
	 * Getter for session id.
	 * @return session id
	 */
	public String getSID() {
		return sid;
	}

	/**
	 * Setter for session id.
	 * @param sID session id
	 */
	public void setSID(String sID) {
		sid = sID;
	}

	/**
	 * Getter for trust token.
	 * @return trust token
	 */
	public String getToken() {
		return token;
	}

	/**
	 * Setter for trust token.
	 * @param token trust token.
	 */
	public void setToken(String token) {
		this.token = token;
	}
	
	/**
	 * Setter for the message.
	 * @param message String
	 */
	public void setMessage(String message) {
		this.message = message;
	}
	
	/**
	 * Getter for the message.
	 * @return message
	 */
	public String getMessage() {
		return message;
	}

	/**
	 * Getter for order.
	 * @return order
	 */
	public Order getOrder() {
		return order;
	}

	/**
	 * Setter for order.
	 * @param order order
	 */
	public void setOrder(Order order) {
		this.order = order;
	}

	/**
	 * Getter for order items.
	 * @return order items.
	 */
	public List<OrderItem> getOrderItems() {
		return orderItems;
	}

	/**
	 * Setter for order items.
	 * @param orderItems list of order items
	 */
	public void setOrderItems(List<OrderItem> orderItems) {
		this.orderItems = orderItems;
	}
}"
interfaces/tools.descartes.teastore.entities/src/main/java/tools/descartes/teastore/entities/OrderItem.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.entities;

/**
 * Entity Class for OrderItems (item with quantity in shopping cart or order).
 * 
 * @author Joakim von Kistowski
 *
 */
public class OrderItem {

  private long id;
  private long productId;
  private long orderId;
  private int quantity;
  private long unitPriceInCents;

  /**
   * Create a new and empty OrderItem.
   */
  public OrderItem() {

  }

  /**
   * Every Entity needs a Copy-Constructor!
   * 
   * @param orderItem
   *          The entity to Copy.
   */
  public OrderItem(OrderItem orderItem) {
    setId(orderItem.getId());
    setProductId(orderItem.getProductId());
    setOrderId(orderItem.getOrderId());
    setQuantity(orderItem.getQuantity());
    setUnitPriceInCents(orderItem.getUnitPriceInCents());
  }

  /**
   * Get the id (remember that this ID may be incorrect, especially if a separate id was passed).
   * 
   * @return The id.
   */
  public long getId() {
    return id;
  }

  /**
   * For REST use only. Sets the ID. Ignored by persistence.
   * 
   * @param id
   *          ID, as passed by the REST API.
   */
  public void setId(long id) {
    this.id = id;
  }

  /**
   * ID of the order item's product.
   * 
   * @return Product Id;
   */
  public long getProductId() {
    return productId;
  }

  /**
   * Sets the ID of the order item's product. Every order Item MUST have a valid product ID.
   * 
   * @param productId
   *          The product ID to set.
   */
  public void setProductId(long productId) {
    this.productId = productId;
  }

  /**
   * Get the quantity (amount in shopping cart/order).
   * 
   * @return The quantity.
   */
  public int getQuantity() {
    return quantity;
  }

  /**
   * Set the quantity (amount in shopping cart/order).
   * 
   * @param quantity
   *          The quantity.
   */
  public void setQuantity(int quantity) {
    this.quantity = quantity;
  }

  /**
   * The price per single item in the order item.
   * 
   * @return Price per single item.
   */
  public long getUnitPriceInCents() {
    return unitPriceInCents;
  }

  /**
   * Set the price per single item in the order item.
   * 
   * @param unitPriceInCents
   *          Price per single item.
   */
  public void setUnitPriceInCents(long unitPriceInCents) {
    this.unitPriceInCents = unitPriceInCents;
  }

  /**
   * Gets the ID of the order item's order.
   * 
   * @return The order ID.
   */
  public long getOrderId() {
    return orderId;
  }

  /**
   * Sets the ID of the order item's order. Persistence requires that every order item MUST have a valid order ID. For
   * persistence the order must already exist in database.
   * 
   * @param orderId
   *          The order ID to set.
   */
  public void setOrderId(long orderId) {
    this.orderId = orderId;
  }

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Object#hashCode()
   */
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (int) (id ^ (id >>> 32));
    result = prime * result + (int) (orderId ^ (orderId >>> 32));
    result = prime * result + (int) (productId ^ (productId >>> 32));
    return result;
  }

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Object#equals(java.lang.Object)
   */
  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    OrderItem other = (OrderItem) obj;
    if (id != other.id) {
      return false;
    }
    if (orderId != other.orderId) {
      return false;
    }
    if (productId != other.productId) {
      return false;
    }
    return true;
  }

}"
interfaces/tools.descartes.teastore.entities/src/main/java/tools/descartes/teastore/entities/Category.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.entities;

/**
 * Entity for Category.
 * @author Joakim von Kistowski
 *
 */
public class Category {

	private long id;

	private String name;
	private String description;
	
	/**
	 * Create a new and empty category.
	 */
	public Category() {
		//always use the setters when setting variables here
		//do not access the attributes directly
	}
	
	/**
	 * Every Entity needs a Copy-Constructor!
	 * @param category The entity to Copy.
	 */
	public Category(Category category) {
		setId(category.getId());
		setName(category.getName());
		setDescription(category.getDescription());
	}
	
	/**
	 * Get the id (remember that this ID may be incorrect, especially if a separate id was passed).
	 * @return The id.
	 */
	public long getId() {
		return id;
	}
	
	/**
	 * For REST use only.
	 * Sets the ID. Ignored by persistence.
	 * @param id ID, as passed by the REST API.
	 */
	public void setId(long id) {
		this.id = id;
	}
	
	/**
	 * Get the name.
	 * @return The category name.
	 */
	public String getName() {
		return name;
	}
	
	/**
	 * Set the name.
	 * @param name The category name.
	 */
	public void setName(String name) {
		this.name = name;
	}
	
	/**
	 * Get the description.
	 * @return The category description.
	 */
	public String getDescription() {
		return description;
	}
	
	/**
	 * Set the description.
	 * @param description The category description.
	 */
	public void setDescription(String description) {
		this.description = description;
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + (int) (id ^ (id >>> 32));
		return result;
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
    }
		Category other = (Category) obj;
		if (id != other.id) {
			return false;
    }
		return true;
  }

}"
interfaces/tools.descartes.teastore.entities/src/main/java/tools/descartes/teastore/entities/Order.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.entities;

/**
 * Entity for orders.
 * 
 * @author Joakim von Kistowski
 *
 */
public class Order {

  private long id;
  private long userId;
  private String time;

  private long totalPriceInCents;
  private String addressName;
  private String address1;
  private String address2;

  private String creditCardCompany;
  private String creditCardNumber;
  private String creditCardExpiryDate;

  /**
   * Create a new and empty order.
   */
  public Order() {

  }

  /**
   * Every entity needs a copy constructor.
   * 
   * @param order
   *          The order to copy.
   */
  public Order(Order order) {
    setId(order.getId());
    setUserId(order.getUserId());
    setTime(order.getTime());
    setTotalPriceInCents(order.getTotalPriceInCents());
    setAddressName(order.getAddressName());
    setAddress1(order.getAddress1());
    setAddress2(order.getAddress2());
    setCreditCardCompany(order.getCreditCardCompany());
    setCreditCardNumber(order.getCreditCardNumber());
    setCreditCardExpiryDate(order.getCreditCardExpiryDate());
  }

  /**
   * Get the id (remember that this ID may be incorrect, especially if a separate id was passed).
   * 
   * @return The id.
   */
  public long getId() {
    return id;
  }

  /**
   * For REST use only. Sets the ID. Ignored by persistence.
   * 
   * @param id
   *          ID, as passed by the REST API.
   */
  public void setId(long id) {
    this.id = id;
  }

  /**
   * Get the User id.
   * 
   * @return the userId.
   */
  public long getUserId() {
    return userId;
  }

  /**
   * Set the User Id.
   * 
   * @param userId
   *          the userId to set.
   */
  public void setUserId(long userId) {
    this.userId = userId;
  }

  /**
   * Get the time of order (ISO formatted). Formatted using {@link DateTimeFormatter.ISO_LOCAL_DATE_TIME}.
   * 
   * @return the time.
   */
  public String getTime() {
    return time;
  }

  /**
   * Set the time of order (ISO formatted). Format using {@link DateTimeFormatter.ISO_LOCAL_DATE_TIME}.
   * 
   * @param time
   *          the time to set.
   */
  public void setTime(String time) {
    this.time = time;
  }

  /**
   * Get the total price in cents.
   * 
   * @return the totalPriceInCents.
   */
  public long getTotalPriceInCents() {
    return totalPriceInCents;
  }

  /**
   * Set the total price in cents.
   * 
   * @param totalPriceInCents
   *          the totalPriceInCents to set.
   */
  public void setTotalPriceInCents(long totalPriceInCents) {
    this.totalPriceInCents = totalPriceInCents;
  }

  /**
   * Get the name for the address.
   * 
   * @return the addressName.
   */
  public String getAddressName() {
    return addressName;
  }

  /**
   * Set the name for the address.
   * 
   * @param addressName
   *          the addressName to set.
   */
  public void setAddressName(String addressName) {
    this.addressName = addressName;
  }

  /**
   * Get address line 1.
   * 
   * @return the address1.
   */
  public String getAddress1() {
    return address1;
  }

  /**
   * Set address line 1.
   * 
   * @param address1
   *          the address1 to set.
   */
  public void setAddress1(String address1) {
    this.address1 = address1;
  }

  /**
   * Get address line 2.
   * 
   * @return the address2.
   */
  public String getAddress2() {
    return address2;
  }

  /**
   * Set address line 2.
   * 
   * @param address2
   *          the address2 to set.
   */
  public void setAddress2(String address2) {
    this.address2 = address2;
  }

  /**
   * Get the name of the credit card company.
   * 
   * @return the creditCardCompany.
   */
  public String getCreditCardCompany() {
    return creditCardCompany;
  }

  /**
   * Set the name of the credit card company.
   * 
   * @param creditCardCompany
   *          the creditCardCompany to set.
   */
  public void setCreditCardCompany(String creditCardCompany) {
    this.creditCardCompany = creditCardCompany;
  }

  /**
   * Get the credit card number.
   * 
   * @return the creditCardNumber.
   */
  public String getCreditCardNumber() {
    return creditCardNumber;
  }

  /**
   * Set the credit card number.
   * 
   * @param creditCardNumber
   *          the creditCardNumber to set.
   */
  public void setCreditCardNumber(String creditCardNumber) {
    this.creditCardNumber = creditCardNumber;
  }

  /**
   * Get the credit card expiry date (ISO formatted). Formatted using {@link DateTimeFormatter.ISO_LOCAL_DATE}.
   * 
   * @return the creditCardExpiryDate.
   */
  public String getCreditCardExpiryDate() {
    return creditCardExpiryDate;
  }

  /**
   * Set the credit card expiry date (ISO formatted). Format using {@link DateTimeFormatter.ISO_LOCAL_DATE}.
   * 
   * @param creditCardExpiryDate
   *          the creditCardExpiryDate to set.
   */
  public void setCreditCardExpiryDate(String creditCardExpiryDate) {
    this.creditCardExpiryDate = creditCardExpiryDate;
  }

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Object#hashCode()
   */
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (int) (id ^ (id >>> 32));
    result = prime * result + (int) (userId ^ (userId >>> 32));
    return result;
  }

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Object#equals(java.lang.Object)
   */
  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    Order other = (Order) obj;
    if (id != other.id) {
      return false;
    }
    if (userId != other.userId) {
      return false;
    }
    return true;
  }

}"
interfaces/tools.descartes.teastore.entities/src/main/java/tools/descartes/teastore/entities/User.java,"/**
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.entities;

/**
 * User for the pet supply store.
 * 
 * @author Joakim von Kistowski
 *
 */
public class User {

  private long id;
  private String userName;
  private String password;
  private String realName;
  private String email;

  /**
   * Create a new and empty user.
   */
  public User() {

  }

  /**
   * Every entity needs a copy constructor.
   * 
   * @param user
   *          The user to copy.
   */
  public User(User user) {
    setId(user.getId());
    setUserName(user.getUserName());
    setPassword(user.getPassword());
    setRealName(user.getRealName());
    setEmail(user.getEmail());
  }

  /**
   * Get the id (remember that this ID may be incorrect, especially if a separate id was passed).
   * 
   * @return The id.
   */
  public long getId() {
    return id;
  }

  /**
   * For REST use only. Sets the ID. Ignored by persistence.
   * 
   * @param id
   *          ID, as passed by the REST API.
   */
  public void setId(long id) {
    this.id = id;
  }

  /**
   * Get the Username.
   * 
   * @return the userName.
   */
  public String getUserName() {
    return userName;
  }

  /**
   * Set the username, should only be set at creation.
   * 
   * @param userName
   *          the userName to set.
   */
  public void setUserName(String userName) {
    this.userName = userName;
  }

  /**
   * Get the password hash.
   * 
   * @return the password hash.
   */
  public String getPassword() {
    return password;
  }

  /**
   * Set the password hash.
   * 
   * @param password
   *          the password hash to set.
   */
  public void setPassword(String password) {
    this.password = password;
  }

  /**
   * Get the user's real name.
   * 
   * @return the realName.
   */
  public String getRealName() {
    return realName;
  }

  /**
   * Set the user's real name.
   * 
   * @param realName
   *          the realName to set.
   */
  public void setRealName(String realName) {
    this.realName = realName;
  }

  /**
   * Get the user's email address.
   * 
   * @return the email.
   */
  public String getEmail() {
    return email;
  }

  /**
   * Set the user's email address.
   * 
   * @param email
   *          the email to set.
   */
  public void setEmail(String email) {
    this.email = email;
  }

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Object#hashCode()
   */
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (int) (id ^ (id >>> 32));
    if (userName == null) {
      result = prime * result + 0;
    } else {
      result = prime * result + userName.hashCode();
    }
    return result;
  }

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Object#equals(java.lang.Object)
   */
  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    User other = (User) obj;
    if (id != other.id) {
      return false;
    }
    if (userName == null) {
      if (other.userName != null) {
        return false;
      }
    } else {
      if (!userName.equals(other.userName)) {
        return false;
      }
    }
    return true;
  }

}"
interfaces/tools.descartes.teastore.entities/src/main/java/tools/descartes/teastore/entities/ImageSizePreset.java,"package tools.descartes.teastore.entities;

/**
 * 
 * @author Simon
 *
 */
public enum ImageSizePreset {
  /**
   * Website icon.
   */
	ICON(new ImageSize(64, 64)),
	/**
	 * Developer portraits.
	 */
	PORTRAIT(new ImageSize(160, 240)),
	/**
	 * Descartes logo.
	 */
	LOGO(new ImageSize(600, 195)),
	/**
	 * Main image.
	 */
	MAIN_IMAGE(new ImageSize(400, 310)),
	/**
	 * preview image size.
	 */
	PREVIEW(new ImageSize(64, 64)),
	/**
	 * Recommender image.
	 */
	RECOMMENDATION(new ImageSize(125, 125)),
	/**
	 * Full size product image.
	 */
	FULL(new ImageSize(300, 300)),
	/**
	 * Error images.
	 */
	ERROR(new ImageSize(600, 400)),
	/**
	 * Index image sizes.
	 */
	INDEX(new ImageSize(600, 450));

  /**
   * Set standard image size to FULL.
   */
	public static final ImageSize STD_IMAGE_SIZE = FULL.getSize();
	
	/**
	 * Image size.
	 */
	private final ImageSize size;
	
	/**
	 * Constructor.
	 * @param size ImageSize
	 */
	private ImageSizePreset(ImageSize size) {
		this.size = size;
	}
	
	/**
	 * Getter for image size.
	 * @return image size
	 */
	public ImageSize getSize() {
		return size;
	}
}"
